const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./ext-beautify-DWqnKm8k.js","./indexhtml-CE3rDMXe.js","./ext-code_lens-DsaC1EjT.js","./ext-elastic_tabstops_lite-DX3ywPtA.js","./ext-emmet-CnoWAt-2.js","./ext-error_marker-DZ2T0BIS.js","./ext-hardwrap-Da65JcNk.js","./ext-inline_autocomplete-DBBJW1fT.js","./ext-keybinding_menu-SAZlcZNE.js","./ext-language_tools-BbdagSBI.js","./ext-linking-K4o5cNZj.js","./ext-modelist-wzlvn3X3.js","./ext-options-Diz2c6gk.js","./ext-prompt-B5A3qxfC.js","./ext-rtl-Do4fobcK.js","./ext-searchbox-d1yxE4lI.js","./ext-settings_menu-5CbjMvUa.js","./ext-spellcheck-CE-SUhdU.js","./ext-split-D4CV93pz.js","./ext-static_highlight-0iOh1XAy.js","./ext-statusbar-RhQqZ5ab.js","./ext-textarea-DTNts59M.js","./ext-themelist-BRnrF-lc.js","./ext-whitespace-C1TBg_0s.js","./keybinding-emacs-lNabNU60.js","./keybinding-sublime-BdxvbBQ0.js","./keybinding-vim-CgQfxFow.js","./keybinding-vscode-6DOeRVNF.js","./mode-abap-CWdjZFJp.js","./mode-abc-Bojakf1Y.js","./mode-actionscript-BM5MG-QJ.js","./mode-ada-C-EpGN7L.js","./mode-alda-Ds4VxHxc.js","./mode-apache_conf-Dit8FYLE.js","./mode-apex-CNLIiRqC.js","./mode-applescript-BHLZ9YO7.js","./mode-aql-Bil53Oy5.js","./mode-asciidoc-cvjwTxyc.js","./mode-asl-PYVuogWe.js","./mode-assembly_x86-CIpgPGW_.js","./mode-autohotkey-DHT3dXMZ.js","./mode-batchfile-D-iIFTlF.js","./mode-bibtex-BaA8s57o.js","./mode-c9search-DPL_O9Qb.js","./mode-c_cpp-DCjjjDOx.js","./mode-cirru-jkpomi4J.js","./mode-clojure-CvddRejZ.js","./mode-cobol-BrRCmj3Y.js","./mode-coffee-BFDuAng_.js","./mode-coldfusion-COTOPnia.js","./mode-crystal-82RJdfwK.js","./mode-csharp-W5JBEC41.js","./mode-csound_document-C_I_8b3j.js","./mode-csound_orchestra-C_v_1Znf.js","./mode-csound_score-BnSCdY1l.js","./mode-csp-Dk5QHFa8.js","./mode-css-Bw_dCJDy.js","./mode-curly-BRVUQMVY.js","./mode-d-Be7tugki.js","./mode-dart-CdHnXzsT.js","./mode-diff-BOAnYXgM.js","./mode-django-CSlg-k6U.js","./mode-dockerfile-CDbdGGeK.js","./mode-dot-BYGzoTs3.js","./mode-drools-pjSwTJ2y.js","./mode-edifact-CKydQZAi.js","./mode-eiffel-DFy9Bc-y.js","./mode-ejs-m7qia6Vq.js","./mode-elixir-DMCezUQE.js","./mode-elm-CaDXghYp.js","./mode-erlang-Buvu6r6E.js","./mode-forth-DW5CTtBl.js","./mode-fortran-DdTL8ajJ.js","./mode-fsharp-0xJ6QMiC.js","./mode-fsl-GreR_qHY.js","./mode-ftl-DzSqawYX.js","./mode-gcode-M7fsSlCv.js","./mode-gherkin-uloBwdle.js","./mode-gitignore-DjC3FmDf.js","./mode-glsl-BHi0t5ox.js","./mode-gobstones-C-Q2ewIZ.js","./mode-golang-BU_VSysM.js","./mode-graphqlschema-GoImzfQa.js","./mode-groovy-B2KLSPUU.js","./mode-haml-yzpLKS0y.js","./mode-handlebars-DDZDizzv.js","./mode-haskell-CsLK_TDf.js","./mode-haskell_cabal-a6kz5-jy.js","./mode-haxe-C82SS-ha.js","./mode-hjson-BhDAeB1Y.js","./mode-html-BVJkMLue.js","./mode-html_elixir-HHDv243T.js","./mode-html_ruby-CgfMz1Qv.js","./mode-ini-BQDfELDa.js","./mode-io-Cs9AFM0G.js","./mode-ion-Cba77CjK.js","./mode-jack-Bi_TLFLn.js","./mode-jade-B6LtBcfj.js","./mode-java-b0EFrfjQ.js","./mode-javascript-xSZQDxHi.js","./mode-jexl-BUzkb3Cr.js","./mode-json-r4mBaCdi.js","./mode-json5-C7jS2D2z.js","./mode-jsoniq-DGo6-NaS.js","./mode-jsp-DGx7JcDB.js","./mode-jssm-Cf5Di5SO.js","./mode-jsx-x_zON0pc.js","./mode-julia-C_uFExbj.js","./mode-kotlin-B_LxMjlX.js","./mode-latex-ChNpGHR7.js","./mode-latte-CrI1gNTw.js","./mode-less-3cIHBecx.js","./mode-liquid-bdjnrw4S.js","./mode-lisp-BnOMI0zg.js","./mode-livescript-Da-tuWik.js","./mode-logiql-D60LhQT8.js","./mode-logtalk-BCUKLGYU.js","./mode-lsl-DoFS8qW2.js","./mode-lua-Bo0_OJBv.js","./mode-luapage-DebxWWMh.js","./mode-lucene-BTIbQypK.js","./mode-makefile-CytO6Cim.js","./mode-markdown-H4rxK8Oi.js","./mode-mask-CTLb-QyO.js","./mode-matlab-aSFM2ESh.js","./mode-maze-B9VncRcO.js","./mode-mediawiki-COUsS_rn.js","./mode-mel-BnUZZ5yv.js","./mode-mips-Bn_sYoC5.js","./mode-mixal-Bz87pcrp.js","./mode-mushcode-C77Q17Az.js","./mode-mysql-DNfNMeEH.js","./mode-nginx-CDzfGUqd.js","./mode-nim-C6q1NbUw.js","./mode-nix-ConYnD5H.js","./mode-nsis-DlN-DoAL.js","./mode-nunjucks-TEOAJW3o.js","./mode-objectivec-Ey6hEK1I.js","./mode-ocaml-BSK4Q5Rs.js","./mode-partiql-DmFAq0uG.js","./mode-pascal-BTW3iz6H.js","./mode-perl-BioDCaAB.js","./mode-pgsql-DNuEdWUq.js","./mode-php-DKMABCBZ.js","./mode-php_laravel_blade-DYDA1qd4.js","./mode-pig-CZk7Vnap.js","./mode-plain_text-BqvTdXlY.js","./mode-plsql-Cj4ZLvtB.js","./mode-powershell-CDo804uu.js","./mode-praat-DkS-ffWH.js","./mode-prisma-qgFo8tPE.js","./mode-prolog-CyWnsGuJ.js","./mode-properties-Ca39WIwt.js","./mode-protobuf-lCWZap3a.js","./mode-puppet-CJAUwTXP.js","./mode-python-D8KWuRGc.js","./mode-qml-Coo2kLWT.js","./mode-r-B15jnayv.js","./mode-raku-CMGHCeDg.js","./mode-razor-BBRFf9pz.js","./mode-rdoc-C4lRvReu.js","./mode-red-0ERRWJL1.js","./mode-redshift-Cde38bVJ.js","./mode-rhtml-69A6i9O2.js","./mode-robot-DIfxeO_P.js","./mode-rst-DNuDkX3_.js","./mode-ruby-CPy8xE2i.js","./mode-rust-C_ZVCM4U.js","./mode-sac-DBGCE-wY.js","./mode-sass-BiWt35Y8.js","./mode-scad-D5vPhBrJ.js","./mode-scala-Dprv3mH9.js","./mode-scheme-CE7lfbvU.js","./mode-scrypt-C9dzH2yK.js","./mode-scss-DkgXrtwx.js","./mode-sh-DewzyMF0.js","./mode-sjs-DOA6xRHA.js","./mode-slim-ivj5lVBg.js","./mode-smarty-CmyoFfsE.js","./mode-smithy-BDqmWMGw.js","./mode-snippets-DA_M8_T7.js","./mode-soy_template-BLGHhsTq.js","./mode-space-Dsrh7x7z.js","./mode-sparql-da5YeyCd.js","./mode-sql-C6aT7e91.js","./mode-sqlserver-Dzbs2NVX.js","./mode-stylus-B3EFO71t.js","./mode-svg-OJUsz-UC.js","./mode-swift-D1a098aZ.js","./mode-tcl-XH-r2LN5.js","./mode-terraform-RwD-cyrN.js","./mode-tex-CkwOirfm.js","./mode-text-D4cNLpwJ.js","./mode-textile-SAmH8K2P.js","./mode-toml-DuEwpoQH.js","./mode-tsx-BIvAGOO_.js","./mode-turtle-beFm2Jh8.js","./mode-twig-Dh-KH-UG.js","./mode-typescript-Bwgk1LJ1.js","./mode-vala-CMH4nojV.js","./mode-vbscript-BD5_dmoJ.js","./mode-velocity-DL3kV132.js","./mode-verilog-6FclDmvN.js","./mode-vhdl-B0M7YKt5.js","./mode-visualforce-BAT9PK65.js","./mode-wollok-DBH6w10z.js","./mode-xml-BlXZNuxd.js","./mode-xquery-BtVw-BhC.js","./mode-yaml-VIut228V.js","./mode-zeek-Bw_ez6fG.js","./theme-ambiance-B4uluc5k.js","./theme-chaos-D6mzr2Yb.js","./theme-chrome-DWVisJrw.js","./theme-cloud9_day-CCS6wwhu.js","./theme-cloud9_night-C3c1vNDz.js","./theme-cloud9_night_low_color-4BLx3xDL.js","./theme-clouds-BvQPPs5g.js","./theme-clouds_midnight-us7iSnbK.js","./theme-cobalt-CzxFL8Q4.js","./theme-crimson_editor-CsAUwCfY.js","./theme-dawn-TctOOE68.js","./theme-dracula-CJfG5-Ty.js","./theme-dreamweaver-cLgxs_cE.js","./theme-eclipse-FbIS5qp3.js","./theme-github-zH6VvHWx.js","./theme-gob-CBrCppgV.js","./theme-gruvbox-DexkiKae.js","./theme-gruvbox_dark_hard-QGwl-11q.js","./theme-gruvbox_light_hard-BmZRKRJq.js","./theme-idle_fingers-Tr85tBUX.js","./theme-iplastic-BBTiX1aR.js","./theme-katzenmilch-CAi8HTbl.js","./theme-kr_theme-C33kJdeb.js","./theme-kuroir-Dp7jOpKN.js","./theme-merbivore-C1_PgmaH.js","./theme-merbivore_soft-DcmhLZLi.js","./theme-mono_industrial-7xq5X-6H.js","./theme-monokai-CoHG5EbA.js","./theme-nord_dark-DQOVwIlZ.js","./theme-one_dark-ClUHZuKU.js","./theme-pastel_on_dark-B2sRrws-.js","./theme-solarized_dark-Cz2rKIjR.js","./theme-solarized_light-ZdvOkaOF.js","./theme-sqlserver-CPF3daef.js","./theme-terminal-CsbEyZb2.js","./theme-textmate-DQtUVNIm.js","./theme-tomorrow-DwlZnZZB.js","./theme-tomorrow_night-bv60VzkD.js","./theme-tomorrow_night_blue-RBG7DPD_.js","./theme-tomorrow_night_bright-BgTIxLno.js","./theme-tomorrow_night_eighties-erYM-vJd.js","./theme-twilight-DohOeJpP.js","./theme-vibrant_ink-BzcsyjCq.js","./theme-xcode-KGoc_oWe.js","./worker-base-CgOHIwHc.js","./worker-coffee-DjtVRDXQ.js","./worker-css-Da_QyoXf.js","./worker-html-XeS91PbI.js","./worker-javascript-DglDr8oQ.js","./worker-json-Dq6edhIa.js","./worker-lua-BUwzH5Wt.js","./worker-php-Cw36pTaU.js","./worker-xml-D9OvSH3q.js","./worker-xquery-BKyStHrf.js","./worker-yaml-DyLD0qcp.js","./abap-CEsUs72j.js","./abc-CNZluz4Z.js","./actionscript-B-swKpKA.js","./ada-DOVqaW44.js","./alda-D67DWsG8.js","./apache_conf-CCOknK1B.js","./apex-DhhkyrI4.js","./applescript-C9WBHmmT.js","./aql-CBlK0mDs.js","./asciidoc-97pJIx1N.js","./asl-BM22YjRo.js","./assembly_x86-DFbmeI29.js","./autohotkey-DR_btT5s.js","./batchfile-CWX-sKB0.js","./bibtex-ZRUXLYHb.js","./c9search-Co8rde2h.js","./c_cpp-Dqe5L_LF.js","./cirru-DmHABcnI.js","./clojure-DmnuN_Ss.js","./cobol-BPply1Q_.js","./coffee-BVi820kf.js","./coldfusion-D5O3vvM2.js","./crystal-DzSgP4TJ.js","./csharp-CNnmOEnj.js","./csound_document-j-7q_Nah.js","./csound_orchestra-ChQtnNZZ.js","./csound_score-CqvBe7k8.js","./csp-BUoMNZ5U.js","./css-CS6w3kod.js","./curly-BADMHUUo.js","./d-QW3nP0eX.js","./dart-CsT8dyAF.js","./diff-BAtPi95_.js","./django-B1n7dois.js","./dockerfile-py6blxxX.js","./dot-DjsOktfx.js","./drools-CIYq9jJK.js","./edifact-Cb73PUHH.js","./eiffel-DqQEYrv9.js","./ejs-DWl3vP4w.js","./elixir-BJda7gNe.js","./elm-PbbgNvYa.js","./erlang-RMn66iAt.js","./forth-C187vFZA.js","./fortran-LayfPElz.js","./fsharp-rVs8DV2p.js","./fsl-Du4fyyH0.js","./ftl-4pOLNi-S.js","./gcode-5t6R3a6s.js","./gherkin-C7sgbKhz.js","./gitignore-BJExyNpy.js","./glsl-BIT7tyqM.js","./gobstones-DZC5o0Yg.js","./golang-Cky0HXmm.js","./graphqlschema-DHz8XIrn.js","./groovy-CxV4LfQ1.js","./haml-CUQKHFbq.js","./handlebars-DjBU5Qci.js","./haskell-Dg_IYtIF.js","./haskell_cabal-DooJpaup.js","./haxe-BcWirKAJ.js","./hjson-l0lQzsls.js","./html-DmuB9C6-.js","./html_elixir-cfoBbPki.js","./html_ruby-CZCw0U8k.js","./ini-D0fXEKqf.js","./io-Cw1KSq5U.js","./ion-rBAJBfqq.js","./jack-BRp9SkWx.js","./jade-DkefQPfW.js","./java-CdR78ZQy.js","./javascript-D1CnXGZV.js","./jexl-DHKJn5mp.js","./json-Dn7_q9gR.js","./json5-D_Nfthur.js","./jsoniq-Dr5RpXfE.js","./jsp-C-dIwKao.js","./jssm-1VoYjpRH.js","./jsx-BZYz8C-8.js","./julia-ZeECDrtS.js","./kotlin-Tavyyrjz.js","./latex-CbSzbM95.js","./latte-x16b9N4M.js","./less-BBVoQUNx.js","./liquid-BJD9Jggn.js","./lisp-brU3Njk9.js","./livescript-R54hsikb.js","./logiql-VT03gQju.js","./logtalk-DgD5tEKl.js","./lsl-DwANLG5L.js","./lua-KB462xJZ.js","./luapage-C2KxtZRD.js","./lucene-Ddsdwf8B.js","./makefile-BAKUlOxX.js","./markdown-C7NXMxs_.js","./mask-CHd8Ii9R.js","./matlab-BgLHc73d.js","./maze-xJbIIxkl.js","./mediawiki-BpU2_ljM.js","./mel-B0bsWAr_.js","./mips-nu4hdQb-.js","./mixal-iqu_c_rC.js","./mushcode-CUUfxNb6.js","./mysql-BdbM_ZxD.js","./nginx-C_NvS4P5.js","./nim-CQ_C_zvq.js","./nix-ILaSSPcB.js","./nsis-CZRhd0ay.js","./nunjucks-DEW4FIKf.js","./objectivec-C6YpGJTm.js","./ocaml-2cjitzaq.js","./partiql-B7-LpKL_.js","./pascal-BhSzRQuD.js","./perl-BU8bn5Cu.js","./pgsql-Dd3ExB6a.js","./php-gD9ZDW9G.js","./php_laravel_blade-Dxj3F60-.js","./pig-CuX1r4qQ.js","./plain_text-CUNdYPfv.js","./plsql-D4MDpFXo.js","./powershell-wlTiAGHi.js","./praat-9jhAaIQ_.js","./prisma-CSA2bC57.js","./prolog-BHcuuWm7.js","./properties-CtEk0z8X.js","./protobuf-OSZ0U1eW.js","./puppet-DI9V265k.js","./python-BRPEAeSJ.js","./qml-ABzcuRnX.js","./r-CBI5rCWz.js","./raku-hrjc4ubt.js","./razor-iSLg8LVw.js","./rdoc-zX8SZqt6.js","./red-DOofQE2H.js","./redshift-Hhw-UQHY.js","./rhtml-BvhChPVY.js","./robot-Ci0OVa9-.js","./rst-DCE6iA3i.js","./ruby-CZGLnLT7.js","./rust-c5qetp3n.js","./sac-CSf5sDos.js","./sass-DaZ8szBO.js","./scad-CVusb0HT.js","./scala-CDdmlwB_.js","./scheme-DHQsYzhT.js","./scrypt-DgPkw0WW.js","./scss-YW3L-2yq.js","./sh-DWcnS245.js","./sjs-C4mscX92.js","./slim-BHpBabcA.js","./smarty-BI4Go1fr.js","./smithy-DOEiwlEw.js","./snippets-DXhyjLWK.js","./soy_template-_lplzK_3.js","./space-BFRaE9cQ.js","./sparql-0GEuLc3r.js","./sql-CtwR3Rip.js","./sqlserver-Bjhpf087.js","./stylus-CGaJzFiU.js","./svg-Cvl0wkJ6.js","./swift-BMZwfT9O.js","./tcl-Bbw2nAxK.js","./terraform-D8lc2x8I.js","./tex-C0PuHebH.js","./text-W0uvhcLs.js","./textile-s60qmdzJ.js","./toml-CEKH2DS9.js","./tsx-CXJT3DM4.js","./turtle-D5jMlPrc.js","./twig-CXG-bFlZ.js","./typescript-CiZ7zDrF.js","./vala-B7rbJ9nI.js","./vbscript-Dov_hbCw.js","./velocity-CK1SoJ8P.js","./verilog--5hx8IP1.js","./vhdl-D_qrqksV.js","./visualforce-U6AQSjD6.js","./wollok-HweflpAN.js","./xml-PWR1Xfhc.js","./xquery-CCCS4Ekw.js","./yaml-YBWsxdcK.js","./zeek-D1ij6H2K.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _a, _b, _c, _d, _e, _root, _rootRendered, _rendering, _state, _stateSetters, _customEvents, _dispatchFlowState, _readyCallback, _renderHooks, _Wrapper, _unmounting, _ReactAdapterElement_instances, maybeRenderRoot_fn, renderWrapper_fn, markAsUsed_fn, _f, _g;
import { c as css, a as addLumoGlobalStyles, r as registerStyles$1, d as defineCustomElement, T as ThemableMixin, t as themeRegistry, u as unsafeCSS, b as ThemePropertyMixin, n as nothing, e as render, h as html$1, D as Directive, P as PartType, f as directive, g as noChange, s as svg, i as color, j as typography, L as LitElement, k as reactExports, l as clientExports, m as jsxDevRuntimeExports, O as Outlet, _ as __vitePreload } from "./indexhtml-CE3rDMXe.js";
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const userColors = css`
  :host {
    --vaadin-user-color-0: #df0b92;
    --vaadin-user-color-1: #650acc;
    --vaadin-user-color-2: #097faa;
    --vaadin-user-color-3: #ad6200;
    --vaadin-user-color-4: #bf16f3;
    --vaadin-user-color-5: #084391;
    --vaadin-user-color-6: #078836;
  }

  [theme~='dark'] {
    --vaadin-user-color-0: #ff66c7;
    --vaadin-user-color-1: #9d8aff;
    --vaadin-user-color-2: #8aff66;
    --vaadin-user-color-3: #ffbd66;
    --vaadin-user-color-4: #dc6bff;
    --vaadin-user-color-5: #66fffa;
    --vaadin-user-color-6: #e6ff66;
  }
`;
addLumoGlobalStyles("user-color-props", userColors);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1(
  "vaadin-field-outline",
  css`
    :host {
      transition: opacity 0.3s;
      -webkit-mask-image: none !important;
      mask-image: none !important;
    }

    :host::before {
      content: '';
      position: absolute;
      inset: 0;
      box-shadow: 0 0 0 2px var(--_active-user-color);
      border-radius: var(--lumo-border-radius-s);
      transition: box-shadow 0.3s;
    }

    :host([context$='checkbox'])::before {
      box-shadow:
        0 0 0 2px var(--lumo-base-color),
        0 0 0 4px var(--_active-user-color);
    }

    :host([context$='radio-button'])::before {
      border-radius: 50%;
      box-shadow:
        0 0 0 3px var(--lumo-base-color),
        0 0 0 5px var(--_active-user-color);
    }

    :host([context$='item'])::before {
      box-shadow: inset 0 0 0 2px var(--_active-user-color);
    }
  `,
  { moduleId: "lumo-field-outline" }
);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const overlay = css`
  :host {
    top: var(--lumo-space-m);
    right: var(--lumo-space-m);
    bottom: var(--lumo-space-m);
    left: var(--lumo-space-m);
    /* Workaround for Edge issue (only on Surface), where an overflowing vaadin-list-box inside vaadin-select-overlay makes the overlay transparent */
    /* stylelint-disable-next-line */
    outline: 0px solid transparent;
  }

  [part='overlay'] {
    background-color: var(--lumo-base-color);
    background-image: linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
    border-radius: var(--lumo-border-radius-m);
    box-shadow:
      0 0 0 1px var(--lumo-shade-5pct),
      var(--lumo-box-shadow-m);
    color: var(--lumo-body-text-color);
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    font-weight: 400;
    line-height: var(--lumo-line-height-m);
    letter-spacing: 0;
    text-transform: none;
    -webkit-text-size-adjust: 100%;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  [part='content'] {
    padding: var(--lumo-space-xs);
  }

  [part='backdrop'] {
    background-color: var(--lumo-shade-20pct);
    animation: 0.2s lumo-overlay-backdrop-enter both;
    will-change: opacity;
  }

  @keyframes lumo-overlay-backdrop-enter {
    0% {
      opacity: 0;
    }
  }

  :host([closing]) [part='backdrop'] {
    animation: 0.2s lumo-overlay-backdrop-exit both;
  }

  @keyframes lumo-overlay-backdrop-exit {
    100% {
      opacity: 0;
    }
  }

  @keyframes lumo-overlay-dummy-animation {
    0% {
      opacity: 1;
    }

    100% {
      opacity: 1;
    }
  }
`;
registerStyles$1("", overlay, { moduleId: "lumo-overlay" });
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1(
  "vaadin-user-tags-overlay",
  [
    overlay,
    css`
      [part='overlay'] {
        will-change: opacity, transform;
      }

      :host([opening]) [part='overlay'] {
        animation: 0.1s lumo-user-tags-enter ease-out both;
      }

      @keyframes lumo-user-tags-enter {
        0% {
          opacity: 0;
        }
      }

      :host([closing]) [part='overlay'] {
        animation: 0.1s lumo-user-tags-exit both;
      }

      @keyframes lumo-user-tags-exit {
        100% {
          opacity: 0;
        }
      }
    `
  ],
  {
    moduleId: "lumo-user-tags-overlay"
  }
);
registerStyles$1(
  "vaadin-user-tag",
  css`
    :host {
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-xxs);
      border-radius: var(--lumo-border-radius-s);
      box-shadow: var(--lumo-box-shadow-xs);
      --vaadin-user-tag-offset: var(--lumo-space-xs);
    }

    [part='name'] {
      color: var(--lumo-primary-contrast-color);
      padding: 0.3em calc(0.3em + var(--lumo-border-radius-s) / 4);
      line-height: 1;
      font-weight: 500;
      min-width: calc(var(--lumo-line-height-xs) * 1em + 0.45em);
    }
  `,
  { moduleId: "lumo-user-tag" }
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
window.JSCompiler_renameProperty = function(prop, obj) {
  return prop;
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let CSS_URL_RX = /(url\()([^)]*)(\))/g;
let ABS_URL = /(^\/[^\/])|(^#)|(^[\w-\d]*:)/;
let workingURL;
let resolveDoc;
function resolveUrl(url, baseURI) {
  if (url && ABS_URL.test(url)) {
    return url;
  }
  if (url === "//") {
    return url;
  }
  if (workingURL === void 0) {
    workingURL = false;
    try {
      const u2 = new URL("b", "http://a");
      u2.pathname = "c%20d";
      workingURL = u2.href === "http://a/c%20d";
    } catch (e2) {
    }
  }
  if (!baseURI) {
    baseURI = document.baseURI || window.location.href;
  }
  if (workingURL) {
    try {
      return new URL(url, baseURI).href;
    } catch (e2) {
      return url;
    }
  }
  if (!resolveDoc) {
    resolveDoc = document.implementation.createHTMLDocument("temp");
    resolveDoc.base = resolveDoc.createElement("base");
    resolveDoc.head.appendChild(resolveDoc.base);
    resolveDoc.anchor = resolveDoc.createElement("a");
    resolveDoc.body.appendChild(resolveDoc.anchor);
  }
  resolveDoc.base.href = baseURI;
  resolveDoc.anchor.href = url;
  return resolveDoc.anchor.href || url;
}
function resolveCss(cssText, baseURI) {
  return cssText.replace(CSS_URL_RX, function(m3, pre, url, post) {
    return pre + "'" + resolveUrl(url.replace(/["']/g, ""), baseURI) + "'" + post;
  });
}
function pathFromUrl(url) {
  return url.substring(0, url.lastIndexOf("/") + 1);
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const useShadow = !window.ShadyDOM || !window.ShadyDOM.inUse;
Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
const supportsAdoptingStyleSheets$1 = useShadow && "adoptedStyleSheets" in Document.prototype && "replaceSync" in CSSStyleSheet.prototype && // Since spec may change, feature detect exact API we need
(() => {
  try {
    const sheet = new CSSStyleSheet();
    sheet.replaceSync("");
    const host = document.createElement("div");
    host.attachShadow({ mode: "open" });
    host.shadowRoot.adoptedStyleSheets = [sheet];
    return host.shadowRoot.adoptedStyleSheets[0] === sheet;
  } catch (e2) {
    return false;
  }
})();
let rootPath = window.Polymer && window.Polymer.rootPath || pathFromUrl(document.baseURI || window.location.href);
let sanitizeDOMValue = window.Polymer && window.Polymer.sanitizeDOMValue || void 0;
window.Polymer && window.Polymer.setPassiveTouchGestures || false;
let strictTemplatePolicy = window.Polymer && window.Polymer.strictTemplatePolicy || false;
let allowTemplateFromDomModule = window.Polymer && window.Polymer.allowTemplateFromDomModule || false;
let legacyOptimizations = window.Polymer && window.Polymer.legacyOptimizations || false;
let legacyWarnings = window.Polymer && window.Polymer.legacyWarnings || false;
let syncInitialRender = window.Polymer && window.Polymer.syncInitialRender || false;
let legacyUndefined = window.Polymer && window.Polymer.legacyUndefined || false;
let orderedComputed = window.Polymer && window.Polymer.orderedComputed || false;
let removeNestedTemplates = window.Polymer && window.Polymer.removeNestedTemplates || false;
let fastDomIf = window.Polymer && window.Polymer.fastDomIf || false;
let suppressTemplateNotifications = window.Polymer && window.Polymer.suppressTemplateNotifications || false;
window.Polymer && window.Polymer.legacyNoObservedAttributes || false;
let useAdoptedStyleSheetsWithBuiltCSS = window.Polymer && window.Polymer.useAdoptedStyleSheetsWithBuiltCSS || false;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let dedupeId$1 = 0;
const dedupingMixin = function(mixin) {
  let mixinApplications = (
    /** @type {!MixinFunction} */
    mixin.__mixinApplications
  );
  if (!mixinApplications) {
    mixinApplications = /* @__PURE__ */ new WeakMap();
    mixin.__mixinApplications = mixinApplications;
  }
  let mixinDedupeId = dedupeId$1++;
  function dedupingMixin2(base) {
    let baseSet = (
      /** @type {!MixinFunction} */
      base.__mixinSet
    );
    if (baseSet && baseSet[mixinDedupeId]) {
      return base;
    }
    let map = mixinApplications;
    let extended = map.get(base);
    if (!extended) {
      extended = /** @type {!Function} */
      mixin(base);
      map.set(base, extended);
      let mixinSet = Object.create(
        /** @type {!MixinFunction} */
        extended.__mixinSet || baseSet || null
      );
      mixinSet[mixinDedupeId] = true;
      extended.__mixinSet = mixinSet;
    }
    return extended;
  }
  return dedupingMixin2;
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let modules = {};
let lcModules = {};
function setModule(id, module2) {
  modules[id] = lcModules[id.toLowerCase()] = module2;
}
function findModule(id) {
  return modules[id] || lcModules[id.toLowerCase()];
}
function styleOutsideTemplateCheck(inst) {
  if (inst.querySelector("style")) {
    console.warn("dom-module %s has style outside template", inst.id);
  }
}
class DomModule extends HTMLElement {
  /** @override */
  static get observedAttributes() {
    return ["id"];
  }
  /**
   * Retrieves the element specified by the css `selector` in the module
   * registered by `id`. For example, this.import('foo', 'img');
   * @param {string} id The id of the dom-module in which to search.
   * @param {string=} selector The css selector by which to find the element.
   * @return {Element} Returns the element which matches `selector` in the
   * module registered at the specified `id`.
   *
   * @export
   * @nocollapse Referred to indirectly in style-gather.js
   */
  static import(id, selector) {
    if (id) {
      let m3 = findModule(id);
      if (m3 && selector) {
        return m3.querySelector(selector);
      }
      return m3;
    }
    return null;
  }
  /* eslint-disable no-unused-vars */
  /**
   * @param {string} name Name of attribute.
   * @param {?string} old Old value of attribute.
   * @param {?string} value Current value of attribute.
   * @param {?string} namespace Attribute namespace.
   * @return {void}
   * @override
   */
  attributeChangedCallback(name, old, value, namespace) {
    if (old !== value) {
      this.register();
    }
  }
  /* eslint-enable no-unused-args */
  /**
   * The absolute URL of the original location of this `dom-module`.
   *
   * This value will differ from this element's `ownerDocument` in the
   * following ways:
   * - Takes into account any `assetpath` attribute added during bundling
   *   to indicate the original location relative to the bundled location
   * - Uses the HTMLImports polyfill's `importForElement` API to ensure
   *   the path is relative to the import document's location since
   *   `ownerDocument` is not currently polyfilled
   */
  get assetpath() {
    if (!this.__assetpath) {
      const owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
      const url = resolveUrl(
        this.getAttribute("assetpath") || "",
        owner.baseURI
      );
      this.__assetpath = pathFromUrl(url);
    }
    return this.__assetpath;
  }
  /**
   * Registers the dom-module at a given id. This method should only be called
   * when a dom-module is imperatively created. For
   * example, `document.createElement('dom-module').register('foo')`.
   * @param {string=} id The id at which to register the dom-module.
   * @return {void}
   */
  register(id) {
    id = id || this.id;
    if (id) {
      if (strictTemplatePolicy && findModule(id) !== void 0) {
        setModule(id, null);
        throw new Error(`strictTemplatePolicy: dom-module ${id} re-registered`);
      }
      this.id = id;
      setModule(id, this);
      styleOutsideTemplateCheck(this);
    }
  }
}
DomModule.prototype["modules"] = modules;
customElements.define("dom-module", DomModule);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const MODULE_STYLE_LINK_SELECTOR = "link[rel=import][type~=css]";
const INCLUDE_ATTR = "include";
const SHADY_UNSCOPED_ATTR = "shady-unscoped";
function importModule(moduleId) {
  return (
    /** @type {?DomModule} */
    DomModule.import(moduleId)
  );
}
function styleForImport(importDoc) {
  let container = importDoc.body ? importDoc.body : importDoc;
  const importCss = resolveCss(
    container.textContent,
    importDoc.baseURI
  );
  const style = document.createElement("style");
  style.textContent = importCss;
  return style;
}
function stylesFromModules(moduleIds) {
  const modules2 = moduleIds.trim().split(/\s+/);
  const styles2 = [];
  for (let i2 = 0; i2 < modules2.length; i2++) {
    styles2.push(...stylesFromModule(modules2[i2]));
  }
  return styles2;
}
function stylesFromModule(moduleId) {
  const m3 = importModule(moduleId);
  if (!m3) {
    console.warn("Could not find style data in module named", moduleId);
    return [];
  }
  if (m3._styles === void 0) {
    const styles2 = [];
    styles2.push(..._stylesFromModuleImports(m3));
    const template2 = (
      /** @type {?HTMLTemplateElement} */
      m3.querySelector("template")
    );
    if (template2) {
      styles2.push(...stylesFromTemplate(
        template2,
        /** @type {templateWithAssetPath} */
        m3.assetpath
      ));
    }
    m3._styles = styles2;
  }
  return m3._styles;
}
function stylesFromTemplate(template2, baseURI) {
  if (!template2._styles) {
    const styles2 = [];
    const e$ = template2.content.querySelectorAll("style");
    for (let i2 = 0; i2 < e$.length; i2++) {
      let e2 = e$[i2];
      let include = e2.getAttribute(INCLUDE_ATTR);
      if (include) {
        styles2.push(...stylesFromModules(include).filter(function(item2, index, self2) {
          return self2.indexOf(item2) === index;
        }));
      }
      if (baseURI) {
        e2.textContent = resolveCss(
          e2.textContent,
          /** @type {string} */
          baseURI
        );
      }
      styles2.push(e2);
    }
    template2._styles = styles2;
  }
  return template2._styles;
}
function stylesFromModuleImports(moduleId) {
  let m3 = importModule(moduleId);
  return m3 ? _stylesFromModuleImports(m3) : [];
}
function _stylesFromModuleImports(module2) {
  const styles2 = [];
  const p$ = module2.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
  for (let i2 = 0; i2 < p$.length; i2++) {
    let p = p$[i2];
    if (p.import) {
      const importDoc = p.import;
      const unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);
      if (unscoped && !importDoc._unscopedStyle) {
        const style = styleForImport(importDoc);
        style.setAttribute(SHADY_UNSCOPED_ATTR, "");
        importDoc._unscopedStyle = style;
      } else if (!importDoc._style) {
        importDoc._style = styleForImport(importDoc);
      }
      styles2.push(unscoped ? importDoc._unscopedStyle : importDoc._style);
    }
  }
  return styles2;
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const wrap$1 = window["ShadyDOM"] && window["ShadyDOM"]["noPatch"] && window["ShadyDOM"]["wrap"] ? window["ShadyDOM"]["wrap"] : window["ShadyDOM"] ? (n) => ShadyDOM["patch"](n) : (n) => n;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function isPath(path) {
  return path.indexOf(".") >= 0;
}
function root(path) {
  let dotIndex = path.indexOf(".");
  if (dotIndex === -1) {
    return path;
  }
  return path.slice(0, dotIndex);
}
function isAncestor(base, path) {
  return base.indexOf(path + ".") === 0;
}
function isDescendant(base, path) {
  return path.indexOf(base + ".") === 0;
}
function translate(base, newBase, path) {
  return newBase + path.slice(base.length);
}
function matches(base, path) {
  return base === path || isAncestor(base, path) || isDescendant(base, path);
}
function normalize(path) {
  if (Array.isArray(path)) {
    let parts = [];
    for (let i2 = 0; i2 < path.length; i2++) {
      let args = path[i2].toString().split(".");
      for (let j = 0; j < args.length; j++) {
        parts.push(args[j]);
      }
    }
    return parts.join(".");
  } else {
    return path;
  }
}
function split(path) {
  if (Array.isArray(path)) {
    return normalize(path).split(".");
  }
  return path.toString().split(".");
}
function get$2(root2, path, info) {
  let prop = root2;
  let parts = split(path);
  for (let i2 = 0; i2 < parts.length; i2++) {
    if (!prop) {
      return;
    }
    let part = parts[i2];
    prop = prop[part];
  }
  if (info) {
    info.path = parts.join(".");
  }
  return prop;
}
function set$1(root2, path, value) {
  let prop = root2;
  let parts = split(path);
  let last = parts[parts.length - 1];
  if (parts.length > 1) {
    for (let i2 = 0; i2 < parts.length - 1; i2++) {
      let part = parts[i2];
      prop = prop[part];
      if (!prop) {
        return;
      }
    }
    prop[last] = value;
  } else {
    prop[path] = value;
  }
  return parts.join(".");
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const caseMap$1 = {};
const DASH_TO_CAMEL = /-[a-z]/g;
const CAMEL_TO_DASH$1 = /([A-Z])/g;
function dashToCamelCase(dash) {
  return caseMap$1[dash] || (caseMap$1[dash] = dash.indexOf("-") < 0 ? dash : dash.replace(
    DASH_TO_CAMEL,
    (m3) => m3[1].toUpperCase()
  ));
}
function camelToDashCase(camel) {
  return caseMap$1[camel] || (caseMap$1[camel] = camel.replace(CAMEL_TO_DASH$1, "-$1").toLowerCase());
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let microtaskCurrHandle$1 = 0;
let microtaskLastHandle$1 = 0;
let microtaskCallbacks$1 = [];
let microtaskNodeContent = 0;
let microtaskScheduled$1 = false;
let microtaskNode = document.createTextNode("");
new window.MutationObserver(microtaskFlush$1).observe(microtaskNode, { characterData: true });
function microtaskFlush$1() {
  microtaskScheduled$1 = false;
  const len = microtaskCallbacks$1.length;
  for (let i2 = 0; i2 < len; i2++) {
    let cb = microtaskCallbacks$1[i2];
    if (cb) {
      try {
        cb();
      } catch (e2) {
        setTimeout(() => {
          throw e2;
        });
      }
    }
  }
  microtaskCallbacks$1.splice(0, len);
  microtaskLastHandle$1 += len;
}
const timeOut$1 = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof timeOut
   * @param {number=} delay Time to wait before calling callbacks in ms
   * @return {!AsyncInterface} An async timeout interface
   */
  after(delay) {
    return {
      run(fn) {
        return window.setTimeout(fn, delay);
      },
      cancel(handle) {
        window.clearTimeout(handle);
      }
    };
  },
  /**
   * Enqueues a function called in the next task.
   *
   * @memberof timeOut
   * @param {!Function} fn Callback to run
   * @param {number=} delay Delay in milliseconds
   * @return {number} Handle used for canceling task
   */
  run(fn, delay) {
    return window.setTimeout(fn, delay);
  },
  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    window.clearTimeout(handle);
  }
};
const animationFrame$1 = {
  /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof animationFrame
   * @param {function(number):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(fn) {
    return window.requestAnimationFrame(fn);
  },
  /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof animationFrame
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    window.cancelAnimationFrame(handle);
  }
};
const idlePeriod$1 = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof idlePeriod
   * @param {function(!IdleDeadline):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(fn) {
    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
  },
  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);
  }
};
const microTask$1 = {
  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(callback) {
    if (!microtaskScheduled$1) {
      microtaskScheduled$1 = true;
      microtaskNode.textContent = microtaskNodeContent++;
    }
    microtaskCallbacks$1.push(callback);
    return microtaskCurrHandle$1++;
  },
  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    const idx = handle - microtaskLastHandle$1;
    if (idx >= 0) {
      if (!microtaskCallbacks$1[idx]) {
        throw new Error("invalid async handle: " + handle);
      }
      microtaskCallbacks$1[idx] = null;
    }
  }
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const microtask = microTask$1;
const PropertiesChanged = dedupingMixin(
  /**
   * @template T
   * @param {function(new:T)} superClass Class to apply mixin to.
   * @return {function(new:T)} superClass with mixin applied.
   */
  (superClass) => {
    class PropertiesChanged2 extends superClass {
      /**
       * Creates property accessors for the given property names.
       * @param {!Object} props Object whose keys are names of accessors.
       * @return {void}
       * @protected
       * @nocollapse
       */
      static createProperties(props) {
        const proto2 = this.prototype;
        for (let prop in props) {
          if (!(prop in proto2)) {
            proto2._createPropertyAccessor(prop);
          }
        }
      }
      /**
       * Returns an attribute name that corresponds to the given property.
       * The attribute name is the lowercased property name. Override to
       * customize this mapping.
       * @param {string} property Property to convert
       * @return {string} Attribute name corresponding to the given property.
       *
       * @protected
       * @nocollapse
       */
      static attributeNameForProperty(property) {
        return property.toLowerCase();
      }
      /**
       * Override point to provide a type to which to deserialize a value to
       * a given property.
       * @param {string} name Name of property
       *
       * @protected
       * @nocollapse
       */
      static typeForProperty(name) {
      }
      //eslint-disable-line no-unused-vars
      /**
       * Creates a setter/getter pair for the named property with its own
       * local storage.  The getter returns the value in the local storage,
       * and the setter calls `_setProperty`, which updates the local storage
       * for the property and enqueues a `_propertiesChanged` callback.
       *
       * This method may be called on a prototype or an instance.  Calling
       * this method may overwrite a property value that already exists on
       * the prototype/instance by creating the accessor.
       *
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created; the
       *   protected `_setProperty` function must be used to set the property
       * @return {void}
       * @protected
       * @override
       */
      _createPropertyAccessor(property, readOnly) {
        this._addPropertyToAttributeMap(property);
        if (!this.hasOwnProperty(JSCompiler_renameProperty("__dataHasAccessor", this))) {
          this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
        }
        if (!this.__dataHasAccessor[property]) {
          this.__dataHasAccessor[property] = true;
          this._definePropertyAccessor(property, readOnly);
        }
      }
      /**
       * Adds the given `property` to a map matching attribute names
       * to property names, using `attributeNameForProperty`. This map is
       * used when deserializing attribute values to properties.
       *
       * @param {string} property Name of the property
       * @override
       */
      _addPropertyToAttributeMap(property) {
        if (!this.hasOwnProperty(JSCompiler_renameProperty("__dataAttributes", this))) {
          this.__dataAttributes = Object.assign({}, this.__dataAttributes);
        }
        let attr = this.__dataAttributes[property];
        if (!attr) {
          attr = this.constructor.attributeNameForProperty(property);
          this.__dataAttributes[attr] = property;
        }
        return attr;
      }
      /**
       * Defines a property accessor for the given property.
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created
       * @return {void}
       * @override
       */
      _definePropertyAccessor(property, readOnly) {
        Object.defineProperty(this, property, {
          /* eslint-disable valid-jsdoc */
          /** @this {PropertiesChanged} */
          get() {
            return this.__data[property];
          },
          /** @this {PropertiesChanged} */
          set: readOnly ? function() {
          } : function(value) {
            if (this._setPendingProperty(property, value, true)) {
              this._invalidateProperties();
            }
          }
          /* eslint-enable */
        });
      }
      constructor() {
        super();
        this.__dataEnabled = false;
        this.__dataReady = false;
        this.__dataInvalid = false;
        this.__data = {};
        this.__dataPending = null;
        this.__dataOld = null;
        this.__dataInstanceProps = null;
        this.__dataCounter = 0;
        this.__serializing = false;
        this._initializeProperties();
      }
      /**
       * Lifecycle callback called when properties are enabled via
       * `_enableProperties`.
       *
       * Users may override this function to implement behavior that is
       * dependent on the element having its property data initialized, e.g.
       * from defaults (initialized from `constructor`, `_initializeProperties`),
       * `attributeChangedCallback`, or values propagated from host e.g. via
       * bindings.  `super.ready()` must be called to ensure the data system
       * becomes enabled.
       *
       * @return {void}
       * @public
       * @override
       */
      ready() {
        this.__dataReady = true;
        this._flushProperties();
      }
      /**
       * Initializes the local storage for property accessors.
       *
       * Provided as an override point for performing any setup work prior
       * to initializing the property accessor system.
       *
       * @return {void}
       * @protected
       * @override
       */
      _initializeProperties() {
        for (let p in this.__dataHasAccessor) {
          if (this.hasOwnProperty(p)) {
            this.__dataInstanceProps = this.__dataInstanceProps || {};
            this.__dataInstanceProps[p] = this[p];
            delete this[p];
          }
        }
      }
      /**
       * Called at ready time with bag of instance properties that overwrote
       * accessors when the element upgraded.
       *
       * The default implementation sets these properties back into the
       * setter at ready time.  This method is provided as an override
       * point for customizing or providing more efficient initialization.
       *
       * @param {Object} props Bag of property values that were overwritten
       *   when creating property accessors.
       * @return {void}
       * @protected
       * @override
       */
      _initializeInstanceProperties(props) {
        Object.assign(this, props);
      }
      /**
       * Updates the local storage for a property (via `_setPendingProperty`)
       * and enqueues a `_proeprtiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @return {void}
       * @protected
       * @override
       */
      _setProperty(property, value) {
        if (this._setPendingProperty(property, value)) {
          this._invalidateProperties();
        }
      }
      /**
       * Returns the value for the given property.
       * @param {string} property Name of property
       * @return {*} Value for the given property
       * @protected
       * @override
       */
      _getProperty(property) {
        return this.__data[property];
      }
      /* eslint-disable no-unused-vars */
      /**
       * Updates the local storage for a property, records the previous value,
       * and adds it to the set of "pending changes" that will be passed to the
       * `_propertiesChanged` callback.  This method does not enqueue the
       * `_propertiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @param {boolean=} ext Not used here; affordance for closure
       * @return {boolean} Returns true if the property changed
       * @protected
       * @override
       */
      _setPendingProperty(property, value, ext) {
        let old = this.__data[property];
        let changed = this._shouldPropertyChange(property, value, old);
        if (changed) {
          if (!this.__dataPending) {
            this.__dataPending = {};
            this.__dataOld = {};
          }
          if (this.__dataOld && !(property in this.__dataOld)) {
            this.__dataOld[property] = old;
          }
          this.__data[property] = value;
          this.__dataPending[property] = value;
        }
        return changed;
      }
      /* eslint-enable */
      /**
       * @param {string} property Name of the property
       * @return {boolean} Returns true if the property is pending.
       */
      _isPropertyPending(property) {
        return !!(this.__dataPending && this.__dataPending.hasOwnProperty(property));
      }
      /**
       * Marks the properties as invalid, and enqueues an async
       * `_propertiesChanged` callback.
       *
       * @return {void}
       * @protected
       * @override
       */
      _invalidateProperties() {
        if (!this.__dataInvalid && this.__dataReady) {
          this.__dataInvalid = true;
          microtask.run(() => {
            if (this.__dataInvalid) {
              this.__dataInvalid = false;
              this._flushProperties();
            }
          });
        }
      }
      /**
       * Call to enable property accessor processing. Before this method is
       * called accessor values will be set but side effects are
       * queued. When called, any pending side effects occur immediately.
       * For elements, generally `connectedCallback` is a normal spot to do so.
       * It is safe to call this method multiple times as it only turns on
       * property accessors once.
       *
       * @return {void}
       * @protected
       * @override
       */
      _enableProperties() {
        if (!this.__dataEnabled) {
          this.__dataEnabled = true;
          if (this.__dataInstanceProps) {
            this._initializeInstanceProperties(this.__dataInstanceProps);
            this.__dataInstanceProps = null;
          }
          this.ready();
        }
      }
      /**
       * Calls the `_propertiesChanged` callback with the current set of
       * pending changes (and old values recorded when pending changes were
       * set), and resets the pending set of changes. Generally, this method
       * should not be called in user code.
       *
       * @return {void}
       * @protected
       * @override
       */
      _flushProperties() {
        this.__dataCounter++;
        const props = this.__data;
        const changedProps = this.__dataPending;
        const old = this.__dataOld;
        if (this._shouldPropertiesChange(props, changedProps, old)) {
          this.__dataPending = null;
          this.__dataOld = null;
          this._propertiesChanged(props, changedProps, old);
        }
        this.__dataCounter--;
      }
      /**
       * Called in `_flushProperties` to determine if `_propertiesChanged`
       * should be called. The default implementation returns true if
       * properties are pending. Override to customize when
       * `_propertiesChanged` is called.
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {?Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {?Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @return {boolean} true if changedProps is truthy
       * @override
       */
      _shouldPropertiesChange(currentProps, changedProps, oldProps) {
        return Boolean(changedProps);
      }
      /**
       * Callback called when any properties with accessors created via
       * `_createPropertyAccessor` have been set.
       *
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {?Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {?Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @return {void}
       * @protected
       * @override
       */
      _propertiesChanged(currentProps, changedProps, oldProps) {
      }
      /**
       * Method called to determine whether a property value should be
       * considered as a change and cause the `_propertiesChanged` callback
       * to be enqueued.
       *
       * The default implementation returns `true` if a strict equality
       * check fails. The method always returns false for `NaN`.
       *
       * Override this method to e.g. provide stricter checking for
       * Objects/Arrays when using immutable patterns.
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       *   and enqueue a `_proeprtiesChanged` callback
       * @protected
       * @override
       */
      _shouldPropertyChange(property, value, old) {
        return (
          // Strict equality check
          old !== value && // This ensures (old==NaN, value==NaN) always returns false
          (old === old || value === value)
        );
      }
      /**
       * Implements native Custom Elements `attributeChangedCallback` to
       * set an attribute value to a property via `_attributeToProperty`.
       *
       * @param {string} name Name of attribute that changed
       * @param {?string} old Old attribute value
       * @param {?string} value New attribute value
       * @param {?string} namespace Attribute namespace.
       * @return {void}
       * @suppress {missingProperties} Super may or may not implement the callback
       * @override
       */
      attributeChangedCallback(name, old, value, namespace) {
        if (old !== value) {
          this._attributeToProperty(name, value);
        }
        if (super.attributeChangedCallback) {
          super.attributeChangedCallback(name, old, value, namespace);
        }
      }
      /**
       * Deserializes an attribute to its associated property.
       *
       * This method calls the `_deserializeValue` method to convert the string to
       * a typed value.
       *
       * @param {string} attribute Name of attribute to deserialize.
       * @param {?string} value of the attribute.
       * @param {*=} type type to deserialize to, defaults to the value
       * returned from `typeForProperty`
       * @return {void}
       * @override
       */
      _attributeToProperty(attribute, value, type) {
        if (!this.__serializing) {
          const map = this.__dataAttributes;
          const property = map && map[attribute] || attribute;
          this[property] = this._deserializeValue(value, type || this.constructor.typeForProperty(property));
        }
      }
      /**
       * Serializes a property to its associated attribute.
       *
       * @suppress {invalidCasts} Closure can't figure out `this` is an element.
       *
       * @param {string} property Property name to reflect.
       * @param {string=} attribute Attribute name to reflect to.
       * @param {*=} value Property value to refect.
       * @return {void}
       * @override
       */
      _propertyToAttribute(property, attribute, value) {
        this.__serializing = true;
        value = arguments.length < 3 ? this[property] : value;
        this._valueToNodeAttribute(
          /** @type {!HTMLElement} */
          this,
          value,
          attribute || this.constructor.attributeNameForProperty(property)
        );
        this.__serializing = false;
      }
      /**
       * Sets a typed value to an HTML attribute on a node.
       *
       * This method calls the `_serializeValue` method to convert the typed
       * value to a string.  If the `_serializeValue` method returns `undefined`,
       * the attribute will be removed (this is the default for boolean
       * type `false`).
       *
       * @param {Element} node Element to set attribute to.
       * @param {*} value Value to serialize.
       * @param {string} attribute Attribute name to serialize to.
       * @return {void}
       * @override
       */
      _valueToNodeAttribute(node, value, attribute) {
        const str = this._serializeValue(value);
        if (attribute === "class" || attribute === "name" || attribute === "slot") {
          node = /** @type {?Element} */
          wrap$1(node);
        }
        if (str === void 0) {
          node.removeAttribute(attribute);
        } else {
          node.setAttribute(
            attribute,
            // Closure's type for `setAttribute`'s second parameter incorrectly
            // excludes `TrustedScript`.
            str === "" && window.trustedTypes ? (
              /** @type {?} */
              window.trustedTypes.emptyScript
            ) : str
          );
        }
      }
      /**
       * Converts a typed JavaScript value to a string.
       *
       * This method is called when setting JS property values to
       * HTML attributes.  Users may override this method to provide
       * serialization for custom types.
       *
       * @param {*} value Property value to serialize.
       * @return {string | undefined} String serialized from the provided
       * property  value.
       * @override
       */
      _serializeValue(value) {
        switch (typeof value) {
          case "boolean":
            return value ? "" : void 0;
          default:
            return value != null ? value.toString() : void 0;
        }
      }
      /**
       * Converts a string to a typed JavaScript value.
       *
       * This method is called when reading HTML attribute values to
       * JS properties.  Users may override this method to provide
       * deserialization for custom `type`s. Types for `Boolean`, `String`,
       * and `Number` convert attributes to the expected types.
       *
       * @param {?string} value Value to deserialize.
       * @param {*=} type Type to deserialize the string to.
       * @return {*} Typed value deserialized from the provided string.
       * @override
       */
      _deserializeValue(value, type) {
        switch (type) {
          case Boolean:
            return value !== null;
          case Number:
            return Number(value);
          default:
            return value;
        }
      }
    }
    return PropertiesChanged2;
  }
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const nativeProperties = {};
let proto = HTMLElement.prototype;
while (proto) {
  let props = Object.getOwnPropertyNames(proto);
  for (let i2 = 0; i2 < props.length; i2++) {
    nativeProperties[props[i2]] = true;
  }
  proto = Object.getPrototypeOf(proto);
}
const isTrustedType = (() => {
  if (!window.trustedTypes) {
    return () => false;
  }
  return (val) => trustedTypes.isHTML(val) || trustedTypes.isScript(val) || trustedTypes.isScriptURL(val);
})();
function saveAccessorValue(model, property) {
  if (!nativeProperties[property]) {
    let value = model[property];
    if (value !== void 0) {
      if (model.__data) {
        model._setPendingProperty(property, value);
      } else {
        if (!model.__dataProto) {
          model.__dataProto = {};
        } else if (!model.hasOwnProperty(JSCompiler_renameProperty("__dataProto", model))) {
          model.__dataProto = Object.create(model.__dataProto);
        }
        model.__dataProto[property] = value;
      }
    }
  }
}
const PropertyAccessors = dedupingMixin((superClass) => {
  const base = PropertiesChanged(superClass);
  class PropertyAccessors2 extends base {
    /**
     * Generates property accessors for all attributes in the standard
     * static `observedAttributes` array.
     *
     * Attribute names are mapped to property names using the `dash-case` to
     * `camelCase` convention
     *
     * @return {void}
     * @nocollapse
     */
    static createPropertiesForAttributes() {
      let a$ = (
        /** @type {?} */
        this.observedAttributes
      );
      for (let i2 = 0; i2 < a$.length; i2++) {
        this.prototype._createPropertyAccessor(dashToCamelCase(a$[i2]));
      }
    }
    /**
     * Returns an attribute name that corresponds to the given property.
     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.
     * @param {string} property Property to convert
     * @return {string} Attribute name corresponding to the given property.
     *
     * @protected
     * @nocollapse
     */
    static attributeNameForProperty(property) {
      return camelToDashCase(property);
    }
    /**
     * Overrides PropertiesChanged implementation to initialize values for
     * accessors created for values that already existed on the element
     * prototype.
     *
     * @return {void}
     * @protected
     * @override
     */
    _initializeProperties() {
      if (this.__dataProto) {
        this._initializeProtoProperties(this.__dataProto);
        this.__dataProto = null;
      }
      super._initializeProperties();
    }
    /**
     * Called at instance time with bag of properties that were overwritten
     * by accessors on the prototype when accessors were created.
     *
     * The default implementation sets these properties back into the
     * setter at instance time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @return {void}
     * @protected
     * @override
     */
    _initializeProtoProperties(props) {
      for (let p in props) {
        this._setProperty(p, props[p]);
      }
    }
    /**
     * Ensures the element has the given attribute. If it does not,
     * assigns the given value to the attribute.
     *
     * @suppress {invalidCasts} Closure can't figure out `this` is infact an
     *     element
     *
     * @param {string} attribute Name of attribute to ensure is set.
     * @param {string} value of the attribute.
     * @return {void}
     * @override
     */
    _ensureAttribute(attribute, value) {
      const el = (
        /** @type {!HTMLElement} */
        this
      );
      if (!el.hasAttribute(attribute)) {
        this._valueToNodeAttribute(el, value, attribute);
      }
    }
    /**
     * Overrides PropertiesChanged implemention to serialize objects as JSON.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided property
     *     value.
     * @override
     */
    _serializeValue(value) {
      switch (typeof value) {
        case "object":
          if (value instanceof Date) {
            return value.toString();
          } else if (value) {
            if (isTrustedType(value)) {
              return (
                /** @type {?} */
                value
              );
            }
            try {
              return JSON.stringify(value);
            } catch (x2) {
              return "";
            }
          }
        default:
          return super._serializeValue(value);
      }
    }
    /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called by Polymer when reading HTML attribute values to
     * JS properties.  Users may override this method on Polymer element
     * prototypes to provide deserialization for custom `type`s.  Note,
     * the `type` argument is the value of the `type` field provided in the
     * `properties` configuration object for a given property, and is
     * by convention the constructor for the type to deserialize.
     *
     *
     * @param {?string} value Attribute value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     * @override
     */
    _deserializeValue(value, type) {
      let outValue;
      switch (type) {
        case Object:
          try {
            outValue = JSON.parse(
              /** @type {string} */
              value
            );
          } catch (x2) {
            outValue = value;
          }
          break;
        case Array:
          try {
            outValue = JSON.parse(
              /** @type {string} */
              value
            );
          } catch (x2) {
            outValue = null;
            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);
          }
          break;
        case Date:
          outValue = isNaN(value) ? String(value) : Number(value);
          outValue = new Date(outValue);
          break;
        default:
          outValue = super._deserializeValue(value, type);
          break;
      }
      return outValue;
    }
    /* eslint-enable no-fallthrough */
    /**
     * Overrides PropertiesChanged implementation to save existing prototype
     * property value so that it can be reset.
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created
     *
     * When calling on a prototype, any overwritten values are saved in
     * `__dataProto`, and it is up to the subclasser to decide how/when
     * to set those properties back into the accessor.  When calling on an
     * instance, the overwritten value is set via `_setPendingProperty`,
     * and the user should call `_invalidateProperties` or `_flushProperties`
     * for the values to take effect.
     * @protected
     * @return {void}
     * @override
     */
    _definePropertyAccessor(property, readOnly) {
      saveAccessorValue(this, property);
      super._definePropertyAccessor(property, readOnly);
    }
    /**
     * Returns true if this library created an accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if an accessor was created
     * @override
     */
    _hasAccessor(property) {
      return this.__dataHasAccessor && this.__dataHasAccessor[property];
    }
    /**
     * Returns true if the specified property has a pending change.
     *
     * @param {string} prop Property name
     * @return {boolean} True if property has a pending change
     * @protected
     * @override
     */
    _isPropertyPending(prop) {
      return Boolean(this.__dataPending && prop in this.__dataPending);
    }
  }
  return PropertyAccessors2;
});
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const templateExtensions = {
  "dom-if": true,
  "dom-repeat": true
};
let placeholderBugDetect = false;
let placeholderBug = false;
function hasPlaceholderBug() {
  if (!placeholderBugDetect) {
    placeholderBugDetect = true;
    const t2 = document.createElement("textarea");
    t2.placeholder = "a";
    placeholderBug = t2.placeholder === t2.textContent;
  }
  return placeholderBug;
}
function fixPlaceholder(node) {
  if (hasPlaceholderBug() && node.localName === "textarea" && node.placeholder && node.placeholder === node.textContent) {
    node.textContent = null;
  }
}
const copyAttributeWithTemplateEventPolicy = (() => {
  const polymerTemplateEventAttributePolicy = window.trustedTypes && window.trustedTypes.createPolicy(
    "polymer-template-event-attribute-policy",
    {
      createScript: (x2) => x2
    }
  );
  return (dest, src, name) => {
    const value = src.getAttribute(name);
    if (polymerTemplateEventAttributePolicy && name.startsWith("on-")) {
      dest.setAttribute(
        name,
        polymerTemplateEventAttributePolicy.createScript(value, name)
      );
      return;
    }
    dest.setAttribute(name, value);
  };
})();
function wrapTemplateExtension(node) {
  let is = node.getAttribute("is");
  if (is && templateExtensions[is]) {
    let t2 = node;
    t2.removeAttribute("is");
    node = t2.ownerDocument.createElement(is);
    t2.parentNode.replaceChild(node, t2);
    node.appendChild(t2);
    while (t2.attributes.length) {
      const { name } = t2.attributes[0];
      copyAttributeWithTemplateEventPolicy(node, t2, name);
      t2.removeAttribute(name);
    }
  }
  return node;
}
function findTemplateNode(root2, nodeInfo) {
  let parent = nodeInfo.parentInfo && findTemplateNode(root2, nodeInfo.parentInfo);
  if (parent) {
    for (let n = parent.firstChild, i2 = 0; n; n = n.nextSibling) {
      if (nodeInfo.parentIndex === i2++) {
        return n;
      }
    }
  } else {
    return root2;
  }
}
function applyIdToMap(inst, map, node, nodeInfo) {
  if (nodeInfo.id) {
    map[nodeInfo.id] = node;
  }
}
function applyEventListener(inst, node, nodeInfo) {
  if (nodeInfo.events && nodeInfo.events.length) {
    for (let j = 0, e$ = nodeInfo.events, e2; j < e$.length && (e2 = e$[j]); j++) {
      inst._addMethodEventListenerToNode(node, e2.name, e2.value, inst);
    }
  }
}
function applyTemplateInfo(inst, node, nodeInfo, parentTemplateInfo) {
  if (nodeInfo.templateInfo) {
    node._templateInfo = nodeInfo.templateInfo;
    node._parentTemplateInfo = parentTemplateInfo;
  }
}
function createNodeEventHandler(context, eventName, methodName) {
  context = context._methodHost || context;
  let handler = function(e2) {
    if (context[methodName]) {
      context[methodName](e2, e2.detail);
    } else {
      console.warn("listener method `" + methodName + "` not defined");
    }
  };
  return handler;
}
const TemplateStamp = dedupingMixin(
  /**
   * @template T
   * @param {function(new:T)} superClass Class to apply mixin to.
   * @return {function(new:T)} superClass with mixin applied.
   */
  (superClass) => {
    class TemplateStamp2 extends superClass {
      /**
       * Scans a template to produce template metadata.
       *
       * Template-specific metadata are stored in the object returned, and node-
       * specific metadata are stored in objects in its flattened `nodeInfoList`
       * array.  Only nodes in the template that were parsed as nodes of
       * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
       * contains an `index` (`childNodes` index in parent) and optionally
       * `parent`, which points to node info of its parent (including its index).
       *
       * The template metadata object returned from this method has the following
       * structure (many fields optional):
       *
       * ```js
       *   {
       *     // Flattened list of node metadata (for nodes that generated metadata)
       *     nodeInfoList: [
       *       {
       *         // `id` attribute for any nodes with id's for generating `$` map
       *         id: {string},
       *         // `on-event="handler"` metadata
       *         events: [
       *           {
       *             name: {string},   // event name
       *             value: {string},  // handler method name
       *           }, ...
       *         ],
       *         // Notes when the template contained a `<slot>` for shady DOM
       *         // optimization purposes
       *         hasInsertionPoint: {boolean},
       *         // For nested `<template>`` nodes, nested template metadata
       *         templateInfo: {object}, // nested template metadata
       *         // Metadata to allow efficient retrieval of instanced node
       *         // corresponding to this metadata
       *         parentInfo: {number},   // reference to parent nodeInfo>
       *         parentIndex: {number},  // index in parent's `childNodes` collection
       *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
       *       },
       *       ...
       *     ],
       *     // When true, the template had the `strip-whitespace` attribute
       *     // or was nested in a template with that setting
       *     stripWhitespace: {boolean},
       *     // For nested templates, nested template content is moved into
       *     // a document fragment stored here; this is an optimization to
       *     // avoid the cost of nested template cloning
       *     content: {DocumentFragment}
       *   }
       * ```
       *
       * This method kicks off a recursive treewalk as follows:
       *
       * ```
       *    _parseTemplate <---------------------+
       *      _parseTemplateContent              |
       *        _parseTemplateNode  <------------|--+
       *          _parseTemplateNestedTemplate --+  |
       *          _parseTemplateChildNodes ---------+
       *          _parseTemplateNodeAttributes
       *            _parseTemplateNodeAttribute
       *
       * ```
       *
       * These methods may be overridden to add custom metadata about templates
       * to either `templateInfo` or `nodeInfo`.
       *
       * Note that this method may be destructive to the template, in that
       * e.g. event annotations may be removed after being noted in the
       * template metadata.
       *
       * @param {!HTMLTemplateElement} template Template to parse
       * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
       *   template, for parsing nested templates
       * @return {!TemplateInfo} Parsed template metadata
       * @nocollapse
       */
      static _parseTemplate(template2, outerTemplateInfo) {
        if (!template2._templateInfo) {
          let templateInfo = template2._templateInfo = {};
          templateInfo.nodeInfoList = [];
          templateInfo.nestedTemplate = Boolean(outerTemplateInfo);
          templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template2.hasAttribute && template2.hasAttribute("strip-whitespace");
          this._parseTemplateContent(
            template2,
            templateInfo,
            /** @type {?} */
            { parent: null }
          );
        }
        return template2._templateInfo;
      }
      /**
       * See docs for _parseTemplateNode.
       *
       * @param {!HTMLTemplateElement} template .
       * @param {!TemplateInfo} templateInfo .
       * @param {!NodeInfo} nodeInfo .
       * @return {boolean} .
       * @nocollapse
       */
      static _parseTemplateContent(template2, templateInfo, nodeInfo) {
        return this._parseTemplateNode(template2.content, templateInfo, nodeInfo);
      }
      /**
       * Parses template node and adds template and node metadata based on
       * the current node, and its `childNodes` and `attributes`.
       *
       * This method may be overridden to add custom node or template specific
       * metadata based on this node.
       *
       * @param {Node} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNode(node, templateInfo, nodeInfo) {
        let noted = false;
        let element = (
          /** @type {!HTMLTemplateElement} */
          node
        );
        if (element.localName == "template" && !element.hasAttribute("preserve-content")) {
          noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
        } else if (element.localName === "slot") {
          templateInfo.hasInsertionPoint = true;
        }
        fixPlaceholder(element);
        if (element.firstChild) {
          this._parseTemplateChildNodes(element, templateInfo, nodeInfo);
        }
        if (element.hasAttributes && element.hasAttributes()) {
          noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
        }
        return noted || nodeInfo.noted;
      }
      /**
       * Parses template child nodes for the given root node.
       *
       * This method also wraps whitelisted legacy template extensions
       * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
       * wrappers, collapses text nodes, and strips whitespace from the template
       * if the `templateInfo.stripWhitespace` setting was provided.
       *
       * @param {Node} root Root node whose `childNodes` will be parsed
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {void}
       */
      static _parseTemplateChildNodes(root2, templateInfo, nodeInfo) {
        if (root2.localName === "script" || root2.localName === "style") {
          return;
        }
        for (let node = root2.firstChild, parentIndex = 0, next; node; node = next) {
          if (node.localName == "template") {
            node = wrapTemplateExtension(node);
          }
          next = node.nextSibling;
          if (node.nodeType === Node.TEXT_NODE) {
            let n = next;
            while (n && n.nodeType === Node.TEXT_NODE) {
              node.textContent += n.textContent;
              next = n.nextSibling;
              root2.removeChild(n);
              n = next;
            }
            if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
              root2.removeChild(node);
              continue;
            }
          }
          let childInfo = (
            /** @type {!NodeInfo} */
            { parentIndex, parentInfo: nodeInfo }
          );
          if (this._parseTemplateNode(node, templateInfo, childInfo)) {
            childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;
          }
          if (node.parentNode) {
            parentIndex++;
          }
        }
      }
      /**
       * Parses template content for the given nested `<template>`.
       *
       * Nested template info is stored as `templateInfo` in the current node's
       * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
       * It will then be the responsibility of the host to set it back to the
       * template and for users stamping nested templates to use the
       * `_contentForTemplate` method to retrieve the content for this template
       * (an optimization to avoid the cost of cloning nested template content).
       *
       * @param {HTMLTemplateElement} node Node to parse (a <template>)
       * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
       *   that includes the template `node`
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
        let element = (
          /** @type {!HTMLTemplateElement} */
          node
        );
        let templateInfo = this._parseTemplate(element, outerTemplateInfo);
        let content = templateInfo.content = element.content.ownerDocument.createDocumentFragment();
        content.appendChild(element.content);
        nodeInfo.templateInfo = templateInfo;
        return true;
      }
      /**
       * Parses template node attributes and adds node metadata to `nodeInfo`
       * for nodes of interest.
       *
       * @param {Element} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current
       *     template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
        let noted = false;
        let attrs = Array.from(node.attributes);
        for (let i2 = attrs.length - 1, a3; a3 = attrs[i2]; i2--) {
          noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a3.name, a3.value) || noted;
        }
        return noted;
      }
      /**
       * Parses a single template node attribute and adds node metadata to
       * `nodeInfo` for attributes of interest.
       *
       * This implementation adds metadata for `on-event="handler"` attributes
       * and `id` attributes.
       *
       * @param {Element} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @param {string} name Attribute name
       * @param {string} value Attribute value
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
        if (name.slice(0, 3) === "on-") {
          node.removeAttribute(name);
          nodeInfo.events = nodeInfo.events || [];
          nodeInfo.events.push({
            name: name.slice(3),
            value
          });
          return true;
        } else if (name === "id") {
          nodeInfo.id = value;
          return true;
        }
        return false;
      }
      /**
       * Returns the `content` document fragment for a given template.
       *
       * For nested templates, Polymer performs an optimization to cache nested
       * template content to avoid the cost of cloning deeply nested templates.
       * This method retrieves the cached content for a given template.
       *
       * @param {HTMLTemplateElement} template Template to retrieve `content` for
       * @return {DocumentFragment} Content fragment
       * @nocollapse
       */
      static _contentForTemplate(template2) {
        let templateInfo = (
          /** @type {HTMLTemplateElementWithInfo} */
          template2._templateInfo
        );
        return templateInfo && templateInfo.content || template2.content;
      }
      /**
       * Clones the provided template content and returns a document fragment
       * containing the cloned dom.
       *
       * The template is parsed (once and memoized) using this library's
       * template parsing features, and provides the following value-added
       * features:
       * * Adds declarative event listeners for `on-event="handler"` attributes
       * * Generates an "id map" for all nodes with id's under `$` on returned
       *   document fragment
       * * Passes template info including `content` back to templates as
       *   `_templateInfo` (a performance optimization to avoid deep template
       *   cloning)
       *
       * Note that the memoized template parsing process is destructive to the
       * template: attributes for bindings and declarative event listeners are
       * removed after being noted in notes, and any nested `<template>.content`
       * is removed and stored in notes as well.
       *
       * @param {!HTMLTemplateElement} template Template to stamp
       * @param {TemplateInfo=} templateInfo Optional template info associated
       *   with the template to be stamped; if omitted the template will be
       *   automatically parsed.
       * @return {!StampedTemplate} Cloned template content
       * @override
       */
      _stampTemplate(template2, templateInfo) {
        if (template2 && !template2.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
          HTMLTemplateElement.decorate(template2);
        }
        templateInfo = templateInfo || this.constructor._parseTemplate(template2);
        let nodeInfo = templateInfo.nodeInfoList;
        let content = templateInfo.content || template2.content;
        let dom = (
          /** @type {DocumentFragment} */
          document.importNode(content, true)
        );
        dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
        let nodes = dom.nodeList = new Array(nodeInfo.length);
        dom.$ = {};
        for (let i2 = 0, l = nodeInfo.length, info; i2 < l && (info = nodeInfo[i2]); i2++) {
          let node = nodes[i2] = findTemplateNode(dom, info);
          applyIdToMap(this, dom.$, node, info);
          applyTemplateInfo(this, node, info, templateInfo);
          applyEventListener(this, node, info);
        }
        dom = /** @type {!StampedTemplate} */
        dom;
        return dom;
      }
      /**
       * Adds an event listener by method name for the event provided.
       *
       * This method generates a handler function that looks up the method
       * name at handling time.
       *
       * @param {!EventTarget} node Node to add listener on
       * @param {string} eventName Name of event
       * @param {string} methodName Name of method
       * @param {*=} context Context the method will be called on (defaults
       *   to `node`)
       * @return {Function} Generated handler function
       * @override
       */
      _addMethodEventListenerToNode(node, eventName, methodName, context) {
        context = context || node;
        let handler = createNodeEventHandler(context, eventName, methodName);
        this._addEventListenerToNode(node, eventName, handler);
        return handler;
      }
      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {!EventTarget} node Node to add event listener to
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to add
       * @return {void}
       * @override
       */
      _addEventListenerToNode(node, eventName, handler) {
        node.addEventListener(eventName, handler);
      }
      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {!EventTarget} node Node to remove event listener from
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to remove
       * @return {void}
       * @override
       */
      _removeEventListenerFromNode(node, eventName, handler) {
        node.removeEventListener(eventName, handler);
      }
    }
    return TemplateStamp2;
  }
);
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
let dedupeId = 0;
const NOOP = [];
const TYPES = {
  COMPUTE: "__computeEffects",
  REFLECT: "__reflectEffects",
  NOTIFY: "__notifyEffects",
  PROPAGATE: "__propagateEffects",
  OBSERVE: "__observeEffects",
  READ_ONLY: "__readOnly"
};
const COMPUTE_INFO = "__computeInfo";
const capitalAttributeRegex = /[A-Z]/;
function ensureOwnEffectMap(model, type, cloneArrays) {
  let effects = model[type];
  if (!effects) {
    effects = model[type] = {};
  } else if (!model.hasOwnProperty(type)) {
    effects = model[type] = Object.create(model[type]);
    if (cloneArrays) {
      for (let p in effects) {
        let protoFx = effects[p];
        let instFx = effects[p] = Array(protoFx.length);
        for (let i2 = 0; i2 < protoFx.length; i2++) {
          instFx[i2] = protoFx[i2];
        }
      }
    }
  }
  return effects;
}
function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
  if (effects) {
    let ran = false;
    const id = dedupeId++;
    for (let prop in props) {
      let rootProperty = hasPaths ? root(prop) : prop;
      let fxs = effects[rootProperty];
      if (fxs) {
        for (let i2 = 0, l = fxs.length, fx; i2 < l && (fx = fxs[i2]); i2++) {
          if ((!fx.info || fx.info.lastRun !== id) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
            if (fx.info) {
              fx.info.lastRun = id;
            }
            fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
            ran = true;
          }
        }
      }
    }
    return ran;
  }
  return false;
}
function runEffectsForProperty(inst, effects, dedupeId2, prop, props, oldProps, hasPaths, extraArgs) {
  let ran = false;
  let rootProperty = hasPaths ? root(prop) : prop;
  let fxs = effects[rootProperty];
  if (fxs) {
    for (let i2 = 0, l = fxs.length, fx; i2 < l && (fx = fxs[i2]); i2++) {
      if ((!fx.info || fx.info.lastRun !== dedupeId2) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        if (fx.info) {
          fx.info.lastRun = dedupeId2;
        }
        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
        ran = true;
      }
    }
  }
  return ran;
}
function pathMatchesTrigger(path, trigger) {
  if (trigger) {
    let triggerPath = (
      /** @type {string} */
      trigger.name
    );
    return triggerPath == path || !!(trigger.structured && isAncestor(triggerPath, path)) || !!(trigger.wildcard && isDescendant(triggerPath, path));
  } else {
    return true;
  }
}
function runObserverEffect(inst, property, props, oldProps, info) {
  let fn = typeof info.method === "string" ? inst[info.method] : info.method;
  let changedProp = info.property;
  if (fn) {
    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
  } else if (!info.dynamicFn) {
    console.warn("observer method `" + info.method + "` not defined");
  }
}
function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
  let fxs = inst[TYPES.NOTIFY];
  let notified;
  let id = dedupeId++;
  for (let prop in notifyProps) {
    if (notifyProps[prop]) {
      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
        notified = true;
      } else if (hasPaths && notifyPath(inst, prop, props)) {
        notified = true;
      }
    }
  }
  let host;
  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
    host._invalidateProperties();
  }
}
function notifyPath(inst, path, props) {
  let rootProperty = root(path);
  if (rootProperty !== path) {
    let eventName = camelToDashCase(rootProperty) + "-changed";
    dispatchNotifyEvent(inst, eventName, props[path], path);
    return true;
  }
  return false;
}
function dispatchNotifyEvent(inst, eventName, value, path) {
  let detail = {
    value,
    queueProperty: true
  };
  if (path) {
    detail.path = path;
  }
  wrap$1(
    /** @type {!HTMLElement} */
    inst
  ).dispatchEvent(new CustomEvent(eventName, { detail }));
}
function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
  let rootProperty = hasPaths ? root(property) : property;
  let path = rootProperty != property ? property : null;
  let value = path ? get$2(inst, path) : inst.__data[property];
  if (path && value === void 0) {
    value = props[property];
  }
  dispatchNotifyEvent(inst, info.eventName, value, path);
}
function handleNotification(event, inst, fromProp, toPath, negate) {
  let value;
  let detail = (
    /** @type {Object} */
    event.detail
  );
  let fromPath = detail && detail.path;
  if (fromPath) {
    toPath = translate(fromProp, toPath, fromPath);
    value = detail && detail.value;
  } else {
    value = event.currentTarget[fromProp];
  }
  value = negate ? !value : value;
  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {
      inst._invalidateProperties();
    }
  }
}
function runReflectEffect(inst, property, props, oldProps, info) {
  let value = inst.__data[property];
  if (sanitizeDOMValue) {
    value = sanitizeDOMValue(
      value,
      info.attrName,
      "attribute",
      /** @type {Node} */
      inst
    );
  }
  inst._propertyToAttribute(property, info.attrName, value);
}
function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
  let computeEffects = inst[TYPES.COMPUTE];
  if (computeEffects) {
    if (orderedComputed) {
      dedupeId++;
      const order = getComputedOrder(inst);
      const queue = [];
      for (let p in changedProps) {
        enqueueEffectsFor(p, computeEffects, queue, order, hasPaths);
      }
      let info;
      while (info = queue.shift()) {
        if (runComputedEffect(inst, "", changedProps, oldProps, info)) {
          enqueueEffectsFor(info.methodInfo, computeEffects, queue, order, hasPaths);
        }
      }
      Object.assign(
        /** @type {!Object} */
        oldProps,
        inst.__dataOld
      );
      Object.assign(
        /** @type {!Object} */
        changedProps,
        inst.__dataPending
      );
      inst.__dataPending = null;
    } else {
      let inputProps = changedProps;
      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
        Object.assign(
          /** @type {!Object} */
          oldProps,
          inst.__dataOld
        );
        Object.assign(
          /** @type {!Object} */
          changedProps,
          inst.__dataPending
        );
        inputProps = inst.__dataPending;
        inst.__dataPending = null;
      }
    }
  }
}
const insertEffect = (info, queue, order) => {
  let start = 0;
  let end = queue.length - 1;
  let idx = -1;
  while (start <= end) {
    const mid = start + end >> 1;
    const cmp = order.get(queue[mid].methodInfo) - order.get(info.methodInfo);
    if (cmp < 0) {
      start = mid + 1;
    } else if (cmp > 0) {
      end = mid - 1;
    } else {
      idx = mid;
      break;
    }
  }
  if (idx < 0) {
    idx = end + 1;
  }
  queue.splice(idx, 0, info);
};
const enqueueEffectsFor = (prop, computeEffects, queue, order, hasPaths) => {
  const rootProperty = hasPaths ? root(prop) : prop;
  const fxs = computeEffects[rootProperty];
  if (fxs) {
    for (let i2 = 0; i2 < fxs.length; i2++) {
      const fx = fxs[i2];
      if (fx.info.lastRun !== dedupeId && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        fx.info.lastRun = dedupeId;
        insertEffect(fx.info, queue, order);
      }
    }
  }
};
function getComputedOrder(inst) {
  let ordered = inst.constructor.__orderedComputedDeps;
  if (!ordered) {
    ordered = /* @__PURE__ */ new Map();
    const effects = inst[TYPES.COMPUTE];
    let { counts, ready, total } = dependencyCounts(inst);
    let curr;
    while (curr = ready.shift()) {
      ordered.set(curr, ordered.size);
      const computedByCurr = effects[curr];
      if (computedByCurr) {
        computedByCurr.forEach((fx) => {
          const computedProp = fx.info.methodInfo;
          --total;
          if (--counts[computedProp] === 0) {
            ready.push(computedProp);
          }
        });
      }
    }
    if (total !== 0) {
      const el = (
        /** @type {HTMLElement} */
        inst
      );
      console.warn(`Computed graph for ${el.localName} incomplete; circular?`);
    }
    inst.constructor.__orderedComputedDeps = ordered;
  }
  return ordered;
}
function dependencyCounts(inst) {
  const infoForComputed = inst[COMPUTE_INFO];
  const counts = {};
  const computedDeps = inst[TYPES.COMPUTE];
  const ready = [];
  let total = 0;
  for (let p in infoForComputed) {
    const info = infoForComputed[p];
    total += counts[p] = info.args.filter((a3) => !a3.literal).length + (info.dynamicFn ? 1 : 0);
  }
  for (let p in computedDeps) {
    if (!infoForComputed[p]) {
      ready.push(p);
    }
  }
  return { counts, ready, total };
}
function runComputedEffect(inst, property, changedProps, oldProps, info) {
  let result = runMethodEffect(inst, property, changedProps, oldProps, info);
  if (result === NOOP) {
    return false;
  }
  let computedProp = info.methodInfo;
  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
    return inst._setPendingProperty(computedProp, result, true);
  } else {
    inst[computedProp] = result;
    return false;
  }
}
function computeLinkedPaths(inst, path, value) {
  let links = inst.__dataLinkedPaths;
  if (links) {
    let link;
    for (let a3 in links) {
      let b2 = links[a3];
      if (isDescendant(a3, path)) {
        link = translate(a3, b2, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      } else if (isDescendant(b2, path)) {
        link = translate(b2, a3, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      }
    }
  }
}
function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
  nodeInfo.bindings = nodeInfo.bindings || [];
  let binding = { kind, target, parts, literal, isCompound: parts.length !== 1 };
  nodeInfo.bindings.push(binding);
  if (shouldAddListener(binding)) {
    let { event, negate } = binding.parts[0];
    binding.listenerEvent = event || camelToDashCase(target) + "-changed";
    binding.listenerNegate = negate;
  }
  let index = templateInfo.nodeInfoList.length;
  for (let i2 = 0; i2 < binding.parts.length; i2++) {
    let part = binding.parts[i2];
    part.compoundIndex = i2;
    addEffectForBindingPart(constructor, templateInfo, binding, part, index);
  }
}
function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
  if (!part.literal) {
    if (binding.kind === "attribute" && binding.target[0] === "-") {
      console.warn("Cannot set attribute " + binding.target + ' because "-" is not a valid attribute starting character');
    } else {
      let dependencies = part.dependencies;
      let info = { index, binding, part, evaluator: constructor };
      for (let j = 0; j < dependencies.length; j++) {
        let trigger = dependencies[j];
        if (typeof trigger == "string") {
          trigger = parseArg(trigger);
          trigger.wildcard = true;
        }
        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
          fn: runBindingEffect,
          info,
          trigger
        });
      }
    }
  }
}
function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
  let node = nodeList[info.index];
  let binding = info.binding;
  let part = info.part;
  if (hasPaths && part.source && path.length > part.source.length && binding.kind == "property" && !binding.isCompound && node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
    let value = props[path];
    path = translate(part.source, binding.target, path);
    if (node._setPendingPropertyOrPath(path, value, false, true)) {
      inst._enqueueClient(node);
    }
  } else {
    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
    if (value !== NOOP) {
      applyBindingValue(inst, node, binding, part, value);
    }
  }
}
function applyBindingValue(inst, node, binding, part, value) {
  value = computeBindingValue(node, value, binding, part);
  if (sanitizeDOMValue) {
    value = sanitizeDOMValue(value, binding.target, binding.kind, node);
  }
  if (binding.kind == "attribute") {
    inst._valueToNodeAttribute(
      /** @type {Element} */
      node,
      value,
      binding.target
    );
  } else {
    let prop = binding.target;
    if (node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
        if (node._setPendingProperty(prop, value)) {
          inst._enqueueClient(node);
        }
      }
    } else {
      inst._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
}
function computeBindingValue(node, value, binding, part) {
  if (binding.isCompound) {
    let storage = node.__dataCompoundStorage[binding.target];
    storage[part.compoundIndex] = value;
    value = storage.join("");
  }
  if (binding.kind !== "attribute") {
    if (binding.target === "textContent" || binding.target === "value" && (node.localName === "input" || node.localName === "textarea")) {
      value = value == void 0 ? "" : value;
    }
  }
  return value;
}
function shouldAddListener(binding) {
  return Boolean(binding.target) && binding.kind != "attribute" && binding.kind != "text" && !binding.isCompound && binding.parts[0].mode === "{";
}
function setupBindings(inst, templateInfo) {
  let { nodeList, nodeInfoList } = templateInfo;
  if (nodeInfoList.length) {
    for (let i2 = 0; i2 < nodeInfoList.length; i2++) {
      let info = nodeInfoList[i2];
      let node = nodeList[i2];
      let bindings = info.bindings;
      if (bindings) {
        for (let i3 = 0; i3 < bindings.length; i3++) {
          let binding = bindings[i3];
          setupCompoundStorage(node, binding);
          addNotifyListener(node, inst, binding);
        }
      }
      node.__dataHost = inst;
    }
  }
}
function setupCompoundStorage(node, binding) {
  if (binding.isCompound) {
    let storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});
    let parts = binding.parts;
    let literals = new Array(parts.length);
    for (let j = 0; j < parts.length; j++) {
      literals[j] = parts[j].literal;
    }
    let target = binding.target;
    storage[target] = literals;
    if (binding.literal && binding.kind == "property") {
      if (target === "className") {
        node = wrap$1(node);
      }
      node[target] = binding.literal;
    }
  }
}
function addNotifyListener(node, inst, binding) {
  if (binding.listenerEvent) {
    let part = binding.parts[0];
    node.addEventListener(binding.listenerEvent, function(e2) {
      handleNotification(e2, inst, binding.target, part.source, part.negate);
    });
  }
}
function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
  dynamicFn = sig.static || dynamicFn && (typeof dynamicFn !== "object" || dynamicFn[sig.methodName]);
  let info = {
    methodName: sig.methodName,
    args: sig.args,
    methodInfo,
    dynamicFn
  };
  for (let i2 = 0, arg; i2 < sig.args.length && (arg = sig.args[i2]); i2++) {
    if (!arg.literal) {
      model._addPropertyEffect(arg.rootProperty, type, {
        fn: effectFn,
        info,
        trigger: arg
      });
    }
  }
  if (dynamicFn) {
    model._addPropertyEffect(sig.methodName, type, {
      fn: effectFn,
      info
    });
  }
  return info;
}
function runMethodEffect(inst, property, props, oldProps, info) {
  let context = inst._methodHost || inst;
  let fn = context[info.methodName];
  if (fn) {
    let args = inst._marshalArgs(info.args, property, props);
    return args === NOOP ? NOOP : fn.apply(context, args);
  } else if (!info.dynamicFn) {
    console.warn("method `" + info.methodName + "` not defined");
  }
}
const emptyArray = [];
const IDENT = "(?:[a-zA-Z_$][\\w.:$\\-*]*)";
const NUMBER = "(?:[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)";
const SQUOTE_STRING = "(?:'(?:[^'\\\\]|\\\\.)*')";
const DQUOTE_STRING = '(?:"(?:[^"\\\\]|\\\\.)*")';
const STRING = "(?:" + SQUOTE_STRING + "|" + DQUOTE_STRING + ")";
const ARGUMENT = "(?:(" + IDENT + "|" + NUMBER + "|" + STRING + ")\\s*)";
const ARGUMENTS = "(?:" + ARGUMENT + "(?:,\\s*" + ARGUMENT + ")*)";
const ARGUMENT_LIST = "(?:\\(\\s*(?:" + ARGUMENTS + "?)\\)\\s*)";
const BINDING = "(" + IDENT + "\\s*" + ARGUMENT_LIST + "?)";
const OPEN_BRACKET = "(\\[\\[|{{)\\s*";
const CLOSE_BRACKET = "(?:]]|}})";
const NEGATE = "(?:(!)\\s*)?";
const EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
const bindingRegex = new RegExp(EXPRESSION, "g");
function literalFromParts(parts) {
  let s3 = "";
  for (let i2 = 0; i2 < parts.length; i2++) {
    let literal = parts[i2].literal;
    s3 += literal || "";
  }
  return s3;
}
function parseMethod(expression) {
  let m3 = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
  if (m3) {
    let methodName = m3[1];
    let sig = { methodName, static: true, args: emptyArray };
    if (m3[2].trim()) {
      let args = m3[2].replace(/\\,/g, "&comma;").split(",");
      return parseArgs(args, sig);
    } else {
      return sig;
    }
  }
  return null;
}
function parseArgs(argList, sig) {
  sig.args = argList.map(function(rawArg) {
    let arg = parseArg(rawArg);
    if (!arg.literal) {
      sig.static = false;
    }
    return arg;
  }, this);
  return sig;
}
function parseArg(rawArg) {
  let arg = rawArg.trim().replace(/&comma;/g, ",").replace(/\\(.)/g, "$1");
  let a3 = {
    name: arg,
    value: "",
    literal: false
  };
  let fc = arg[0];
  if (fc === "-") {
    fc = arg[1];
  }
  if (fc >= "0" && fc <= "9") {
    fc = "#";
  }
  switch (fc) {
    case "'":
    case '"':
      a3.value = arg.slice(1, -1);
      a3.literal = true;
      break;
    case "#":
      a3.value = Number(arg);
      a3.literal = true;
      break;
  }
  if (!a3.literal) {
    a3.rootProperty = root(arg);
    a3.structured = isPath(arg);
    if (a3.structured) {
      a3.wildcard = arg.slice(-2) == ".*";
      if (a3.wildcard) {
        a3.name = arg.slice(0, -2);
      }
    }
  }
  return a3;
}
function getArgValue(data, props, path) {
  let value = get$2(data, path);
  if (value === void 0) {
    value = props[path];
  }
  return value;
}
function notifySplices(inst, array, path, splices) {
  const splicesData = { indexSplices: splices };
  if (legacyUndefined && !inst._overrideLegacyUndefined) {
    array.splices = splicesData;
  }
  inst.notifyPath(path + ".splices", splicesData);
  inst.notifyPath(path + ".length", array.length);
  if (legacyUndefined && !inst._overrideLegacyUndefined) {
    splicesData.indexSplices = [];
  }
}
function notifySplice(inst, array, path, index, addedCount, removed) {
  notifySplices(inst, array, path, [{
    index,
    addedCount,
    removed,
    object: array,
    type: "splice"
  }]);
}
function upper$1(name) {
  return name[0].toUpperCase() + name.substring(1);
}
const PropertyEffects = dedupingMixin((superClass) => {
  const propertyEffectsBase = TemplateStamp(PropertyAccessors(superClass));
  class PropertyEffects2 extends propertyEffectsBase {
    constructor() {
      super();
      this.__isPropertyEffectsClient = true;
      this.__dataClientsReady;
      this.__dataPendingClients;
      this.__dataToNotify;
      this.__dataLinkedPaths;
      this.__dataHasPaths;
      this.__dataCompoundStorage;
      this.__dataHost;
      this.__dataTemp;
      this.__dataClientsInitialized;
      this.__data;
      this.__dataPending;
      this.__dataOld;
      this.__computeEffects;
      this.__computeInfo;
      this.__reflectEffects;
      this.__notifyEffects;
      this.__propagateEffects;
      this.__observeEffects;
      this.__readOnly;
      this.__templateInfo;
      this._overrideLegacyUndefined;
    }
    get PROPERTY_EFFECT_TYPES() {
      return TYPES;
    }
    /**
     * @override
     * @return {void}
     */
    _initializeProperties() {
      super._initializeProperties();
      this._registerHost();
      this.__dataClientsReady = false;
      this.__dataPendingClients = null;
      this.__dataToNotify = null;
      this.__dataLinkedPaths = null;
      this.__dataHasPaths = false;
      this.__dataCompoundStorage = this.__dataCompoundStorage || null;
      this.__dataHost = this.__dataHost || null;
      this.__dataTemp = {};
      this.__dataClientsInitialized = false;
    }
    _registerHost() {
      if (hostStack.length) {
        let host = hostStack[hostStack.length - 1];
        host._enqueueClient(this);
        this.__dataHost = host;
      }
    }
    /**
     * Overrides `PropertyAccessors` implementation to provide a
     * more efficient implementation of initializing properties from
     * the prototype on the instance.
     *
     * @override
     * @param {Object} props Properties to initialize on the prototype
     * @return {void}
     */
    _initializeProtoProperties(props) {
      this.__data = Object.create(props);
      this.__dataPending = Object.create(props);
      this.__dataOld = {};
    }
    /**
     * Overrides `PropertyAccessors` implementation to avoid setting
     * `_setProperty`'s `shouldNotify: true`.
     *
     * @override
     * @param {Object} props Properties to initialize on the instance
     * @return {void}
     */
    _initializeInstanceProperties(props) {
      let readOnly = this[TYPES.READ_ONLY];
      for (let prop in props) {
        if (!readOnly || !readOnly[prop]) {
          this.__dataPending = this.__dataPending || {};
          this.__dataOld = this.__dataOld || {};
          this.__data[prop] = this.__dataPending[prop] = props[prop];
        }
      }
    }
    // Prototype setup ----------------------------------------
    /**
     * Equivalent to static `addPropertyEffect` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     */
    _addPropertyEffect(property, type, effect) {
      this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
      let effects = ensureOwnEffectMap(this, type, true)[property];
      if (!effects) {
        effects = this[type][property] = [];
      }
      effects.push(effect);
    }
    /**
     * Removes the given property effect.
     *
     * @override
     * @param {string} property Property the effect was associated with
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object to remove
     * @return {void}
     */
    _removePropertyEffect(property, type, effect) {
      let effects = ensureOwnEffectMap(this, type, true)[property];
      let idx = effects.indexOf(effect);
      if (idx >= 0) {
        effects.splice(idx, 1);
      }
    }
    /**
     * Returns whether the current prototype/instance has a property effect
     * of a certain type.
     *
     * @override
     * @param {string} property Property name
     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasPropertyEffect(property, type) {
      let effects = this[type];
      return Boolean(effects && effects[property]);
    }
    /**
     * Returns whether the current prototype/instance has a "read only"
     * accessor for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasReadOnlyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.READ_ONLY);
    }
    /**
     * Returns whether the current prototype/instance has a "notify"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasNotifyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.NOTIFY);
    }
    /**
     * Returns whether the current prototype/instance has a "reflect to
     * attribute" property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasReflectEffect(property) {
      return this._hasPropertyEffect(property, TYPES.REFLECT);
    }
    /**
     * Returns whether the current prototype/instance has a "computed"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasComputedEffect(property) {
      return this._hasPropertyEffect(property, TYPES.COMPUTE);
    }
    // Runtime ----------------------------------------
    /**
     * Sets a pending property or path.  If the root property of the path in
     * question had no accessor, the path is set, otherwise it is enqueued
     * via `_setPendingProperty`.
     *
     * This function isolates relatively expensive functionality necessary
     * for the public API (`set`, `setProperties`, `notifyPath`, and property
     * change listeners via {{...}} bindings), such that it is only done
     * when paths enter the system, and not at every propagation step.  It
     * also sets a `__dataHasPaths` flag on the instance which is used to
     * fast-path slower path-matching code in the property effects host paths.
     *
     * `path` can be a path string or array of path parts as accepted by the
     * public API.
     *
     * @override
     * @param {string | !Array<number|string>} path Path to set
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify Set to true if this change should
     *  cause a property notification event dispatch
     * @param {boolean=} isPathNotification If the path being set is a path
     *   notification of an already changed value, as opposed to a request
     *   to set and notify the change.  In the latter `false` case, a dirty
     *   check is performed and then the value is set to the path before
     *   enqueuing the pending property change.
     * @return {boolean} Returns true if the property/path was enqueued in
     *   the pending changes bag.
     * @protected
     */
    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
      if (isPathNotification || root(Array.isArray(path) ? path[0] : path) !== path) {
        if (!isPathNotification) {
          let old = get$2(this, path);
          path = /** @type {string} */
          set$1(this, path, value);
          if (!path || !super._shouldPropertyChange(path, value, old)) {
            return false;
          }
        }
        this.__dataHasPaths = true;
        if (this._setPendingProperty(
          /**@type{string}*/
          path,
          value,
          shouldNotify
        )) {
          computeLinkedPaths(
            this,
            /**@type{string}*/
            path,
            value
          );
          return true;
        }
      } else {
        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
          return this._setPendingProperty(
            /**@type{string}*/
            path,
            value,
            shouldNotify
          );
        } else {
          this[path] = value;
        }
      }
      return false;
    }
    /**
     * Applies a value to a non-Polymer element/node's property.
     *
     * The implementation makes a best-effort at binding interop:
     * Some native element properties have side-effects when
     * re-setting the same value (e.g. setting `<input>.value` resets the
     * cursor position), so we do a dirty-check before setting the value.
     * However, for better interop with non-Polymer custom elements that
     * accept objects, we explicitly re-set object changes coming from the
     * Polymer world (which may include deep object changes without the
     * top reference changing), erring on the side of providing more
     * information.
     *
     * Users may override this method to provide alternate approaches.
     *
     * @override
     * @param {!Node} node The node to set a property on
     * @param {string} prop The property to set
     * @param {*} value The value to set
     * @return {void}
     * @protected
     */
    _setUnmanagedPropertyToNode(node, prop, value) {
      if (value !== node[prop] || typeof value == "object") {
        if (prop === "className") {
          node = /** @type {!Node} */
          wrap$1(node);
        }
        node[prop] = value;
      }
    }
    /**
     * Overrides the `PropertiesChanged` implementation to introduce special
     * dirty check logic depending on the property & value being set:
     *
     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
     * 2. Object set to simple property (e.g. 'prop': {...})
     *    Stored in `__dataTemp` and `__data`, dirty checked against
     *    `__dataTemp` by default implementation of `_shouldPropertyChange`
     * 3. Primitive value set to simple property (e.g. 'prop': 42)
     *    Stored in `__data`, dirty checked against `__data`
     *
     * The dirty-check is important to prevent cycles due to two-way
     * notification, but paths and objects are only dirty checked against any
     * previous value set during this turn via a "temporary cache" that is
     * cleared when the last `_propertiesChanged` exits. This is so:
     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
     *    due to array mutations like shift/unshift/splice; this is fine
     *    since path changes are dirty-checked at user entry points like `set`
     * b. dirty-checking for objects only lasts one turn to allow the user
     *    to mutate the object in-place and re-set it with the same identity
     *    and have all sub-properties re-propagated in a subsequent turn.
     *
     * The temp cache is not necessarily sufficient to prevent invalid array
     * paths, since a splice can happen during the same turn (with pathological
     * user code); we could introduce a "fixup" for temporarily cached array
     * paths if needed: https://github.com/Polymer/polymer/issues/4227
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify True if property should fire notification
     *   event (applies only for `notify: true` properties)
     * @return {boolean} Returns true if the property changed
     */
    _setPendingProperty(property, value, shouldNotify) {
      let propIsPath = this.__dataHasPaths && isPath(property);
      let prevProps = propIsPath ? this.__dataTemp : this.__data;
      if (this._shouldPropertyChange(property, value, prevProps[property])) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        }
        if (!(property in this.__dataOld)) {
          this.__dataOld[property] = this.__data[property];
        }
        if (propIsPath) {
          this.__dataTemp[property] = value;
        } else {
          this.__data[property] = value;
        }
        this.__dataPending[property] = value;
        if (propIsPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
          this.__dataToNotify = this.__dataToNotify || {};
          this.__dataToNotify[property] = shouldNotify;
        }
        return true;
      }
      return false;
    }
    /**
     * Overrides base implementation to ensure all accessors set `shouldNotify`
     * to true, for per-property notification tracking.
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {void}
     */
    _setProperty(property, value) {
      if (this._setPendingProperty(property, value, true)) {
        this._invalidateProperties();
      }
    }
    /**
     * Overrides `PropertyAccessor`'s default async queuing of
     * `_propertiesChanged`: if `__dataReady` is false (has not yet been
     * manually flushed), the function no-ops; otherwise flushes
     * `_propertiesChanged` synchronously.
     *
     * @override
     * @return {void}
     */
    _invalidateProperties() {
      if (this.__dataReady) {
        this._flushProperties();
      }
    }
    /**
     * Enqueues the given client on a list of pending clients, whose
     * pending property changes can later be flushed via a call to
     * `_flushClients`.
     *
     * @override
     * @param {Object} client PropertyEffects client to enqueue
     * @return {void}
     * @protected
     */
    _enqueueClient(client) {
      this.__dataPendingClients = this.__dataPendingClients || [];
      if (client !== this) {
        this.__dataPendingClients.push(client);
      }
    }
    /**
     * Flushes any clients previously enqueued via `_enqueueClient`, causing
     * their `_flushProperties` method to run.
     *
     * @override
     * @return {void}
     * @protected
     */
    _flushClients() {
      if (!this.__dataClientsReady) {
        this.__dataClientsReady = true;
        this._readyClients();
        this.__dataReady = true;
      } else {
        this.__enableOrFlushClients();
      }
    }
    // NOTE: We ensure clients either enable or flush as appropriate. This
    // handles two corner cases:
    // (1) clients flush properly when connected/enabled before the host
    // enables; e.g.
    //   (a) Templatize stamps with no properties and does not flush and
    //   (b) the instance is inserted into dom and
    //   (c) then the instance flushes.
    // (2) clients enable properly when not connected/enabled when the host
    // flushes; e.g.
    //   (a) a template is runtime stamped and not yet connected/enabled
    //   (b) a host sets a property, causing stamped dom to flush
    //   (c) the stamped dom enables.
    __enableOrFlushClients() {
      let clients = this.__dataPendingClients;
      if (clients) {
        this.__dataPendingClients = null;
        for (let i2 = 0; i2 < clients.length; i2++) {
          let client = clients[i2];
          if (!client.__dataEnabled) {
            client._enableProperties();
          } else if (client.__dataPending) {
            client._flushProperties();
          }
        }
      }
    }
    /**
     * Perform any initial setup on client dom. Called before the first
     * `_flushProperties` call on client dom and before any element
     * observers are called.
     *
     * @override
     * @return {void}
     * @protected
     */
    _readyClients() {
      this.__enableOrFlushClients();
    }
    /**
     * Sets a bag of property changes to this instance, and
     * synchronously processes all effects of the properties as a batch.
     *
     * Property names must be simple properties, not paths.  Batched
     * path propagation is not supported.
     *
     * @override
     * @param {Object} props Bag of one or more key-value pairs whose key is
     *   a property and value is the new value to set for that property.
     * @param {boolean=} setReadOnly When true, any private values set in
     *   `props` will be set. By default, `setProperties` will not set
     *   `readOnly: true` root properties.
     * @return {void}
     * @public
     */
    setProperties(props, setReadOnly) {
      for (let path in props) {
        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
          this._setPendingPropertyOrPath(path, props[path], true);
        }
      }
      this._invalidateProperties();
    }
    /**
     * Overrides `PropertyAccessors` so that property accessor
     * side effects are not enabled until after client dom is fully ready.
     * Also calls `_flushClients` callback to ensure client dom is enabled
     * that was not enabled as a result of flushing properties.
     *
     * @override
     * @return {void}
     */
    ready() {
      this._flushProperties();
      if (!this.__dataClientsReady) {
        this._flushClients();
      }
      if (this.__dataPending) {
        this._flushProperties();
      }
    }
    /**
     * Implements `PropertyAccessors`'s properties changed callback.
     *
     * Runs each class of effects for the batch of changed properties in
     * a specific order (compute, propagate, reflect, observe, notify).
     *
     * @override
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {void}
     */
    _propertiesChanged(currentProps, changedProps, oldProps) {
      let hasPaths = this.__dataHasPaths;
      this.__dataHasPaths = false;
      let notifyProps;
      runComputedEffects(this, changedProps, oldProps, hasPaths);
      notifyProps = this.__dataToNotify;
      this.__dataToNotify = null;
      this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
      this._flushClients();
      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
      if (notifyProps) {
        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
      }
      if (this.__dataCounter == 1) {
        this.__dataTemp = {};
      }
    }
    /**
     * Called to propagate any property changes to stamped template nodes
     * managed by this element.
     *
     * @override
     * @param {Object} changedProps Bag of changed properties
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {void}
     * @protected
     */
    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
      if (this[TYPES.PROPAGATE]) {
        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
      }
      if (this.__templateInfo) {
        this._runEffectsForTemplate(this.__templateInfo, changedProps, oldProps, hasPaths);
      }
    }
    _runEffectsForTemplate(templateInfo, changedProps, oldProps, hasPaths) {
      const baseRunEffects = (changedProps2, hasPaths2) => {
        runEffects(
          this,
          templateInfo.propertyEffects,
          changedProps2,
          oldProps,
          hasPaths2,
          templateInfo.nodeList
        );
        for (let info = templateInfo.firstChild; info; info = info.nextSibling) {
          this._runEffectsForTemplate(info, changedProps2, oldProps, hasPaths2);
        }
      };
      if (templateInfo.runEffects) {
        templateInfo.runEffects(baseRunEffects, changedProps, hasPaths);
      } else {
        baseRunEffects(changedProps, hasPaths);
      }
    }
    /**
     * Aliases one data path as another, such that path notifications from one
     * are routed to the other.
     *
     * @override
     * @param {string | !Array<string|number>} to Target path to link.
     * @param {string | !Array<string|number>} from Source path to link.
     * @return {void}
     * @public
     */
    linkPaths(to, from) {
      to = normalize(to);
      from = normalize(from);
      this.__dataLinkedPaths = this.__dataLinkedPaths || {};
      this.__dataLinkedPaths[to] = from;
    }
    /**
     * Removes a data path alias previously established with `_linkPaths`.
     *
     * Note, the path to unlink should be the target (`to`) used when
     * linking the paths.
     *
     * @override
     * @param {string | !Array<string|number>} path Target path to unlink.
     * @return {void}
     * @public
     */
    unlinkPaths(path) {
      path = normalize(path);
      if (this.__dataLinkedPaths) {
        delete this.__dataLinkedPaths[path];
      }
    }
    /**
     * Notify that an array has changed.
     *
     * Example:
     *
     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
     *     ...
     *     this.items.splice(1, 1, {name: 'Sam'});
     *     this.items.push({name: 'Bob'});
     *     this.notifySplices('items', [
     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,
     *         object: this.items, type: 'splice' },
     *       { index: 3, removed: [], addedCount: 1,
     *         object: this.items, type: 'splice'}
     *     ]);
     *
     * @param {string} path Path that should be notified.
     * @param {Array} splices Array of splice records indicating ordered
     *   changes that occurred to the array. Each record should have the
     *   following fields:
     *    * index: index at which the change occurred
     *    * removed: array of items that were removed from this index
     *    * addedCount: number of new items added at this index
     *    * object: a reference to the array in question
     *    * type: the string literal 'splice'
     *
     *   Note that splice records _must_ be normalized such that they are
     *   reported in index order (raw results from `Object.observe` are not
     *   ordered and must be normalized/merged before notifying).
     *
     * @override
     * @return {void}
     * @public
     */
    notifySplices(path, splices) {
      let info = { path: "" };
      let array = (
        /** @type {Array} */
        get$2(this, path, info)
      );
      notifySplices(this, array, info.path, splices);
    }
    /**
     * Convenience method for reading a value from a path.
     *
     * Note, if any part in the path is undefined, this method returns
     * `undefined` (this method does not throw when dereferencing undefined
     * paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `users.12.name` or `['users', 12, 'name']`).
     * @param {Object=} root Root object from which the path is evaluated.
     * @return {*} Value at the path, or `undefined` if any part of the path
     *   is undefined.
     * @public
     */
    get(path, root2) {
      return get$2(root2 || this, path);
    }
    /**
     * Convenience method for setting a value to a path and notifying any
     * elements bound to the same path.
     *
     * Note, if any part in the path except for the last is undefined,
     * this method does nothing (this method does not throw when
     * dereferencing undefined paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
     * @param {*} value Value to set at the specified path.
     * @param {Object=} root Root object from which the path is evaluated.
     *   When specified, no notification will occur.
     * @return {void}
     * @public
     */
    set(path, value, root2) {
      if (root2) {
        set$1(root2, path, value);
      } else {
        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][
          /** @type {string} */
          path
        ]) {
          if (this._setPendingPropertyOrPath(path, value, true)) {
            this._invalidateProperties();
          }
        }
      }
    }
    /**
     * Adds items onto the end of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to push onto array
     * @return {number} New length of the array.
     * @public
     */
    push(path, ...items) {
      let info = { path: "" };
      let array = (
        /** @type {Array}*/
        get$2(this, path, info)
      );
      let len = array.length;
      let ret = array.push(...items);
      if (items.length) {
        notifySplice(this, array, info.path, len, items.length, []);
      }
      return ret;
    }
    /**
     * Removes an item from the end of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    pop(path) {
      let info = { path: "" };
      let array = (
        /** @type {Array} */
        get$2(this, path, info)
      );
      let hadLength = Boolean(array.length);
      let ret = array.pop();
      if (hadLength) {
        notifySplice(this, array, info.path, array.length, 0, [ret]);
      }
      return ret;
    }
    /**
     * Starting from the start index specified, removes 0 or more items
     * from the array and inserts 0 or more new items in their place.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.splice`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {number} start Index from which to start removing/inserting.
     * @param {number=} deleteCount Number of items to remove.
     * @param {...*} items Items to insert into array.
     * @return {!Array} Array of removed items.
     * @public
     */
    splice(path, start, deleteCount, ...items) {
      let info = { path: "" };
      let array = (
        /** @type {Array} */
        get$2(this, path, info)
      );
      if (start < 0) {
        start = array.length - Math.floor(-start);
      } else if (start) {
        start = Math.floor(start);
      }
      let ret;
      if (arguments.length === 2) {
        ret = array.splice(start);
      } else {
        ret = array.splice(start, deleteCount, ...items);
      }
      if (items.length || ret.length) {
        notifySplice(this, array, info.path, start, items.length, ret);
      }
      return ret;
    }
    /**
     * Removes an item from the beginning of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    shift(path) {
      let info = { path: "" };
      let array = (
        /** @type {Array} */
        get$2(this, path, info)
      );
      let hadLength = Boolean(array.length);
      let ret = array.shift();
      if (hadLength) {
        notifySplice(this, array, info.path, 0, 0, [ret]);
      }
      return ret;
    }
    /**
     * Adds items onto the beginning of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to insert info array
     * @return {number} New length of the array.
     * @public
     */
    unshift(path, ...items) {
      let info = { path: "" };
      let array = (
        /** @type {Array} */
        get$2(this, path, info)
      );
      let ret = array.unshift(...items);
      if (items.length) {
        notifySplice(this, array, info.path, 0, items.length, []);
      }
      return ret;
    }
    /**
     * Notify that a path has changed.
     *
     * Example:
     *
     *     this.item.user.name = 'Bob';
     *     this.notifyPath('item.user.name');
     *
     * @override
     * @param {string} path Path that should be notified.
     * @param {*=} value Value at the path (optional).
     * @return {void}
     * @public
     */
    notifyPath(path, value) {
      let propPath;
      if (arguments.length == 1) {
        let info = { path: "" };
        value = get$2(this, path, info);
        propPath = info.path;
      } else if (Array.isArray(path)) {
        propPath = normalize(path);
      } else {
        propPath = /** @type{string} */
        path;
      }
      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
        this._invalidateProperties();
      }
    }
    /**
     * Equivalent to static `createReadOnlyProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     */
    _createReadOnlyProperty(property, protectedSetter) {
      this._addPropertyEffect(property, TYPES.READ_ONLY);
      if (protectedSetter) {
        this["_set" + upper$1(property)] = /** @this {PropertyEffects} */
        function(value) {
          this._setProperty(property, value);
        };
      }
    }
    /**
     * Equivalent to static `createPropertyObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method
     *     to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createPropertyObserver(property, method, dynamicFn) {
      let info = { property, method, dynamicFn: Boolean(dynamicFn) };
      this._addPropertyEffect(property, TYPES.OBSERVE, {
        fn: runObserverEffect,
        info,
        trigger: { name: property }
      });
      if (dynamicFn) {
        this._addPropertyEffect(
          /** @type {string} */
          method,
          TYPES.OBSERVE,
          {
            fn: runObserverEffect,
            info,
            trigger: { name: method }
          }
        );
      }
    }
    /**
     * Equivalent to static `createMethodObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createMethodObserver(expression, dynamicFn) {
      let sig = parseMethod(expression);
      if (!sig) {
        throw new Error("Malformed observer expression '" + expression + "'");
      }
      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
    }
    /**
     * Equivalent to static `createNotifyingProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     */
    _createNotifyingProperty(property) {
      this._addPropertyEffect(property, TYPES.NOTIFY, {
        fn: runNotifyEffect,
        info: {
          eventName: camelToDashCase(property) + "-changed",
          property
        }
      });
    }
    /**
     * Equivalent to static `createReflectedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */
    _createReflectedProperty(property) {
      let attr = this.constructor.attributeNameForProperty(property);
      if (attr[0] === "-") {
        console.warn("Property " + property + " cannot be reflected to attribute " + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');
      } else {
        this._addPropertyEffect(property, TYPES.REFLECT, {
          fn: runReflectEffect,
          info: {
            attrName: attr
          }
        });
      }
    }
    /**
     * Equivalent to static `createComputedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createComputedProperty(property, expression, dynamicFn) {
      let sig = parseMethod(expression);
      if (!sig) {
        throw new Error("Malformed computed expression '" + expression + "'");
      }
      const info = createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
      ensureOwnEffectMap(this, COMPUTE_INFO)[property] = info;
    }
    /**
     * Gather the argument values for a method specified in the provided array
     * of argument metadata.
     *
     * The `path` and `value` arguments are used to fill in wildcard descriptor
     * when the method is being called as a result of a path notification.
     *
     * @param {!Array<!MethodArg>} args Array of argument metadata
     * @param {string} path Property/path name that triggered the method effect
     * @param {Object} props Bag of current property changes
     * @return {!Array<*>} Array of argument values
     * @private
     */
    _marshalArgs(args, path, props) {
      const data = this.__data;
      const values = [];
      for (let i2 = 0, l = args.length; i2 < l; i2++) {
        let { name, structured, wildcard, value, literal } = args[i2];
        if (!literal) {
          if (wildcard) {
            const matches2 = isDescendant(name, path);
            const pathValue = getArgValue(data, props, matches2 ? path : name);
            value = {
              path: matches2 ? path : name,
              value: pathValue,
              base: matches2 ? get$2(data, name) : pathValue
            };
          } else {
            value = structured ? getArgValue(data, props, name) : data[name];
          }
        }
        if (legacyUndefined && !this._overrideLegacyUndefined && value === void 0 && args.length > 1) {
          return NOOP;
        }
        values[i2] = value;
      }
      return values;
    }
    // -- static class methods ------------
    /**
     * Ensures an accessor exists for the specified property, and adds
     * to a list of "property effects" that will run when the accessor for
     * the specified property is set.  Effects are grouped by "type", which
     * roughly corresponds to a phase in effect processing.  The effect
     * metadata should be in the following form:
     *
     *     {
     *       fn: effectFunction, // Reference to function to call to perform effect
     *       info: { ... }       // Effect metadata passed to function
     *       trigger: {          // Optional triggering metadata; if not provided
     *         name: string      // the property is treated as a wildcard
     *         structured: boolean
     *         wildcard: boolean
     *       }
     *     }
     *
     * Effects are called from `_propertiesChanged` in the following order by
     * type:
     *
     * 1. COMPUTE
     * 2. PROPAGATE
     * 3. REFLECT
     * 4. OBSERVE
     * 5. NOTIFY
     *
     * Effect functions are called with the following signature:
     *
     *     effectFunction(inst, path, props, oldProps, info, hasPaths)
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */
    static addPropertyEffect(property, type, effect) {
      this.prototype._addPropertyEffect(property, type, effect);
    }
    /**
     * Creates a single-property observer for the given property.
     *
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createPropertyObserver(property, method, dynamicFn) {
      this.prototype._createPropertyObserver(property, method, dynamicFn);
    }
    /**
     * Creates a multi-property "method observer" based on the provided
     * expression, which should be a string in the form of a normal JavaScript
     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
     * should correspond to a property or path in the context of this
     * prototype (or instance), or may be a literal string or number.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     * @return {void}
     *   whether method names should be included as a dependency to the effect.
     * @protected
     * @nocollapse
     */
    static createMethodObserver(expression, dynamicFn) {
      this.prototype._createMethodObserver(expression, dynamicFn);
    }
    /**
     * Causes the setter for the given property to dispatch `<property>-changed`
     * events to notify of changes to the property.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createNotifyingProperty(property) {
      this.prototype._createNotifyingProperty(property);
    }
    /**
     * Creates a read-only accessor for the given property.
     *
     * To set the property, use the protected `_setProperty` API.
     * To create a custom protected setter (e.g. `_setMyProp()` for
     * property `myProp`), pass `true` for `protectedSetter`.
     *
     * Note, if the property will have other property effects, this method
     * should be called first, before adding other effects.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createReadOnlyProperty(property, protectedSetter) {
      this.prototype._createReadOnlyProperty(property, protectedSetter);
    }
    /**
     * Causes the setter for the given property to reflect the property value
     * to a (dash-cased) attribute of the same name.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createReflectedProperty(property) {
      this.prototype._createReflectedProperty(property);
    }
    /**
     * Creates a computed property whose value is set to the result of the
     * method described by the given `expression` each time one or more
     * arguments to the method changes.  The expression should be a string
     * in the form of a normal JavaScript function signature:
     * `'methodName(arg1, [..., argn])'`
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
     *   method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createComputedProperty(property, expression, dynamicFn) {
      this.prototype._createComputedProperty(property, expression, dynamicFn);
    }
    /**
     * Parses the provided template to ensure binding effects are created
     * for them, and then ensures property accessors are created for any
     * dependent properties in the template.  Binding effects for bound
     * templates are stored in a linked list on the instance so that
     * templates can be efficiently stamped and unstamped.
     *
     * @param {!HTMLTemplateElement} template Template containing binding
     *   bindings
     * @return {!TemplateInfo} Template metadata object
     * @protected
     * @nocollapse
     */
    static bindTemplate(template2) {
      return this.prototype._bindTemplate(template2);
    }
    // -- binding ----------------------------------------------
    /*
     * Overview of binding flow:
     *
     * During finalization (`instanceBinding==false`, `wasPreBound==false`):
     *  `_bindTemplate(t, false)` called directly during finalization - parses
     *  the template (for the first time), and then assigns that _prototypical_
     *  template info to `__preboundTemplateInfo` _on the prototype_; note in
     *  this case `wasPreBound` is false; this is the first time we're binding
     *  it, thus we create accessors.
     *
     * During first stamping (`instanceBinding==true`, `wasPreBound==true`):
     *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`
     *   returned matches the prebound one, and so this is `wasPreBound == true`
     *   state; thus we _skip_ creating accessors, but _do_ create an instance
     *   of the template info to serve as the start of our linked list (needs to
     *   be an instance, not the prototypical one, so that we can add `nodeList`
     *   to it to contain the `nodeInfo`-ordered list of instance nodes for
     *   bindings, and so we can chain runtime-stamped template infos off of
     *   it). At this point, the call to `_stampTemplate` calls
     *   `applyTemplateInfo` for each nested `<template>` found during parsing
     *   to hand prototypical `_templateInfo` to them; we also pass the _parent_
     *   `templateInfo` to the `<template>` so that we have the instance-time
     *   parent to link the `templateInfo` under in the case it was
     *   runtime-stamped.
     *
     * During subsequent runtime stamping (`instanceBinding==true`,
     *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`
     *   - here `templateInfo` is guaranteed to _not_ match the prebound one,
     *   because it was either a different template altogether, or even if it
     *   was the same template, the step above created a instance of the info;
     *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_
     *   link a instance into the linked list.
     */
    /**
     * Equivalent to static `bindTemplate` API but can be called on an instance
     * to add effects at runtime.  See that method for full API docs.
     *
     * This method may be called on the prototype (for prototypical template
     * binding, to avoid creating accessors every instance) once per prototype,
     * and will be called with `runtimeBinding: true` by `_stampTemplate` to
     * create and link an instance of the template metadata associated with a
     * particular stamping.
     *
     * @override
     * @param {!HTMLTemplateElement} template Template containing binding
     * bindings
     * @param {boolean=} instanceBinding When false (default), performs
     * "prototypical" binding of the template and overwrites any previously
     * bound template for the class. When true (as passed from
     * `_stampTemplate`), the template info is instanced and linked into the
     * list of bound templates.
     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
     * this is an instance of the prototypical template info
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */
    _bindTemplate(template2, instanceBinding) {
      let templateInfo = this.constructor._parseTemplate(template2);
      let wasPreBound = this.__preBoundTemplateInfo == templateInfo;
      if (!wasPreBound) {
        for (let prop in templateInfo.propertyEffects) {
          this._createPropertyAccessor(prop);
        }
      }
      if (instanceBinding) {
        templateInfo = /** @type {!TemplateInfo} */
        Object.create(templateInfo);
        templateInfo.wasPreBound = wasPreBound;
        if (!this.__templateInfo) {
          this.__templateInfo = templateInfo;
        } else {
          const parent = template2._parentTemplateInfo || this.__templateInfo;
          const previous = parent.lastChild;
          templateInfo.parent = parent;
          parent.lastChild = templateInfo;
          templateInfo.previousSibling = previous;
          if (previous) {
            previous.nextSibling = templateInfo;
          } else {
            parent.firstChild = templateInfo;
          }
        }
      } else {
        this.__preBoundTemplateInfo = templateInfo;
      }
      return templateInfo;
    }
    /**
     * Adds a property effect to the given template metadata, which is run
     * at the "propagate" stage of `_propertiesChanged` when the template
     * has been bound to the element via `_bindTemplate`.
     *
     * The `effect` object should match the format in `_addPropertyEffect`.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */
    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
      hostProps[prop] = true;
      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
      let propEffects = effects[prop] = effects[prop] || [];
      propEffects.push(effect);
    }
    /**
     * Stamps the provided template and performs instance-time setup for
     * Polymer template features, including data bindings, declarative event
     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
     * is returned containing the stamped DOM, ready for insertion into the
     * DOM.
     *
     * This method may be called more than once; however note that due to
     * `shadycss` polyfill limitations, only styles from templates prepared
     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
     * to the shadow root and support CSS custom properties), and note that
     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
     * any styles required by in runtime-stamped templates must be included
     * in the main element template.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @param {TemplateInfo=} templateInfo Optional bound template info associated
     *   with the template to be stamped; if omitted the template will be
     *   automatically bound.
     * @return {!StampedTemplate} Cloned template content
     * @override
     * @protected
     */
    _stampTemplate(template2, templateInfo) {
      templateInfo = templateInfo || /** @type {!TemplateInfo} */
      this._bindTemplate(template2, true);
      hostStack.push(this);
      let dom = super._stampTemplate(template2, templateInfo);
      hostStack.pop();
      templateInfo.nodeList = dom.nodeList;
      if (!templateInfo.wasPreBound) {
        let nodes = templateInfo.childNodes = [];
        for (let n = dom.firstChild; n; n = n.nextSibling) {
          nodes.push(n);
        }
      }
      dom.templateInfo = templateInfo;
      setupBindings(this, templateInfo);
      if (this.__dataClientsReady) {
        this._runEffectsForTemplate(templateInfo, this.__data, null, false);
        this._flushClients();
      }
      return dom;
    }
    /**
     * Removes and unbinds the nodes previously contained in the provided
     * DocumentFragment returned from `_stampTemplate`.
     *
     * @override
     * @param {!StampedTemplate} dom DocumentFragment previously returned
     *   from `_stampTemplate` associated with the nodes to be removed
     * @return {void}
     * @protected
     */
    _removeBoundDom(dom) {
      const templateInfo = dom.templateInfo;
      const { previousSibling, nextSibling, parent } = templateInfo;
      if (previousSibling) {
        previousSibling.nextSibling = nextSibling;
      } else if (parent) {
        parent.firstChild = nextSibling;
      }
      if (nextSibling) {
        nextSibling.previousSibling = previousSibling;
      } else if (parent) {
        parent.lastChild = previousSibling;
      }
      templateInfo.nextSibling = templateInfo.previousSibling = null;
      let nodes = templateInfo.childNodes;
      for (let i2 = 0; i2 < nodes.length; i2++) {
        let node = nodes[i2];
        wrap$1(wrap$1(node).parentNode).removeChild(node);
      }
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted = propertyEffectsBase._parseTemplateNode.call(
        this,
        node,
        templateInfo,
        nodeInfo
      );
      if (node.nodeType === Node.TEXT_NODE) {
        let parts = this._parseBindings(node.textContent, templateInfo);
        if (parts) {
          node.textContent = literalFromParts(parts) || " ";
          addBinding(this, templateInfo, nodeInfo, "text", "textContent", parts);
          noted = true;
        }
      }
      return noted;
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from attributes.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      let parts = this._parseBindings(value, templateInfo);
      if (parts) {
        let origName = name;
        let kind = "property";
        if (capitalAttributeRegex.test(name)) {
          kind = "attribute";
        } else if (name[name.length - 1] == "$") {
          name = name.slice(0, -1);
          kind = "attribute";
        }
        let literal = literalFromParts(parts);
        if (literal && kind == "attribute") {
          if (name == "class" && node.hasAttribute("class")) {
            literal += " " + node.getAttribute(name);
          }
          node.setAttribute(name, literal);
        }
        if (kind == "attribute" && origName == "disable-upgrade$") {
          node.setAttribute(name, "");
        }
        if (node.localName === "input" && origName === "value") {
          node.setAttribute(origName, "");
        }
        node.removeAttribute(origName);
        if (kind === "property") {
          name = dashToCamelCase(name);
        }
        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
        return true;
      } else {
        return propertyEffectsBase._parseTemplateNodeAttribute.call(
          this,
          node,
          templateInfo,
          nodeInfo,
          name,
          value
        );
      }
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * binding the properties that a nested template depends on to the template
     * as `_host_<property>`.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
      let noted = propertyEffectsBase._parseTemplateNestedTemplate.call(
        this,
        node,
        templateInfo,
        nodeInfo
      );
      const parent = node.parentNode;
      const nestedTemplateInfo = nodeInfo.templateInfo;
      const isDomIf = parent.localName === "dom-if";
      const isDomRepeat = parent.localName === "dom-repeat";
      if (removeNestedTemplates && (isDomIf || isDomRepeat)) {
        parent.removeChild(node);
        nodeInfo = nodeInfo.parentInfo;
        nodeInfo.templateInfo = nestedTemplateInfo;
        nodeInfo.noted = true;
        noted = false;
      }
      let hostProps = nestedTemplateInfo.hostProps;
      if (fastDomIf && isDomIf) {
        if (hostProps) {
          templateInfo.hostProps = Object.assign(templateInfo.hostProps || {}, hostProps);
          if (!removeNestedTemplates) {
            nodeInfo.parentInfo.noted = true;
          }
        }
      } else {
        let mode = "{";
        for (let source in hostProps) {
          let parts = [{ mode, source, dependencies: [source], hostProp: true }];
          addBinding(this, templateInfo, nodeInfo, "property", "_host_" + source, parts);
        }
      }
      return noted;
    }
    /**
     * Called to parse text in a template (either attribute values or
     * textContent) into binding metadata.
     *
     * Any overrides of this method should return an array of binding part
     * metadata  representing one or more bindings found in the provided text
     * and any "literal" text in between.  Any non-literal parts will be passed
     * to `_evaluateBinding` when any dependencies change.  The only required
     * fields of each "part" in the returned array are as follows:
     *
     * - `dependencies` - Array containing trigger metadata for each property
     *   that should trigger the binding to update
     * - `literal` - String containing text if the part represents a literal;
     *   in this case no `dependencies` are needed
     *
     * Additional metadata for use by `_evaluateBinding` may be provided in
     * each part object as needed.
     *
     * The default implementation handles the following types of bindings
     * (one or more may be intermixed with literal strings):
     * - Property binding: `[[prop]]`
     * - Path binding: `[[object.prop]]`
     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
     * - Two-way property or path bindings (supports negation):
     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
     * - Inline computed method (supports negation):
     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
     *
     * The default implementation uses a regular expression for best
     * performance. However, the regular expression uses a white-list of
     * allowed characters in a data-binding, which causes problems for
     * data-bindings that do use characters not in this white-list.
     *
     * Instead of updating the white-list with all allowed characters,
     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)
     * that uses a state machine instead. This state machine is able to handle
     * all characters. However, it is slightly less performant, therefore we
     * extracted it into a separate optional mixin.
     *
     * @param {string} text Text to parse from attribute or textContent
     * @param {Object} templateInfo Current template metadata
     * @return {Array<!BindingPart>} Array of binding part metadata
     * @protected
     * @nocollapse
     */
    static _parseBindings(text, templateInfo) {
      let parts = [];
      let lastIndex = 0;
      let m3;
      while ((m3 = bindingRegex.exec(text)) !== null) {
        if (m3.index > lastIndex) {
          parts.push({ literal: text.slice(lastIndex, m3.index) });
        }
        let mode = m3[1][0];
        let negate = Boolean(m3[2]);
        let source = m3[3].trim();
        let customEvent = false, notifyEvent = "", colon = -1;
        if (mode == "{" && (colon = source.indexOf("::")) > 0) {
          notifyEvent = source.substring(colon + 2);
          source = source.substring(0, colon);
          customEvent = true;
        }
        let signature = parseMethod(source);
        let dependencies = [];
        if (signature) {
          let { args, methodName } = signature;
          for (let i2 = 0; i2 < args.length; i2++) {
            let arg = args[i2];
            if (!arg.literal) {
              dependencies.push(arg);
            }
          }
          let dynamicFns = templateInfo.dynamicFns;
          if (dynamicFns && dynamicFns[methodName] || signature.static) {
            dependencies.push(methodName);
            signature.dynamicFn = true;
          }
        } else {
          dependencies.push(source);
        }
        parts.push({
          source,
          mode,
          negate,
          customEvent,
          signature,
          dependencies,
          event: notifyEvent
        });
        lastIndex = bindingRegex.lastIndex;
      }
      if (lastIndex && lastIndex < text.length) {
        let literal = text.substring(lastIndex);
        if (literal) {
          parts.push({
            literal
          });
        }
      }
      if (parts.length) {
        return parts;
      } else {
        return null;
      }
    }
    /**
     * Called to evaluate a previously parsed binding part based on a set of
     * one or more changed dependencies.
     *
     * @param {!Polymer_PropertyEffects} inst Element that should be used as
     *     scope for binding dependencies
     * @param {BindingPart} part Binding part metadata
     * @param {string} path Property/path that triggered this effect
     * @param {Object} props Bag of current property changes
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {*} Value the binding part evaluated to
     * @protected
     * @nocollapse
     */
    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
      let value;
      if (part.signature) {
        value = runMethodEffect(inst, path, props, oldProps, part.signature);
      } else if (path != part.source) {
        value = get$2(inst, part.source);
      } else {
        if (hasPaths && isPath(path)) {
          value = get$2(inst, path);
        } else {
          value = inst.__data[path];
        }
      }
      if (part.negate) {
        value = !value;
      }
      return value;
    }
  }
  return PropertyEffects2;
});
const hostStack = [];
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function register$1(prototype) {
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function normalizeProperties(props) {
  const output = {};
  for (let p in props) {
    const o = props[p];
    output[p] = typeof o === "function" ? { type: o } : o;
  }
  return output;
}
const PropertiesMixin = dedupingMixin((superClass) => {
  const base = PropertiesChanged(superClass);
  function superPropertiesClass(constructor) {
    const superCtor = Object.getPrototypeOf(constructor);
    return superCtor.prototype instanceof PropertiesMixin2 ? (
      /** @type {!PropertiesMixinConstructor} */
      superCtor
    ) : null;
  }
  function ownProperties(constructor) {
    if (!constructor.hasOwnProperty(JSCompiler_renameProperty("__ownProperties", constructor))) {
      let props = null;
      if (constructor.hasOwnProperty(JSCompiler_renameProperty("properties", constructor))) {
        const properties = constructor.properties;
        if (properties) {
          props = normalizeProperties(properties);
        }
      }
      constructor.__ownProperties = props;
    }
    return constructor.__ownProperties;
  }
  class PropertiesMixin2 extends base {
    /**
     * Implements standard custom elements getter to observes the attributes
     * listed in `properties`.
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static get observedAttributes() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("__observedAttributes", this))) {
        register$1(this.prototype);
        const props = this._properties;
        this.__observedAttributes = props ? Object.keys(props).map((p) => this.prototype._addPropertyToAttributeMap(p)) : [];
      }
      return this.__observedAttributes;
    }
    /**
     * Finalizes an element definition, including ensuring any super classes
     * are also finalized. This includes ensuring property
     * accessors exist on the element prototype. This method calls
     * `_finalizeClass` to finalize each constructor in the prototype chain.
     * @return {void}
     * @nocollapse
     */
    static finalize() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("__finalized", this))) {
        const superCtor = superPropertiesClass(
          /** @type {!PropertiesMixinConstructor} */
          this
        );
        if (superCtor) {
          superCtor.finalize();
        }
        this.__finalized = true;
        this._finalizeClass();
      }
    }
    /**
     * Finalize an element class. This includes ensuring property
     * accessors exist on the element prototype. This method is called by
     * `finalize` and finalizes the class constructor.
     *
     * @protected
     * @nocollapse
     */
    static _finalizeClass() {
      const props = ownProperties(
        /** @type {!PropertiesMixinConstructor} */
        this
      );
      if (props) {
        this.createProperties(props);
      }
    }
    /**
     * Returns a memoized version of all properties, including those inherited
     * from super classes. Properties not in object format are converted to
     * at least {type}.
     *
     * @return {Object} Object containing properties for this class
     * @protected
     * @nocollapse
     */
    static get _properties() {
      if (!this.hasOwnProperty(
        JSCompiler_renameProperty("__properties", this)
      )) {
        const superCtor = superPropertiesClass(
          /** @type {!PropertiesMixinConstructor} */
          this
        );
        this.__properties = Object.assign(
          {},
          superCtor && superCtor._properties,
          ownProperties(
            /** @type {PropertiesMixinConstructor} */
            this
          )
        );
      }
      return this.__properties;
    }
    /**
     * Overrides `PropertiesChanged` method to return type specified in the
     * static `properties` object for the given property.
     * @param {string} name Name of property
     * @return {*} Type to which to deserialize attribute
     *
     * @protected
     * @nocollapse
     */
    static typeForProperty(name) {
      const info = this._properties[name];
      return info && info.type;
    }
    /**
     * Overrides `PropertiesChanged` method and adds a call to
     * `finalize` which lazily configures the element's property accessors.
     * @override
     * @return {void}
     */
    _initializeProperties() {
      this.constructor.finalize();
      super._initializeProperties();
    }
    /**
     * Called when the element is added to a document.
     * Calls `_enableProperties` to turn on property system from
     * `PropertiesChanged`.
     * @suppress {missingProperties} Super may or may not implement the callback
     * @return {void}
     * @override
     */
    connectedCallback() {
      if (super.connectedCallback) {
        super.connectedCallback();
      }
      this._enableProperties();
    }
    /**
     * Called when the element is removed from a document
     * @suppress {missingProperties} Super may or may not implement the callback
     * @return {void}
     * @override
     */
    disconnectedCallback() {
      if (super.disconnectedCallback) {
        super.disconnectedCallback();
      }
    }
  }
  return PropertiesMixin2;
});
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
const version = "3.5.2";
const builtCSS = window.ShadyCSS && window.ShadyCSS["cssBuild"];
const ElementMixin$1 = dedupingMixin((base) => {
  const polymerElementBase = PropertiesMixin(PropertyEffects(base));
  function propertyDefaults(constructor) {
    if (!constructor.hasOwnProperty(
      JSCompiler_renameProperty("__propertyDefaults", constructor)
    )) {
      constructor.__propertyDefaults = null;
      let props = constructor._properties;
      for (let p in props) {
        let info = props[p];
        if ("value" in info) {
          constructor.__propertyDefaults = constructor.__propertyDefaults || {};
          constructor.__propertyDefaults[p] = info;
        }
      }
    }
    return constructor.__propertyDefaults;
  }
  function ownObservers(constructor) {
    if (!constructor.hasOwnProperty(
      JSCompiler_renameProperty("__ownObservers", constructor)
    )) {
      constructor.__ownObservers = constructor.hasOwnProperty(
        JSCompiler_renameProperty("observers", constructor)
      ) ? (
        /** @type {PolymerElementConstructor} */
        constructor.observers
      ) : null;
    }
    return constructor.__ownObservers;
  }
  function createPropertyFromConfig(proto2, name, info, allProps) {
    if (info.computed) {
      info.readOnly = true;
    }
    if (info.computed) {
      if (proto2._hasReadOnlyEffect(name)) {
        console.warn(`Cannot redefine computed property '${name}'.`);
      } else {
        proto2._createComputedProperty(name, info.computed, allProps);
      }
    }
    if (info.readOnly && !proto2._hasReadOnlyEffect(name)) {
      proto2._createReadOnlyProperty(name, !info.computed);
    } else if (info.readOnly === false && proto2._hasReadOnlyEffect(name)) {
      console.warn(`Cannot make readOnly property '${name}' non-readOnly.`);
    }
    if (info.reflectToAttribute && !proto2._hasReflectEffect(name)) {
      proto2._createReflectedProperty(name);
    } else if (info.reflectToAttribute === false && proto2._hasReflectEffect(name)) {
      console.warn(`Cannot make reflected property '${name}' non-reflected.`);
    }
    if (info.notify && !proto2._hasNotifyEffect(name)) {
      proto2._createNotifyingProperty(name);
    } else if (info.notify === false && proto2._hasNotifyEffect(name)) {
      console.warn(`Cannot make notify property '${name}' non-notify.`);
    }
    if (info.observer) {
      proto2._createPropertyObserver(name, info.observer, allProps[info.observer]);
    }
    proto2._addPropertyToAttributeMap(name);
  }
  function processElementStyles(klass, template2, is, baseURI) {
    if (!builtCSS) {
      const templateStyles = template2.content.querySelectorAll("style");
      const stylesWithImports = stylesFromTemplate(template2);
      const linkedStyles = stylesFromModuleImports(is);
      const firstTemplateChild = template2.content.firstElementChild;
      for (let idx = 0; idx < linkedStyles.length; idx++) {
        let s3 = linkedStyles[idx];
        s3.textContent = klass._processStyleText(s3.textContent, baseURI);
        template2.content.insertBefore(s3, firstTemplateChild);
      }
      let templateStyleIndex = 0;
      for (let i2 = 0; i2 < stylesWithImports.length; i2++) {
        let s3 = stylesWithImports[i2];
        let templateStyle = templateStyles[templateStyleIndex];
        if (templateStyle !== s3) {
          s3 = s3.cloneNode(true);
          templateStyle.parentNode.insertBefore(s3, templateStyle);
        } else {
          templateStyleIndex++;
        }
        s3.textContent = klass._processStyleText(s3.textContent, baseURI);
      }
    }
    if (window.ShadyCSS) {
      window.ShadyCSS.prepareTemplate(template2, is);
    }
    if (useAdoptedStyleSheetsWithBuiltCSS && builtCSS && supportsAdoptingStyleSheets$1) {
      const styles2 = template2.content.querySelectorAll("style");
      if (styles2) {
        let css2 = "";
        Array.from(styles2).forEach((s3) => {
          css2 += s3.textContent;
          s3.parentNode.removeChild(s3);
        });
        klass._styleSheet = new CSSStyleSheet();
        klass._styleSheet.replaceSync(css2);
      }
    }
  }
  function getTemplateFromDomModule(is) {
    let template2 = null;
    if (is && (!strictTemplatePolicy || allowTemplateFromDomModule)) {
      template2 = /** @type {?HTMLTemplateElement} */
      DomModule.import(is, "template");
      if (strictTemplatePolicy && !template2) {
        throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${is}`);
      }
    }
    return template2;
  }
  class PolymerElement2 extends polymerElementBase {
    /**
     * Current Polymer version in Semver notation.
     * @type {string} Semver notation of the current version of Polymer.
     * @nocollapse
     */
    static get polymerElementVersion() {
      return version;
    }
    /**
     * Override of PropertiesMixin _finalizeClass to create observers and
     * find the template.
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _finalizeClass() {
      polymerElementBase._finalizeClass.call(this);
      const observers = ownObservers(this);
      if (observers) {
        this.createObservers(observers, this._properties);
      }
      this._prepareTemplate();
    }
    /** @nocollapse */
    static _prepareTemplate() {
      let template2 = (
        /** @type {PolymerElementConstructor} */
        this.template
      );
      if (template2) {
        if (typeof template2 === "string") {
          console.error("template getter must return HTMLTemplateElement");
          template2 = null;
        } else if (!legacyOptimizations) {
          template2 = template2.cloneNode(true);
        }
      }
      this.prototype._template = template2;
    }
    /**
     * Override of PropertiesChanged createProperties to create accessors
     * and property effects for all of the properties.
     * @param {!Object} props .
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createProperties(props) {
      for (let p in props) {
        createPropertyFromConfig(
          /** @type {?} */
          this.prototype,
          p,
          props[p],
          props
        );
      }
    }
    /**
     * Creates observers for the given `observers` array.
     * Leverages `PropertyEffects` to create observers.
     * @param {Object} observers Array of observer descriptors for
     *   this class
     * @param {Object} dynamicFns Object containing keys for any properties
     *   that are functions and should trigger the effect when the function
     *   reference is changed
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createObservers(observers, dynamicFns) {
      const proto2 = this.prototype;
      for (let i2 = 0; i2 < observers.length; i2++) {
        proto2._createMethodObserver(observers[i2], dynamicFns);
      }
    }
    /**
     * Returns the template that will be stamped into this element's shadow root.
     *
     * If a `static get is()` getter is defined, the default implementation will
     * return the first `<template>` in a `dom-module` whose `id` matches this
     * element's `is` (note that a `_template` property on the class prototype
     * takes precedence over the `dom-module` template, to maintain legacy
     * element semantics; a subclass will subsequently fall back to its super
     * class template if neither a `prototype._template` or a `dom-module` for
     * the class's `is` was found).
     *
     * Users may override this getter to return an arbitrary template
     * (in which case the `is` getter is unnecessary). The template returned
     * must be an `HTMLTemplateElement`.
     *
     * Note that when subclassing, if the super class overrode the default
     * implementation and the subclass would like to provide an alternate
     * template via a `dom-module`, it should override this getter and
     * return `DomModule.import(this.is, 'template')`.
     *
     * If a subclass would like to modify the super class template, it should
     * clone it rather than modify it in place.  If the getter does expensive
     * work such as cloning/modifying a template, it should memoize the
     * template for maximum performance:
     *
     *   let memoizedTemplate;
     *   class MySubClass extends MySuperClass {
     *     static get template() {
     *       if (!memoizedTemplate) {
     *         memoizedTemplate = super.template.cloneNode(true);
     *         let subContent = document.createElement('div');
     *         subContent.textContent = 'This came from MySubClass';
     *         memoizedTemplate.content.appendChild(subContent);
     *       }
     *       return memoizedTemplate;
     *     }
     *   }
     *
     * @return {!HTMLTemplateElement|string} Template to be stamped
     * @nocollapse
     */
    static get template() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("_template", this))) {
        let protoTemplate = this.prototype.hasOwnProperty(
          JSCompiler_renameProperty("_template", this.prototype)
        ) ? this.prototype._template : void 0;
        if (typeof protoTemplate === "function") {
          protoTemplate = protoTemplate();
        }
        this._template = // If user has put template on prototype (e.g. in legacy via registered
        // callback or info object), prefer that first. Note that `null` is
        // used as a sentinel to indicate "no template" and can be used to
        // override a super template, whereas `undefined` is used as a
        // sentinel to mean "fall-back to default template lookup" via
        // dom-module and/or super.template.
        protoTemplate !== void 0 ? protoTemplate : (
          // Look in dom-module associated with this element's is
          this.hasOwnProperty(JSCompiler_renameProperty("is", this)) && getTemplateFromDomModule(
            /** @type {PolymerElementConstructor}*/
            this.is
          ) || // Next look for superclass template (call the super impl this
          // way so that `this` points to the superclass)
          Object.getPrototypeOf(
            /** @type {PolymerElementConstructor}*/
            this.prototype
          ).constructor.template
        );
      }
      return this._template;
    }
    /**
     * Set the template.
     *
     * @param {!HTMLTemplateElement|string} value Template to set.
     * @nocollapse
     */
    static set template(value) {
      this._template = value;
    }
    /**
     * Path matching the url from which the element was imported.
     *
     * This path is used to resolve url's in template style cssText.
     * The `importPath` property is also set on element instances and can be
     * used to create bindings relative to the import path.
     *
     * For elements defined in ES modules, users should implement
     * `static get importMeta() { return import.meta; }`, and the default
     * implementation of `importPath` will  return `import.meta.url`'s path.
     * For elements defined in HTML imports, this getter will return the path
     * to the document containing a `dom-module` element matching this
     * element's static `is` property.
     *
     * Note, this path should contain a trailing `/`.
     *
     * @return {string} The import path for this element class
     * @suppress {missingProperties}
     * @nocollapse
     */
    static get importPath() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("_importPath", this))) {
        const meta = this.importMeta;
        if (meta) {
          this._importPath = pathFromUrl(meta.url);
        } else {
          const module2 = DomModule.import(
            /** @type {PolymerElementConstructor} */
            this.is
          );
          this._importPath = module2 && module2.assetpath || Object.getPrototypeOf(
            /** @type {PolymerElementConstructor}*/
            this.prototype
          ).constructor.importPath;
        }
      }
      return this._importPath;
    }
    constructor() {
      super();
      this._template;
      this._importPath;
      this.rootPath;
      this.importPath;
      this.root;
      this.$;
    }
    /**
     * Overrides the default `PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @return {void}
     * @override
     * @suppress {invalidCasts,missingProperties} go/missingfnprops
     */
    _initializeProperties() {
      this.constructor.finalize();
      this.constructor._finalizeTemplate(
        /** @type {!HTMLElement} */
        this.localName
      );
      super._initializeProperties();
      this.rootPath = rootPath;
      this.importPath = this.constructor.importPath;
      let p$ = propertyDefaults(this.constructor);
      if (!p$) {
        return;
      }
      for (let p in p$) {
        let info = p$[p];
        if (this._canApplyPropertyDefault(p)) {
          let value = typeof info.value == "function" ? info.value.call(this) : info.value;
          if (this._hasAccessor(p)) {
            this._setPendingProperty(p, value, true);
          } else {
            this[p] = value;
          }
        }
      }
    }
    /**
     * Determines if a property dfeault can be applied. For example, this
     * prevents a default from being applied when a property that has no
     * accessor is overridden by its host before upgrade (e.g. via a binding).
     * @override
     * @param {string} property Name of the property
     * @return {boolean} Returns true if the property default can be applied.
     */
    _canApplyPropertyDefault(property) {
      return !this.hasOwnProperty(property);
    }
    /**
     * Gather style text for a style element in the template.
     *
     * @param {string} cssText Text containing styling to process
     * @param {string} baseURI Base URI to rebase CSS paths against
     * @return {string} The processed CSS text
     * @protected
     * @nocollapse
     */
    static _processStyleText(cssText, baseURI) {
      return resolveCss(cssText, baseURI);
    }
    /**
    * Configures an element `proto` to function with a given `template`.
    * The element name `is` and extends `ext` must be specified for ShadyCSS
    * style scoping.
    *
    * @param {string} is Tag name (or type extension name) for this element
    * @return {void}
    * @protected
    * @nocollapse
    */
    static _finalizeTemplate(is) {
      const template2 = this.prototype._template;
      if (template2 && !template2.__polymerFinalized) {
        template2.__polymerFinalized = true;
        const importPath = this.importPath;
        const baseURI = importPath ? resolveUrl(importPath) : "";
        processElementStyles(this, template2, is, baseURI);
        this.prototype._bindTemplate(template2);
      }
    }
    /**
     * Provides a default implementation of the standard Custom Elements
     * `connectedCallback`.
     *
     * The default implementation enables the property effects system and
     * flushes any pending properties, and updates shimmed CSS properties
     * when using the ShadyCSS scoping/custom properties polyfill.
     *
     * @override
     * @suppress {missingProperties, invalidCasts} Super may or may not
     *     implement the callback
     * @return {void}
     */
    connectedCallback() {
      if (window.ShadyCSS && this._template) {
        window.ShadyCSS.styleElement(
          /** @type {!HTMLElement} */
          this
        );
      }
      super.connectedCallback();
    }
    /**
     * Stamps the element template.
     *
     * @return {void}
     * @override
     */
    ready() {
      if (this._template) {
        this.root = this._stampTemplate(this._template);
        this.$ = this.root.$;
      }
      super.ready();
    }
    /**
     * Implements `PropertyEffects`'s `_readyClients` call. Attaches
     * element dom by calling `_attachDom` with the dom stamped from the
     * element's template via `_stampTemplate`. Note that this allows
     * client dom to be attached to the element prior to any observers
     * running.
     *
     * @return {void}
     * @override
     */
    _readyClients() {
      if (this._template) {
        this.root = this._attachDom(
          /** @type {StampedTemplate} */
          this.root
        );
      }
      super._readyClients();
    }
    /**
     * Attaches an element's stamped dom to itself. By default,
     * this method creates a `shadowRoot` and adds the dom to it.
     * However, this method may be overridden to allow an element
     * to put its dom in another location.
     *
     * @override
     * @throws {Error}
     * @suppress {missingReturn}
     * @param {StampedTemplate} dom to attach to the element.
     * @return {ShadowRoot} node to which the dom has been attached.
     */
    _attachDom(dom) {
      const n = wrap$1(this);
      if (n.attachShadow) {
        if (dom) {
          if (!n.shadowRoot) {
            n.attachShadow({ mode: "open", shadyUpgradeFragment: dom });
            n.shadowRoot.appendChild(dom);
            if (this.constructor._styleSheet) {
              n.shadowRoot.adoptedStyleSheets = [this.constructor._styleSheet];
            }
          }
          if (syncInitialRender && window.ShadyDOM) {
            window.ShadyDOM.flushInitial(n.shadowRoot);
          }
          return n.shadowRoot;
        }
        return null;
      } else {
        throw new Error("ShadowDOM not available. PolymerElement can create dom as children instead of in ShadowDOM by setting `this.root = this;` before `ready`.");
      }
    }
    /**
     * When using the ShadyCSS scoping and custom property shim, causes all
     * shimmed styles in this element (and its subtree) to be updated
     * based on current custom property values.
     *
     * The optional parameter overrides inline custom property styles with an
     * object of properties where the keys are CSS properties, and the values
     * are strings.
     *
     * Example: `this.updateStyles({'--color': 'blue'})`
     *
     * These properties are retained unless a value of `null` is set.
     *
     * Note: This function does not support updating CSS mixins.
     * You can not dynamically change the value of an `@apply`.
     *
     * @override
     * @param {Object=} properties Bag of custom property key/values to
     *   apply to this element.
     * @return {void}
     * @suppress {invalidCasts}
     */
    updateStyles(properties) {
      if (window.ShadyCSS) {
        window.ShadyCSS.styleSubtree(
          /** @type {!HTMLElement} */
          this,
          properties
        );
      }
    }
    /**
     * Rewrites a given URL relative to a base URL. The base URL defaults to
     * the original location of the document containing the `dom-module` for
     * this element. This method will return the same URL before and after
     * bundling.
     *
     * Note that this function performs no resolution for URLs that start
     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
     * URL resolution, use `window.URL`.
     *
     * @override
     * @param {string} url URL to resolve.
     * @param {string=} base Optional base URL to resolve against, defaults
     * to the element's `importPath`
     * @return {string} Rewritten URL relative to base
     */
    resolveUrl(url, base2) {
      if (!base2 && this.importPath) {
        base2 = resolveUrl(this.importPath);
      }
      return resolveUrl(url, base2);
    }
    /**
     * Overrides `PropertyEffects` to add map of dynamic functions on
     * template info, for consumption by `PropertyEffects` template binding
     * code. This map determines which method templates should have accessors
     * created for them.
     *
     * @param {!HTMLTemplateElement} template Template
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} .
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateContent(template2, templateInfo, nodeInfo) {
      templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;
      return polymerElementBase._parseTemplateContent.call(
        this,
        template2,
        templateInfo,
        nodeInfo
      );
    }
    /**
     * Overrides `PropertyEffects` to warn on use of undeclared properties in
     * template.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      if (legacyWarnings && !(prop in this._properties) && // Methods used in templates with no dependencies (or only literal
      // dependencies) become accessors with template effects; ignore these
      !(effect.info.part.signature && effect.info.part.signature.static) && // Warnings for bindings added to nested templates are handled by
      // templatizer so ignore both the host-to-template bindings
      // (`hostProp`) and TemplateInstance-to-child bindings
      // (`nestedTemplate`)
      !effect.info.part.hostProp && !templateInfo.nestedTemplate) {
        console.warn(`Property '${prop}' used in template but not declared in 'properties'; attribute will not be observed.`);
      }
      return polymerElementBase._addTemplatePropertyEffect.call(
        this,
        templateInfo,
        prop,
        effect
      );
    }
  }
  return PolymerElement2;
});
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const policy = window.trustedTypes && trustedTypes.createPolicy("polymer-html-literal", { createHTML: (s3) => s3 });
class LiteralString {
  /**
   * @param {!ITemplateArray} strings Constant parts of tagged template literal
   * @param {!Array<*>} values Variable parts of tagged template literal
   */
  constructor(strings, values) {
    assertValidTemplateStringParameters(strings, values);
    const string = values.reduce(
      (acc, v, idx) => acc + literalValue(v) + strings[idx + 1],
      strings[0]
    );
    this.value = string.toString();
  }
  /**
   * @return {string} LiteralString string value
   * @override
   */
  toString() {
    return this.value;
  }
}
function literalValue(value) {
  if (value instanceof LiteralString) {
    return (
      /** @type {!LiteralString} */
      value.value
    );
  } else {
    throw new Error(
      `non-literal value passed to Polymer's htmlLiteral function: ${value}`
    );
  }
}
function htmlValue(value) {
  if (value instanceof HTMLTemplateElement) {
    return (
      /** @type {!HTMLTemplateElement } */
      value.innerHTML
    );
  } else if (value instanceof LiteralString) {
    return literalValue(value);
  } else {
    throw new Error(
      `non-template value passed to Polymer's html function: ${value}`
    );
  }
}
const html = function html2(strings, ...values) {
  assertValidTemplateStringParameters(strings, values);
  const template2 = (
    /** @type {!HTMLTemplateElement} */
    document.createElement("template")
  );
  let value = values.reduce(
    (acc, v, idx) => acc + htmlValue(v) + strings[idx + 1],
    strings[0]
  );
  if (policy) {
    value = policy.createHTML(value);
  }
  template2.innerHTML = value;
  return template2;
};
const assertValidTemplateStringParameters = (strings, values) => {
  if (!Array.isArray(strings) || !Array.isArray(strings.raw) || values.length !== strings.length - 1) {
    throw new TypeError("Invalid call to the html template tag");
  }
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const PolymerElement = ElementMixin$1(HTMLElement);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const directionSubscribers = [];
function alignDirs(element, documentDir, elementDir = element.getAttribute("dir")) {
  if (documentDir) {
    element.setAttribute("dir", documentDir);
  } else if (elementDir != null) {
    element.removeAttribute("dir");
  }
}
function getDocumentDir() {
  return document.documentElement.getAttribute("dir");
}
function directionUpdater() {
  const documentDir = getDocumentDir();
  directionSubscribers.forEach((element) => {
    alignDirs(element, documentDir);
  });
}
const directionObserver = new MutationObserver(directionUpdater);
directionObserver.observe(document.documentElement, { attributes: true, attributeFilter: ["dir"] });
const DirMixin = (superClass) => class VaadinDirMixin extends superClass {
  static get properties() {
    return {
      /**
       * @protected
       */
      dir: {
        type: String,
        value: "",
        reflectToAttribute: true,
        converter: {
          fromAttribute: (attr) => {
            return !attr ? "" : attr;
          },
          toAttribute: (prop) => {
            return prop === "" ? null : prop;
          }
        }
      }
    };
  }
  /**
   * @return {boolean}
   * @protected
   */
  get __isRTL() {
    return this.getAttribute("dir") === "rtl";
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (!this.hasAttribute("dir") || this.__restoreSubscription) {
      this.__subscribe();
      alignDirs(this, getDocumentDir(), null);
    }
  }
  /** @protected */
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (name !== "dir") {
      return;
    }
    const documentDir = getDocumentDir();
    const newValueEqlDocDir = newValue === documentDir && directionSubscribers.indexOf(this) === -1;
    const newValueEmptied = !newValue && oldValue && directionSubscribers.indexOf(this) === -1;
    const newDiffValue = newValue !== documentDir && oldValue === documentDir;
    if (newValueEqlDocDir || newValueEmptied) {
      this.__subscribe();
      alignDirs(this, documentDir, newValue);
    } else if (newDiffValue) {
      this.__unsubscribe();
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__restoreSubscription = directionSubscribers.includes(this);
    this.__unsubscribe();
  }
  /** @protected */
  _valueToNodeAttribute(node, value, attribute) {
    if (attribute === "dir" && value === "" && !node.hasAttribute("dir")) {
      return;
    }
    super._valueToNodeAttribute(node, value, attribute);
  }
  /** @protected */
  _attributeToProperty(attribute, value, type) {
    if (attribute === "dir" && !value) {
      this.dir = "";
    } else {
      super._attributeToProperty(attribute, value, type);
    }
  }
  /** @private */
  __subscribe() {
    if (!directionSubscribers.includes(this)) {
      directionSubscribers.push(this);
    }
  }
  /** @private */
  __unsubscribe() {
    if (directionSubscribers.includes(this)) {
      directionSubscribers.splice(directionSubscribers.indexOf(this), 1);
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class UserTag extends ThemableMixin(DirMixin(PolymerElement)) {
  static get is() {
    return "vaadin-user-tag";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          box-sizing: border-box;
          margin: 0 0 var(--vaadin-user-tag-offset);
          opacity: 0;
          height: 1.3rem;
          transition: opacity 0.2s ease-in-out;
          background-color: var(--vaadin-user-tag-color);
          color: #fff;
          cursor: default;
          -webkit-user-select: none;
          user-select: none;
          --vaadin-user-tag-offset: 4px;
        }

        :host(.show) {
          opacity: 1;
        }

        :host(:last-of-type) {
          margin-bottom: 0;
        }

        [part='name'] {
          overflow: hidden;
          white-space: nowrap;
          text-overflow: ellipsis;
          box-sizing: border-box;
          padding: 2px 4px;
          height: 1.3rem;
          font-size: 13px;
        }
      </style>
      <div part="name">[[name]]</div>
    `;
  }
  static get properties() {
    return {
      /**
       * Name of the user.
       */
      name: {
        type: String
      },
      /**
       * Id of the user.
       */
      uid: {
        type: String
      },
      /**
       * Color index of the user.
       */
      colorIndex: {
        type: Number,
        observer: "_colorIndexChanged"
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("mousedown", this._onClick.bind(this), true);
  }
  /** @private */
  _colorIndexChanged(index) {
    if (index != null) {
      this.style.setProperty("--vaadin-user-tag-color", `var(--vaadin-user-color-${index})`);
    }
  }
  /**
   * @param {Event} e
   * @private
   */
  _onClick(e2) {
    e2.preventDefault();
    this.dispatchEvent(
      new CustomEvent("user-tag-click", {
        bubbles: true,
        composed: true,
        detail: {
          name: this.name
        }
      })
    );
  }
}
defineCustomElement(UserTag);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let scheduled = false;
let beforeRenderQueue = [];
let afterRenderQueue = [];
function schedule() {
  scheduled = true;
  requestAnimationFrame(function() {
    scheduled = false;
    flushQueue(beforeRenderQueue);
    setTimeout(function() {
      runQueue(afterRenderQueue);
    });
  });
}
function flushQueue(queue) {
  while (queue.length) {
    callMethod(queue.shift());
  }
}
function runQueue(queue) {
  for (let i2 = 0, l = queue.length; i2 < l; i2++) {
    callMethod(queue.shift());
  }
}
function callMethod(info) {
  const context = info[0];
  const callback = info[1];
  const args = info[2];
  try {
    callback.apply(context, args);
  } catch (e2) {
    setTimeout(() => {
      throw e2;
    });
  }
}
function beforeNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  beforeRenderQueue.push([context, callback, args]);
}
function afterNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  afterRenderQueue.push([context, callback, args]);
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const testUserAgent = (regexp) => regexp.test(navigator.userAgent);
const testPlatform = (regexp) => regexp.test(navigator.platform);
const testVendor = (regexp) => regexp.test(navigator.vendor);
const isAndroid = testUserAgent(/Android/u);
const isChrome = testUserAgent(/Chrome/u) && testVendor(/Google Inc/u);
const isFirefox = testUserAgent(/Firefox/u);
const isIPad = testPlatform(/^iPad/u) || testPlatform(/^Mac/u) && navigator.maxTouchPoints > 1;
const isIPhone = testPlatform(/^iPhone/u);
const isIOS = isIPhone || isIPad;
const isSafari = testUserAgent(/^((?!chrome|android).)*safari/iu);
const isTouch = (() => {
  try {
    document.createEvent("TouchEvent");
    return true;
  } catch (_) {
    return false;
  }
})();
const supportsAdoptingStyleSheets = window.ShadowRoot && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
/**
 * @license
 * Copyright (c) 2017 Anton Korzunov
 * SPDX-License-Identifier: MIT
 */
let counterMap = /* @__PURE__ */ new WeakMap();
let uncontrolledNodes = /* @__PURE__ */ new WeakMap();
let markerMap = {};
let lockCount = 0;
const isElement = (node) => node && node.nodeType === Node.ELEMENT_NODE;
const logError = (...args) => {
  console.error(`Error: ${args.join(" ")}. Skip setting aria-hidden.`);
};
const correctTargets = (parent, targets) => {
  if (!isElement(parent)) {
    logError(parent, "is not a valid element");
    return [];
  }
  return targets.map((target) => {
    if (!isElement(target)) {
      logError(target, "is not a valid element");
      return null;
    }
    let node = target;
    while (node && node !== parent) {
      if (parent.contains(node)) {
        return target;
      }
      node = node.getRootNode().host;
    }
    logError(target, "is not contained inside", parent);
    return null;
  }).filter((x2) => Boolean(x2));
};
const applyAttributeToOthers = (originalTarget, parentNode, markerName, controlAttribute) => {
  const targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  const markerCounter = markerMap[markerName];
  const hiddenNodes = [];
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(targets);
  const keep = (el) => {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    const slot = el.assignedSlot;
    if (slot) {
      keep(slot);
    }
    keep(el.parentNode || el.host);
  };
  targets.forEach(keep);
  const deep = (parent) => {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    const root2 = parent.shadowRoot;
    const children = root2 ? [...parent.children, ...root2.children] : [...parent.children];
    children.forEach((node) => {
      if (["template", "script", "style"].includes(node.localName)) {
        return;
      }
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        const attr = node.getAttribute(controlAttribute);
        const alreadyHidden = attr !== null && attr !== "false";
        const counterValue = (counterMap.get(node) || 0) + 1;
        const markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenNodes.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node, true);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node.setAttribute(controlAttribute, "true");
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount += 1;
  return () => {
    hiddenNodes.forEach((node) => {
      const counterValue = counterMap.get(node) - 1;
      const markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (uncontrolledNodes.has(node)) {
          uncontrolledNodes.delete(node);
        } else {
          node.removeAttribute(controlAttribute);
        }
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount -= 1;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
const hideOthers = (originalTarget, parentNode = document.body, markerName = "data-aria-hidden") => {
  const targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (parentNode) {
    targets.push(...Array.from(parentNode.querySelectorAll("[aria-live]")));
  }
  return applyAttributeToOthers(targets, parentNode, markerName, "aria-hidden");
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class AriaModalController {
  /**
   * @param {HTMLElement} host
   */
  constructor(host, callback) {
    this.host = host;
    this.callback = typeof callback === "function" ? callback : () => host;
  }
  /**
   * Make the controller host modal by hiding other elements from screen readers
   * using `aria-hidden` attribute (can be replaced with `inert` in the future).
   *
   * The method name is chosen to align with the one provided by native `<dialog>`:
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/showModal
   */
  showModal() {
    const targets = this.callback();
    this.__showOthers = hideOthers(targets);
  }
  /**
   * Remove `aria-hidden` from other elements unless there are any other
   * controller hosts on the page activated by using `showModal()` call.
   */
  close() {
    if (this.__showOthers) {
      this.__showOthers();
      this.__showOthers = null;
    }
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let keyboardActive = false;
window.addEventListener(
  "keydown",
  () => {
    keyboardActive = true;
  },
  { capture: true }
);
window.addEventListener(
  "mousedown",
  () => {
    keyboardActive = false;
  },
  { capture: true }
);
function getDeepActiveElement() {
  let host = document.activeElement || document.body;
  while (host.shadowRoot && host.shadowRoot.activeElement) {
    host = host.shadowRoot.activeElement;
  }
  return host;
}
function isKeyboardActive() {
  return keyboardActive;
}
function isElementHiddenDirectly(element) {
  const style = element.style;
  if (style.visibility === "hidden" || style.display === "none") {
    return true;
  }
  const computedStyle = window.getComputedStyle(element);
  if (computedStyle.visibility === "hidden" || computedStyle.display === "none") {
    return true;
  }
  return false;
}
function hasLowerTabOrder(a3, b2) {
  const ati = Math.max(a3.tabIndex, 0);
  const bti = Math.max(b2.tabIndex, 0);
  return ati === 0 || bti === 0 ? bti > ati : ati > bti;
}
function mergeSortByTabIndex(left, right) {
  const result = [];
  while (left.length > 0 && right.length > 0) {
    if (hasLowerTabOrder(left[0], right[0])) {
      result.push(right.shift());
    } else {
      result.push(left.shift());
    }
  }
  return result.concat(left, right);
}
function sortElementsByTabIndex(elements) {
  const len = elements.length;
  if (len < 2) {
    return elements;
  }
  const pivot = Math.ceil(len / 2);
  const left = sortElementsByTabIndex(elements.slice(0, pivot));
  const right = sortElementsByTabIndex(elements.slice(pivot));
  return mergeSortByTabIndex(left, right);
}
function isElementHidden(element) {
  if (element.offsetParent === null && element.clientWidth === 0 && element.clientHeight === 0) {
    return true;
  }
  return isElementHiddenDirectly(element);
}
function isElementFocusable(element) {
  if (element.matches('[tabindex="-1"]')) {
    return false;
  }
  if (element.matches("input, select, textarea, button, object")) {
    return element.matches(":not([disabled])");
  }
  return element.matches("a[href], area[href], iframe, [tabindex], [contentEditable]");
}
function isElementFocused(element) {
  return element.getRootNode().activeElement === element;
}
function normalizeTabIndex(element) {
  if (!isElementFocusable(element)) {
    return -1;
  }
  const tabIndex = element.getAttribute("tabindex") || 0;
  return Number(tabIndex);
}
function collectFocusableNodes(node, result) {
  if (node.nodeType !== Node.ELEMENT_NODE || isElementHiddenDirectly(node)) {
    return false;
  }
  const element = (
    /** @type {HTMLElement} */
    node
  );
  const tabIndex = normalizeTabIndex(element);
  let needsSort = tabIndex > 0;
  if (tabIndex >= 0) {
    result.push(element);
  }
  let children = [];
  if (element.localName === "slot") {
    children = element.assignedNodes({ flatten: true });
  } else {
    children = (element.shadowRoot || element).children;
  }
  [...children].forEach((child) => {
    needsSort = collectFocusableNodes(child, result) || needsSort;
  });
  return needsSort;
}
function getFocusableElements(element) {
  const focusableElements = [];
  const needsSortByTabIndex = collectFocusableNodes(element, focusableElements);
  if (needsSortByTabIndex) {
    return sortElementsByTabIndex(focusableElements);
  }
  return focusableElements;
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class FocusRestorationController {
  /**
   * Saves the given node as a target for restoring focus to
   * when `restoreFocus()` is called. If no node is provided,
   * the currently focused node in the DOM is saved as a target.
   *
   * @param {Node | null | undefined} focusNode
   */
  saveFocus(focusNode) {
    this.focusNode = focusNode || getDeepActiveElement();
  }
  /**
   * Restores focus to the target node that was saved previously with `saveFocus()`.
   */
  restoreFocus(options) {
    const focusNode = this.focusNode;
    if (!focusNode) {
      return;
    }
    const preventScroll = options ? options.preventScroll : false;
    if (getDeepActiveElement() === document.body) {
      setTimeout(() => focusNode.focus({ preventScroll }));
    } else {
      focusNode.focus({ preventScroll });
    }
    this.focusNode = null;
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const instances = [];
class FocusTrapController {
  /**
   * @param {HTMLElement} host
   */
  constructor(host) {
    this.host = host;
    this.__trapNode = null;
    this.__onKeyDown = this.__onKeyDown.bind(this);
  }
  /**
   * An array of tab-ordered focusable elements inside the trap node.
   *
   * @return {HTMLElement[]}
   * @private
   */
  get __focusableElements() {
    return getFocusableElements(this.__trapNode);
  }
  /**
   * The index of the element inside the trap node that currently has focus.
   *
   * @return {HTMLElement | undefined}
   * @private
   */
  get __focusedElementIndex() {
    const focusableElements = this.__focusableElements;
    return focusableElements.indexOf(focusableElements.filter(isElementFocused).pop());
  }
  hostConnected() {
    document.addEventListener("keydown", this.__onKeyDown);
  }
  hostDisconnected() {
    document.removeEventListener("keydown", this.__onKeyDown);
  }
  /**
   * Activates a focus trap for a DOM node that will prevent focus from escaping the node.
   * The trap can be deactivated with the `.releaseFocus()` method.
   *
   * If focus is initially outside the trap, the method will move focus inside,
   * on the first focusable element of the trap in the tab order.
   * The first focusable element can be the trap node itself if it is focusable
   * and comes first in the tab order.
   *
   * If there are no focusable elements, the method will throw an exception
   * and the trap will not be set.
   *
   * @param {HTMLElement} trapNode
   */
  trapFocus(trapNode) {
    this.__trapNode = trapNode;
    if (this.__focusableElements.length === 0) {
      this.__trapNode = null;
      throw new Error("The trap node should have at least one focusable descendant or be focusable itself.");
    }
    instances.push(this);
    if (this.__focusedElementIndex === -1) {
      this.__focusableElements[0].focus();
    }
  }
  /**
   * Deactivates the focus trap set with the `.trapFocus()` method
   * so that it becomes possible to tab outside the trap node.
   */
  releaseFocus() {
    this.__trapNode = null;
    instances.pop();
  }
  /**
   * A `keydown` event handler that manages tabbing navigation when the trap is enabled.
   *
   * - Moves focus to the next focusable element of the trap on `Tab` press.
   * When no next element to focus, the method moves focus to the first focusable element.
   * - Moves focus to the prev focusable element of the trap on `Shift+Tab` press.
   * When no prev element to focus, the method moves focus to the last focusable element.
   *
   * @param {KeyboardEvent} event
   * @private
   */
  __onKeyDown(event) {
    if (!this.__trapNode) {
      return;
    }
    if (this !== Array.from(instances).pop()) {
      return;
    }
    if (event.key === "Tab") {
      event.preventDefault();
      const backward = event.shiftKey;
      this.__focusNextElement(backward);
    }
  }
  /**
   * - Moves focus to the next focusable element if `backward === false`.
   * When no next element to focus, the method moves focus to the first focusable element.
   * - Moves focus to the prev focusable element if `backward === true`.
   * When no prev element to focus the method moves focus to the last focusable element.
   *
   * If no focusable elements, the method returns immediately.
   *
   * @param {boolean} backward
   * @private
   */
  __focusNextElement(backward = false) {
    const focusableElements = this.__focusableElements;
    const step = backward ? -1 : 1;
    const currentIndex = this.__focusedElementIndex;
    const nextIndex = (focusableElements.length + currentIndex + step) % focusableElements.length;
    const element = focusableElements[nextIndex];
    element.focus();
    if (element.localName === "input") {
      element.select();
    }
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ControllerMixin = dedupingMixin((superClass) => {
  if (typeof superClass.prototype.addController === "function") {
    return superClass;
  }
  return class ControllerMixinClass extends superClass {
    constructor() {
      super();
      this.__controllers = /* @__PURE__ */ new Set();
    }
    /** @protected */
    connectedCallback() {
      super.connectedCallback();
      this.__controllers.forEach((c2) => {
        if (c2.hostConnected) {
          c2.hostConnected();
        }
      });
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback();
      this.__controllers.forEach((c2) => {
        if (c2.hostDisconnected) {
          c2.hostDisconnected();
        }
      });
    }
    /**
     * Registers a controller to participate in the element update cycle.
     *
     * @param {ReactiveController} controller
     * @protected
     */
    addController(controller) {
      this.__controllers.add(controller);
      if (this.$ !== void 0 && this.isConnected && controller.hostConnected) {
        controller.hostConnected();
      }
    }
    /**
     * Removes a controller from the element.
     *
     * @param {ReactiveController} controller
     * @protected
     */
    removeController(controller) {
      this.__controllers.delete(controller);
    }
  };
});
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const OverlayFocusMixin = (superClass) => class OverlayFocusMixin extends ControllerMixin(superClass) {
  static get properties() {
    return {
      /**
       * When true, opening the overlay moves focus to the first focusable child,
       * or to the overlay part with tabindex if there are no focusable children.
       * @attr {boolean} focus-trap
       */
      focusTrap: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to enable restoring of focus when overlay is closed.
       * @attr {boolean} restore-focus-on-close
       */
      restoreFocusOnClose: {
        type: Boolean,
        value: false
      },
      /**
       * Set to specify the element which should be focused on overlay close,
       * if `restoreFocusOnClose` is set to true.
       * @type {HTMLElement}
       */
      restoreFocusNode: {
        type: HTMLElement
      }
    };
  }
  constructor() {
    super();
    this.__ariaModalController = new AriaModalController(this);
    this.__focusTrapController = new FocusTrapController(this);
    this.__focusRestorationController = new FocusRestorationController();
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(this.__ariaModalController);
    this.addController(this.__focusTrapController);
    this.addController(this.__focusRestorationController);
  }
  /**
   * Release focus and restore focus after the overlay is closed.
   *
   * @protected
   */
  _resetFocus() {
    if (this.focusTrap) {
      this.__ariaModalController.close();
      this.__focusTrapController.releaseFocus();
    }
    if (this.restoreFocusOnClose && this._shouldRestoreFocus()) {
      const preventScroll = !isKeyboardActive();
      this.__focusRestorationController.restoreFocus({ preventScroll });
    }
  }
  /**
   * Save the previously focused node when the overlay starts to open.
   *
   * @protected
   */
  _saveFocus() {
    if (this.restoreFocusOnClose) {
      this.__focusRestorationController.saveFocus(this.restoreFocusNode);
    }
  }
  /**
   * Trap focus within the overlay after opening has completed.
   *
   * @protected
   */
  _trapFocus() {
    if (this.focusTrap) {
      this.__ariaModalController.showModal();
      this.__focusTrapController.trapFocus(this.$.overlay);
    }
  }
  /**
   * Returns true if focus is still inside the overlay or on the body element,
   * otherwise false.
   *
   * Focus shouldn't be restored if it's been moved elsewhere by another
   * component or as a result of a user interaction e.g. the user clicked
   * on a button outside the overlay while the overlay was open.
   *
   * @protected
   * @return {boolean}
   */
  _shouldRestoreFocus() {
    const activeElement = getDeepActiveElement();
    return activeElement === document.body || this._deepContains(activeElement);
  }
  /**
   * Returns true if the overlay contains the given node,
   * including those within shadow DOM trees.
   *
   * @param {Node} node
   * @return {boolean}
   * @protected
   */
  _deepContains(node) {
    if (this.contains(node)) {
      return true;
    }
    let n = node;
    const doc = node.ownerDocument;
    while (n && n !== doc && n !== this) {
      n = n.parentNode || n.host;
    }
    return n === this;
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const getAttachedInstances = () => Array.from(document.body.children).filter((el) => el instanceof HTMLElement && el._hasOverlayStackMixin && !el.hasAttribute("closing")).sort((a3, b2) => a3.__zIndex - b2.__zIndex || 0);
const getOverlayInstances = () => getAttachedInstances().filter((el) => el.$.overlay);
const isLastOverlay = (overlay2) => overlay2 === getOverlayInstances().pop();
const OverlayStackMixin = (superClass) => class OverlayStackMixin extends superClass {
  constructor() {
    super();
    this._hasOverlayStackMixin = true;
  }
  /**
   * Returns true if this is the last one in the opened overlays stack.
   *
   * @return {boolean}
   * @protected
   */
  get _last() {
    return isLastOverlay(this);
  }
  /**
   * Brings the overlay as visually the frontmost one.
   */
  bringToFront() {
    let zIndex = "";
    const frontmost = getAttachedInstances().filter((o) => o !== this).pop();
    if (frontmost) {
      const frontmostZIndex = frontmost.__zIndex;
      zIndex = frontmostZIndex + 1;
    }
    this.style.zIndex = zIndex;
    this.__zIndex = zIndex || parseFloat(getComputedStyle(this).zIndex);
  }
  /** @protected */
  _enterModalState() {
    if (document.body.style.pointerEvents !== "none") {
      this._previousDocumentPointerEvents = document.body.style.pointerEvents;
      document.body.style.pointerEvents = "none";
    }
    getOverlayInstances().forEach((el) => {
      if (el !== this) {
        el.$.overlay.style.pointerEvents = "none";
      }
    });
  }
  /** @protected */
  _exitModalState() {
    if (this._previousDocumentPointerEvents !== void 0) {
      document.body.style.pointerEvents = this._previousDocumentPointerEvents;
      delete this._previousDocumentPointerEvents;
    }
    const instances2 = getOverlayInstances();
    let el;
    while (el = instances2.pop()) {
      if (el === this) {
        continue;
      }
      el.$.overlay.style.removeProperty("pointer-events");
      if (!el.modeless) {
        break;
      }
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const OverlayMixin = (superClass) => class OverlayMixin extends OverlayFocusMixin(OverlayStackMixin(superClass)) {
  static get properties() {
    return {
      /**
       * When true, the overlay is visible and attached to body.
       */
      opened: {
        type: Boolean,
        notify: true,
        observer: "_openedChanged",
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Owner element passed with renderer function
       * @type {HTMLElement}
       */
      owner: {
        type: Object,
        sync: true
      },
      /**
       * Object with properties that is passed to `renderer` function
       */
      model: {
        type: Object,
        sync: true
      },
      /**
       * Custom function for rendering the content of the overlay.
       * Receives three arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `owner` The host element of the renderer function.
       * - `model` The object with the properties related with rendering.
       * @type {OverlayRenderer | null | undefined}
       */
      renderer: {
        type: Object,
        sync: true
      },
      /**
       * When true the overlay won't disable the main content, showing
       * it doesn't change the functionality of the user interface.
       * @type {boolean}
       */
      modeless: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_modelessChanged",
        sync: true
      },
      /**
       * When set to true, the overlay is hidden. This also closes the overlay
       * immediately in case there is a closing animation in progress.
       * @type {boolean}
       */
      hidden: {
        type: Boolean,
        reflectToAttribute: true,
        observer: "_hiddenChanged",
        sync: true
      },
      /**
       * When true the overlay has backdrop on top of content when opened.
       * @type {boolean}
       */
      withBackdrop: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      }
    };
  }
  static get observers() {
    return ["_rendererOrDataChanged(renderer, owner, model, opened)"];
  }
  constructor() {
    super();
    this._boundMouseDownListener = this._mouseDownListener.bind(this);
    this._boundMouseUpListener = this._mouseUpListener.bind(this);
    this._boundOutsideClickListener = this._outsideClickListener.bind(this);
    this._boundKeydownListener = this._keydownListener.bind(this);
    if (isIOS) {
      this._boundIosResizeListener = () => this._detectIosNavbar();
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("click", () => {
    });
    this.$.backdrop.addEventListener("click", () => {
    });
    this.addEventListener("mouseup", () => {
      if (document.activeElement === document.body && this.$.overlay.getAttribute("tabindex") === "0") {
        this.$.overlay.focus();
      }
    });
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this._boundIosResizeListener) {
      this._detectIosNavbar();
      window.addEventListener("resize", this._boundIosResizeListener);
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this._boundIosResizeListener) {
      window.removeEventListener("resize", this._boundIosResizeListener);
    }
  }
  /**
   * Requests an update for the content of the overlay.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (this.renderer) {
      this.renderer.call(this.owner, this, this.owner, this.model);
    }
  }
  /**
   * @param {Event=} sourceEvent
   */
  close(sourceEvent) {
    const evt = new CustomEvent("vaadin-overlay-close", {
      bubbles: true,
      cancelable: true,
      detail: { sourceEvent }
    });
    this.dispatchEvent(evt);
    if (!evt.defaultPrevented) {
      this.opened = false;
    }
  }
  /** @private */
  _detectIosNavbar() {
    if (!this.opened) {
      return;
    }
    const innerHeight = window.innerHeight;
    const innerWidth = window.innerWidth;
    const landscape = innerWidth > innerHeight;
    const clientHeight = document.documentElement.clientHeight;
    if (landscape && clientHeight > innerHeight) {
      this.style.setProperty("--vaadin-overlay-viewport-bottom", `${clientHeight - innerHeight}px`);
    } else {
      this.style.setProperty("--vaadin-overlay-viewport-bottom", "0");
    }
  }
  /** @private */
  _addGlobalListeners() {
    document.addEventListener("mousedown", this._boundMouseDownListener);
    document.addEventListener("mouseup", this._boundMouseUpListener);
    document.documentElement.addEventListener("click", this._boundOutsideClickListener, true);
  }
  /** @private */
  _removeGlobalListeners() {
    document.removeEventListener("mousedown", this._boundMouseDownListener);
    document.removeEventListener("mouseup", this._boundMouseUpListener);
    document.documentElement.removeEventListener("click", this._boundOutsideClickListener, true);
  }
  /** @private */
  _rendererOrDataChanged(renderer, owner, model, opened) {
    const ownerOrModelChanged = this._oldOwner !== owner || this._oldModel !== model;
    this._oldModel = model;
    this._oldOwner = owner;
    const rendererChanged = this._oldRenderer !== renderer;
    const hasOldRenderer = this._oldRenderer !== void 0;
    this._oldRenderer = renderer;
    const openedChanged = this._oldOpened !== opened;
    this._oldOpened = opened;
    if (rendererChanged && hasOldRenderer) {
      this.innerHTML = "";
      delete this._$litPart$;
    }
    if (opened && renderer && (rendererChanged || openedChanged || ownerOrModelChanged)) {
      this.requestContentUpdate();
    }
  }
  /** @private */
  _modelessChanged(modeless) {
    if (!modeless) {
      if (this.opened) {
        this._addGlobalListeners();
        this._enterModalState();
      }
    } else {
      this._removeGlobalListeners();
      this._exitModalState();
    }
  }
  /** @private */
  _openedChanged(opened, wasOpened) {
    if (opened) {
      this._saveFocus();
      this._animatedOpening();
      afterNextRender(this, () => {
        this._trapFocus();
        const evt = new CustomEvent("vaadin-overlay-open", { bubbles: true });
        this.dispatchEvent(evt);
      });
      document.addEventListener("keydown", this._boundKeydownListener);
      if (!this.modeless) {
        this._addGlobalListeners();
      }
    } else if (wasOpened) {
      this._resetFocus();
      this._animatedClosing();
      document.removeEventListener("keydown", this._boundKeydownListener);
      if (!this.modeless) {
        this._removeGlobalListeners();
      }
    }
  }
  /** @private */
  _hiddenChanged(hidden) {
    if (hidden && this.hasAttribute("closing")) {
      this._flushAnimation("closing");
    }
  }
  /**
   * @return {boolean}
   * @private
   */
  _shouldAnimate() {
    const style = getComputedStyle(this);
    const name = style.getPropertyValue("animation-name");
    const hidden = style.getPropertyValue("display") === "none";
    return !hidden && name && name !== "none";
  }
  /**
   * @param {string} type
   * @param {Function} callback
   * @private
   */
  _enqueueAnimation(type, callback) {
    const handler = `__${type}Handler`;
    const listener = (event) => {
      if (event && event.target !== this) {
        return;
      }
      callback();
      this.removeEventListener("animationend", listener);
      delete this[handler];
    };
    this[handler] = listener;
    this.addEventListener("animationend", listener);
  }
  /**
   * @param {string} type
   * @protected
   */
  _flushAnimation(type) {
    const handler = `__${type}Handler`;
    if (typeof this[handler] === "function") {
      this[handler]();
    }
  }
  /** @private */
  _animatedOpening() {
    if (this.parentNode === document.body && this.hasAttribute("closing")) {
      this._flushAnimation("closing");
    }
    this._attachOverlay();
    if (!this.modeless) {
      this._enterModalState();
    }
    this.setAttribute("opening", "");
    if (this._shouldAnimate()) {
      this._enqueueAnimation("opening", () => {
        this._finishOpening();
      });
    } else {
      this._finishOpening();
    }
  }
  /** @private */
  _attachOverlay() {
    this._placeholder = document.createComment("vaadin-overlay-placeholder");
    this.parentNode.insertBefore(this._placeholder, this);
    document.body.appendChild(this);
    this.bringToFront();
  }
  /** @private */
  _finishOpening() {
    this.removeAttribute("opening");
  }
  /** @private */
  _finishClosing() {
    this._detachOverlay();
    this.$.overlay.style.removeProperty("pointer-events");
    this.removeAttribute("closing");
    this.dispatchEvent(new CustomEvent("vaadin-overlay-closed"));
  }
  /** @private */
  _animatedClosing() {
    if (this.hasAttribute("opening")) {
      this._flushAnimation("opening");
    }
    if (this._placeholder) {
      this._exitModalState();
      this.setAttribute("closing", "");
      this.dispatchEvent(new CustomEvent("vaadin-overlay-closing"));
      if (this._shouldAnimate()) {
        this._enqueueAnimation("closing", () => {
          this._finishClosing();
        });
      } else {
        this._finishClosing();
      }
    }
  }
  /** @private */
  _detachOverlay() {
    this._placeholder.parentNode.insertBefore(this, this._placeholder);
    this._placeholder.parentNode.removeChild(this._placeholder);
  }
  /** @private */
  _mouseDownListener(event) {
    this._mouseDownInside = event.composedPath().indexOf(this.$.overlay) >= 0;
  }
  /** @private */
  _mouseUpListener(event) {
    this._mouseUpInside = event.composedPath().indexOf(this.$.overlay) >= 0;
  }
  /**
   * Whether to close the overlay on outside click or not.
   * Override this method to customize the closing logic.
   *
   * @param {Event} _event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(_event) {
    return this._last;
  }
  /**
   * Outside click listener used in capture phase to close the overlay before
   * propagating the event to the listener on the element that triggered it.
   * Otherwise, calling `open()` would result in closing and re-opening.
   *
   * @private
   */
  _outsideClickListener(event) {
    if (event.composedPath().includes(this.$.overlay) || this._mouseDownInside || this._mouseUpInside) {
      this._mouseDownInside = false;
      this._mouseUpInside = false;
      return;
    }
    if (!this._shouldCloseOnOutsideClick(event)) {
      return;
    }
    const evt = new CustomEvent("vaadin-overlay-outside-click", {
      bubbles: true,
      cancelable: true,
      detail: { sourceEvent: event }
    });
    this.dispatchEvent(evt);
    if (this.opened && !evt.defaultPrevented) {
      this.close(event);
    }
  }
  /**
   * Listener used to close whe overlay on Escape press, if it is the last one.
   * @private
   */
  _keydownListener(event) {
    if (!this._last) {
      return;
    }
    if (this.modeless && !event.composedPath().includes(this.$.overlay)) {
      return;
    }
    if (event.key === "Escape") {
      const evt = new CustomEvent("vaadin-overlay-escape-press", {
        bubbles: true,
        cancelable: true,
        detail: { sourceEvent: event }
      });
      this.dispatchEvent(evt);
      if (this.opened && !evt.defaultPrevented) {
        this.close(event);
      }
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function getAncestorRootNodes(node) {
  const result = [];
  while (node) {
    if (node.nodeType === Node.DOCUMENT_NODE) {
      result.push(node);
      break;
    }
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      result.push(node);
      node = node.host;
      continue;
    }
    if (node.assignedSlot) {
      node = node.assignedSlot;
      continue;
    }
    node = node.parentNode;
  }
  return result;
}
function getFlattenedElements(node) {
  const result = [];
  let elements;
  if (node.localName === "slot") {
    elements = node.assignedElements();
  } else {
    result.push(node);
    elements = [...node.children];
  }
  elements.forEach((elem) => result.push(...getFlattenedElements(elem)));
  return result;
}
function getClosestElement(selector, node) {
  if (!node) {
    return null;
  }
  return node.closest(selector) || getClosestElement(selector, node.getRootNode().host);
}
function deserializeAttributeValue(value) {
  if (!value) {
    return /* @__PURE__ */ new Set();
  }
  return new Set(value.split(" "));
}
function serializeAttributeValue(values) {
  return values ? [...values].join(" ") : "";
}
function addValueToAttribute(element, attr, value) {
  const values = deserializeAttributeValue(element.getAttribute(attr));
  values.add(value);
  element.setAttribute(attr, serializeAttributeValue(values));
}
function removeValueFromAttribute(element, attr, value) {
  const values = deserializeAttributeValue(element.getAttribute(attr));
  values.delete(value);
  if (values.size === 0) {
    element.removeAttribute(attr);
    return;
  }
  element.setAttribute(attr, serializeAttributeValue(values));
}
function isEmptyTextNode(node) {
  return node.nodeType === Node.TEXT_NODE && node.textContent.trim() === "";
}
/**
 * @license
 * Copyright (c) 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function observeMove(element, callback) {
  let io = null;
  const root2 = document.documentElement;
  function cleanup() {
    io && io.disconnect();
    io = null;
  }
  function refresh(skip = false, threshold = 1) {
    cleanup();
    const { left, top, width, height } = element.getBoundingClientRect();
    if (!skip) {
      callback();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = Math.floor(top);
    const insetRight = Math.floor(root2.clientWidth - (left + width));
    const insetBottom = Math.floor(root2.clientHeight - (top + height));
    const insetLeft = Math.floor(left);
    const rootMargin = `${-insetTop}px ${-insetRight}px ${-insetBottom}px ${-insetLeft}px`;
    const options = {
      rootMargin,
      threshold: Math.max(0, Math.min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      let ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (ratio === 0) {
          ratio = 1e-7;
        }
        refresh(false, ratio);
      }
      isFirstUpdate = false;
    }
    io = new IntersectionObserver(handleObserve, options);
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const PROP_NAMES_VERTICAL = {
  start: "top",
  end: "bottom"
};
const PROP_NAMES_HORIZONTAL = {
  start: "left",
  end: "right"
};
const targetResizeObserver = new ResizeObserver((entries) => {
  setTimeout(() => {
    entries.forEach((entry) => {
      if (entry.target.__overlay) {
        entry.target.__overlay._updatePosition();
      }
    });
  });
});
const PositionMixin = (superClass) => class PositionMixin extends superClass {
  static get properties() {
    return {
      /**
       * The element next to which this overlay should be aligned.
       * The position of the overlay relative to the positionTarget can be adjusted
       * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`
       * and `noVerticalOverlap`.
       */
      positionTarget: {
        type: Object,
        value: null,
        sync: true
      },
      /**
       * When `positionTarget` is set, this property defines whether to align the overlay's
       * left or right side to the target element by default.
       * Possible values are `start` and `end`.
       * RTL is taken into account when interpreting the value.
       * The overlay is automatically flipped to the opposite side when it doesn't fit into
       * the default side defined by this property.
       *
       * @attr {start|end} horizontal-align
       */
      horizontalAlign: {
        type: String,
        value: "start",
        sync: true
      },
      /**
       * When `positionTarget` is set, this property defines whether to align the overlay's
       * top or bottom side to the target element by default.
       * Possible values are `top` and `bottom`.
       * The overlay is automatically flipped to the opposite side when it doesn't fit into
       * the default side defined by this property.
       *
       * @attr {top|bottom} vertical-align
       */
      verticalAlign: {
        type: String,
        value: "top",
        sync: true
      },
      /**
       * When `positionTarget` is set, this property defines whether the overlay should overlap
       * the target element in the x-axis, or be positioned right next to it.
       *
       * @attr {boolean} no-horizontal-overlap
       */
      noHorizontalOverlap: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * When `positionTarget` is set, this property defines whether the overlay should overlap
       * the target element in the y-axis, or be positioned right above/below it.
       *
       * @attr {boolean} no-vertical-overlap
       */
      noVerticalOverlap: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * If the overlay content has no intrinsic height, this property can be used to set
       * the minimum vertical space (in pixels) required by the overlay. Setting a value to
       * the property effectively disables the content measurement in favor of using this
       * fixed value for determining the open direction.
       *
       * @attr {number} required-vertical-space
       */
      requiredVerticalSpace: {
        type: Number,
        value: 0,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "__positionSettingsChanged(horizontalAlign, verticalAlign, noHorizontalOverlap, noVerticalOverlap, requiredVerticalSpace)",
      "__overlayOpenedChanged(opened, positionTarget)"
    ];
  }
  constructor() {
    super();
    this.__onScroll = this.__onScroll.bind(this);
    this._updatePosition = this._updatePosition.bind(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this.opened) {
      this.__addUpdatePositionEventListeners();
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__removeUpdatePositionEventListeners();
  }
  /** @private */
  __addUpdatePositionEventListeners() {
    window.visualViewport.addEventListener("resize", this._updatePosition);
    window.visualViewport.addEventListener("scroll", this.__onScroll, true);
    this.__positionTargetAncestorRootNodes = getAncestorRootNodes(this.positionTarget);
    this.__positionTargetAncestorRootNodes.forEach((node) => {
      node.addEventListener("scroll", this.__onScroll, true);
    });
    if (this.positionTarget) {
      this.__observePositionTargetMove = observeMove(this.positionTarget, () => {
        this._updatePosition();
      });
    }
  }
  /** @private */
  __removeUpdatePositionEventListeners() {
    window.visualViewport.removeEventListener("resize", this._updatePosition);
    window.visualViewport.removeEventListener("scroll", this.__onScroll, true);
    if (this.__positionTargetAncestorRootNodes) {
      this.__positionTargetAncestorRootNodes.forEach((node) => {
        node.removeEventListener("scroll", this.__onScroll, true);
      });
      this.__positionTargetAncestorRootNodes = null;
    }
    if (this.__observePositionTargetMove) {
      this.__observePositionTargetMove();
      this.__observePositionTargetMove = null;
    }
  }
  /** @private */
  __overlayOpenedChanged(opened, positionTarget) {
    this.__removeUpdatePositionEventListeners();
    if (positionTarget) {
      positionTarget.__overlay = null;
      targetResizeObserver.unobserve(positionTarget);
      if (opened) {
        this.__addUpdatePositionEventListeners();
        positionTarget.__overlay = this;
        targetResizeObserver.observe(positionTarget);
      }
    }
    if (opened) {
      const computedStyle = getComputedStyle(this);
      if (!this.__margins) {
        this.__margins = {};
        ["top", "bottom", "left", "right"].forEach((propName) => {
          this.__margins[propName] = parseInt(computedStyle[propName], 10);
        });
      }
      this._updatePosition();
      requestAnimationFrame(() => this._updatePosition());
    }
  }
  __positionSettingsChanged() {
    this._updatePosition();
  }
  /** @private */
  __onScroll(e2) {
    if (e2.target instanceof Node && this.contains(e2.target)) {
      return;
    }
    this._updatePosition();
  }
  _updatePosition() {
    if (!this.positionTarget || !this.opened || !this.__margins) {
      return;
    }
    const targetRect = this.positionTarget.getBoundingClientRect();
    if (targetRect.width === 0 && targetRect.height === 0 && this.opened) {
      this.opened = false;
      return;
    }
    const shouldAlignStartVertically = this.__shouldAlignStartVertically(targetRect);
    this.style.justifyContent = shouldAlignStartVertically ? "flex-start" : "flex-end";
    const isRTL = this.__isRTL;
    const shouldAlignStartHorizontally = this.__shouldAlignStartHorizontally(targetRect, isRTL);
    const flexStart = !isRTL && shouldAlignStartHorizontally || isRTL && !shouldAlignStartHorizontally;
    this.style.alignItems = flexStart ? "flex-start" : "flex-end";
    const overlayRect = this.getBoundingClientRect();
    const verticalProps = this.__calculatePositionInOneDimension(
      targetRect,
      overlayRect,
      this.noVerticalOverlap,
      PROP_NAMES_VERTICAL,
      this,
      shouldAlignStartVertically
    );
    const horizontalProps = this.__calculatePositionInOneDimension(
      targetRect,
      overlayRect,
      this.noHorizontalOverlap,
      PROP_NAMES_HORIZONTAL,
      this,
      shouldAlignStartHorizontally
    );
    Object.assign(this.style, verticalProps, horizontalProps);
    this.toggleAttribute("bottom-aligned", !shouldAlignStartVertically);
    this.toggleAttribute("top-aligned", shouldAlignStartVertically);
    this.toggleAttribute("end-aligned", !flexStart);
    this.toggleAttribute("start-aligned", flexStart);
  }
  __shouldAlignStartHorizontally(targetRect, rtl) {
    const contentWidth = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);
    this.__oldContentWidth = this.$.overlay.offsetWidth;
    const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);
    const defaultAlignLeft = !rtl && this.horizontalAlign === "start" || rtl && this.horizontalAlign === "end";
    return this.__shouldAlignStart(
      targetRect,
      contentWidth,
      viewportWidth,
      this.__margins,
      defaultAlignLeft,
      this.noHorizontalOverlap,
      PROP_NAMES_HORIZONTAL
    );
  }
  __shouldAlignStartVertically(targetRect) {
    const contentHeight = this.requiredVerticalSpace || Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);
    this.__oldContentHeight = this.$.overlay.offsetHeight;
    const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);
    const defaultAlignTop = this.verticalAlign === "top";
    return this.__shouldAlignStart(
      targetRect,
      contentHeight,
      viewportHeight,
      this.__margins,
      defaultAlignTop,
      this.noVerticalOverlap,
      PROP_NAMES_VERTICAL
    );
  }
  // eslint-disable-next-line @typescript-eslint/max-params
  __shouldAlignStart(targetRect, contentSize, viewportSize, margins, defaultAlignStart, noOverlap, propNames) {
    const spaceForStartAlignment = viewportSize - targetRect[noOverlap ? propNames.end : propNames.start] - margins[propNames.end];
    const spaceForEndAlignment = targetRect[noOverlap ? propNames.start : propNames.end] - margins[propNames.start];
    const spaceForDefaultAlignment = defaultAlignStart ? spaceForStartAlignment : spaceForEndAlignment;
    const spaceForOtherAlignment = defaultAlignStart ? spaceForEndAlignment : spaceForStartAlignment;
    const shouldGoToDefaultSide = spaceForDefaultAlignment > spaceForOtherAlignment || spaceForDefaultAlignment > contentSize;
    return defaultAlignStart === shouldGoToDefaultSide;
  }
  /**
   * Returns an adjusted value after resizing the browser window,
   * to avoid wrong calculations when e.g. previously set `bottom`
   * CSS property value is larger than the updated viewport height.
   * See https://github.com/vaadin/web-components/issues/4604
   */
  __adjustBottomProperty(cssPropNameToSet, propNames, currentValue) {
    let adjustedProp;
    if (cssPropNameToSet === propNames.end) {
      if (propNames.end === PROP_NAMES_VERTICAL.end) {
        const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);
        if (currentValue > viewportHeight && this.__oldViewportHeight) {
          const heightDiff = this.__oldViewportHeight - viewportHeight;
          adjustedProp = currentValue - heightDiff;
        }
        this.__oldViewportHeight = viewportHeight;
      }
      if (propNames.end === PROP_NAMES_HORIZONTAL.end) {
        const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);
        if (currentValue > viewportWidth && this.__oldViewportWidth) {
          const widthDiff = this.__oldViewportWidth - viewportWidth;
          adjustedProp = currentValue - widthDiff;
        }
        this.__oldViewportWidth = viewportWidth;
      }
    }
    return adjustedProp;
  }
  /**
   * Returns an object with CSS position properties to set,
   * e.g. { top: "100px" }
   */
  // eslint-disable-next-line @typescript-eslint/max-params
  __calculatePositionInOneDimension(targetRect, overlayRect, noOverlap, propNames, overlay2, shouldAlignStart) {
    const cssPropNameToSet = shouldAlignStart ? propNames.start : propNames.end;
    const cssPropNameToClear = shouldAlignStart ? propNames.end : propNames.start;
    const currentValue = parseFloat(overlay2.style[cssPropNameToSet] || getComputedStyle(overlay2)[cssPropNameToSet]);
    const adjustedValue = this.__adjustBottomProperty(cssPropNameToSet, propNames, currentValue);
    const diff = overlayRect[shouldAlignStart ? propNames.start : propNames.end] - targetRect[noOverlap === shouldAlignStart ? propNames.end : propNames.start];
    const valueToSet = adjustedValue ? `${adjustedValue}px` : `${currentValue + diff * (shouldAlignStart ? -1 : 1)}px`;
    return {
      [cssPropNameToSet]: valueToSet,
      [cssPropNameToClear]: ""
    };
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const overlayStyles = css`
  :host {
    z-index: 200;
    position: fixed;

    /* Despite of what the names say, <vaadin-overlay> is just a container
          for position/sizing/alignment. The actual overlay is the overlay part. */

    /* Default position constraints: the entire viewport. Note: themes can
          override this to introduce gaps between the overlay and the viewport. */
    inset: 0;
    bottom: var(--vaadin-overlay-viewport-bottom);

    /* Use flexbox alignment for the overlay part. */
    display: flex;
    flex-direction: column; /* makes dropdowns sizing easier */
    /* Align to center by default. */
    align-items: center;
    justify-content: center;

    /* Allow centering when max-width/max-height applies. */
    margin: auto;

    /* The host is not clickable, only the overlay part is. */
    pointer-events: none;

    /* Remove tap highlight on touch devices. */
    -webkit-tap-highlight-color: transparent;

    /* CSS API for host */
    --vaadin-overlay-viewport-bottom: 0;
  }

  :host([hidden]),
  :host(:not([opened]):not([closing])),
  :host(:not([opened]):not([closing])) [part='overlay'] {
    display: none !important;
  }

  [part='overlay'] {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
    pointer-events: auto;

    /* Prevent overflowing the host */
    max-width: 100%;
    box-sizing: border-box;

    -webkit-tap-highlight-color: initial; /* reenable tap highlight inside */
  }

  [part='backdrop'] {
    z-index: -1;
    content: '';
    background: rgba(0, 0, 0, 0.5);
    position: fixed;
    inset: 0;
    pointer-events: auto;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const userTagsOverlayStyles = css`
  :host {
    background: transparent;
    box-shadow: none;
  }

  [part='overlay'] {
    box-shadow: none;
    background: transparent;
    position: relative;
    left: -4px;
    padding: 4px;
    outline: none;
    overflow: visible;
  }

  ::slotted([part='tags']) {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
  }

  :host([dir='rtl']) [part='overlay'] {
    left: auto;
    right: -4px;
  }

  [part='content'] {
    padding: 0;
  }

  :host([opening]),
  :host([closing]) {
    animation: 0.14s user-tags-overlay-dummy-animation;
  }

  @keyframes user-tags-overlay-dummy-animation {
    0% {
      opacity: 1;
    }

    100% {
      opacity: 1;
    }
  }
`;
registerStyles$1("vaadin-user-tags-overlay", [overlayStyles, userTagsOverlayStyles]);
class UserTagsOverlay extends PositionMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-user-tags-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
}
defineCustomElement(UserTagsOverlay);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function newSplice(index, removed, addedCount) {
  return {
    index,
    removed,
    addedCount
  };
}
const EDIT_LEAVE = 0;
const EDIT_UPDATE = 1;
const EDIT_ADD = 2;
const EDIT_DELETE = 3;
function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  let rowCount = oldEnd - oldStart + 1;
  let columnCount = currentEnd - currentStart + 1;
  let distances = new Array(rowCount);
  for (let i2 = 0; i2 < rowCount; i2++) {
    distances[i2] = new Array(columnCount);
    distances[i2][0] = i2;
  }
  for (let j = 0; j < columnCount; j++)
    distances[0][j] = j;
  for (let i2 = 1; i2 < rowCount; i2++) {
    for (let j = 1; j < columnCount; j++) {
      if (equals(current[currentStart + j - 1], old[oldStart + i2 - 1]))
        distances[i2][j] = distances[i2 - 1][j - 1];
      else {
        let north = distances[i2 - 1][j] + 1;
        let west = distances[i2][j - 1] + 1;
        distances[i2][j] = north < west ? north : west;
      }
    }
  }
  return distances;
}
function spliceOperationsFromEditDistances(distances) {
  let i2 = distances.length - 1;
  let j = distances[0].length - 1;
  let current = distances[i2][j];
  let edits = [];
  while (i2 > 0 || j > 0) {
    if (i2 == 0) {
      edits.push(EDIT_ADD);
      j--;
      continue;
    }
    if (j == 0) {
      edits.push(EDIT_DELETE);
      i2--;
      continue;
    }
    let northWest = distances[i2 - 1][j - 1];
    let west = distances[i2 - 1][j];
    let north = distances[i2][j - 1];
    let min;
    if (west < north)
      min = west < northWest ? west : northWest;
    else
      min = north < northWest ? north : northWest;
    if (min == northWest) {
      if (northWest == current) {
        edits.push(EDIT_LEAVE);
      } else {
        edits.push(EDIT_UPDATE);
        current = northWest;
      }
      i2--;
      j--;
    } else if (min == west) {
      edits.push(EDIT_DELETE);
      i2--;
      current = west;
    } else {
      edits.push(EDIT_ADD);
      j--;
      current = north;
    }
  }
  edits.reverse();
  return edits;
}
function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  let prefixCount = 0;
  let suffixCount = 0;
  let splice;
  let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
  if (currentStart == 0 && oldStart == 0)
    prefixCount = sharedPrefix(current, old, minLength);
  if (currentEnd == current.length && oldEnd == old.length)
    suffixCount = sharedSuffix(current, old, minLength - prefixCount);
  currentStart += prefixCount;
  oldStart += prefixCount;
  currentEnd -= suffixCount;
  oldEnd -= suffixCount;
  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
    return [];
  if (currentStart == currentEnd) {
    splice = newSplice(currentStart, [], 0);
    while (oldStart < oldEnd)
      splice.removed.push(old[oldStart++]);
    return [splice];
  } else if (oldStart == oldEnd)
    return [newSplice(currentStart, [], currentEnd - currentStart)];
  let ops = spliceOperationsFromEditDistances(
    calcEditDistances(
      current,
      currentStart,
      currentEnd,
      old,
      oldStart,
      oldEnd
    )
  );
  splice = void 0;
  let splices = [];
  let index = currentStart;
  let oldIndex = oldStart;
  for (let i2 = 0; i2 < ops.length; i2++) {
    switch (ops[i2]) {
      case EDIT_LEAVE:
        if (splice) {
          splices.push(splice);
          splice = void 0;
        }
        index++;
        oldIndex++;
        break;
      case EDIT_UPDATE:
        if (!splice)
          splice = newSplice(index, [], 0);
        splice.addedCount++;
        index++;
        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
      case EDIT_ADD:
        if (!splice)
          splice = newSplice(index, [], 0);
        splice.addedCount++;
        index++;
        break;
      case EDIT_DELETE:
        if (!splice)
          splice = newSplice(index, [], 0);
        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
    }
  }
  if (splice) {
    splices.push(splice);
  }
  return splices;
}
function sharedPrefix(current, old, searchLength) {
  for (let i2 = 0; i2 < searchLength; i2++)
    if (!equals(current[i2], old[i2]))
      return i2;
  return searchLength;
}
function sharedSuffix(current, old, searchLength) {
  let index1 = current.length;
  let index2 = old.length;
  let count = 0;
  while (count < searchLength && equals(current[--index1], old[--index2]))
    count++;
  return count;
}
function calculateSplices(current, previous) {
  return calcSplices(
    current,
    0,
    current.length,
    previous,
    0,
    previous.length
  );
}
function equals(currentValue, previousValue) {
  return currentValue === previousValue;
}
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
let microtaskCurrHandle = 0;
let microtaskLastHandle = 0;
const microtaskCallbacks = [];
let microtaskScheduled = false;
function microtaskFlush() {
  microtaskScheduled = false;
  const len = microtaskCallbacks.length;
  for (let i2 = 0; i2 < len; i2++) {
    const cb = microtaskCallbacks[i2];
    if (cb) {
      try {
        cb();
      } catch (e2) {
        setTimeout(() => {
          throw e2;
        });
      }
    }
  }
  microtaskCallbacks.splice(0, len);
  microtaskLastHandle += len;
}
const timeOut = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof timeOut
   * @param {number=} delay Time to wait before calling callbacks in ms
   * @return {!AsyncInterface} An async timeout interface
   */
  after(delay) {
    return {
      run(fn) {
        return window.setTimeout(fn, delay);
      },
      cancel(handle) {
        window.clearTimeout(handle);
      }
    };
  },
  /**
   * Enqueues a function called in the next task.
   *
   * @memberof timeOut
   * @param {!Function} fn Callback to run
   * @param {number=} delay Delay in milliseconds
   * @return {number} Handle used for canceling task
   */
  run(fn, delay) {
    return window.setTimeout(fn, delay);
  },
  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    window.clearTimeout(handle);
  }
};
const animationFrame = {
  /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof animationFrame
   * @param {function(number):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(fn) {
    return window.requestAnimationFrame(fn);
  },
  /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof animationFrame
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    window.cancelAnimationFrame(handle);
  }
};
const idlePeriod = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof idlePeriod
   * @param {function(!IdleDeadline):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(fn) {
    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
  },
  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    if (window.cancelIdleCallback) {
      window.cancelIdleCallback(handle);
    } else {
      window.clearTimeout(handle);
    }
  }
};
const microTask = {
  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(callback) {
    if (!microtaskScheduled) {
      microtaskScheduled = true;
      queueMicrotask(() => microtaskFlush());
    }
    microtaskCallbacks.push(callback);
    const result = microtaskCurrHandle;
    microtaskCurrHandle += 1;
    return result;
  },
  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    const idx = handle - microtaskLastHandle;
    if (idx >= 0) {
      if (!microtaskCallbacks[idx]) {
        throw new Error(`invalid async handle: ${handle}`);
      }
      microtaskCallbacks[idx] = null;
    }
  }
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const debouncerQueue$1 = /* @__PURE__ */ new Set();
let Debouncer$1 = class Debouncer {
  /**
   * Creates a debouncer if no debouncer is passed as a parameter
   * or it cancels an active debouncer otherwise. The following
   * example shows how a debouncer can be called multiple times within a
   * microtask and "debounced" such that the provided callback function is
   * called once. Add this method to a custom element:
   *
   * ```js
   * import {microTask} from '@vaadin/component-base/src/async.js';
   * import {Debouncer} from '@vaadin/component-base/src/debounce.js';
   * // ...
   *
   * _debounceWork() {
   *   this._debounceJob = Debouncer.debounce(this._debounceJob,
   *       microTask, () => this._doWork());
   * }
   * ```
   *
   * If the `_debounceWork` method is called multiple times within the same
   * microtask, the `_doWork` function will be called only once at the next
   * microtask checkpoint.
   *
   * Note: In testing it is often convenient to avoid asynchrony. To accomplish
   * this with a debouncer, you can use `enqueueDebouncer` and
   * `flush`. For example, extend the above example by adding
   * `enqueueDebouncer(this._debounceJob)` at the end of the
   * `_debounceWork` method. Then in a test, call `flush` to ensure
   * the debouncer has completed.
   *
   * @param {Debouncer?} debouncer Debouncer object.
   * @param {!AsyncInterface} asyncModule Object with Async interface
   * @param {function()} callback Callback to run.
   * @return {!Debouncer} Returns a debouncer object.
   */
  static debounce(debouncer, asyncModule, callback) {
    if (debouncer instanceof Debouncer) {
      debouncer._cancelAsync();
    } else {
      debouncer = new Debouncer();
    }
    debouncer.setConfig(asyncModule, callback);
    return debouncer;
  }
  constructor() {
    this._asyncModule = null;
    this._callback = null;
    this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncInterface} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   * @return {void}
   */
  setConfig(asyncModule, callback) {
    this._asyncModule = asyncModule;
    this._callback = callback;
    this._timer = this._asyncModule.run(() => {
      this._timer = null;
      debouncerQueue$1.delete(this);
      this._callback();
    });
  }
  /**
   * Cancels an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  cancel() {
    if (this.isActive()) {
      this._cancelAsync();
      debouncerQueue$1.delete(this);
    }
  }
  /**
   * Cancels a debouncer's async callback.
   *
   * @return {void}
   */
  _cancelAsync() {
    if (this.isActive()) {
      this._asyncModule.cancel(
        /** @type {number} */
        this._timer
      );
      this._timer = null;
    }
  }
  /**
   * Flushes an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  flush() {
    if (this.isActive()) {
      this.cancel();
      this._callback();
    }
  }
  /**
   * Returns true if the debouncer is active.
   *
   * @return {boolean} True if active.
   */
  isActive() {
    return this._timer != null;
  }
};
function enqueueDebouncer$1(debouncer) {
  debouncerQueue$1.add(debouncer);
}
function flushDebouncers$1() {
  const didFlush = Boolean(debouncerQueue$1.size);
  debouncerQueue$1.forEach((debouncer) => {
    try {
      debouncer.flush();
    } catch (e2) {
      setTimeout(() => {
        throw e2;
      });
    }
  });
  return didFlush;
}
const flush$1 = () => {
  let debouncers;
  do {
    debouncers = flushDebouncers$1();
  } while (debouncers);
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const listenOnce = (elem, type) => {
  return new Promise((resolve) => {
    const listener = () => {
      elem.removeEventListener(type, listener);
      resolve();
    };
    elem.addEventListener(type, listener);
  });
};
class UserTags extends PolymerElement {
  static get is() {
    return "vaadin-user-tags";
  }
  static get template() {
    return html`
      <style>
        :host {
          position: absolute;
        }
      </style>
      <vaadin-user-tags-overlay
        id="overlay"
        modeless
        opened="[[opened]]"
        no-vertical-overlap
        on-vaadin-overlay-open="_onOverlayOpen"
      ></vaadin-user-tags-overlay>
    `;
  }
  static get properties() {
    return {
      /**
       * True when the field has focus. In this case, the overlay
       * with a list of the user tags needs to be always visible.
       */
      hasFocus: {
        type: Boolean,
        value: false,
        observer: "_hasFocusChanged"
      },
      /**
       * True when the overlay is opened.
       */
      opened: {
        type: Boolean,
        value: false
      },
      /**
       * True when the overlay is flashing: quickly shown and then hidden
       * once a different user starts to interact with the field.
       */
      flashing: {
        type: Boolean,
        value: false
      },
      /**
       * A target element that the overlay is positioned to.
       */
      target: {
        type: Object,
        observer: "__targetChanged"
      },
      /**
       * A list of users who focused the field.
       */
      users: {
        type: Array,
        value: () => []
      },
      duration: {
        type: Number,
        value: 200
      },
      delay: {
        type: Number,
        value: 2e3
      },
      /** @private */
      __flashQueue: {
        type: Array,
        value: () => []
      },
      /** @private */
      __isTargetVisible: {
        type: Boolean,
        value: false
      }
    };
  }
  constructor() {
    super();
    this.__targetVisibilityObserver = new IntersectionObserver(
      ([entry]) => {
        this.__onTargetVisibilityChange(entry.isIntersecting);
      },
      { threshold: 1 }
    );
  }
  /** @protected */
  get wrapper() {
    return this.$.overlay.querySelector('[part="tags"]');
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this.target) {
      this.__targetVisibilityObserver.observe(this.target);
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.opened = false;
    if (this.target) {
      this.__targetVisibilityObserver.unobserve(this.target);
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this.$.overlay.renderer = (root2) => {
      if (!root2.firstChild) {
        const tags = document.createElement("div");
        tags.setAttribute("part", "tags");
        root2.appendChild(tags);
      }
    };
    this.$.overlay.requestContentUpdate();
  }
  /** @private */
  __onTargetVisibilityChange(isVisible) {
    this.__isTargetVisible = isVisible;
    if (isVisible && this.__flashQueue.length > 0 && !this.flashing) {
      this.flashTags(this.__flashQueue.shift());
      return;
    }
    if (isVisible && this.hasFocus) {
      this.opened = true;
      return;
    }
    if (!isVisible && this.opened) {
      this.opened = false;
    }
  }
  /** @private */
  __targetChanged(newTarget, oldTarget) {
    this.$.overlay.positionTarget = newTarget;
    if (oldTarget) {
      this.__targetVisibilityObserver.unobserve(oldTarget);
    }
    if (newTarget) {
      this.__targetVisibilityObserver.observe(newTarget);
    }
  }
  /** @private */
  _hasFocusChanged(hasFocus) {
    if (hasFocus && this.flashing) {
      this.stopFlash();
    }
  }
  createUserTag(user) {
    const tag = document.createElement("vaadin-user-tag");
    tag.name = user.name;
    tag.uid = user.id;
    tag.colorIndex = user.colorIndex;
    return tag;
  }
  getTagForUser(user) {
    return Array.from(this.wrapper.children).find((tag) => tag.uid === user.id);
  }
  getChangedTags(addedUsers, removedUsers) {
    const removed = removedUsers.map((user) => this.getTagForUser(user));
    const added = addedUsers.map((user) => this.getTagForUser(user) || this.createUserTag(user));
    return { added, removed };
  }
  getChangedUsers(users, splices) {
    const usersToAdd = [];
    const usersToRemove = [];
    splices.forEach((splice) => {
      splice.removed.forEach((user) => {
        usersToRemove.push(user);
      });
      for (let i2 = splice.addedCount - 1; i2 >= 0; i2--) {
        usersToAdd.push(users[splice.index + i2]);
      }
    });
    const addedUsers = usersToAdd.filter((u2) => !usersToRemove.some((u22) => u2.id === u22.id));
    const removedUsers = usersToRemove.filter((u2) => !usersToAdd.some((u22) => u2.id === u22.id));
    return { addedUsers, removedUsers };
  }
  applyTagsStart({ added, removed }) {
    const wrapper = this.wrapper;
    removed.forEach((tag) => {
      if (tag) {
        tag.classList.add("removing");
        tag.classList.remove("show");
      }
    });
    added.forEach((tag) => wrapper.insertBefore(tag, wrapper.firstChild));
  }
  applyTagsEnd({ added, removed }) {
    const wrapper = this.wrapper;
    removed.forEach((tag) => {
      if (tag && tag.parentNode === wrapper) {
        wrapper.removeChild(tag);
      }
    });
    added.forEach((tag) => tag && tag.classList.add("show"));
  }
  setUsers(users) {
    this.requestContentUpdate();
    const splices = calculateSplices(users, this.users);
    if (splices.length === 0) {
      return;
    }
    const { addedUsers, removedUsers } = this.getChangedUsers(users, splices);
    if (addedUsers.length === 0 && removedUsers.length === 0) {
      return;
    }
    const changedTags = this.getChangedTags(addedUsers, removedUsers);
    if (this.__flashQueue.length > 0) {
      removedUsers.forEach((user, i2) => {
        if (changedTags.removed[i2] === null) {
          return;
        }
        this.__flashQueue.forEach((tags) => {
          if (tags.some((tag) => tag.uid === user.id)) {
            this.splice("__flashQueue", i2, 1);
          }
        });
      });
    }
    if (this.opened && this.hasFocus) {
      this.updateTags(users, changedTags);
    } else if (addedUsers.length > 0 && document.visibilityState !== "hidden") {
      const addedTags = changedTags.added;
      const removedTags = changedTags.removed;
      this.updateTagsSync(users, {
        added: [],
        removed: removedTags
      });
      if (this.flashing || !this.__isTargetVisible) {
        this.push("__flashQueue", addedTags);
      } else {
        this.flashTags(addedTags);
      }
    } else {
      this.updateTagsSync(users, changedTags);
    }
  }
  /** @private */
  _onOverlayOpen() {
    Array.from(this.wrapper.children).forEach((tag) => {
      if (!tag.classList.contains("removing")) {
        tag.classList.add("show");
      }
    });
  }
  flashTags(added) {
    this.flashing = true;
    const wrapper = this.wrapper;
    const hidden = Array.from(wrapper.children);
    hidden.forEach((tag) => {
      tag.style.display = "none";
    });
    added.forEach((tag) => {
      wrapper.insertBefore(tag, wrapper.firstChild);
    });
    this.flashPromise = new Promise((resolve) => {
      listenOnce(this.$.overlay, "vaadin-overlay-open").then(() => {
        this._debounceFlashStart = Debouncer$1.debounce(
          this._debounceFlashStart,
          timeOut.after(this.duration + this.delay),
          () => {
            if (!this.hasFocus) {
              added.forEach((tag) => tag.classList.remove("show"));
            }
            this._debounceFlashEnd = Debouncer$1.debounce(this._debounceFlashEnd, timeOut.after(this.duration), () => {
              const finishFlash = () => {
                hidden.forEach((tag) => {
                  tag.style.display = "block";
                });
                this.flashing = false;
                resolve();
              };
              if (this.hasFocus) {
                finishFlash();
              } else {
                listenOnce(this.$.overlay, "animationend").then(() => {
                  finishFlash();
                });
                this.opened = false;
              }
            });
          }
        );
      });
    }).then(() => {
      if (this.__flashQueue.length > 0) {
        const tags = this.__flashQueue[0];
        this.splice("__flashQueue", 0, 1);
        this.flashTags(tags);
      }
    });
    this.opened = true;
  }
  stopFlash() {
    if (this._debounceFlashStart) {
      this._debounceFlashStart.flush();
    }
    if (this._debounceFlashEnd) {
      this._debounceFlashEnd.flush();
    }
    this.$.overlay._flushAnimation("closing");
  }
  updateTags(users, changed) {
    this.applyTagsStart(changed);
    this._debounceRender = Debouncer$1.debounce(this._debounceRender, timeOut.after(this.duration), () => {
      this.set("users", users);
      this.applyTagsEnd(changed);
      if (users.length === 0 && this.opened) {
        this.opened = false;
      }
    });
  }
  updateTagsSync(users, changed) {
    this.applyTagsStart(changed);
    this.set("users", users);
    this.applyTagsEnd(changed);
  }
  show() {
    this.hasFocus = true;
    if (this.__isTargetVisible) {
      this.opened = true;
    }
  }
  hide() {
    this.hasFocus = false;
    this.opened = false;
  }
  requestContentUpdate() {
    if (this._debounceRender && this._debounceRender.isActive()) {
      this._debounceRender.flush();
    }
  }
}
defineCustomElement(UserTags);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class FieldOutline extends ThemableMixin(DirMixin(PolymerElement)) {
  static get is() {
    return "vaadin-field-outline";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          box-sizing: border-box;
          position: absolute;
          inset: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          user-select: none;
          opacity: 0;
          --_active-user-color: transparent;
        }

        :host([has-active-user]) {
          opacity: 1;
        }
      </style>
    `;
  }
  static get properties() {
    return {
      /**
       * A user who last interacted with the field.
       */
      user: {
        type: Object,
        value: null,
        observer: "_userChanged"
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("part", "outline");
    this._field = this.getRootNode().host;
  }
  /** @private */
  _userChanged(user) {
    this.toggleAttribute("has-active-user", Boolean(user));
    const value = user ? `var(--vaadin-user-color-${user.colorIndex})` : "transparent";
    const prop = "--_active-user-color";
    this.style.setProperty(prop, value);
    if (this._field) {
      this._field.style.setProperty(prop, value);
    }
  }
}
defineCustomElement(FieldOutline);
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const region = document.createElement("div");
region.style.position = "fixed";
region.style.clip = "rect(0px, 0px, 0px, 0px)";
region.setAttribute("aria-live", "polite");
document.body.appendChild(region);
let alertDebouncer;
function announce(text, options = {}) {
  const mode = options.mode || "polite";
  const timeout = options.timeout === void 0 ? 150 : options.timeout;
  if (mode === "alert") {
    region.removeAttribute("aria-live");
    region.removeAttribute("role");
    alertDebouncer = Debouncer$1.debounce(alertDebouncer, animationFrame, () => {
      region.setAttribute("role", "alert");
    });
  } else {
    if (alertDebouncer) {
      alertDebouncer.cancel();
    }
    region.removeAttribute("role");
    region.setAttribute("aria-live", mode);
  }
  region.textContent = "";
  setTimeout(() => {
    region.textContent = text;
  }, timeout);
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const getOutlineTarget = (element, tagName) => {
  switch (tagName) {
    /* c8 ignore next */
    case "vaadin-big-decimal-field":
    case "vaadin-combo-box":
    case "vaadin-date-picker":
    case "vaadin-email-field":
    case "vaadin-integer-field":
    case "vaadin-number-field":
    case "vaadin-password-field":
    case "vaadin-select":
    case "vaadin-text-area":
    case "vaadin-text-field":
    case "vaadin-time-picker":
      return element.shadowRoot.querySelector('[part="input-field"]');
    /* c8 ignore next */
    case "vaadin-checkbox":
      return element.shadowRoot.querySelector('[part="checkbox"]');
    /* c8 ignore next */
    case "vaadin-radio-button":
      return element.shadowRoot.querySelector('[part="radio"]');
    /* c8 ignore next */
    default:
      return element;
  }
};
const fields = /* @__PURE__ */ new WeakMap();
const initOutline = (field) => {
  if (!fields.has(field)) {
    const tagName = field.tagName.toLowerCase();
    const target = getOutlineTarget(field, tagName);
    target.style.position = "relative";
    if (tagName.endsWith("text-area")) {
      target.style.overflow = "visible";
    }
    const style = document.createElement("style");
    style.textContent = `
      :host([active]) [part="outline"],
      :host([focus-ring]) [part="outline"] {
        display: none;
      }
    `;
    field.shadowRoot.appendChild(style);
    const outline = document.createElement("vaadin-field-outline");
    (target === field ? field.shadowRoot : target).appendChild(outline);
    outline.setAttribute("context", tagName);
    fields.set(field, { root: field, target, outline });
  }
  return fields.get(field);
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ComponentObserver {
  constructor(component) {
    this.component = component;
    this.initTags(component);
  }
  getFields() {
    return [this.component];
  }
  getFieldIndex(field) {
    return this.getFields().indexOf(field);
  }
  getFocusTarget(_event) {
    return this.component;
  }
  initTags(component) {
    const tags = document.createElement("vaadin-user-tags");
    component.shadowRoot.appendChild(tags);
    tags.target = component;
    this._tags = tags;
    component.addEventListener("mouseenter", (event) => {
      if (event.relatedTarget === this._tags.$.overlay) {
        return;
      }
      this._mouse = true;
      this._mouseDebouncer = Debouncer$1.debounce(this._mouseDebouncer, timeOut.after(200), () => {
        if (this._mouse) {
          this._tags.show();
        }
      });
    });
    component.addEventListener("mouseleave", (event) => {
      if (event.relatedTarget === this._tags.$.overlay) {
        return;
      }
      this._mouse = false;
      if (!this._hasFocus) {
        this._tags.hide();
      }
    });
    component.addEventListener("vaadin-highlight-show", (_event) => {
      this._hasFocus = true;
      if (this._debouncer && this._debouncer.isActive()) {
        this._debouncer.cancel();
      } else {
        this._tags.show();
      }
    });
    component.addEventListener("vaadin-highlight-hide", (_event) => {
      this._hasFocus = false;
      if (!this._mouse) {
        this._debouncer = Debouncer$1.debounce(this._debouncer, timeOut.after(1), () => {
          this._tags.hide();
        });
      }
    });
    this._tags.$.overlay.addEventListener("mouseleave", (event) => {
      if (event.relatedTarget === component) {
        return;
      }
      this._mouse = false;
      if (!component.hasAttribute("focused")) {
        this._tags.hide();
      }
    });
  }
  setOutlines(users) {
    const fields2 = this.getFields();
    fields2.forEach((field, idx) => {
      const { outline } = initOutline(field);
      const index = fields2.length === 1 ? 0 : users.map((user) => user.fieldIndex).indexOf(idx);
      outline.user = users[index];
    });
  }
  showOutline(field) {
    this.fire("show", field);
  }
  hideOutline(field) {
    this.fire("hide", field);
  }
  fire(action, field) {
    this.component.dispatchEvent(
      new CustomEvent(`vaadin-highlight-${action}`, {
        bubbles: true,
        composed: true,
        detail: { fieldIndex: this.getFieldIndex(field) }
      })
    );
  }
  redraw(users) {
    this._tags.setUsers(users);
    this.setOutlines(users);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class FieldObserver extends ComponentObserver {
  constructor(field) {
    super(field);
    this.addListeners(field);
  }
  addListeners(field) {
    field.addEventListener("focusin", (event) => this.onFocusIn(event));
    field.addEventListener("focusout", (event) => this.onFocusOut(event));
  }
  onFocusIn(event) {
    const target = this.getFocusTarget(event);
    this.showOutline(target);
  }
  onFocusOut(event) {
    const target = this.getFocusTarget(event);
    this.hideOutline(target);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class CheckboxGroupObserver extends FieldObserver {
  getFields() {
    return this.component.__checkboxes;
  }
  getFocusTarget(event) {
    const fields2 = this.getFields();
    return Array.from(event.composedPath()).find((node) => fields2.includes(node));
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class DatePickerObserver extends ComponentObserver {
  constructor(datePicker2) {
    super(datePicker2);
    this.datePicker = datePicker2;
    this.fullscreenFocus = false;
    this.blurWhileOpened = false;
    this.addListeners(datePicker2);
  }
  addListeners(datePicker2) {
    this.overlay = datePicker2.$.overlay;
    datePicker2.addEventListener("blur", (event) => this.onBlur(event), true);
    datePicker2.addEventListener("opened-changed", (event) => this.onOpenedChanged(event));
    this.overlay.addEventListener("focusout", (event) => this.onOverlayFocusOut(event));
    datePicker2.addEventListener("focusin", (event) => this.onFocusIn(event));
    datePicker2.addEventListener("focusout", (event) => this.onFocusOut(event));
  }
  isEventInOverlay(node) {
    return this.datePicker._overlayContent && this.datePicker._overlayContent.contains(node);
  }
  onBlur(event) {
    const datePicker2 = this.datePicker;
    if (datePicker2._fullscreen && !this.isEventInOverlay(event.relatedTarget)) {
      this.fullscreenFocus = true;
    }
  }
  onFocusIn(event) {
    if (this.isEventInOverlay(event.relatedTarget)) {
      return;
    }
    if (this.blurWhileOpened) {
      this.blurWhileOpened = false;
      return;
    }
    this.showOutline(this.datePicker);
  }
  onFocusOut(event) {
    if (this.fullscreenFocus || this.isEventInOverlay(event.relatedTarget)) ;
    else if (!this.datePicker.opened) {
      this.hideOutline(this.datePicker);
    } else {
      this.blurWhileOpened = true;
    }
  }
  onOverlayFocusOut(event) {
    if (!this.datePicker.contains(event.relatedTarget)) {
      this.blurWhileOpened = true;
    }
  }
  onOpenedChanged(event) {
    if (event.detail.value === true && this.fullscreenFocus) {
      this.fullscreenFocus = false;
      this.showOutline(this.datePicker);
    }
    if (event.detail.value === false && this.blurWhileOpened) {
      this.blurWhileOpened = false;
      this.hideOutline(this.datePicker);
    }
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class DateObserver extends DatePickerObserver {
  constructor(datePicker2, host) {
    super(datePicker2);
    this.component = host;
  }
  getFieldIndex() {
    return 0;
  }
}
class TimeObserver extends FieldObserver {
  constructor(timePicker2, host) {
    super(timePicker2);
    this.component = host;
    this.timePicker = timePicker2;
  }
  getFocusTarget(_event) {
    return this.timePicker;
  }
  getFieldIndex() {
    return 1;
  }
}
class DateTimePickerObserver extends ComponentObserver {
  constructor(picker) {
    super(picker);
    const [datePicker2, timePicker2] = this.getFields();
    this.dateObserver = new DateObserver(datePicker2, picker);
    this.timeObserver = new TimeObserver(timePicker2, picker);
  }
  getFields() {
    return [this.component.querySelector("[slot=date-picker]"), this.component.querySelector("[slot=time-picker]")];
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ListBoxObserver extends FieldObserver {
  getFields() {
    return this.component.items || [];
  }
  getFocusTarget(event) {
    const fields2 = this.getFields();
    return Array.from(event.composedPath()).find((node) => fields2.includes(node));
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class RadioGroupObserver extends FieldObserver {
  getFields() {
    return this.component.__radioButtons;
  }
  getFocusTarget(event) {
    const fields2 = this.getFields();
    return Array.from(event.composedPath()).find((node) => fields2.includes(node));
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SelectObserver extends FieldObserver {
  constructor(select2) {
    super(select2);
    this.blurWhileOpened = false;
    this.overlay = select2._overlayElement;
  }
  addListeners(select2) {
    super.addListeners(select2);
    select2.addEventListener("opened-changed", (event) => {
      if (select2._phone && event.detail.value === false) {
        this.hideOutline(select2);
      }
    });
  }
  onFocusIn(event) {
    if (this.overlay.contains(event.relatedTarget)) {
      return;
    }
    if (!this.component._phone && this.overlay.hasAttribute("closing")) {
      return;
    }
    super.onFocusIn(event);
  }
  onFocusOut(event) {
    if (this.overlay.contains(event.relatedTarget)) {
      return;
    }
    super.onFocusOut(event);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const initFieldObserver = (field) => {
  let result;
  switch (field.tagName.toLowerCase()) {
    /* c8 ignore next */
    case "vaadin-date-picker":
      result = new DatePickerObserver(field);
      break;
    /* c8 ignore next */
    case "vaadin-date-time-picker":
      result = new DateTimePickerObserver(field);
      break;
    /* c8 ignore next */
    case "vaadin-select":
      result = new SelectObserver(field);
      break;
    /* c8 ignore next 2 */
    case "vaadin-checkbox-group":
      result = new CheckboxGroupObserver(field);
      break;
    case "vaadin-radio-group":
      result = new RadioGroupObserver(field);
      break;
    case "vaadin-list-box":
      result = new ListBoxObserver(field);
      break;
    default:
      result = new FieldObserver(field);
  }
  return result;
};
class FieldHighlighterController {
  constructor(host) {
    this.host = host;
    this.user = null;
    this.users = [];
  }
  get user() {
    return this._user;
  }
  set user(user) {
    this._user = user;
    if (user) {
      const msg = `${user.name} started editing`;
      const { label } = this.host;
      announce(label ? `${msg} ${label}` : msg);
    }
  }
  hostConnected() {
    this.redraw();
  }
  addUser(user) {
    if (user) {
      this.users.push(user);
      this.redraw();
      this.user = user;
    }
  }
  setUsers(users) {
    if (Array.isArray(users)) {
      this.users = users;
      this.redraw();
      this.user = users[users.length - 1] || null;
    }
  }
  removeUser(user) {
    if (user && user.id !== void 0) {
      let index;
      for (let i2 = 0; i2 < this.users.length; i2++) {
        if (this.users[i2].id === user.id) {
          index = i2;
          break;
        }
      }
      if (index !== void 0) {
        this.users.splice(index, 1);
        this.redraw();
        if (this.users.length > 0) {
          this.user = this.users[this.users.length - 1];
        } else {
          this.user = null;
        }
      }
    }
  }
  redraw() {
    this.observer.redraw([...this.users].reverse());
  }
}
class FieldHighlighter extends HTMLElement {
  static get is() {
    return "vaadin-field-highlighter";
  }
  static init(field) {
    if (!field._highlighterController) {
      const instance = new FieldHighlighterController(field);
      field.setAttribute("has-highlighter", "");
      instance.observer = initFieldObserver(field);
      field.addController(instance);
      field._highlighterController = instance;
    }
    return field._highlighterController;
  }
  static addUser(field, user) {
    this.init(field).addUser(user);
  }
  static removeUser(field, user) {
    this.init(field).removeUser(user);
  }
  static setUsers(field, users) {
    this.init(field).setUsers(users);
  }
}
defineCustomElement(FieldHighlighter);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let moduleIdIndex = 0;
function registerStyles(themeFor, styles2 = [], options = {}) {
  const themeId = options.moduleId || `custom-style-module-${moduleIdIndex}`;
  moduleIdIndex += 1;
  const module2 = document.createElement("dom-module");
  if (themeFor) {
    module2.setAttribute("theme-for", themeFor);
  }
  const includeStylesToTemplate = !!(styles2.length && options.moduleId);
  const moduleIncludes = [].concat(options.include || []);
  if (moduleIncludes.length === 0) {
    module2.__allStyles = styles2;
  } else if (!includeStylesToTemplate) {
    module2.__partialStyles = styles2;
  }
  module2.innerHTML = `
    <template>
      ${moduleIncludes.map((include) => `<style include=${include}></style>`)}
      ${includeStylesToTemplate ? `<style>${styles2.map((style) => style.cssText).join("\n")}</style>` : ""}
    </template>
  `;
  module2.register(themeId);
}
function getModuleStyles(module2) {
  return stylesFromTemplate(module2.querySelector("template")).map((styleElement) => {
    return unsafeCSS(styleElement.textContent);
  });
}
function getAllThemes() {
  const domModule = DomModule;
  const modules2 = domModule.prototype.modules;
  return Object.keys(modules2).map((moduleId) => {
    const module2 = modules2[moduleId];
    const themeFor = module2.getAttribute("theme-for");
    if (!module2.__allStyles) {
      module2.__allStyles = getModuleStyles(module2).concat(module2.__partialStyles || []);
    }
    return {
      themeFor,
      moduleId,
      styles: module2.__allStyles
    };
  });
}
if (!window.Vaadin) {
  window.Vaadin = {};
}
window.Vaadin.styleModules = {
  getAllThemes,
  registerStyles
};
if (themeRegistry.length > 0) {
  themeRegistry.forEach((theme) => {
    registerStyles(theme.themeFor, theme.styles, {
      moduleId: theme.moduleId,
      include: theme.include
    });
  });
  themeRegistry.length = 0;
}
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const fontIcons = css`
  @font-face {
    font-family: 'lumo-icons';
    src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAABHAAAsAAAAAI6AAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADsAAABUIIslek9TLzIAAAFEAAAAQwAAAFZAIUuNY21hcAAAAYgAAAD+AAADymne8hxnbHlmAAACiAAAC+gAABioIzlOlWhlYWQAAA5wAAAAMAAAADZa/6SsaGhlYQAADqAAAAAdAAAAJAbpA4BobXR4AAAOwAAAABAAAAC0q+AAAGxvY2EAAA7QAAAAXAAAAFyF7o1GbWF4cAAADywAAAAfAAAAIAFMAXBuYW1lAAAPTAAAATEAAAIuUUJZCHBvc3QAABCAAAABPQAAAgfdkltveJxjYGRgYOBiMGCwY2BycfMJYeDLSSzJY5BiYGGAAJA8MpsxJzM9kYEDxgPKsYBpDiBmg4gCACY7BUgAeJxjYGS+xDiBgZWBgamKaQ8DA0MPhGZ8wGDIyAQUZWBlZsAKAtJcUxgcXjG+0mEO+p/FEMUcxDANKMwIkgMABvgMMAB4nO3SV26EMABF0UsZpjG9d6Y3FpgF5StLYxMTP16WEUvHV1gGIQzQAJKgDFKIfojQ+A6rUb2e0KnXU77qPanWq/LzCXOkOVyn9RyHvWl4YkaTFu1wX5ecHn0GDBkxZsKUGXMWLFmxZsOWHXsOFBw5cebClRt3Hjx58dZ7RRn/I9cUF39Xpb691acRG2piOtUqNZ1P1TCdeJUZatNQW4baNtSO6U+ouoaam96u6hlq31AHhjo01JGhjg11YqhTQ50Z6txQF4a6NNSVoa4NdWOoW0PdGereUA+GWhjq0VBPhno21IuhXg31Zqh3Q30Y6tNQX4b6NtTSKH8BOIRpQQAAeJy1WH1sW9UVv+fG9vPz+7Bf/N6zHcd2/J04jbP6s0lap4kDpB9JWzUUCqxNgaHxpTI6hNhUNLVr17HSISb2D2iAJrWb6FTWahNQdQxRvmHamAR0qibE1E18CG3QaVNFvJ17n+3YIf1AiMQ679x77j3v3HPPPed3H7ER/OsYpw8TmQRIiuQJ8RZK+WjO1B3xaCzla21orY10a+OQ6aHTHtP0zB31mBs1GZ6RNU2uXc7oPL+xdRS9R9X1oK4fVfijdsBqvqF6vd1eLzPrYrYZ57WteF7bPDIc5+ZcJnta+S9i2Vfhs4MaMwZNQmO0Vv7gF/MZcNsCcJp4sJFSwYyAmRuFCmTBDRBUkwGqnlViyjmVBpLqaXhNpt0J5V1JOqMkuqn8WkMHvZX+iOlImiqkBiFVYDrCqINulmkwKb8ry2fkZBBn7FcTlk4ZdfpRZ9MOesLSAakKt0N3g4p2jAL8eIEOOqom/U0lgQRXUl8LtXM7HFkojUIpF0ErVBhcZC1vtyjtpsqr83a8RVcSH+ool8LgcIMjNohmVCACuDs506BdO6WIQeXjUsh1XKZGRNpp9piv3+Givoh00OU6KEV81HUHTLtN093Q+YGlE3wLHWRtMNy9XWqdLm2HKbaNsGzhu+41eswFOjE6WKSk2/1Wpt+qHeM6phbohmVmj3GvpdcVkiy9zbXfzHVqKuDB0IR2P6ZpF+D7dy6YC/9svGmBE5hKB9+X2+hh4iYRMkhGyTqyFc9APmeGQHf043tWQKHkizmwaY5AroTNVJzJDc2SFzUu92kOLsdmKu77vByb8/IjtxmhkMFISRBFISO4XMLJlj4XgGuRXtaHw2FLyHifdSOpisIhJjgkiPBAyJh7lfXTkhEadwk1mUngrOC6MazX7mASeEAPV1FyjEumBOaEDu4DP/ogRDKkiLEV1woVyMeLLKJCEM+FwdCwL4XLcRgdbfkhbzS8BNvXDKzNQiAWgOzagTXF1Eyq+Ci6/TPm/JrNY/59p1epKN4jQFGe0fx+LTMwNVCrAU2VSqnaKYzIiGmWe2Rvp9KDJhncrjLaFce8VCUbyQ1kB9lNfkJ+To6R58mfyd/Ip9ABXohDHqqwEW7A2Mij1ehntLu+h8xMtocjUJcYwoLdtYafv/1Vjy8vjLaLtBfOt3/B931Rexa24e5zstgnyqvZHs69zuhq3vFgRpQVJyN7FuE++RLSeW4xMi+t6Zeo5sIK6S5dlGVRD2hWnGoB3j7OV3lesvNLic8tOnLRSRfRdOna63VJp/1WbYs5dFZjy1AqpGICQEWKmNI+CZNoVTJ7pNop+IZkRrBHgnEmqr3TrEsfw1Gi8LqE+S1aV0SNNwXVVVvuUoU3ld6TLwmditIpvKTU50zSzWwO1h0rL8awnulwTXMYrGDT4aQ1fb4GPkyv5vMEh5Vec6yw0AMXnfcx1l/rfVZaKLDi0W4j/HfeyGZuHOf1IUGW1udizU2leXY0OmLpVDpVKJfKpZzPRKHgEBzpXAUKWYipoIeBdl3JfLZVBizEqWun1i4ZGFiyduq3DebayXsmJ+95gBG4+Urm1a2SdpKV57lP2wZyZqI+FAlfUtO+NCmgdWhMOS1gDY+jHWnBhwjBQLMEXxmLbx6t9JXTWDLtsSxgisfErqvQMbbBoywZmeyLeWe8OWNydFDxzMx4lMGRtX0xN3YFJkeW+O0bascGNwwObtjCCOzrzAVWjSwN2K9cpyn9o5cZOXMmkAuM85EbNHnJyHhfLLCnPhxJYw9eoIMkyC3l+4ZuY5ig7lW2oYUynDgg+Xrk+++Xe3zSgRYetnyuy+KbfjiB+GAAtZ8HHXmtijZfFFgrujhmOs2qkXvuSV6WqA1WLYqhPHOfsa26rklKFqbAGL2dOIlGurB6LWFVFd/KoBBaYTFYVBs93hZRFlrG5Ex4NVFIJguJVvqnBW2kNNvFGx90YUcSEvyZSMDeZjc0xYlEYy8+hHcWx9YrZOaPPyCGepP5Q34aXnGBr8d1QhSf4yjtiebZqNJfEYl4SY6dDRb8WSguLZW9ZQtBpoW4hX0QMyB2KmsYcOh8HMQxBn288oZ6BXV0GOq/ClKsC6T8g9X3OFKZNkJrYkOx2lEk+KNDy953+wGHXuGGzhGZ+uLK8FVrQkbtKBv+9EztU2sgTCNpvXMdJjqJ4tkdw+x00dPKkZ1QR254x7GQoFmvfakSnL3gCc5nREly2mN2pyTLMacMipNT7YInGU7JzlN2p9N+yinXTirOKEvPUafSWMNDmCf9pIQYaG19DSxKGqvAQ+xg60iabEm5MheUU2n+HxO4TDDbjnw6xxK8QzfhbHXq8pWVqanKysun9s6ztdt7sivGqruqYyuyPS6Hw9XehGt6q+l0dT0jvaFMZjiTuTHo7+vdtHJTb58/2ML+IxHt9/n9vv5owiWKrrbWD+sakKxhKoYzxF5f7y9INxki42QNuYrVFDPfvqxyY83xWNMV+ZxPSMWb62W+wPSCJwkDDl1WZOGW84nAEo4A7HjB/uWmOdayRFnKjazi668u/ajJlUd87aPk048Crlu4j1Oh9gxdL3Z1inNPIt2xvKNlsU4hn54Z5Y6YbTDu9hHOvkcFAb35fU6hNovKOrtQmcvbNV9/Ntfv5xf4atDWOOTX6CSHZ08xujhPs51+f9zvf1YLIGoPPKvxVh0TSLAXzzUBFiXs7GJVB7vH5/PAXznd4+vx4a95h3qI/oYIpIdMkA1kC7kVLS3GhWI5bwj1fIaVKG/Ei5gXWOjhtcJbzFthaMQrwIcIRj0ppvO6yV95icu9j/YPDNySWp7w+kOr95R1RfGpfVlDVhS/2geJ5Umv2mn0rkxBvzvgdisndJXaVF1X5z5jdHGe2n/QnYo8+b2uaMivhowgjYcLnVqnrEpQezsieyVZ6ooETbdJO6ip+cORLpes6BL82/qg8VHbo45B/vch/YQeJX28QvEANR3sQhxh+TcMCEd4l8BKF7uID7KM05tRYlIHHXY63YIi2fXQyj5XSBbcMeewKLpttkJ2Syz33YJfDdJdSYkqHbYb3VHRJgTV8c0TAy67YHeK7htwOKWax5co7Do8Pfh1tKdx1g5j9o6TZeQyMo27FuW3vbYsbY/Op3AG06DMKionRlpgHzCEeMmLU5opRrCyS670RzppZeW5p/iT3jL3lB4O63QS6dzzh8SAtOqwGJK3bv+lGJTWbr++471wsVKMRJCEK5H+cLg/Qp+IDsdqs7HhKD7hMXyyrD/Li8RjRqimHhI7HP2vSDZn9brplySb0L9dgpURSwmSiBFhilrwB8OA9gZ29NkRO/669parW9e7XZDxwvgRu+SE7zgl+xG5p/HtRqJ3cdwSZwsbwTA1WT3jEdyPN0sWxvDGy+xovIzHosnwc9LePf9tywun0fMkWaFYZbB4oovRq8VyKYUBkMVXqVhBHSylQ0wanvla3+rQ1XbR8ZzstYOo2Mf7vjk8ftcGDWxdSdXx0cAVveHg1TZFtEOn8ntBBFs11V++vuLUQ5qz+U6d/oUjpGIdNjOQhJXNqn5YCS1Yy5PofLGEs6Js2yOKe2yyOLxtaGjbt7cNIURCEDdWfaQ6lurtRYbePCuItv1iUNxvE4Vdw2zQ0LZhdv2fxjHp5uAmdlBpopHXoJGU8e6BRc0yi+PztkaHTRRrW1m2hcfFLlEUzzD+DGczjEVCg9jEQZhFcdAL2DjD+DPiSWQzjM2I89g5RXdxfECS+CIWy1hTGmFs6EIbkv/pbtkfU3aPrZ+4c2Lizn07qufym/L5TTdtyuU2/We3HPeDsjtb3bGPSSfW31aX3LQpX/d9sL7fWYpRJPBbCJavYjrFjj0rT2GWCZjf6Ytffr8beXl/HYeyGwJiIK8FLDHbfo65xGz7YCSRqCQSkbbHI5eUU5X4sjj+zrU9aHnRlEnrd7YGptd0x2Jf/RbH9PAiovadckSnEsJ661OgPFuH9B4O6e202vIN0h9xHXSJh1wRP5Vqv1uI6Wn9Gxmrwzqrii1gqhEscJanuAlGas+s2/uzvetgS72NpHZ6aHbZstmh/wPq1seEeJxjYGRgYADi31ySEvH8Nl8ZuJlfAEUYalQ3NCLo/6+ZpzLdAnI5GJhAogAiBgraeJxjYGRgYA76nwUkXzAAAfNUBkYGVKALAFb4A3EAAAB4nGNgYGBgfjG0MAAMzihlAAAAAABOAJoA6AEKASwBTgFwAZoBxAHuAhoCnALoBJoEvATWBPIFDgUqBXoF0AX+BkQGlga4BwgHagfiCGoIpAi8CVAJmAoQCiwKVgqQCtYLGAtOC4gL6AwuDFR4nGNgZGBg0GVMYRBlAAEmIOYCQgaG/2A+AwAYygG+AHicbZE9TsMwGIbf9A/RSggEYmHxAgtq+jN2ZGj3Dt3T1GlTOXHkuBW9AyfgEByCgTNwCA7BW/NJlVBtyd/jx+8XKwmAa3whwnFE6Ib1OBq44O6Pm6Qb4Rb5QbiNHh6FO/RD4S6eMRHu4RaaT4halzR3eBVu4Apvwk36d+EW+UO4jXt8Cnfov4W7WOBHuIen6MXsCtvPU1vWc73emcSdxIkW2tW5LdUoHp7kTJfaJV6v1PKg6v167H2mMmcLNbWl18ZYVTm71amPN95Xk8EgEx+ntoDBDgUs+siRspaoMef7rukNEriziXNuwS7Hmoe9wggxv+e55IzJMqQTeNYV00scuNbY8+YxrUfGfcaMZb/CNPQe04bT0lThbEuT0sfYhK6K/23Amf3Lx+H24hcj4GScAAAAeJxtjuduwzAMhH2NnTqOk+6993TfSZFY24giGZTVon36eiRFf5SAiO/A05HBWtBXEvxfGdYwQIgIQ6wjxggJxkgxwRQb2MQWtrGDXexhHwc4xBGOcYJTnOEcF7jEFa5xg1vc4R4PeMQTnvGCV2R4C1Khy9xkkkxNnPRC03s97pHLvKgTYXJNmbKfZom9o8POEffsq0Qw28+ltcPe2uHS2rGvRjPBmSwE1+GMtI6l0GSU4JEsSM4XgudpQx9sTRf3K9rAyUr0962UryKprZwPpM0jyda5uP2qrVBjxSLPCmGUplixrdpBSKqsI2oO4gF9Udq8TJVOzDSpcEHGR4vSeJdaVsSkMl26OqoKa6jttQ0rLb6a5l3YjO2QqV01YXLlNy2XDR0JlkXojbJTb/5GDX3V+kPviIPgB9AUks0AAAA=)
      format('woff');
    font-weight: normal;
    font-style: normal;
  }

  html {
    --lumo-icons-align-center: '\\ea01';
    --lumo-icons-align-left: '\\ea02';
    --lumo-icons-align-right: '\\ea03';
    --lumo-icons-angle-down: '\\ea04';
    --lumo-icons-angle-left: '\\ea05';
    --lumo-icons-angle-right: '\\ea06';
    --lumo-icons-angle-up: '\\ea07';
    --lumo-icons-arrow-down: '\\ea08';
    --lumo-icons-arrow-left: '\\ea09';
    --lumo-icons-arrow-right: '\\ea0a';
    --lumo-icons-arrow-up: '\\ea0b';
    --lumo-icons-bar-chart: '\\ea0c';
    --lumo-icons-bell: '\\ea0d';
    --lumo-icons-calendar: '\\ea0e';
    --lumo-icons-checkmark: '\\ea0f';
    --lumo-icons-chevron-down: '\\ea10';
    --lumo-icons-chevron-left: '\\ea11';
    --lumo-icons-chevron-right: '\\ea12';
    --lumo-icons-chevron-up: '\\ea13';
    --lumo-icons-clock: '\\ea14';
    --lumo-icons-cog: '\\ea15';
    --lumo-icons-cross: '\\ea16';
    --lumo-icons-download: '\\ea17';
    --lumo-icons-drag-handle: '\\ea18';
    --lumo-icons-dropdown: '\\ea19';
    --lumo-icons-edit: '\\ea1a';
    --lumo-icons-error: '\\ea1b';
    --lumo-icons-eye: '\\ea1c';
    --lumo-icons-eye-disabled: '\\ea1d';
    --lumo-icons-menu: '\\ea1e';
    --lumo-icons-minus: '\\ea1f';
    --lumo-icons-ordered-list: '\\ea20';
    --lumo-icons-phone: '\\ea21';
    --lumo-icons-photo: '\\ea22';
    --lumo-icons-play: '\\ea23';
    --lumo-icons-plus: '\\ea24';
    --lumo-icons-redo: '\\ea25';
    --lumo-icons-reload: '\\ea26';
    --lumo-icons-resize-handle: '\\ea27';
    --lumo-icons-search: '\\ea28';
    --lumo-icons-undo: '\\ea29';
    --lumo-icons-unordered-list: '\\ea2a';
    --lumo-icons-upload: '\\ea2b';
    --lumo-icons-user: '\\ea2c';
  }
`;
addLumoGlobalStyles("font-icons", fontIcons);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const sizing = css`
  :host {
    --lumo-size-xs: 1.625rem;
    --lumo-size-s: 1.875rem;
    --lumo-size-m: 2.25rem;
    --lumo-size-l: 2.75rem;
    --lumo-size-xl: 3.5rem;

    /* Icons */
    --lumo-icon-size-s: 1.25em;
    --lumo-icon-size-m: 1.5em;
    --lumo-icon-size-l: 2.25em;
    /* For backwards compatibility */
    --lumo-icon-size: var(--lumo-icon-size-m);
  }
`;
addLumoGlobalStyles("sizing-props", sizing);
const detailsSummary = css`
  :host {
    display: flex;
    align-items: center;
    width: 100%;
    outline: none;
    padding: var(--lumo-space-s) 0;
    box-sizing: border-box;
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    font-weight: 500;
    line-height: var(--lumo-line-height-xs);
    color: var(--lumo-secondary-text-color);
    background-color: inherit;
    border-radius: var(--lumo-border-radius-m);
    cursor: var(--lumo-clickable-cursor);
    -webkit-tap-highlight-color: transparent;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  :host([disabled]),
  :host([disabled]) [part='toggle'] {
    color: var(--lumo-disabled-text-color);
    cursor: default;
  }

  @media (hover: hover) {
    :host(:hover:not([disabled])),
    :host(:hover:not([disabled])) [part='toggle'] {
      color: var(--lumo-contrast-80pct);
    }
  }

  [part='toggle'] {
    display: block;
    width: 1em;
    height: 1em;
    margin-left: calc(var(--lumo-space-xs) * -1);
    margin-right: var(--lumo-space-xs);
    font-size: var(--lumo-icon-size-s);
    line-height: 1;
    color: var(--lumo-contrast-60pct);
    font-family: 'lumo-icons';
    cursor: var(--lumo-clickable-cursor);
  }

  [part='toggle']::before {
    content: var(--lumo-icons-angle-right);
  }

  :host([opened]) [part='toggle'] {
    transform: rotate(90deg);
  }

  [part='content'] {
    flex-grow: 1;
  }

  /* RTL styles */
  :host([dir='rtl']) [part='toggle'] {
    margin-left: var(--lumo-space-xs);
    margin-right: calc(var(--lumo-space-xs) * -1);
  }

  :host([dir='rtl']) [part='toggle']::before {
    content: var(--lumo-icons-angle-left);
  }

  :host([opened][dir='rtl']) [part='toggle'] {
    transform: rotate(-90deg);
  }

  /* Small */
  :host([theme~='small']) {
    padding-top: var(--lumo-space-xs);
    padding-bottom: var(--lumo-space-xs);
  }

  :host([theme~='small']) [part='toggle'] {
    margin-right: calc(var(--lumo-space-xs) / 2);
  }

  :host([theme~='small'][dir='rtl']) [part='toggle'] {
    margin-left: calc(var(--lumo-space-xs) / 2);
  }

  /* Filled */
  :host([theme~='filled']) {
    padding: var(--lumo-space-s) calc(var(--lumo-space-s) + var(--lumo-space-xs) / 2);
  }

  /* Reverse */
  :host([theme~='reverse']) {
    justify-content: space-between;
  }

  :host([theme~='reverse']) [part='toggle'] {
    order: 1;
    margin-right: 0;
  }

  :host([theme~='reverse'][dir='rtl']) [part='toggle'] {
    margin-left: 0;
  }

  /* Filled reverse */
  :host([theme~='reverse'][theme~='filled']) {
    padding-left: var(--lumo-space-m);
  }

  :host([theme~='reverse'][theme~='filled'][dir='rtl']) {
    padding-right: var(--lumo-space-m);
  }
`;
registerStyles$1("vaadin-details-summary", detailsSummary, { moduleId: "lumo-details-summary" });
const accordionHeading$1 = css`
  :host {
    padding: 0;
  }

  [part='content'] {
    padding: var(--lumo-space-s) 0;
  }

  :host([theme~='filled']) {
    padding-top: 0;
    padding-bottom: 0;
  }
`;
registerStyles$1("vaadin-accordion-heading", [detailsSummary, accordionHeading$1], { moduleId: "lumo-accordion-heading" });
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const wrap = (node) => node;
const HAS_NATIVE_TA = typeof document.head.style.touchAction === "string";
const GESTURE_KEY = "__polymerGestures";
const HANDLED_OBJ = "__polymerGesturesHandled";
const TOUCH_ACTION = "__polymerGesturesTouchAction";
const TAP_DISTANCE = 25;
const TRACK_DISTANCE = 5;
const TRACK_LENGTH = 2;
const MOUSE_EVENTS = ["mousedown", "mousemove", "mouseup", "click"];
const MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
const MOUSE_HAS_BUTTONS = function() {
  try {
    return new MouseEvent("test", { buttons: 1 }).buttons === 1;
  } catch (_) {
    return false;
  }
}();
function isMouseEvent(name) {
  return MOUSE_EVENTS.indexOf(name) > -1;
}
let supportsPassive = false;
(function() {
  try {
    const opts = Object.defineProperty({}, "passive", {
      // eslint-disable-next-line getter-return
      get() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test", null, opts);
    window.removeEventListener("test", null, opts);
  } catch (_) {
  }
})();
function PASSIVE_TOUCH(eventName) {
  if (isMouseEvent(eventName) || eventName === "touchend") {
    return;
  }
}
const IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/u);
const canBeDisabled = {
  button: true,
  command: true,
  fieldset: true,
  input: true,
  keygen: true,
  optgroup: true,
  option: true,
  select: true,
  textarea: true
};
function hasLeftMouseButton(ev) {
  const type = ev.type;
  if (!isMouseEvent(type)) {
    return false;
  }
  if (type === "mousemove") {
    let buttons = ev.buttons === void 0 ? 1 : ev.buttons;
    if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
    }
    return Boolean(buttons & 1);
  }
  const button2 = ev.button === void 0 ? 0 : ev.button;
  return button2 === 0;
}
function isSyntheticClick(ev) {
  if (ev.type === "click") {
    if (ev.detail === 0) {
      return true;
    }
    const t2 = _findOriginalTarget(ev);
    if (!t2.nodeType || /** @type {Element} */
    t2.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    const bcr = (
      /** @type {Element} */
      t2.getBoundingClientRect()
    );
    const x2 = ev.pageX, y3 = ev.pageY;
    return !(x2 >= bcr.left && x2 <= bcr.right && y3 >= bcr.top && y3 <= bcr.bottom);
  }
  return false;
}
const POINTERSTATE = {
  mouse: {
    target: null,
    mouseIgnoreJob: null
  },
  touch: {
    x: 0,
    y: 0,
    id: -1,
    scrollDecided: false
  }
};
function firstTouchAction(ev) {
  let ta = "auto";
  const path = getComposedPath(ev);
  for (let i2 = 0, n; i2 < path.length; i2++) {
    n = path[i2];
    if (n[TOUCH_ACTION]) {
      ta = n[TOUCH_ACTION];
      break;
    }
  }
  return ta;
}
function trackDocument(stateObj, movefn, upfn) {
  stateObj.movefn = movefn;
  stateObj.upfn = upfn;
  document.addEventListener("mousemove", movefn);
  document.addEventListener("mouseup", upfn);
}
function untrackDocument(stateObj) {
  document.removeEventListener("mousemove", stateObj.movefn);
  document.removeEventListener("mouseup", stateObj.upfn);
  stateObj.movefn = null;
  stateObj.upfn = null;
}
const getComposedPath = window.ShadyDOM && window.ShadyDOM.noPatch ? window.ShadyDOM.composedPath : (event) => event.composedPath && event.composedPath() || [];
const gestures = {};
const recognizers = [];
function deepTargetFind(x2, y3) {
  let node = document.elementFromPoint(x2, y3);
  let next = node;
  while (next && next.shadowRoot && !window.ShadyDOM) {
    const oldNext = next;
    next = next.shadowRoot.elementFromPoint(x2, y3);
    if (oldNext === next) {
      break;
    }
    if (next) {
      node = next;
    }
  }
  return node;
}
function _findOriginalTarget(ev) {
  const path = getComposedPath(
    /** @type {?Event} */
    ev
  );
  return path.length > 0 ? path[0] : ev.target;
}
function _handleNative(ev) {
  const type = ev.type;
  const node = ev.currentTarget;
  const gobj = node[GESTURE_KEY];
  if (!gobj) {
    return;
  }
  const gs = gobj[type];
  if (!gs) {
    return;
  }
  if (!ev[HANDLED_OBJ]) {
    ev[HANDLED_OBJ] = {};
    if (type.startsWith("touch")) {
      const t2 = ev.changedTouches[0];
      if (type === "touchstart") {
        if (ev.touches.length === 1) {
          POINTERSTATE.touch.id = t2.identifier;
        }
      }
      if (POINTERSTATE.touch.id !== t2.identifier) {
        return;
      }
      if (!HAS_NATIVE_TA) {
        if (type === "touchstart" || type === "touchmove") {
          _handleTouchAction(ev);
        }
      }
    }
  }
  const handled = ev[HANDLED_OBJ];
  if (handled.skip) {
    return;
  }
  for (let i2 = 0, r; i2 < recognizers.length; i2++) {
    r = recognizers[i2];
    if (gs[r.name] && !handled[r.name]) {
      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
        r.reset();
      }
    }
  }
  for (let i2 = 0, r; i2 < recognizers.length; i2++) {
    r = recognizers[i2];
    if (gs[r.name] && !handled[r.name]) {
      handled[r.name] = true;
      r[type](ev);
    }
  }
}
function _handleTouchAction(ev) {
  const t2 = ev.changedTouches[0];
  const type = ev.type;
  if (type === "touchstart") {
    POINTERSTATE.touch.x = t2.clientX;
    POINTERSTATE.touch.y = t2.clientY;
    POINTERSTATE.touch.scrollDecided = false;
  } else if (type === "touchmove") {
    if (POINTERSTATE.touch.scrollDecided) {
      return;
    }
    POINTERSTATE.touch.scrollDecided = true;
    const ta = firstTouchAction(ev);
    let shouldPrevent = false;
    const dx = Math.abs(POINTERSTATE.touch.x - t2.clientX);
    const dy = Math.abs(POINTERSTATE.touch.y - t2.clientY);
    if (!ev.cancelable) ;
    else if (ta === "none") {
      shouldPrevent = true;
    } else if (ta === "pan-x") {
      shouldPrevent = dy > dx;
    } else if (ta === "pan-y") {
      shouldPrevent = dx > dy;
    }
    if (shouldPrevent) {
      ev.preventDefault();
    } else {
      prevent("track");
    }
  }
}
function addListener(node, evType, handler) {
  if (gestures[evType]) {
    _add(node, evType, handler);
    return true;
  }
  return false;
}
function removeListener(node, evType, handler) {
  if (gestures[evType]) {
    _remove(node, evType, handler);
    return true;
  }
  return false;
}
function _add(node, evType, handler) {
  const recognizer = gestures[evType];
  const deps = recognizer.deps;
  const name = recognizer.name;
  let gobj = node[GESTURE_KEY];
  if (!gobj) {
    node[GESTURE_KEY] = gobj = {};
  }
  for (let i2 = 0, dep, gd; i2 < deps.length; i2++) {
    dep = deps[i2];
    if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== "click") {
      continue;
    }
    gd = gobj[dep];
    if (!gd) {
      gobj[dep] = gd = { _count: 0 };
    }
    if (gd._count === 0) {
      node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
    }
    gd[name] = (gd[name] || 0) + 1;
    gd._count = (gd._count || 0) + 1;
  }
  node.addEventListener(evType, handler);
  if (recognizer.touchAction) {
    setTouchAction(node, recognizer.touchAction);
  }
}
function _remove(node, evType, handler) {
  const recognizer = gestures[evType];
  const deps = recognizer.deps;
  const name = recognizer.name;
  const gobj = node[GESTURE_KEY];
  if (gobj) {
    for (let i2 = 0, dep, gd; i2 < deps.length; i2++) {
      dep = deps[i2];
      gd = gobj[dep];
      if (gd && gd[name]) {
        gd[name] = (gd[name] || 1) - 1;
        gd._count = (gd._count || 1) - 1;
        if (gd._count === 0) {
          node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
        }
      }
    }
  }
  node.removeEventListener(evType, handler);
}
function register(recog) {
  recognizers.push(recog);
  recog.emits.forEach((emit) => {
    gestures[emit] = recog;
  });
}
function _findRecognizerByEvent(evName) {
  for (let i2 = 0, r; i2 < recognizers.length; i2++) {
    r = recognizers[i2];
    for (let j = 0, n; j < r.emits.length; j++) {
      n = r.emits[j];
      if (n === evName) {
        return r;
      }
    }
  }
  return null;
}
function setTouchAction(node, value) {
  if (HAS_NATIVE_TA && node instanceof HTMLElement) {
    microTask.run(() => {
      node.style.touchAction = value;
    });
  }
  node[TOUCH_ACTION] = value;
}
function _fire(target, type, detail) {
  const ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
  ev.detail = detail;
  wrap(
    /** @type {!Node} */
    target
  ).dispatchEvent(ev);
  if (ev.defaultPrevented) {
    const preventer = detail.preventer || detail.sourceEvent;
    if (preventer && preventer.preventDefault) {
      preventer.preventDefault();
    }
  }
}
function prevent(evName) {
  const recognizer = _findRecognizerByEvent(evName);
  if (recognizer.info) {
    recognizer.info.prevent = true;
  }
}
register({
  name: "downup",
  deps: ["mousedown", "touchstart", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["mouseup", "touchend"]
  },
  emits: ["down", "up"],
  info: {
    movefn: null,
    upfn: null
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset() {
    untrackDocument(this.info);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown(e2) {
    if (!hasLeftMouseButton(e2)) {
      return;
    }
    const t2 = _findOriginalTarget(e2);
    const self2 = this;
    const movefn = (e3) => {
      if (!hasLeftMouseButton(e3)) {
        downupFire("up", t2, e3);
        untrackDocument(self2.info);
      }
    };
    const upfn = (e3) => {
      if (hasLeftMouseButton(e3)) {
        downupFire("up", t2, e3);
      }
      untrackDocument(self2.info);
    };
    trackDocument(this.info, movefn, upfn);
    downupFire("down", t2, e2);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart(e2) {
    downupFire("down", _findOriginalTarget(e2), e2.changedTouches[0], e2);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend(e2) {
    downupFire("up", _findOriginalTarget(e2), e2.changedTouches[0], e2);
  }
});
function downupFire(type, target, event, preventer) {
  if (!target) {
    return;
  }
  _fire(target, type, {
    x: event.clientX,
    y: event.clientY,
    sourceEvent: event,
    preventer,
    prevent(e2) {
      return prevent(e2);
    }
  });
}
register({
  name: "track",
  touchAction: "none",
  deps: ["mousedown", "touchstart", "touchmove", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["mouseup", "touchend"]
  },
  emits: ["track"],
  info: {
    x: 0,
    y: 0,
    state: "start",
    started: false,
    moves: [],
    /** @this {GestureInfo} */
    addMove(move) {
      if (this.moves.length > TRACK_LENGTH) {
        this.moves.shift();
      }
      this.moves.push(move);
    },
    movefn: null,
    upfn: null,
    prevent: false
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset() {
    this.info.state = "start";
    this.info.started = false;
    this.info.moves = [];
    this.info.x = 0;
    this.info.y = 0;
    this.info.prevent = false;
    untrackDocument(this.info);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown(e2) {
    if (!hasLeftMouseButton(e2)) {
      return;
    }
    const t2 = _findOriginalTarget(e2);
    const self2 = this;
    const movefn = (e3) => {
      const x2 = e3.clientX, y3 = e3.clientY;
      if (trackHasMovedEnough(self2.info, x2, y3)) {
        self2.info.state = self2.info.started ? e3.type === "mouseup" ? "end" : "track" : "start";
        if (self2.info.state === "start") {
          prevent("tap");
        }
        self2.info.addMove({ x: x2, y: y3 });
        if (!hasLeftMouseButton(e3)) {
          self2.info.state = "end";
          untrackDocument(self2.info);
        }
        if (t2) {
          trackFire(self2.info, t2, e3);
        }
        self2.info.started = true;
      }
    };
    const upfn = (e3) => {
      if (self2.info.started) {
        movefn(e3);
      }
      untrackDocument(self2.info);
    };
    trackDocument(this.info, movefn, upfn);
    this.info.x = e2.clientX;
    this.info.y = e2.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart(e2) {
    const ct = e2.changedTouches[0];
    this.info.x = ct.clientX;
    this.info.y = ct.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchmove(e2) {
    const t2 = _findOriginalTarget(e2);
    const ct = e2.changedTouches[0];
    const x2 = ct.clientX, y3 = ct.clientY;
    if (trackHasMovedEnough(this.info, x2, y3)) {
      if (this.info.state === "start") {
        prevent("tap");
      }
      this.info.addMove({ x: x2, y: y3 });
      trackFire(this.info, t2, ct);
      this.info.state = "track";
      this.info.started = true;
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend(e2) {
    const t2 = _findOriginalTarget(e2);
    const ct = e2.changedTouches[0];
    if (this.info.started) {
      this.info.state = "end";
      this.info.addMove({ x: ct.clientX, y: ct.clientY });
      trackFire(this.info, t2, ct);
    }
  }
});
function trackHasMovedEnough(info, x2, y3) {
  if (info.prevent) {
    return false;
  }
  if (info.started) {
    return true;
  }
  const dx = Math.abs(info.x - x2);
  const dy = Math.abs(info.y - y3);
  return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
}
function trackFire(info, target, touch) {
  if (!target) {
    return;
  }
  const secondlast = info.moves[info.moves.length - 2];
  const lastmove = info.moves[info.moves.length - 1];
  const dx = lastmove.x - info.x;
  const dy = lastmove.y - info.y;
  let ddx, ddy = 0;
  if (secondlast) {
    ddx = lastmove.x - secondlast.x;
    ddy = lastmove.y - secondlast.y;
  }
  _fire(target, "track", {
    state: info.state,
    x: touch.clientX,
    y: touch.clientY,
    dx,
    dy,
    ddx,
    ddy,
    sourceEvent: touch,
    hover() {
      return deepTargetFind(touch.clientX, touch.clientY);
    }
  });
}
register({
  name: "tap",
  deps: ["mousedown", "click", "touchstart", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["click", "touchend"]
  },
  emits: ["tap"],
  info: {
    x: NaN,
    y: NaN,
    prevent: false
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset() {
    this.info.x = NaN;
    this.info.y = NaN;
    this.info.prevent = false;
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown(e2) {
    if (hasLeftMouseButton(e2)) {
      this.info.x = e2.clientX;
      this.info.y = e2.clientY;
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  click(e2) {
    if (hasLeftMouseButton(e2)) {
      trackForward(this.info, e2);
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart(e2) {
    const touch = e2.changedTouches[0];
    this.info.x = touch.clientX;
    this.info.y = touch.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend(e2) {
    trackForward(this.info, e2.changedTouches[0], e2);
  }
});
function trackForward(info, e2, preventer) {
  const dx = Math.abs(e2.clientX - info.x);
  const dy = Math.abs(e2.clientY - info.y);
  const t2 = _findOriginalTarget(preventer || e2);
  if (!t2 || canBeDisabled[
    /** @type {!HTMLElement} */
    t2.localName
  ] && t2.hasAttribute("disabled")) {
    return;
  }
  if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e2)) {
    if (!info.prevent) {
      _fire(t2, "tap", {
        x: e2.clientX,
        y: e2.clientY,
        sourceEvent: e2,
        preventer
      });
    }
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DisabledMixin = dedupingMixin(
  (superclass) => class DisabledMixinClass extends superclass {
    static get properties() {
      return {
        /**
         * If true, the user cannot interact with this element.
         */
        disabled: {
          type: Boolean,
          value: false,
          observer: "_disabledChanged",
          reflectToAttribute: true,
          sync: true
        }
      };
    }
    /**
     * @param {boolean} disabled
     * @protected
     */
    _disabledChanged(disabled) {
      this._setAriaDisabled(disabled);
    }
    /**
     * @param {boolean} disabled
     * @protected
     */
    _setAriaDisabled(disabled) {
      if (disabled) {
        this.setAttribute("aria-disabled", "true");
      } else {
        this.removeAttribute("aria-disabled");
      }
    }
    /**
     * Overrides the default element `click` method in order to prevent
     * firing the `click` event when the element is disabled.
     * @protected
     * @override
     */
    click() {
      if (!this.disabled) {
        super.click();
      }
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const KeyboardMixin = dedupingMixin(
  (superclass) => class KeyboardMixinClass extends superclass {
    /** @protected */
    ready() {
      super.ready();
      this.addEventListener("keydown", (event) => {
        this._onKeyDown(event);
      });
      this.addEventListener("keyup", (event) => {
        this._onKeyUp(event);
      });
    }
    /**
     * A handler for the `keydown` event. By default, it calls
     * separate methods for handling "Enter" and "Escape" keys.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} event
     * @protected
     */
    _onKeyDown(event) {
      switch (event.key) {
        case "Enter":
          this._onEnter(event);
          break;
        case "Escape":
          this._onEscape(event);
          break;
      }
    }
    /**
     * A handler for the `keyup` event. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} _event
     * @protected
     */
    _onKeyUp(_event) {
    }
    /**
     * A handler for the "Enter" key. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} _event
     * @protected
     */
    _onEnter(_event) {
    }
    /**
     * A handler for the "Escape" key. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} _event
     * @protected
     */
    _onEscape(_event) {
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ActiveMixin = (superclass) => class ActiveMixinClass extends DisabledMixin(KeyboardMixin(superclass)) {
  /**
   * An array of activation keys.
   *
   * See possible values here:
   * https://developer.mozilla.org/ru/docs/Web/API/KeyboardEvent/key/Key_Values
   *
   * @protected
   * @return {!Array<!string>}
   */
  get _activeKeys() {
    return [" "];
  }
  /** @protected */
  ready() {
    super.ready();
    addListener(this, "down", (event) => {
      if (this._shouldSetActive(event)) {
        this._setActive(true);
      }
    });
    addListener(this, "up", () => {
      this._setActive(false);
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this._setActive(false);
  }
  /**
   * @param {KeyboardEvent | MouseEvent} _event
   * @protected
   */
  _shouldSetActive(_event) {
    return !this.disabled;
  }
  /**
   * Sets the `active` attribute on the element if an activation key is pressed.
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    if (this._shouldSetActive(event) && this._activeKeys.includes(event.key)) {
      this._setActive(true);
      document.addEventListener(
        "keyup",
        (e2) => {
          if (this._activeKeys.includes(e2.key)) {
            this._setActive(false);
          }
        },
        { once: true }
      );
    }
  }
  /**
   * Toggles the `active` attribute on the element.
   *
   * @param {boolean} active
   * @protected
   */
  _setActive(active) {
    this.toggleAttribute("active", active);
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const accordionHeading = css`
  :host {
    display: block;
    outline: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
  }

  :host([hidden]) {
    display: none !important;
  }

  button {
    display: flex;
    align-items: center;
    justify-content: inherit;
    width: 100%;
    margin: 0;
    padding: 0;
    background-color: initial;
    color: inherit;
    border: initial;
    outline: none;
    font: inherit;
    text-align: inherit;
  }
`;
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-accordion-heading", accordionHeading, { moduleId: "vaadin-accordion-heading-styles" });
class AccordionHeading extends ActiveMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-accordion-heading";
  }
  static get template() {
    return html`
      <button id="button" part="content" disabled$="[[disabled]]" aria-expanded$="[[__updateAriaExpanded(opened)]]">
        <span part="toggle" aria-hidden="true"></span>
        <slot></slot>
      </button>
    `;
  }
  static get properties() {
    return {
      /**
       * When true, the element is opened.
       */
      opened: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      }
    };
  }
  /**
   * @param {DocumentFragment} dom
   * @return {null}
   * @protected
   * @override
   */
  _attachDom(dom) {
    const root2 = this.attachShadow({ mode: "open", delegatesFocus: true });
    root2.appendChild(dom);
    return root2;
  }
  /** @protected */
  ready() {
    super.ready();
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", "heading");
    }
  }
  /** @private */
  __updateAriaExpanded(opened) {
    return opened ? "true" : "false";
  }
}
defineCustomElement(AccordionHeading);
const details = css`
  :host {
    margin: var(--lumo-space-xs) 0;
    outline: none;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  :host([focus-ring]) ::slotted([slot='summary']) {
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  [part='content'] {
    padding: var(--lumo-space-xs) 0 var(--lumo-space-s);
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-m);
  }

  :host([theme~='filled']) {
    background-color: var(--lumo-contrast-5pct);
    border-radius: var(--lumo-border-radius-m);
  }

  :host([theme~='filled']) [part='content'] {
    padding-left: var(--lumo-space-m);
    padding-right: var(--lumo-space-m);
  }

  :host([theme~='small']) [part$='content'] {
    font-size: var(--lumo-font-size-s);
  }
`;
registerStyles$1("vaadin-details", details, { moduleId: "lumo-details" });
const accordionPanel$1 = css`
  :host {
    margin: 0;
    border-bottom: solid 1px var(--lumo-contrast-10pct);
  }

  :host(:last-child) {
    border-bottom: none;
  }

  :host([theme~='filled']) {
    border-bottom: none;
  }

  :host([theme~='filled']:not(:last-child)) {
    margin-bottom: 2px;
  }
`;
registerStyles$1("vaadin-accordion-panel", [details, accordionPanel$1], { moduleId: "lumo-accordion-panel" });
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const FocusMixin = dedupingMixin(
  (superclass) => class FocusMixinClass extends superclass {
    /**
     * @protected
     * @return {boolean}
     */
    get _keyboardActive() {
      return isKeyboardActive();
    }
    /** @protected */
    ready() {
      this.addEventListener("focusin", (e2) => {
        if (this._shouldSetFocus(e2)) {
          this._setFocused(true);
        }
      });
      this.addEventListener("focusout", (e2) => {
        if (this._shouldRemoveFocus(e2)) {
          this._setFocused(false);
        }
      });
      super.ready();
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback();
      if (this.hasAttribute("focused")) {
        this._setFocused(false);
      }
    }
    /**
     * Override to change how focused and focus-ring attributes are set.
     *
     * @param {boolean} focused
     * @protected
     */
    _setFocused(focused) {
      this.toggleAttribute("focused", focused);
      this.toggleAttribute("focus-ring", focused && this._keyboardActive);
    }
    /**
     * Override to define if the field receives focus based on the event.
     *
     * @param {FocusEvent} _event
     * @return {boolean}
     * @protected
     */
    _shouldSetFocus(_event) {
      return true;
    }
    /**
     * Override to define if the field loses focus based on the event.
     *
     * @param {FocusEvent} _event
     * @return {boolean}
     * @protected
     */
    _shouldRemoveFocus(_event) {
      return true;
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const TabindexMixin = (superclass) => class TabindexMixinClass extends DisabledMixin(superclass) {
  static get properties() {
    return {
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       *
       * @protected
       */
      tabindex: {
        type: Number,
        reflectToAttribute: true,
        observer: "_tabindexChanged"
      },
      /**
       * Stores the last known tabindex since the element has been disabled.
       *
       * @protected
       */
      _lastTabIndex: {
        type: Number
      }
    };
  }
  /**
   * When the element gets disabled, the observer saves the last known tabindex
   * and makes the element not focusable by setting tabindex to -1.
   * As soon as the element gets enabled, the observer restores the last known tabindex
   * so that the element can be focusable again.
   *
   * @protected
   * @override
   */
  _disabledChanged(disabled, oldDisabled) {
    super._disabledChanged(disabled, oldDisabled);
    if (disabled) {
      if (this.tabindex !== void 0) {
        this._lastTabIndex = this.tabindex;
      }
      this.tabindex = -1;
    } else if (oldDisabled) {
      this.tabindex = this._lastTabIndex;
    }
  }
  /**
   * When the user has changed tabindex while the element is disabled,
   * the observer reverts tabindex to -1 and rather saves the new tabindex value to apply it later.
   * The new value will be applied as soon as the element becomes enabled.
   *
   * @protected
   */
  _tabindexChanged(tabindex) {
    if (this.disabled && tabindex !== -1) {
      this._lastTabIndex = tabindex;
      this.tabindex = -1;
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DelegateFocusMixin = dedupingMixin(
  (superclass) => class DelegateFocusMixinClass extends FocusMixin(TabindexMixin(superclass)) {
    static get properties() {
      return {
        /**
         * Specify that this control should have input focus when the page loads.
         */
        autofocus: {
          type: Boolean
        },
        /**
         * A reference to the focusable element controlled by the mixin.
         * It can be an input, textarea, button or any element with tabindex > -1.
         *
         * Any component implementing this mixin is expected to provide it
         * by using `this._setFocusElement(input)` Polymer API.
         *
         * Toggling `tabindex` attribute on the host element propagates its value to `focusElement`.
         *
         * @protected
         * @type {!HTMLElement}
         */
        focusElement: {
          type: Object,
          readOnly: true,
          observer: "_focusElementChanged"
        },
        /**
         * Override the property from `TabIndexMixin`
         * to ensure the `tabindex` attribute of the focus element
         * will be restored to `0` after re-enabling the element.
         *
         * @protected
         * @override
         */
        _lastTabIndex: {
          value: 0
        }
      };
    }
    constructor() {
      super();
      this._boundOnBlur = this._onBlur.bind(this);
      this._boundOnFocus = this._onFocus.bind(this);
    }
    /** @protected */
    ready() {
      super.ready();
      if (this.autofocus && !this.disabled) {
        requestAnimationFrame(() => {
          this.focus();
          this.setAttribute("focus-ring", "");
        });
      }
    }
    /**
     * @protected
     * @override
     */
    focus() {
      if (this.focusElement && !this.disabled) {
        this.focusElement.focus();
      }
    }
    /**
     * @protected
     * @override
     */
    blur() {
      if (this.focusElement) {
        this.focusElement.blur();
      }
    }
    /**
     * @protected
     * @override
     */
    click() {
      if (this.focusElement && !this.disabled) {
        this.focusElement.click();
      }
    }
    /** @protected */
    _focusElementChanged(element, oldElement) {
      if (element) {
        element.disabled = this.disabled;
        this._addFocusListeners(element);
        this.__forwardTabIndex(this.tabindex);
      } else if (oldElement) {
        this._removeFocusListeners(oldElement);
      }
    }
    /**
     * @param {HTMLElement} element
     * @protected
     */
    _addFocusListeners(element) {
      element.addEventListener("blur", this._boundOnBlur);
      element.addEventListener("focus", this._boundOnFocus);
    }
    /**
     * @param {HTMLElement} element
     * @protected
     */
    _removeFocusListeners(element) {
      element.removeEventListener("blur", this._boundOnBlur);
      element.removeEventListener("focus", this._boundOnFocus);
    }
    /**
     * Focus event does not bubble, so we dispatch it manually
     * on the host element to support adding focus listeners
     * when the focusable element is placed in light DOM.
     * @param {FocusEvent} event
     * @protected
     */
    _onFocus(event) {
      event.stopPropagation();
      this.dispatchEvent(new Event("focus"));
    }
    /**
     * Blur event does not bubble, so we dispatch it manually
     * on the host element to support adding blur listeners
     * when the focusable element is placed in light DOM.
     * @param {FocusEvent} event
     * @protected
     */
    _onBlur(event) {
      event.stopPropagation();
      this.dispatchEvent(new Event("blur"));
    }
    /**
     * @param {FocusEvent} event
     * @return {boolean}
     * @protected
     * @override
     */
    _shouldSetFocus(event) {
      return event.target === this.focusElement;
    }
    /**
     * @param {FocusEvent} event
     * @return {boolean}
     * @protected
     * @override
     */
    _shouldRemoveFocus(event) {
      return event.target === this.focusElement;
    }
    /**
     * @param {boolean} disabled
     * @param {boolean} oldDisabled
     * @protected
     * @override
     */
    _disabledChanged(disabled, oldDisabled) {
      super._disabledChanged(disabled, oldDisabled);
      if (this.focusElement) {
        this.focusElement.disabled = disabled;
      }
      if (disabled) {
        this.blur();
      }
    }
    /**
     * Override an observer from `TabindexMixin`.
     * Do not call super to remove tabindex attribute
     * from the host after it has been forwarded.
     * @param {string} tabindex
     * @protected
     * @override
     */
    _tabindexChanged(tabindex) {
      this.__forwardTabIndex(tabindex);
    }
    /** @private */
    __forwardTabIndex(tabindex) {
      if (tabindex !== void 0 && this.focusElement) {
        this.focusElement.tabIndex = tabindex;
        if (tabindex !== -1) {
          this.tabindex = void 0;
        }
      }
      if (this.disabled && tabindex) {
        if (tabindex !== -1) {
          this._lastTabIndex = tabindex;
        }
        this.tabindex = void 0;
      }
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DelegateStateMixin = dedupingMixin(
  (superclass) => class DelegateStateMixinClass extends superclass {
    static get properties() {
      return {
        /**
         * A target element to which attributes and properties are delegated.
         * @protected
         */
        stateTarget: {
          type: Object,
          observer: "_stateTargetChanged"
        }
      };
    }
    /**
     * An array of the host attributes to delegate to the target element.
     */
    static get delegateAttrs() {
      return [];
    }
    /**
     * An array of the host properties to delegate to the target element.
     */
    static get delegateProps() {
      return [];
    }
    /** @protected */
    ready() {
      super.ready();
      this._createDelegateAttrsObserver();
      this._createDelegatePropsObserver();
    }
    /** @protected */
    _stateTargetChanged(target) {
      if (target) {
        this._ensureAttrsDelegated();
        this._ensurePropsDelegated();
      }
    }
    /** @protected */
    _createDelegateAttrsObserver() {
      this._createMethodObserver(`_delegateAttrsChanged(${this.constructor.delegateAttrs.join(", ")})`);
    }
    /** @protected */
    _createDelegatePropsObserver() {
      this._createMethodObserver(`_delegatePropsChanged(${this.constructor.delegateProps.join(", ")})`);
    }
    /** @protected */
    _ensureAttrsDelegated() {
      this.constructor.delegateAttrs.forEach((name) => {
        this._delegateAttribute(name, this[name]);
      });
    }
    /** @protected */
    _ensurePropsDelegated() {
      this.constructor.delegateProps.forEach((name) => {
        this._delegateProperty(name, this[name]);
      });
    }
    /** @protected */
    _delegateAttrsChanged(...values) {
      this.constructor.delegateAttrs.forEach((name, index) => {
        this._delegateAttribute(name, values[index]);
      });
    }
    /** @protected */
    _delegatePropsChanged(...values) {
      this.constructor.delegateProps.forEach((name, index) => {
        this._delegateProperty(name, values[index]);
      });
    }
    /** @protected */
    _delegateAttribute(name, value) {
      if (!this.stateTarget) {
        return;
      }
      if (name === "invalid") {
        this._delegateAttribute("aria-invalid", value ? "true" : false);
      }
      if (typeof value === "boolean") {
        this.stateTarget.toggleAttribute(name, value);
      } else if (value) {
        this.stateTarget.setAttribute(name, value);
      } else {
        this.stateTarget.removeAttribute(name);
      }
    }
    /** @protected */
    _delegateProperty(name, value) {
      if (!this.stateTarget) {
        return;
      }
      this.stateTarget[name] = value;
    }
  }
);
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SlotObserver {
  constructor(slot, callback) {
    this.slot = slot;
    this.callback = callback;
    this._storedNodes = [];
    this._connected = false;
    this._scheduled = false;
    this._boundSchedule = () => {
      this._schedule();
    };
    this.connect();
    this._schedule();
  }
  /**
   * Activates an observer. This method is automatically called when
   * a `SlotObserver` is created. It should only be called to  re-activate
   * an observer that has been deactivated via the `disconnect` method.
   */
  connect() {
    this.slot.addEventListener("slotchange", this._boundSchedule);
    this._connected = true;
  }
  /**
   * Deactivates the observer. After calling this method the observer callback
   * will not be called when changes to slotted nodes occur. The `connect` method
   * may be subsequently called to reactivate the observer.
   */
  disconnect() {
    this.slot.removeEventListener("slotchange", this._boundSchedule);
    this._connected = false;
  }
  /** @private */
  _schedule() {
    if (!this._scheduled) {
      this._scheduled = true;
      queueMicrotask(() => {
        this.flush();
      });
    }
  }
  /**
   * Run the observer callback synchronously.
   */
  flush() {
    if (!this._connected) {
      return;
    }
    this._scheduled = false;
    this._processNodes();
  }
  /** @private */
  _processNodes() {
    const currentNodes = this.slot.assignedNodes({ flatten: true });
    let addedNodes = [];
    const removedNodes = [];
    const movedNodes = [];
    if (currentNodes.length) {
      addedNodes = currentNodes.filter((node) => !this._storedNodes.includes(node));
    }
    if (this._storedNodes.length) {
      this._storedNodes.forEach((node, index) => {
        const idx = currentNodes.indexOf(node);
        if (idx === -1) {
          removedNodes.push(node);
        } else if (idx !== index) {
          movedNodes.push(node);
        }
      });
    }
    if (addedNodes.length || removedNodes.length || movedNodes.length) {
      this.callback({ addedNodes, currentNodes, movedNodes, removedNodes });
    }
    this._storedNodes = currentNodes;
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let uniqueId = 0;
function generateUniqueId() {
  return uniqueId++;
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SlotController extends EventTarget {
  /**
   * Ensure that every instance has unique ID.
   *
   * @param {HTMLElement} host
   * @param {string} slotName
   * @return {string}
   * @protected
   */
  static generateId(host, prefix = "default") {
    return `${prefix}-${host.localName}-${generateUniqueId()}`;
  }
  constructor(host, slotName, tagName, config = {}) {
    super();
    const { initializer, multiple, observe, useUniqueId, uniqueIdPrefix } = config;
    this.host = host;
    this.slotName = slotName;
    this.tagName = tagName;
    this.observe = typeof observe === "boolean" ? observe : true;
    this.multiple = typeof multiple === "boolean" ? multiple : false;
    this.slotInitializer = initializer;
    if (multiple) {
      this.nodes = [];
    }
    if (useUniqueId) {
      this.defaultId = this.constructor.generateId(host, uniqueIdPrefix || slotName);
    }
  }
  hostConnected() {
    if (!this.initialized) {
      if (this.multiple) {
        this.initMultiple();
      } else {
        this.initSingle();
      }
      if (this.observe) {
        this.observeSlot();
      }
      this.initialized = true;
    }
  }
  /** @protected */
  initSingle() {
    let node = this.getSlotChild();
    if (!node) {
      node = this.attachDefaultNode();
      this.initNode(node);
    } else {
      this.node = node;
      this.initAddedNode(node);
    }
  }
  /** @protected */
  initMultiple() {
    const children = this.getSlotChildren();
    if (children.length === 0) {
      const defaultNode = this.attachDefaultNode();
      if (defaultNode) {
        this.nodes = [defaultNode];
        this.initNode(defaultNode);
      }
    } else {
      this.nodes = children;
      children.forEach((node) => {
        this.initAddedNode(node);
      });
    }
  }
  /**
   * Create and attach default node using the provided tag name, if any.
   * @return {Node | undefined}
   * @protected
   */
  attachDefaultNode() {
    const { host, slotName, tagName } = this;
    let node = this.defaultNode;
    if (!node && tagName) {
      node = document.createElement(tagName);
      if (node instanceof Element) {
        if (slotName !== "") {
          node.setAttribute("slot", slotName);
        }
        this.defaultNode = node;
      }
    }
    if (node) {
      this.node = node;
      host.appendChild(node);
    }
    return node;
  }
  /**
   * Return the list of nodes matching the slot managed by the controller.
   * @return {Node}
   */
  getSlotChildren() {
    const { slotName } = this;
    return Array.from(this.host.childNodes).filter((node) => {
      return node.nodeType === Node.ELEMENT_NODE && node.slot === slotName || node.nodeType === Node.TEXT_NODE && node.textContent.trim() && slotName === "";
    });
  }
  /**
   * Return a reference to the node managed by the controller.
   * @return {Node}
   */
  getSlotChild() {
    return this.getSlotChildren()[0];
  }
  /**
   * Run `slotInitializer` for the node managed by the controller.
   *
   * @param {Node} node
   * @protected
   */
  initNode(node) {
    const { slotInitializer } = this;
    if (slotInitializer) {
      slotInitializer(node, this.host);
    }
  }
  /**
   * Override to initialize the newly added custom node.
   *
   * @param {Node} _node
   * @protected
   */
  initCustomNode(_node) {
  }
  /**
   * Override to teardown slotted node when it's removed.
   *
   * @param {Node} _node
   * @protected
   */
  teardownNode(_node) {
  }
  /**
   * Run both `initCustomNode` and `initNode` for a custom slotted node.
   *
   * @param {Node} node
   * @protected
   */
  initAddedNode(node) {
    if (node !== this.defaultNode) {
      this.initCustomNode(node);
      this.initNode(node);
    }
  }
  /**
   * Setup the observer to manage slot content changes.
   * @protected
   */
  observeSlot() {
    const { slotName } = this;
    const selector = slotName === "" ? "slot:not([name])" : `slot[name=${slotName}]`;
    const slot = this.host.shadowRoot.querySelector(selector);
    this.__slotObserver = new SlotObserver(slot, ({ addedNodes, removedNodes }) => {
      const current = this.multiple ? this.nodes : [this.node];
      const newNodes = addedNodes.filter((node) => !isEmptyTextNode(node) && !current.includes(node));
      if (removedNodes.length) {
        this.nodes = current.filter((node) => !removedNodes.includes(node));
        removedNodes.forEach((node) => {
          this.teardownNode(node);
        });
      }
      if (newNodes && newNodes.length > 0) {
        if (this.multiple) {
          if (this.defaultNode) {
            this.defaultNode.remove();
          }
          this.nodes = [...current, ...newNodes].filter((node) => node !== this.defaultNode);
          newNodes.forEach((node) => {
            this.initAddedNode(node);
          });
        } else {
          if (this.node) {
            this.node.remove();
          }
          this.node = newNodes[0];
          this.initAddedNode(this.node);
        }
      }
    });
  }
}
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TooltipController extends SlotController {
  constructor(host) {
    super(host, "tooltip");
    this.setTarget(host);
  }
  /**
   * Override to initialize the newly added custom tooltip.
   *
   * @param {Node} tooltipNode
   * @protected
   * @override
   */
  initCustomNode(tooltipNode) {
    tooltipNode.target = this.target;
    if (this.ariaTarget !== void 0) {
      tooltipNode.ariaTarget = this.ariaTarget;
    }
    if (this.context !== void 0) {
      tooltipNode.context = this.context;
    }
    if (this.manual !== void 0) {
      tooltipNode.manual = this.manual;
    }
    if (this.opened !== void 0) {
      tooltipNode.opened = this.opened;
    }
    if (this.position !== void 0) {
      tooltipNode._position = this.position;
    }
    if (this.shouldShow !== void 0) {
      tooltipNode.shouldShow = this.shouldShow;
    }
    this.__notifyChange();
  }
  /**
   * Override to notify the host when the tooltip is removed.
   *
   * @param {Node} tooltipNode
   * @protected
   * @override
   */
  teardownNode() {
    this.__notifyChange();
  }
  /**
   * Set an HTML element for linking with the tooltip overlay
   * via `aria-describedby` attribute used by screen readers.
   * @param {HTMLElement} ariaTarget
   */
  setAriaTarget(ariaTarget) {
    this.ariaTarget = ariaTarget;
    const tooltipNode = this.node;
    if (tooltipNode) {
      tooltipNode.ariaTarget = ariaTarget;
    }
  }
  /**
   * Set a context object to be used by generator.
   * @param {object} context
   */
  setContext(context) {
    this.context = context;
    const tooltipNode = this.node;
    if (tooltipNode) {
      tooltipNode.context = context;
    }
  }
  /**
   * Toggle manual state on the slotted tooltip.
   * @param {boolean} manual
   */
  setManual(manual) {
    this.manual = manual;
    const tooltipNode = this.node;
    if (tooltipNode) {
      tooltipNode.manual = manual;
    }
  }
  /**
   * Toggle opened state on the slotted tooltip.
   * @param {boolean} opened
   */
  setOpened(opened) {
    this.opened = opened;
    const tooltipNode = this.node;
    if (tooltipNode) {
      tooltipNode.opened = opened;
    }
  }
  /**
   * Set default position for the slotted tooltip.
   * This can be overridden by setting the position
   * using corresponding property or attribute.
   * @param {string} position
   */
  setPosition(position) {
    this.position = position;
    const tooltipNode = this.node;
    if (tooltipNode) {
      tooltipNode._position = position;
    }
  }
  /**
   * Set function used to detect whether to show
   * the tooltip based on a condition.
   * @param {Function} shouldShow
   */
  setShouldShow(shouldShow) {
    this.shouldShow = shouldShow;
    const tooltipNode = this.node;
    if (tooltipNode) {
      tooltipNode.shouldShow = shouldShow;
    }
  }
  /**
   * Set an HTML element to attach the tooltip to.
   * @param {HTMLElement} target
   */
  setTarget(target) {
    this.target = target;
    const tooltipNode = this.node;
    if (tooltipNode) {
      tooltipNode.target = target;
    }
  }
  /** @private */
  __notifyChange() {
    this.dispatchEvent(new CustomEvent("tooltip-changed", { detail: { node: this.node } }));
  }
}
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SlotChildObserveController extends SlotController {
  constructor(host, slot, tagName, config = {}) {
    super(host, slot, tagName, { ...config, useUniqueId: true });
  }
  /**
   * Override to initialize the newly added custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initCustomNode(node) {
    this.__updateNodeId(node);
    this.__notifyChange(node);
  }
  /**
   * Override to notify the controller host about removal of
   * the custom node, and to apply the default one if needed.
   *
   * @param {Node} _node
   * @protected
   * @override
   */
  teardownNode(_node) {
    const node = this.getSlotChild();
    if (node && node !== this.defaultNode) {
      this.__notifyChange(node);
    } else {
      this.restoreDefaultNode();
      this.updateDefaultNode(this.node);
    }
  }
  /**
   * Override method inherited from `SlotMixin`
   * to set ID attribute on the default node.
   *
   * @return {Node}
   * @protected
   * @override
   */
  attachDefaultNode() {
    const node = super.attachDefaultNode();
    if (node) {
      this.__updateNodeId(node);
    }
    return node;
  }
  /**
   * Override to restore default node when a custom one is removed.
   *
   * @protected
   */
  restoreDefaultNode() {
  }
  /**
   * Override to update default node text on property change.
   *
   * @param {Node} node
   * @protected
   */
  updateDefaultNode(node) {
    this.__notifyChange(node);
  }
  /**
   * Setup the mutation observer on the node to update ID and notify host.
   * Node doesn't get observed automatically until this method is called.
   *
   * @param {Node} node
   * @protected
   */
  observeNode(node) {
    if (this.__nodeObserver) {
      this.__nodeObserver.disconnect();
    }
    this.__nodeObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        const target = mutation.target;
        const isCurrentNodeMutation = target === this.node;
        if (mutation.type === "attributes") {
          if (isCurrentNodeMutation) {
            this.__updateNodeId(target);
          }
        } else if (isCurrentNodeMutation || target.parentElement === this.node) {
          this.__notifyChange(this.node);
        }
      });
    });
    this.__nodeObserver.observe(node, {
      attributes: true,
      attributeFilter: ["id"],
      childList: true,
      subtree: true,
      characterData: true
    });
  }
  /**
   * Returns true if a node is an HTML element with children,
   * or is a defined custom element, or has non-empty text.
   *
   * @param {Node} node
   * @return {boolean}
   * @private
   */
  __hasContent(node) {
    if (!node) {
      return false;
    }
    return node.nodeType === Node.ELEMENT_NODE && (customElements.get(node.localName) || node.children.length > 0) || node.textContent && node.textContent.trim() !== "";
  }
  /**
   * Fire an event to notify the controller host about node changes.
   *
   * @param {Node} node
   * @private
   */
  __notifyChange(node) {
    this.dispatchEvent(
      new CustomEvent("slot-content-changed", {
        detail: { hasContent: this.__hasContent(node), node }
      })
    );
  }
  /**
   * Set default ID on the node in case it is an HTML element.
   *
   * @param {Node} node
   * @private
   */
  __updateNodeId(node) {
    const isFirstNode = !this.nodes || node === this.nodes[0];
    if (node.nodeType === Node.ELEMENT_NODE && (!this.multiple || isFirstNode) && !node.id) {
      node.id = this.defaultId;
    }
  }
}
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ContentController extends SlotChildObserveController {
  /**
   * Override method from `SlotController` to change
   * the ID prefix for the default slot content.
   *
   * @param {HTMLElement} host
   * @return {string}
   * @protected
   * @override
   */
  static generateId(host) {
    return super.generateId(host, "content");
  }
  constructor(host) {
    super(host, "", null, { multiple: true });
  }
}
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const CollapsibleMixin = (superClass) => class CollapsibleMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * If true, the collapsible content is visible.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        notify: true
      },
      /**
       * List of elements assigned to the default `<slot>`
       * that represent the collapsible content.
       *
       * @protected
       */
      _contentElements: {
        type: Array
      }
    };
  }
  static get observers() {
    return ["_openedOrContentChanged(opened, _contentElements)"];
  }
  constructor() {
    super();
    this._contentController = new ContentController(this);
    this._contentController.addEventListener("slot-content-changed", (event) => {
      const content = event.target.nodes || [];
      this._contentElements = content.filter((node) => node.parentNode === this);
    });
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(this._contentController);
    this.addEventListener("click", ({ target }) => {
      if (this.disabled) {
        return;
      }
      if (target.localName === "a") {
        return;
      }
      const summary = this.focusElement;
      if (summary && (target === summary || summary.contains(target))) {
        this.opened = !this.opened;
      }
    });
  }
  /** @private */
  _openedOrContentChanged(opened, elements) {
    if (elements) {
      elements.forEach((el) => {
        el.setAttribute("aria-hidden", opened ? "false" : "true");
      });
    }
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SummaryController extends SlotChildObserveController {
  constructor(host, tagName) {
    super(host, "summary", tagName);
  }
  /**
   * Set summary based on corresponding host property.
   *
   * @param {string} summary
   */
  setSummary(summary) {
    this.summary = summary;
    const summaryNode = this.getSlotChild();
    if (!summaryNode) {
      this.restoreDefaultNode();
    }
    if (this.node === this.defaultNode) {
      this.updateDefaultNode(this.node);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to restore and observe the default summary element.
   *
   * @protected
   * @override
   */
  restoreDefaultNode() {
    const { summary } = this;
    if (summary && summary.trim() !== "") {
      this.attachDefaultNode();
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the default summary element text content.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(node) {
    if (node) {
      node.textContent = this.summary;
    }
    super.updateDefaultNode(node);
  }
}
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const AccordionPanelMixin = (superClass) => class AccordionPanelMixinClass extends CollapsibleMixin(DelegateFocusMixin(DelegateStateMixin(superClass))) {
  static get properties() {
    return {
      /**
       * A text that is displayed in the heading, if no
       * element is assigned to the `summary` slot.
       */
      summary: {
        type: String,
        observer: "_summaryChanged"
      }
    };
  }
  static get observers() {
    return ["__updateAriaAttributes(focusElement, _contentElements)"];
  }
  static get delegateProps() {
    return ["disabled", "opened", "_theme"];
  }
  constructor() {
    super();
    this._summaryController = new SummaryController(this, "vaadin-accordion-heading");
    this._summaryController.addEventListener("slot-content-changed", (event) => {
      const { node } = event.target;
      this._setFocusElement(node);
      this.stateTarget = node;
      this._tooltipController.setTarget(node);
    });
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("bottom-start");
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(this._summaryController);
    this.addController(this._tooltipController);
  }
  /**
   * Override method from `DelegateStateMixin` to set delegate `theme`
   * using attribute instead of property (needed for the Lit version).
   * @protected
   * @override
   */
  _delegateProperty(name, value) {
    if (!this.stateTarget) {
      return;
    }
    if (name === "_theme") {
      this._delegateAttribute("theme", value);
      return;
    }
    super._delegateProperty(name, value);
  }
  /**
   * Override method inherited from `DisabledMixin`
   * to not set `aria-disabled` on the host element.
   *
   * @protected
   * @override
   */
  _setAriaDisabled() {
  }
  /** @private */
  _summaryChanged(summary) {
    this._summaryController.setSummary(summary);
  }
  /** @private */
  __updateAriaAttributes(focusElement, contentElements) {
    if (focusElement && contentElements) {
      const node = contentElements[0];
      if (node) {
        node.setAttribute("role", "region");
        node.setAttribute("aria-labelledby", focusElement.id);
      }
      if (node && node.id) {
        focusElement.setAttribute("aria-controls", node.id);
      } else {
        focusElement.removeAttribute("aria-controls");
      }
    }
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const accordionPanel = css`
  :host {
    display: block;
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='content'] {
    display: none;
    overflow: hidden;
  }

  :host([opened]) [part='content'] {
    display: block;
    overflow: visible;
  }
`;
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-accordion-panel", accordionPanel, { moduleId: "vaadin-accordion-panel-styles" });
class AccordionPanel extends AccordionPanelMixin(ThemableMixin(ControllerMixin(PolymerElement))) {
  static get is() {
    return "vaadin-accordion-panel";
  }
  static get template() {
    return html`
      <slot name="summary"></slot>

      <div part="content">
        <slot></slot>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
}
defineCustomElement(AccordionPanel);
const DEV_MODE_CODE_REGEXP = /\/\*[\*!]\s+vaadin-dev-mode:start([\s\S]*)vaadin-dev-mode:end\s+\*\*\//i;
const FlowClients = window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients;
function isMinified() {
  function test() {
    return true;
  }
  return uncommentAndRun(test);
}
function isDevelopmentMode() {
  try {
    if (isForcedDevelopmentMode()) {
      return true;
    }
    if (!isLocalhost()) {
      return false;
    }
    if (FlowClients) {
      return !isFlowProductionMode();
    }
    return !isMinified();
  } catch (e2) {
    return false;
  }
}
function isForcedDevelopmentMode() {
  return localStorage.getItem("vaadin.developmentmode.force");
}
function isLocalhost() {
  return ["localhost", "127.0.0.1"].indexOf(window.location.hostname) >= 0;
}
function isFlowProductionMode() {
  if (FlowClients) {
    const productionModeApps = Object.keys(FlowClients).map((key) => FlowClients[key]).filter((client) => client.productionMode);
    if (productionModeApps.length > 0) {
      return true;
    }
  }
  return false;
}
function uncommentAndRun(callback, args) {
  if (typeof callback !== "function") {
    return;
  }
  const match2 = DEV_MODE_CODE_REGEXP.exec(callback.toString());
  if (match2) {
    try {
      callback = new Function(match2[1]);
    } catch (e2) {
      console.log("vaadin-development-mode-detector: uncommentAndRun() failed", e2);
    }
  }
  return callback(args);
}
window["Vaadin"] = window["Vaadin"] || {};
const runIfDevelopmentMode = function(callback, args) {
  if (window.Vaadin.developmentMode) {
    return uncommentAndRun(callback, args);
  }
};
if (window.Vaadin.developmentMode === void 0) {
  window.Vaadin.developmentMode = isDevelopmentMode();
}
function maybeGatherAndSendStats() {
  /*! vaadin-dev-mode:start
    (function () {
  'use strict';
  
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  
  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  
  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
  
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  
  var getPolymerVersion = function getPolymerVersion() {
    return window.Polymer && window.Polymer.version;
  };
  
  var StatisticsGatherer = function () {
    function StatisticsGatherer(logger) {
      classCallCheck(this, StatisticsGatherer);
  
      this.now = new Date().getTime();
      this.logger = logger;
    }
  
    createClass(StatisticsGatherer, [{
      key: 'frameworkVersionDetectors',
      value: function frameworkVersionDetectors() {
        return {
          'Flow': function Flow() {
            if (window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients) {
              var flowVersions = Object.keys(window.Vaadin.Flow.clients).map(function (key) {
                return window.Vaadin.Flow.clients[key];
              }).filter(function (client) {
                return client.getVersionInfo;
              }).map(function (client) {
                return client.getVersionInfo().flow;
              });
              if (flowVersions.length > 0) {
                return flowVersions[0];
              }
            }
          },
          'Vaadin Framework': function VaadinFramework() {
            if (window.vaadin && window.vaadin.clients) {
              var frameworkVersions = Object.values(window.vaadin.clients).filter(function (client) {
                return client.getVersionInfo;
              }).map(function (client) {
                return client.getVersionInfo().vaadinVersion;
              });
              if (frameworkVersions.length > 0) {
                return frameworkVersions[0];
              }
            }
          },
          'AngularJs': function AngularJs() {
            if (window.angular && window.angular.version && window.angular.version) {
              return window.angular.version.full;
            }
          },
          'Angular': function Angular() {
            if (window.ng) {
              var tags = document.querySelectorAll("[ng-version]");
              if (tags.length > 0) {
                return tags[0].getAttribute("ng-version");
              }
              return "Unknown";
            }
          },
          'Backbone.js': function BackboneJs() {
            if (window.Backbone) {
              return window.Backbone.VERSION;
            }
          },
          'React': function React() {
            var reactSelector = '[data-reactroot], [data-reactid]';
            if (!!document.querySelector(reactSelector)) {
              // React does not publish the version by default
              return "unknown";
            }
          },
          'Ember': function Ember() {
            if (window.Em && window.Em.VERSION) {
              return window.Em.VERSION;
            } else if (window.Ember && window.Ember.VERSION) {
              return window.Ember.VERSION;
            }
          },
          'jQuery': function (_jQuery) {
            function jQuery() {
              return _jQuery.apply(this, arguments);
            }
  
            jQuery.toString = function () {
              return _jQuery.toString();
            };
  
            return jQuery;
          }(function () {
            if (typeof jQuery === 'function' && jQuery.prototype.jquery !== undefined) {
              return jQuery.prototype.jquery;
            }
          }),
          'Polymer': function Polymer() {
            var version = getPolymerVersion();
            if (version) {
              return version;
            }
          },
          'LitElement': function LitElement() {
            var version = window.litElementVersions && window.litElementVersions[0];
            if (version) {
              return version;
            }
          },
          'LitHtml': function LitHtml() {
            var version = window.litHtmlVersions && window.litHtmlVersions[0];
            if (version) {
              return version;
            }
          },
          'Vue.js': function VueJs() {
            if (window.Vue) {
              return window.Vue.version;
            }
          }
        };
      }
    }, {
      key: 'getUsedVaadinElements',
      value: function getUsedVaadinElements(elements) {
        var version = getPolymerVersion();
        var elementClasses = void 0;
        // NOTE: In case you edit the code here, YOU MUST UPDATE any statistics reporting code in Flow.
        // Check all locations calling the method getEntries() in
        // https://github.com/vaadin/flow/blob/master/flow-server/src/main/java/com/vaadin/flow/internal/UsageStatistics.java#L106
        // Currently it is only used by BootstrapHandler.
        if (version && version.indexOf('2') === 0) {
          // Polymer 2: components classes are stored in window.Vaadin
          elementClasses = Object.keys(window.Vaadin).map(function (c) {
            return window.Vaadin[c];
          }).filter(function (c) {
            return c.is;
          });
        } else {
          // Polymer 3: components classes are stored in window.Vaadin.registrations
          elementClasses = window.Vaadin.registrations || [];
        }
        elementClasses.forEach(function (klass) {
          var version = klass.version ? klass.version : "0.0.0";
          elements[klass.is] = { version: version };
        });
      }
    }, {
      key: 'getUsedVaadinThemes',
      value: function getUsedVaadinThemes(themes) {
        ['Lumo', 'Material'].forEach(function (themeName) {
          var theme;
          var version = getPolymerVersion();
          if (version && version.indexOf('2') === 0) {
            // Polymer 2: themes are stored in window.Vaadin
            theme = window.Vaadin[themeName];
          } else {
            // Polymer 3: themes are stored in custom element registry
            theme = customElements.get('vaadin-' + themeName.toLowerCase() + '-styles');
          }
          if (theme && theme.version) {
            themes[themeName] = { version: theme.version };
          }
        });
      }
    }, {
      key: 'getFrameworks',
      value: function getFrameworks(frameworks) {
        var detectors = this.frameworkVersionDetectors();
        Object.keys(detectors).forEach(function (framework) {
          var detector = detectors[framework];
          try {
            var version = detector();
            if (version) {
              frameworks[framework] = { version: version };
            }
          } catch (e) {}
        });
      }
    }, {
      key: 'gather',
      value: function gather(storage) {
        var storedStats = storage.read();
        var gatheredStats = {};
        var types = ["elements", "frameworks", "themes"];
  
        types.forEach(function (type) {
          gatheredStats[type] = {};
          if (!storedStats[type]) {
            storedStats[type] = {};
          }
        });
  
        var previousStats = JSON.stringify(storedStats);
  
        this.getUsedVaadinElements(gatheredStats.elements);
        this.getFrameworks(gatheredStats.frameworks);
        this.getUsedVaadinThemes(gatheredStats.themes);
  
        var now = this.now;
        types.forEach(function (type) {
          var keys = Object.keys(gatheredStats[type]);
          keys.forEach(function (key) {
            if (!storedStats[type][key] || _typeof(storedStats[type][key]) != _typeof({})) {
              storedStats[type][key] = { firstUsed: now };
            }
            // Discards any previously logged version number
            storedStats[type][key].version = gatheredStats[type][key].version;
            storedStats[type][key].lastUsed = now;
          });
        });
  
        var newStats = JSON.stringify(storedStats);
        storage.write(newStats);
        if (newStats != previousStats && Object.keys(storedStats).length > 0) {
          this.logger.debug("New stats: " + newStats);
        }
      }
    }]);
    return StatisticsGatherer;
  }();
  
  var StatisticsStorage = function () {
    function StatisticsStorage(key) {
      classCallCheck(this, StatisticsStorage);
  
      this.key = key;
    }
  
    createClass(StatisticsStorage, [{
      key: 'read',
      value: function read() {
        var localStorageStatsString = localStorage.getItem(this.key);
        try {
          return JSON.parse(localStorageStatsString ? localStorageStatsString : '{}');
        } catch (e) {
          return {};
        }
      }
    }, {
      key: 'write',
      value: function write(data) {
        localStorage.setItem(this.key, data);
      }
    }, {
      key: 'clear',
      value: function clear() {
        localStorage.removeItem(this.key);
      }
    }, {
      key: 'isEmpty',
      value: function isEmpty() {
        var storedStats = this.read();
        var empty = true;
        Object.keys(storedStats).forEach(function (key) {
          if (Object.keys(storedStats[key]).length > 0) {
            empty = false;
          }
        });
  
        return empty;
      }
    }]);
    return StatisticsStorage;
  }();
  
  var StatisticsSender = function () {
    function StatisticsSender(url, logger) {
      classCallCheck(this, StatisticsSender);
  
      this.url = url;
      this.logger = logger;
    }
  
    createClass(StatisticsSender, [{
      key: 'send',
      value: function send(data, errorHandler) {
        var logger = this.logger;
  
        if (navigator.onLine === false) {
          logger.debug("Offline, can't send");
          errorHandler();
          return;
        }
        logger.debug("Sending data to " + this.url);
  
        var req = new XMLHttpRequest();
        req.withCredentials = true;
        req.addEventListener("load", function () {
          // Stats sent, nothing more to do
          logger.debug("Response: " + req.responseText);
        });
        req.addEventListener("error", function () {
          logger.debug("Send failed");
          errorHandler();
        });
        req.addEventListener("abort", function () {
          logger.debug("Send aborted");
          errorHandler();
        });
        req.open("POST", this.url);
        req.setRequestHeader("Content-Type", "application/json");
        req.send(data);
      }
    }]);
    return StatisticsSender;
  }();
  
  var StatisticsLogger = function () {
    function StatisticsLogger(id) {
      classCallCheck(this, StatisticsLogger);
  
      this.id = id;
    }
  
    createClass(StatisticsLogger, [{
      key: '_isDebug',
      value: function _isDebug() {
        return localStorage.getItem("vaadin." + this.id + ".debug");
      }
    }, {
      key: 'debug',
      value: function debug(msg) {
        if (this._isDebug()) {
          console.info(this.id + ": " + msg);
        }
      }
    }]);
    return StatisticsLogger;
  }();
  
  var UsageStatistics = function () {
    function UsageStatistics() {
      classCallCheck(this, UsageStatistics);
  
      this.now = new Date();
      this.timeNow = this.now.getTime();
      this.gatherDelay = 10; // Delay between loading this file and gathering stats
      this.initialDelay = 24 * 60 * 60;
  
      this.logger = new StatisticsLogger("statistics");
      this.storage = new StatisticsStorage("vaadin.statistics.basket");
      this.gatherer = new StatisticsGatherer(this.logger);
      this.sender = new StatisticsSender("https://tools.vaadin.com/usage-stats/submit", this.logger);
    }
  
    createClass(UsageStatistics, [{
      key: 'maybeGatherAndSend',
      value: function maybeGatherAndSend() {
        var _this = this;
  
        if (localStorage.getItem(UsageStatistics.optOutKey)) {
          return;
        }
        this.gatherer.gather(this.storage);
        setTimeout(function () {
          _this.maybeSend();
        }, this.gatherDelay * 1000);
      }
    }, {
      key: 'lottery',
      value: function lottery() {
        return true;
      }
    }, {
      key: 'currentMonth',
      value: function currentMonth() {
        return this.now.getYear() * 12 + this.now.getMonth();
      }
    }, {
      key: 'maybeSend',
      value: function maybeSend() {
        var firstUse = Number(localStorage.getItem(UsageStatistics.firstUseKey));
        var monthProcessed = Number(localStorage.getItem(UsageStatistics.monthProcessedKey));
  
        if (!firstUse) {
          // Use a grace period to avoid interfering with tests, incognito mode etc
          firstUse = this.timeNow;
          localStorage.setItem(UsageStatistics.firstUseKey, firstUse);
        }
  
        if (this.timeNow < firstUse + this.initialDelay * 1000) {
          this.logger.debug("No statistics will be sent until the initial delay of " + this.initialDelay + "s has passed");
          return;
        }
        if (this.currentMonth() <= monthProcessed) {
          this.logger.debug("This month has already been processed");
          return;
        }
        localStorage.setItem(UsageStatistics.monthProcessedKey, this.currentMonth());
        // Use random sampling
        if (this.lottery()) {
          this.logger.debug("Congratulations, we have a winner!");
        } else {
          this.logger.debug("Sorry, no stats from you this time");
          return;
        }
  
        this.send();
      }
    }, {
      key: 'send',
      value: function send() {
        // Ensure we have the latest data
        this.gatherer.gather(this.storage);
  
        // Read, send and clean up
        var data = this.storage.read();
        data["firstUse"] = Number(localStorage.getItem(UsageStatistics.firstUseKey));
        data["usageStatisticsVersion"] = UsageStatistics.version;
        var info = 'This request contains usage statistics gathered from the application running in development mode. \n\nStatistics gathering is automatically disabled and excluded from production builds.\n\nFor details and to opt-out, see https://github.com/vaadin/vaadin-usage-statistics.\n\n\n\n';
        var self = this;
        this.sender.send(info + JSON.stringify(data), function () {
          // Revert the 'month processed' flag
          localStorage.setItem(UsageStatistics.monthProcessedKey, self.currentMonth() - 1);
        });
      }
    }], [{
      key: 'version',
      get: function get$1() {
        return '2.1.2';
      }
    }, {
      key: 'firstUseKey',
      get: function get$1() {
        return 'vaadin.statistics.firstuse';
      }
    }, {
      key: 'monthProcessedKey',
      get: function get$1() {
        return 'vaadin.statistics.monthProcessed';
      }
    }, {
      key: 'optOutKey',
      get: function get$1() {
        return 'vaadin.statistics.optout';
      }
    }]);
    return UsageStatistics;
  }();
  
  try {
    window.Vaadin = window.Vaadin || {};
    window.Vaadin.usageStatsChecker = window.Vaadin.usageStatsChecker || new UsageStatistics();
    window.Vaadin.usageStatsChecker.maybeGatherAndSend();
  } catch (e) {
    // Intentionally ignored as this is not a problem in the app being developed
  }
  
  }());
  
    vaadin-dev-mode:end **/
}
const usageStatistics = function() {
  if (typeof runIfDevelopmentMode === "function") {
    return runIfDevelopmentMode(maybeGatherAndSendStats);
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
if (!window.Vaadin) {
  window.Vaadin = {};
}
if (!window.Vaadin.registrations) {
  window.Vaadin.registrations = [];
}
if (!window.Vaadin.developmentModeCallback) {
  window.Vaadin.developmentModeCallback = {};
}
window.Vaadin.developmentModeCallback["vaadin-usage-statistics"] = function() {
  usageStatistics();
};
let statsJob;
const registered = /* @__PURE__ */ new Set();
const ElementMixin = (superClass) => class VaadinElementMixin extends DirMixin(superClass) {
  /** @protected */
  static finalize() {
    super.finalize();
    const { is } = this;
    if (is && !registered.has(is)) {
      window.Vaadin.registrations.push(this);
      registered.add(is);
      if (window.Vaadin.developmentModeCallback) {
        statsJob = Debouncer$1.debounce(statsJob, idlePeriod, () => {
          window.Vaadin.developmentModeCallback["vaadin-usage-statistics"]();
        });
        enqueueDebouncer$1(statsJob);
      }
    }
  }
  constructor() {
    super();
    if (document.doctype === null) {
      console.warn(
        'Vaadin components require the "standards mode" declaration. Please add <!DOCTYPE html> to the HTML document.'
      );
    }
  }
};
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const KeyboardDirectionMixin = (superclass) => class KeyboardDirectionMixinClass extends KeyboardMixin(superclass) {
  /**
   * @return {Element | null}
   * @protected
   */
  get focused() {
    return (this._getItems() || []).find(isElementFocused);
  }
  /**
   * @return {boolean}
   * @protected
   */
  get _vertical() {
    return true;
  }
  /** @protected */
  focus() {
    const items = this._getItems();
    if (Array.isArray(items)) {
      const idx = this._getAvailableIndex(items, 0, null, (item2) => !isElementHidden(item2));
      if (idx >= 0) {
        this._focus(idx);
      }
    }
  }
  /**
   * Get the list of items participating in keyboard navigation.
   * By default, it treats all the light DOM children as items.
   * Override this method to provide custom list of elements.
   *
   * @return {Element[]}
   * @protected
   */
  _getItems() {
    return Array.from(this.children);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    if (event.metaKey || event.ctrlKey) {
      return;
    }
    const { key } = event;
    const items = this._getItems() || [];
    const currentIdx = items.indexOf(this.focused);
    let idx;
    let increment;
    const isRTL = !this._vertical && this.getAttribute("dir") === "rtl";
    const dirIncrement = isRTL ? -1 : 1;
    if (this.__isPrevKey(key)) {
      increment = -dirIncrement;
      idx = currentIdx - dirIncrement;
    } else if (this.__isNextKey(key)) {
      increment = dirIncrement;
      idx = currentIdx + dirIncrement;
    } else if (key === "Home") {
      increment = 1;
      idx = 0;
    } else if (key === "End") {
      increment = -1;
      idx = items.length - 1;
    }
    idx = this._getAvailableIndex(items, idx, increment, (item2) => !isElementHidden(item2));
    if (idx >= 0) {
      event.preventDefault();
      this._focus(idx, true);
    }
  }
  /**
   * @param {string} key
   * @return {boolean}
   * @private
   */
  __isPrevKey(key) {
    return this._vertical ? key === "ArrowUp" : key === "ArrowLeft";
  }
  /**
   * @param {string} key
   * @return {boolean}
   * @private
   */
  __isNextKey(key) {
    return this._vertical ? key === "ArrowDown" : key === "ArrowRight";
  }
  /**
   * Focus the item at given index. Override this method to add custom logic.
   *
   * @param {number} index
   * @param {boolean} navigating
   * @protected
   */
  _focus(index, navigating = false) {
    const items = this._getItems();
    this._focusItem(items[index], navigating);
  }
  /**
   * Focus the given item. Override this method to add custom logic.
   *
   * @param {Element} item
   * @param {boolean} navigating
   * @protected
   */
  _focusItem(item2) {
    if (item2) {
      item2.focus();
      item2.setAttribute("focus-ring", "");
    }
  }
  /**
   * Returns index of the next item that satisfies the given condition,
   * based on the index of the current item and a numeric increment.
   *
   * @param {Element[]} items - array of items to iterate over
   * @param {number} index - index of the current item
   * @param {number} increment - numeric increment, can be either 1 or -1
   * @param {Function} condition - function used to check the item
   * @return {number}
   * @protected
   */
  _getAvailableIndex(items, index, increment, condition) {
    const totalItems = items.length;
    let idx = index;
    for (let i2 = 0; typeof idx === "number" && i2 < totalItems; i2 += 1, idx += increment || 1) {
      if (idx < 0) {
        idx = totalItems - 1;
      } else if (idx >= totalItems) {
        idx = 0;
      }
      const item2 = items[idx];
      if (!item2.hasAttribute("disabled") && this.__isMatchingItem(item2, condition)) {
        return idx;
      }
    }
    return -1;
  }
  /**
   * Returns true if the item matches condition.
   *
   * @param {Element} item - item to check
   * @param {Function} condition - function used to check the item
   * @return {number}
   * @private
   */
  __isMatchingItem(item2, condition) {
    return typeof condition === "function" ? condition(item2) : true;
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const AccordionMixin = (superClass) => class AccordionMixinClass extends KeyboardDirectionMixin(superClass) {
  static get properties() {
    return {
      /**
       * The index of currently opened panel. First panel is opened by
       * default. Only one panel can be opened at the same time.
       * Setting null or undefined closes all the accordion panels.
       * @type {number}
       */
      opened: {
        type: Number,
        value: 0,
        notify: true,
        reflectToAttribute: true
      },
      /**
       * The list of `<vaadin-accordion-panel>` child elements.
       * It is populated from the elements passed to the light DOM,
       * and updated dynamically when adding or removing panels.
       * @type {!Array<!AccordionPanel>}
       */
      items: {
        type: Array,
        readOnly: true,
        notify: true
      }
    };
  }
  static get observers() {
    return ["_updateItems(items, opened)"];
  }
  constructor() {
    super();
    this._boundUpdateOpened = this._updateOpened.bind(this);
  }
  /**
   * Override getter from `KeyboardDirectionMixin`
   * to check if the heading element has focus.
   *
   * @return {Element | null}
   * @protected
   * @override
   */
  get focused() {
    return (this._getItems() || []).find((item2) => isElementFocused(item2.focusElement));
  }
  /**
   * @protected
   * @override
   */
  focus() {
    if (this._observer) {
      this._observer.flush();
    }
    super.focus();
  }
  /** @protected */
  ready() {
    super.ready();
    const slot = this.shadowRoot.querySelector("slot");
    this._observer = new SlotObserver(slot, (info) => {
      this._setItems(this._filterItems(Array.from(this.children)));
      this._filterItems(info.addedNodes).forEach((el) => {
        el.addEventListener("opened-changed", this._boundUpdateOpened);
      });
    });
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin`
   * to use the stored list of accordion panels as items.
   *
   * @return {Element[]}
   * @protected
   * @override
   */
  _getItems() {
    return this.items;
  }
  /**
   * @param {!Array<!Element>} array
   * @return {!Array<!AccordionPanel>}
   * @protected
   */
  _filterItems(array) {
    return array.filter((el) => el instanceof customElements.get("vaadin-accordion-panel"));
  }
  /** @private */
  _updateItems(items, opened) {
    if (items) {
      const itemToOpen = items[opened];
      items.forEach((item2) => {
        item2.opened = item2 === itemToOpen;
      });
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`
   * to only handle details toggle buttons events.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    if (!this.items.some((item2) => item2.focusElement === event.target)) {
      return;
    }
    super._onKeyDown(event);
  }
  /** @private */
  _updateOpened(e2) {
    const target = this._filterItems(e2.composedPath())[0];
    const idx = this.items.indexOf(target);
    if (e2.detail.value) {
      if (target.disabled || idx === -1) {
        return;
      }
      this.opened = idx;
    } else if (!this.items.some((item2) => item2.opened)) {
      this.opened = null;
    }
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Accordion extends AccordionMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <slot></slot>
    `;
  }
  static get is() {
    return "vaadin-accordion";
  }
}
defineCustomElement(Accordion);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ButtonMixin = (superClass) => class ButtonMixinClass extends ActiveMixin(TabindexMixin(FocusMixin(superClass))) {
  static get properties() {
    return {
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       *
       * @override
       * @protected
       */
      tabindex: {
        type: Number,
        value: 0,
        reflectToAttribute: true
      }
    };
  }
  /**
   * By default, `Space` is the only possible activation key for a focusable HTML element.
   * Nonetheless, the button is an exception as it can be also activated by pressing `Enter`.
   * See the "Keyboard Support" section in https://www.w3.org/TR/wai-aria-practices/examples/button/button.html.
   *
   * @protected
   * @override
   */
  get _activeKeys() {
    return ["Enter", " "];
  }
  /** @protected */
  ready() {
    super.ready();
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", "button");
    }
  }
  /**
   * Since the button component is designed on the base of the `[role=button]` attribute,
   * and doesn't have a native <button> inside, in order to be fully accessible from the keyboard,
   * it should manually fire the `click` event once an activation key is pressed,
   * as it follows from the WAI-ARIA specifications:
   * https://www.w3.org/TR/wai-aria-practices-1.1/#button
   *
   * According to the UI Events specifications,
   * the `click` event should be fired exactly on `keydown`:
   * https://www.w3.org/TR/uievents/#event-type-keydown
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
      return;
    }
    if (this._activeKeys.includes(event.key)) {
      event.preventDefault();
      this.click();
    }
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class DetailsSummary extends ButtonMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-details-summary";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          outline: none;
          white-space: nowrap;
          -webkit-user-select: none;
          -moz-user-select: none;
          user-select: none;
        }

        :host([hidden]) {
          display: none !important;
        }

        :host([disabled]) {
          pointer-events: none;
        }
      </style>
      <span part="toggle" aria-hidden="true"></span>
      <div part="content"><slot></slot></div>
    `;
  }
  static get properties() {
    return {
      /**
       * When true, the element is opened.
       */
      opened: {
        type: Boolean,
        reflectToAttribute: true
      }
    };
  }
}
defineCustomElement(DetailsSummary);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DetailsBaseMixin = (superClass) => class DetailsBaseMixin extends CollapsibleMixin(DelegateFocusMixin(DelegateStateMixin(superClass))) {
  static get properties() {
    return {
      /**
       * A text that is displayed in the summary, if no
       * element is assigned to the `summary` slot.
       */
      summary: {
        type: String,
        observer: "_summaryChanged"
      }
    };
  }
  static get observers() {
    return ["__updateAriaControls(focusElement, _contentElements)", "__updateAriaExpanded(focusElement, opened)"];
  }
  static get delegateProps() {
    return ["disabled", "opened", "_theme"];
  }
  constructor() {
    super();
    this._summaryController = new SummaryController(this, "vaadin-details-summary");
    this._summaryController.addEventListener("slot-content-changed", (event) => {
      const { node } = event.target;
      this._setFocusElement(node);
      this.stateTarget = node;
      this._tooltipController.setTarget(node);
    });
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("bottom-start");
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(this._summaryController);
    this.addController(this._tooltipController);
  }
  /**
   * Override method from `DelegateStateMixin` to set delegate `theme`
   * using attribute instead of property (needed for the Lit version).
   * @protected
   * @override
   */
  _delegateProperty(name, value) {
    if (!this.stateTarget) {
      return;
    }
    if (name === "_theme") {
      this._delegateAttribute("theme", value);
      return;
    }
    super._delegateProperty(name, value);
  }
  /**
   * Override method inherited from `DisabledMixin`
   * to not set `aria-disabled` on the host element.
   *
   * @protected
   * @override
   */
  _setAriaDisabled() {
  }
  /** @private */
  _summaryChanged(summary) {
    this._summaryController.setSummary(summary);
  }
  /** @private */
  __updateAriaControls(summary, contentElements) {
    if (summary && contentElements) {
      const node = contentElements[0];
      if (node && node.id) {
        summary.setAttribute("aria-controls", node.id);
      } else {
        summary.removeAttribute("aria-controls");
      }
    }
  }
  /** @private */
  __updateAriaExpanded(focusElement, opened) {
    if (focusElement) {
      focusElement.setAttribute("aria-expanded", opened ? "true" : "false");
    }
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Details extends DetailsBaseMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='content'] {
          display: none;
        }

        :host([opened]) [part='content'] {
          display: block;
        }
      </style>

      <slot name="summary"></slot>

      <div part="content">
        <slot></slot>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-details";
  }
}
defineCustomElement(Details);
registerStyles$1(
  "vaadin-app-layout",
  css`
    [part='navbar'],
    [part='drawer'] {
      background-color: var(--lumo-base-color);
      background-clip: padding-box;
    }

    [part='navbar'] {
      min-height: var(--lumo-size-xl);
      border-bottom: 1px solid var(--lumo-contrast-10pct);
    }

    [part='navbar'][bottom] {
      border-bottom: none;
      border-top: 1px solid var(--lumo-contrast-10pct);
    }

    [part='drawer'] {
      border-inline-end: 1px solid var(--lumo-contrast-10pct);
    }

    :host([overlay]) [part='drawer'] {
      border-inline-end: none;
      box-shadow: var(--lumo-box-shadow-s);
    }

    :host([primary-section='navbar']) [part='navbar'] {
      border: none;
      background-image: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
    }

    :host([primary-section='drawer']:not([overlay])) [part='drawer'] {
      background-image: linear-gradient(var(--lumo-shade-5pct), var(--lumo-shade-5pct));
    }

    [part='backdrop'] {
      background-color: var(--lumo-shade-20pct);
      opacity: 1;
    }

    [part] ::slotted(h2),
    [part] ::slotted(h3),
    [part] ::slotted(h4) {
      margin-top: var(--lumo-space-xs) !important;
      margin-bottom: var(--lumo-space-xs) !important;
    }
  `,
  { moduleId: "lumo-app-layout" }
);
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function _detectIosNavbar() {
  if (isIOS) {
    const innerHeight = window.innerHeight;
    const innerWidth = window.innerWidth;
    const landscape = innerWidth > innerHeight;
    const clientHeight = document.documentElement.clientHeight;
    if (landscape && clientHeight > innerHeight) {
      document.documentElement.style.setProperty("--vaadin-viewport-offset-bottom", `${clientHeight - innerHeight}px`);
    } else {
      document.documentElement.style.setProperty("--vaadin-viewport-offset-bottom", "");
    }
  }
}
_detectIosNavbar();
window.addEventListener("resize", _detectIosNavbar);
const template$7 = document.createElement("template");
template$7.innerHTML = `
  <style>
    /* Use units so that the values can be used in calc() */
    html {
      --safe-area-inset-top: env(safe-area-inset-top, 0px);
      --safe-area-inset-right: env(safe-area-inset-right, 0px);
      --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
      --safe-area-inset-left: env(safe-area-inset-left, 0px);
    }
  </style>
`;
document.head.appendChild(template$7.content);
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class AppLayout extends ElementMixin(ThemableMixin(ControllerMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          box-sizing: border-box;
          height: 100%;
          --vaadin-app-layout-transition: 200ms;
          transition: padding var(--vaadin-app-layout-transition);
          --_vaadin-app-layout-drawer-width: var(--vaadin-app-layout-drawer-width, 16em);
          --vaadin-app-layout-touch-optimized: false;
          --vaadin-app-layout-navbar-offset-top: var(--_vaadin-app-layout-navbar-offset-size);
          --vaadin-app-layout-navbar-offset-bottom: var(--_vaadin-app-layout-navbar-offset-size-bottom);
          padding-block: var(--vaadin-app-layout-navbar-offset-top) var(--vaadin-app-layout-navbar-offset-bottom);
          padding-inline-start: var(--vaadin-app-layout-navbar-offset-left);
        }

        :host([hidden]),
        [hidden] {
          display: none !important;
        }

        :host([no-anim]) {
          --vaadin-app-layout-transition: none !important;
        }

        :host([drawer-opened]) {
          --vaadin-app-layout-drawer-offset-left: var(--_vaadin-app-layout-drawer-offset-size);
        }

        :host([overlay]) {
          --vaadin-app-layout-drawer-offset-left: 0;
          --vaadin-app-layout-navbar-offset-left: 0;
        }

        :host(:not([no-scroll])) [content] {
          overflow: auto;
        }

        [content] {
          height: 100%;
        }

        @media (pointer: coarse) and (max-width: 800px) and (min-height: 500px) {
          :host {
            --vaadin-app-layout-touch-optimized: true;
          }
        }

        [part='navbar'] {
          position: fixed;
          display: flex;
          align-items: center;
          top: 0;
          inset-inline: 0;
          transition: inset-inline-start var(--vaadin-app-layout-transition);
          padding-top: var(--safe-area-inset-top);
          padding-left: var(--safe-area-inset-left);
          padding-right: var(--safe-area-inset-right);
          z-index: 1;
        }

        :host([primary-section='drawer'][drawer-opened]:not([overlay])) [part='navbar'] {
          inset-inline-start: var(--vaadin-app-layout-drawer-offset-left, 0);
        }

        :host([primary-section='drawer']) [part='drawer'] {
          top: 0;
        }

        [part='navbar'][bottom] {
          top: auto;
          bottom: 0;
          padding-bottom: var(--safe-area-inset-bottom);
        }

        [part='drawer'] {
          overflow: auto;
          position: fixed;
          top: var(--vaadin-app-layout-navbar-offset-top, 0);
          bottom: var(--vaadin-app-layout-navbar-offset-bottom, var(--vaadin-viewport-offset-bottom, 0));
          inset-inline: var(--vaadin-app-layout-navbar-offset-left, 0) auto;
          transition:
            transform var(--vaadin-app-layout-transition),
            visibility var(--vaadin-app-layout-transition);
          transform: translateX(-100%);
          max-width: 90%;
          width: var(--_vaadin-app-layout-drawer-width);
          box-sizing: border-box;
          padding: var(--safe-area-inset-top) 0 var(--safe-area-inset-bottom) var(--safe-area-inset-left);
          outline: none;
          /* The drawer should be inaccessible by the tabbing navigation when it is closed. */
          visibility: hidden;
          display: flex;
          flex-direction: column;
        }

        :host([drawer-opened]) [part='drawer'] {
          /* The drawer should be accessible by the tabbing navigation when it is opened. */
          visibility: visible;
          transform: translateX(0%);
          touch-action: manipulation;
        }

        [part='backdrop'] {
          background-color: #000;
          opacity: 0.3;
        }

        :host(:not([drawer-opened])) [part='backdrop'] {
          opacity: 0;
        }

        :host([overlay]) [part='backdrop'] {
          position: fixed;
          inset: 0;
          pointer-events: none;
          transition: opacity var(--vaadin-app-layout-transition);
          -webkit-tap-highlight-color: transparent;
        }

        :host([overlay]) [part='drawer'] {
          top: 0;
          bottom: 0;
        }

        :host([overlay]) [part='drawer'],
        :host([overlay]) [part='backdrop'] {
          z-index: 2;
        }

        :host([drawer-opened][overlay]) [part='backdrop'] {
          pointer-events: auto;
          touch-action: manipulation;
        }

        :host([dir='rtl']) [part='drawer'] {
          transform: translateX(100%);
        }

        :host([dir='rtl'][drawer-opened]) [part='drawer'] {
          transform: translateX(0%);
        }

        :host([drawer-opened]:not([overlay])) {
          padding-inline-start: var(--vaadin-app-layout-drawer-offset-left);
        }

        @media (max-width: 800px), (max-height: 600px) {
          :host {
            --vaadin-app-layout-drawer-overlay: true;
            --_vaadin-app-layout-drawer-width: var(--vaadin-app-layout-drawer-width, 20em);
          }
        }

        /* If a vaadin-scroller is used in the drawer, allow it to take all remaining space and contain scrolling */
        [part='drawer'] ::slotted(vaadin-scroller) {
          flex: 1;
          overscroll-behavior: contain;
        }
      </style>
      <div part="navbar" id="navbarTop">
        <slot name="navbar" on-slotchange="_updateTouchOptimizedMode"></slot>
      </div>
      <div part="backdrop" on-click="_onBackdropClick" on-touchend="_onBackdropTouchend"></div>
      <div part="drawer" id="drawer">
        <slot name="drawer" id="drawerSlot" on-slotchange="_updateDrawerSize"></slot>
      </div>
      <div content>
        <slot></slot>
      </div>
      <div part="navbar" id="navbarBottom" bottom hidden>
        <slot name="navbar-bottom"></slot>
      </div>
      <div hidden>
        <slot id="touchSlot" name="navbar touch-optimized" on-slotchange="_updateTouchOptimizedMode"></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-app-layout";
  }
  static get properties() {
    return {
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * `i18n` object with a custom one.
       *
       * To update individual properties, extend the existing i18n object as follows:
       * ```js
       * appLayout.i18n = {
       *   ...appLayout.i18n,
       *   drawer: 'Drawer'
       * }
       * ```
       *
       * The object has the following structure and default values:
       * ```
       * {
       *   drawer: 'Drawer'
       * }
       * ```
       *
       * @type {AppLayoutI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        observer: "__i18nChanged",
        value: () => {
          return {
            drawer: "Drawer"
          };
        }
      },
      /**
       * Defines whether navbar or drawer will come first visually.
       * - By default (`primary-section="navbar"`), the navbar takes the full available width and moves the drawer down.
       * - If `primary-section="drawer"` is set, then the drawer will move the navbar, taking the full available height.
       * @attr {navbar|drawer} primary-section
       * @type {!PrimarySection}
       */
      primarySection: {
        type: String,
        value: "navbar",
        notify: true,
        reflectToAttribute: true,
        observer: "__primarySectionChanged"
      },
      /**
       * Controls whether the drawer is opened (visible) or not.
       * Its default value depends on the viewport:
       * - `true`, for desktop size views
       * - `false`, for mobile size views
       * @attr {boolean} drawer-opened
       * @type {boolean}
       */
      drawerOpened: {
        type: Boolean,
        notify: true,
        value: true,
        reflectToAttribute: true,
        observer: "__drawerOpenedChanged"
      },
      /**
       * Drawer is an overlay on top of the content
       * Controlled via CSS using `--vaadin-app-layout-drawer-overlay: true|false`;
       * @type {boolean}
       */
      overlay: {
        type: Boolean,
        notify: true,
        readOnly: true,
        value: false,
        reflectToAttribute: true
      },
      /**
       * A global event that causes the drawer to close (be hidden) when it is in overlay mode.
       * - The default is `vaadin-router-location-changed` dispatched by Vaadin Router
       *
       * @attr {string} close-drawer-on
       * @type {string}
       */
      closeDrawerOn: {
        type: String,
        value: "vaadin-router-location-changed",
        observer: "_closeDrawerOnChanged"
      }
    };
  }
  /**
   * Helper static method that dispatches a `close-overlay-drawer` event
   */
  static dispatchCloseOverlayDrawerEvent() {
    window.dispatchEvent(new CustomEvent("close-overlay-drawer"));
  }
  constructor() {
    super();
    this.__boundResizeListener = this._resize.bind(this);
    this.__drawerToggleClickListener = this._drawerToggleClick.bind(this);
    this.__onDrawerKeyDown = this.__onDrawerKeyDown.bind(this);
    this.__closeOverlayDrawerListener = this.__closeOverlayDrawer.bind(this);
    this.__trapFocusInDrawer = this.__trapFocusInDrawer.bind(this);
    this.__releaseFocusFromDrawer = this.__releaseFocusFromDrawer.bind(this);
    this.__ariaModalController = new AriaModalController(this, () => [
      ...this.querySelectorAll('vaadin-drawer-toggle, [slot="drawer"]')
    ]);
    this.__focusTrapController = new FocusTrapController(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this._blockAnimationUntilAfterNextRender();
    window.addEventListener("resize", this.__boundResizeListener);
    this.addEventListener("drawer-toggle-click", this.__drawerToggleClickListener);
    beforeNextRender(this, this._afterFirstRender);
    this._updateTouchOptimizedMode();
    this._updateDrawerSize();
    this._updateOverlayMode();
    this._navbarSizeObserver = new ResizeObserver(() => {
      requestAnimationFrame(() => {
        if (this.__isDrawerAnimating) {
          this.__updateOffsetSizePending = true;
        } else {
          this._updateOffsetSize();
        }
      });
    });
    this._navbarSizeObserver.observe(this.$.navbarTop);
    this._navbarSizeObserver.observe(this.$.navbarBottom);
    window.addEventListener("close-overlay-drawer", this.__closeOverlayDrawerListener);
    window.addEventListener("keydown", this.__onDrawerKeyDown);
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(this.__focusTrapController);
    this.__setAriaExpanded();
    this.$.drawer.addEventListener("transitionstart", () => {
      this.__isDrawerAnimating = true;
    });
    this.$.drawer.addEventListener("transitionend", () => {
      if (this.__updateOffsetSizePending) {
        this.__updateOffsetSizePending = false;
        this._updateOffsetSize();
      }
      requestAnimationFrame(() => {
        this.__isDrawerAnimating = false;
      });
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("resize", this.__boundResizeListener);
    this.removeEventListener("drawer-toggle-click", this.__drawerToggleClickListener);
    window.removeEventListener("close-overlay-drawer", this.__drawerToggleClickListener);
    window.removeEventListener("keydown", this.__onDrawerKeyDown);
  }
  /**
   * A callback for the `primarySection` property observer.
   *
   * Ensures the property is set to its default value `navbar`
   * whenever the new value is not one of the valid values: `navbar`, `drawer`.
   *
   * @param {string} value
   * @private
   */
  __primarySectionChanged(value) {
    const isValid2 = ["navbar", "drawer"].includes(value);
    if (!isValid2) {
      this.set("primarySection", "navbar");
    }
  }
  /**
   * A callback for the `drawerOpened` property observer.
   *
   * When the drawer opens, the method ensures the drawer has a proper height and sets focus on it.
   * As long as the drawer is open, the focus is trapped within the drawer.
   *
   * When the drawer closes, the method releases focus from the drawer, setting focus on the drawer toggle.
   *
   * @param {boolean} drawerOpened
   * @param {boolean} oldDrawerOpened
   * @private
   */
  __drawerOpenedChanged(drawerOpened, oldDrawerOpened) {
    if (this.overlay) {
      if (drawerOpened) {
        this.__trapFocusInDrawer();
      } else if (oldDrawerOpened) {
        this.__releaseFocusFromDrawer();
      }
    }
    this.__setAriaExpanded();
  }
  /**
   * A callback for the `i18n` property observer.
   *
   * The method ensures the drawer has ARIA attributes updated
   * once the `i18n` property changes.
   *
   * @private
   */
  __i18nChanged() {
    this.__updateDrawerAriaAttributes();
  }
  /** @protected */
  _afterFirstRender() {
    this._blockAnimationUntilAfterNextRender();
    this._updateOffsetSize();
  }
  /** @private */
  _drawerToggleClick(e2) {
    e2.stopPropagation();
    this.drawerOpened = !this.drawerOpened;
  }
  /** @private */
  __closeOverlayDrawer() {
    if (this.overlay) {
      this.drawerOpened = false;
    }
  }
  /** @private */
  __setAriaExpanded() {
    const toggle = this.querySelector("vaadin-drawer-toggle");
    if (toggle) {
      toggle.setAttribute("aria-expanded", this.drawerOpened);
    }
  }
  /** @protected */
  _updateDrawerSize() {
    const childCount = this.querySelectorAll("[slot=drawer]").length;
    const drawer = this.$.drawer;
    if (childCount === 0) {
      drawer.setAttribute("hidden", "");
      this.style.setProperty("--_vaadin-app-layout-drawer-width", 0);
    } else {
      drawer.removeAttribute("hidden");
      this.style.removeProperty("--_vaadin-app-layout-drawer-width");
    }
    this._updateOffsetSize();
  }
  /** @private */
  _resize() {
    this._blockAnimationUntilAfterNextRender();
    this._updateTouchOptimizedMode();
    this._updateOverlayMode();
  }
  /** @protected */
  _updateOffsetSize() {
    const navbar = this.$.navbarTop;
    const navbarRect = navbar.getBoundingClientRect();
    const navbarBottom = this.$.navbarBottom;
    const navbarBottomRect = navbarBottom.getBoundingClientRect();
    const drawer = this.$.drawer;
    const drawerRect = drawer.getBoundingClientRect();
    this.style.setProperty("--_vaadin-app-layout-navbar-offset-size", `${navbarRect.height}px`);
    this.style.setProperty("--_vaadin-app-layout-navbar-offset-size-bottom", `${navbarBottomRect.height}px`);
    this.style.setProperty("--_vaadin-app-layout-drawer-offset-size", `${drawerRect.width}px`);
  }
  /** @protected */
  _updateOverlayMode() {
    const overlay2 = this._getCustomPropertyValue("--vaadin-app-layout-drawer-overlay") === "true";
    if (!this.overlay && overlay2) {
      this._drawerStateSaved = this.drawerOpened;
      this.drawerOpened = false;
    }
    this._setOverlay(overlay2);
    if (!this.overlay && this._drawerStateSaved) {
      this.drawerOpened = this._drawerStateSaved;
      this._drawerStateSaved = null;
    }
    this.__updateDrawerAriaAttributes();
  }
  /**
   * Updates ARIA attributes on the drawer depending on the drawer mode.
   *
   * - In the overlay mode, the method marks the drawer with ARIA attributes as a dialog
   * labelled with the `i18n.drawer` property.
   * - In the normal mode, the method removes the ARIA attributes that has been set for the overlay mode.
   *
   * @private
   */
  __updateDrawerAriaAttributes() {
    const drawer = this.$.drawer;
    if (this.overlay) {
      drawer.setAttribute("role", "dialog");
      drawer.setAttribute("aria-modal", "true");
      drawer.setAttribute("aria-label", this.i18n.drawer);
    } else {
      drawer.removeAttribute("role");
      drawer.removeAttribute("aria-modal");
      drawer.removeAttribute("aria-label");
    }
  }
  /**
   * Returns a promise that resolves when the drawer opening/closing CSS transition ends.
   *
   * The method relies on the `--vaadin-app-layout-transition` CSS variable to detect whether
   * the drawer has a CSS transition that needs to be awaited. If the CSS variable equals `none`,
   * the promise resolves immediately.
   *
   * @return {Promise}
   * @private
   */
  __drawerTransitionComplete() {
    return new Promise((resolve) => {
      if (this._getCustomPropertyValue("--vaadin-app-layout-transition") === "none") {
        resolve();
        return;
      }
      this.$.drawer.addEventListener("transitionend", resolve, { once: true });
    });
  }
  /** @private */
  async __trapFocusInDrawer() {
    await this.__drawerTransitionComplete();
    if (!this.drawerOpened) {
      return;
    }
    this.$.drawer.setAttribute("tabindex", "0");
    this.__ariaModalController.showModal();
    this.__focusTrapController.trapFocus(this.$.drawer);
  }
  /** @private */
  async __releaseFocusFromDrawer() {
    await this.__drawerTransitionComplete();
    if (this.drawerOpened) {
      return;
    }
    this.__ariaModalController.close();
    this.__focusTrapController.releaseFocus();
    this.$.drawer.removeAttribute("tabindex");
    const toggle = this.querySelector("vaadin-drawer-toggle");
    if (toggle) {
      toggle.focus();
      toggle.setAttribute("focus-ring", "focus");
    }
  }
  /**
   * Closes the drawer on Escape press if it has been opened in the overlay mode.
   *
   * @param {KeyboardEvent} event
   * @private
   */
  __onDrawerKeyDown(event) {
    if (event.key === "Escape" && this.overlay) {
      this.drawerOpened = false;
    }
  }
  /** @private */
  _closeDrawerOnChanged(closeDrawerOn, oldCloseDrawerOn) {
    if (oldCloseDrawerOn) {
      window.removeEventListener(oldCloseDrawerOn, this.__closeOverlayDrawerListener);
    }
    if (closeDrawerOn) {
      window.addEventListener(closeDrawerOn, this.__closeOverlayDrawerListener);
    }
  }
  /** @private */
  _onBackdropClick() {
    this._close();
  }
  /** @private */
  _onBackdropTouchend(event) {
    event.preventDefault();
    this._close();
  }
  /** @protected */
  _close() {
    this.drawerOpened = false;
  }
  /** @private */
  _getCustomPropertyValue(customProperty) {
    const customPropertyValue = getComputedStyle(this).getPropertyValue(customProperty);
    return (customPropertyValue || "").trim().toLowerCase();
  }
  /** @protected */
  _updateTouchOptimizedMode() {
    const touchOptimized = this._getCustomPropertyValue("--vaadin-app-layout-touch-optimized") === "true";
    const navbarItems = this.querySelectorAll('[slot*="navbar"]');
    if (navbarItems.length > 0) {
      Array.from(navbarItems).forEach((navbar) => {
        if (navbar.getAttribute("slot").indexOf("touch-optimized") > -1) {
          navbar.__touchOptimized = true;
        }
        if (touchOptimized && navbar.__touchOptimized) {
          navbar.setAttribute("slot", "navbar-bottom");
        } else {
          navbar.setAttribute("slot", "navbar");
        }
      });
    }
    if (this.$.navbarTop.querySelector("[name=navbar]").assignedNodes().length === 0) {
      this.$.navbarTop.setAttribute("hidden", "");
    } else {
      this.$.navbarTop.removeAttribute("hidden");
    }
    if (this.$.navbarBottom.querySelector("[name=navbar-bottom]").assignedNodes().length === 0) {
      this.$.navbarBottom.setAttribute("hidden", "");
    } else {
      this.$.navbarBottom.removeAttribute("hidden");
    }
    this._updateOffsetSize();
  }
  /** @protected */
  _blockAnimationUntilAfterNextRender() {
    this.setAttribute("no-anim", "");
    afterNextRender(this, () => {
      this.removeAttribute("no-anim");
    });
  }
  /**
   * App Layout listens to `close-overlay-drawer` on the window level.
   * A custom event can be dispatched and the App Layout will close the drawer in overlay.
   *
   * That can be used, for instance, when a navigation occurs when user clicks in a menu item inside the drawer.
   *
   * See `dispatchCloseOverlayDrawerEvent()` helper method.
   *
   * @event close-overlay-drawer
   */
}
defineCustomElement(AppLayout);
const button = css`
  :host {
    /* Sizing */
    --lumo-button-size: var(--lumo-size-m);
    min-width: var(--vaadin-button-min-width, calc(var(--_button-size) * 2));
    height: var(--_button-size);
    padding: var(--vaadin-button-padding, 0 calc(var(--_button-size) / 3 + var(--lumo-border-radius-m) / 2));
    margin: var(--vaadin-button-margin, var(--lumo-space-xs) 0);
    box-sizing: border-box;
    /* Style */
    font-family: var(--lumo-font-family);
    font-size: var(--vaadin-button-font-size, var(--lumo-font-size-m));
    font-weight: var(--vaadin-button-font-weight, 500);
    color: var(--_lumo-button-text-color);
    background: var(--_lumo-button-background);
    border: var(--vaadin-button-border, none);
    border-radius: var(--vaadin-button-border-radius, var(--lumo-border-radius-m));
    cursor: var(--lumo-clickable-cursor);
    -webkit-tap-highlight-color: transparent;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    flex-shrink: 0;
    --_button-size: var(--vaadin-button-height, var(--lumo-button-size));
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
    /* Used by notification */
    --_lumo-button-background: var(--vaadin-button-background, var(--lumo-contrast-5pct));
    --_lumo-button-text-color: var(--vaadin-button-text-color, var(--lumo-primary-text-color));
    --_lumo-button-primary-background: var(--vaadin-button-primary-background, var(--lumo-primary-color));
    --_lumo-button-primary-text-color: var(--vaadin-button-primary-text-color, var(--lumo-primary-contrast-color));
  }

  /* Set only for the internal parts so we don't affect the host vertical alignment */
  [part='label'],
  [part='prefix'],
  [part='suffix'] {
    line-height: var(--lumo-line-height-xs);
  }

  [part='label'] {
    padding: calc(var(--lumo-button-size) / 6) 0;
  }

  :host([theme~='small']) {
    font-size: var(--lumo-font-size-s);
    --lumo-button-size: var(--lumo-size-s);
  }

  :host([theme~='large']) {
    font-size: var(--lumo-font-size-l);
    --lumo-button-size: var(--lumo-size-l);
  }

  /* For interaction states */
  :host::before,
  :host::after {
    content: '';
    /* We rely on the host always being relative */
    position: absolute;
    z-index: 1;
    inset: 0;
    background-color: currentColor;
    border-radius: inherit;
    opacity: 0;
    pointer-events: none;
  }

  /* Hover */

  @media (any-hover: hover) {
    :host(:hover)::before {
      opacity: 0.02;
    }
  }

  /* Active */

  :host::after {
    transition:
      opacity 1.4s,
      transform 0.1s;
    filter: blur(8px);
  }

  :host([active])::before {
    opacity: 0.05;
    transition-duration: 0s;
  }

  :host([active])::after {
    opacity: 0.1;
    transition-duration: 0s, 0s;
    transform: scale(0);
  }

  /* Keyboard focus */

  :host([focus-ring]) {
    box-shadow:
      0 0 0 calc(1px * var(--_focus-ring-gap-on, 0)) var(--_focus-ring-gap-color, var(--lumo-base-color)),
      0 0 0 calc(var(--_focus-ring-width) + 1px * var(--_focus-ring-gap-on, 0)) var(--_focus-ring-color);
  }

  :host([theme~='primary'][focus-ring]) {
    --_focus-ring-gap-on: 1;
  }

  /* Types (primary, tertiary, tertiary-inline */

  :host([theme~='tertiary']),
  :host([theme~='tertiary-inline']) {
    --_background: transparent !important;
    background: var(--vaadin-button-tertiary-background, var(--_background));
    min-width: 0;
  }

  :host([theme~='tertiary']) {
    border: var(--vaadin-button-tertiary-border, none);
    color: var(--vaadin-button-tertiary-text-color, var(--lumo-primary-text-color));
    font-weight: var(--vaadin-button-tertiary-font-weight, 500);
    padding: var(--vaadin-button-tertiary-padding, 0 calc(var(--_button-size) / 6));
  }

  :host([theme~='tertiary-inline'])::before {
    display: none;
  }

  :host([theme~='tertiary-inline']) {
    margin: 0;
    height: auto;
    padding: 0;
    line-height: inherit;
    font-size: inherit;
  }

  :host([theme~='tertiary-inline']) [part='label'] {
    padding: 0;
    overflow: visible;
    line-height: inherit;
  }

  :host([theme~='primary']) {
    background: var(--_lumo-button-primary-background);
    border: var(--vaadin-button-primary-border, none);
    color: var(--_lumo-button-primary-text-color);
    font-weight: var(--vaadin-button-primary-font-weight, 600);
    min-width: calc(var(--lumo-button-size) * 2.5);
  }

  :host([theme~='primary'])::before {
    background-color: black;
  }

  @media (any-hover: hover) {
    :host([theme~='primary']:hover)::before {
      opacity: 0.05;
    }
  }

  :host([theme~='primary'][active])::before {
    opacity: 0.1;
  }

  :host([theme~='primary'][active])::after {
    opacity: 0.2;
  }

  /* Colors (success, warning, error, contrast) */

  :host([theme~='success']) {
    color: var(--lumo-success-text-color);
  }

  :host([theme~='success'][theme~='primary']) {
    background-color: var(--lumo-success-color);
    color: var(--lumo-success-contrast-color);
  }

  :host([theme~='warning']) {
    color: var(--lumo-warning-text-color);
  }

  :host([theme~='warning'][theme~='primary']) {
    background-color: var(--lumo-warning-color);
    color: var(--lumo-warning-contrast-color);
  }

  :host([theme~='error']) {
    color: var(--lumo-error-text-color);
  }

  :host([theme~='error'][theme~='primary']) {
    background-color: var(--lumo-error-color);
    color: var(--lumo-error-contrast-color);
  }

  :host([theme~='contrast']) {
    color: var(--lumo-contrast);
  }

  :host([theme~='contrast'][theme~='primary']) {
    background-color: var(--lumo-contrast);
    color: var(--lumo-base-color);
  }

  /* Disabled state. Keep selectors after other color variants. */

  :host([disabled]) {
    pointer-events: none;
    color: var(--lumo-disabled-text-color);
  }

  :host([theme~='primary'][disabled]) {
    background-color: var(--lumo-contrast-30pct);
    color: var(--lumo-base-color);
  }

  :host([theme~='primary'][disabled]) [part] {
    opacity: 0.7;
  }

  /* Icons */

  [part] ::slotted(vaadin-icon) {
    display: inline-block;
    width: var(--lumo-icon-size-m);
    height: var(--lumo-icon-size-m);
  }

  /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
  [part] ::slotted(vaadin-icon[icon^='vaadin:']) {
    padding: 0.25em;
    box-sizing: border-box !important;
  }

  [part='prefix'] {
    margin-left: -0.25em;
    margin-right: 0.25em;
  }

  [part='suffix'] {
    margin-left: 0.25em;
    margin-right: -0.25em;
  }

  /* Icon-only */

  :host([theme~='icon']:not([theme~='tertiary-inline'])) {
    min-width: var(--lumo-button-size);
    padding-left: calc(var(--lumo-button-size) / 4);
    padding-right: calc(var(--lumo-button-size) / 4);
  }

  :host([theme~='icon']) [part='prefix'],
  :host([theme~='icon']) [part='suffix'] {
    margin-left: 0;
    margin-right: 0;
  }

  /* RTL specific styles */

  :host([dir='rtl']) [part='prefix'] {
    margin-left: 0.25em;
    margin-right: -0.25em;
  }

  :host([dir='rtl']) [part='suffix'] {
    margin-left: -0.25em;
    margin-right: 0.25em;
  }

  :host([dir='rtl'][theme~='icon']) [part='prefix'],
  :host([dir='rtl'][theme~='icon']) [part='suffix'] {
    margin-left: 0;
    margin-right: 0;
  }
`;
registerStyles$1("vaadin-button", button, { moduleId: "lumo-button" });
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const buttonStyles = css`
  :host {
    display: inline-block;
    position: relative;
    outline: none;
    white-space: nowrap;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
  }

  :host([hidden]) {
    display: none !important;
  }

  /* Aligns the button with form fields when placed on the same line.
  Note, to make it work, the form fields should have the same "::before" pseudo-element. */
  .vaadin-button-container::before {
    content: '\\2003';
    display: inline-block;
    width: 0;
    max-height: 100%;
  }

  .vaadin-button-container {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    width: 100%;
    height: 100%;
    min-height: inherit;
    text-shadow: inherit;
  }

  [part='prefix'],
  [part='suffix'] {
    flex: none;
  }

  [part='label'] {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  @media (forced-colors: active) {
    :host {
      outline: 1px solid;
      outline-offset: -1px;
    }

    :host([focused]) {
      outline-width: 2px;
    }

    :host([disabled]) {
      outline-color: GrayText;
    }
  }
`;
const buttonTemplate = (html3) => html3`
  <div class="vaadin-button-container">
    <span part="prefix" aria-hidden="true">
      <slot name="prefix"></slot>
    </span>
    <span part="label">
      <slot></slot>
    </span>
    <span part="suffix" aria-hidden="true">
      <slot name="suffix"></slot>
    </span>
  </div>
  <slot name="tooltip"></slot>
`;
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-button", buttonStyles, { moduleId: "vaadin-button-styles" });
class Button extends ButtonMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-button";
  }
  static get template() {
    return buttonTemplate(html);
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
  }
}
defineCustomElement(Button);
const drawerToggle$1 = css`
  :host {
    width: var(--lumo-size-l);
    height: var(--lumo-size-l);
    min-width: auto;
    margin: 0 var(--lumo-space-s);
    padding: 0;
    background: transparent;
  }

  [part='icon'],
  [part='icon']::after,
  [part='icon']::before {
    position: inherit;
    height: auto;
    width: auto;
    background: transparent;
    top: auto;
  }

  [part='icon']::before {
    font-family: lumo-icons;
    font-size: var(--lumo-icon-size-m);
    content: var(--lumo-icons-menu);
  }

  :host([slot~='navbar']) {
    color: var(--lumo-secondary-text-color);
  }
`;
registerStyles$1("vaadin-drawer-toggle", [button, drawerToggle$1], { moduleId: "lumo-drawer-toggle" });
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const drawerToggle = css`
  :host {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: default;
    position: relative;
    outline: none;
    height: 24px;
    width: 24px;
    padding: 4px;
  }

  [part='icon'],
  [part='icon']::after,
  [part='icon']::before {
    position: absolute;
    top: 8px;
    height: 3px;
    width: 24px;
    background-color: #000;
  }

  [part='icon']::after,
  [part='icon']::before {
    content: '';
  }

  [part='icon']::after {
    top: 6px;
  }

  [part='icon']::before {
    top: 12px;
  }
`;
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-drawer-toggle", [buttonStyles, drawerToggle], { moduleId: "vaadin-drawer-toggle-styles" });
class DrawerToggle extends ButtonMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <slot id="slot">
        <div part="icon"></div>
      </slot>
      <div part="icon" hidden$="[[!_showFallbackIcon]]"></div>
    `;
  }
  static get is() {
    return "vaadin-drawer-toggle";
  }
  static get properties() {
    return {
      ariaLabel: {
        type: String,
        value: "Toggle navigation panel",
        reflectToAttribute: true
      },
      /** @private */
      _showFallbackIcon: {
        type: Boolean,
        value: false
      }
    };
  }
  constructor() {
    super();
    this.addEventListener("click", () => {
      this.dispatchEvent(new CustomEvent("drawer-toggle-click", { bubbles: true, composed: true }));
    });
  }
  /** @protected */
  ready() {
    super.ready();
    this._toggleFallbackIcon();
    this.$.slot.addEventListener("slotchange", () => {
      this._toggleFallbackIcon();
    });
  }
  /** @private */
  _toggleFallbackIcon() {
    const nodes = this.$.slot.assignedNodes();
    this._showFallbackIcon = nodes.length > 0 && nodes.every((node) => isEmptyTextNode(node));
  }
}
defineCustomElement(DrawerToggle);
const tooltipOverlay = css`
  :host {
    --vaadin-tooltip-offset-top: var(--lumo-space-xs);
    --vaadin-tooltip-offset-bottom: var(--lumo-space-xs);
    --vaadin-tooltip-offset-start: var(--lumo-space-xs);
    --vaadin-tooltip-offset-end: var(--lumo-space-xs);
  }

  [part='overlay'] {
    background: var(--lumo-base-color) linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-s);
  }

  [part='content'] {
    padding: var(--lumo-space-xs) var(--lumo-space-s);
  }
`;
registerStyles$1("vaadin-tooltip-overlay", [overlay, tooltipOverlay], { moduleId: "lumo-tooltip-overlay" });
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const PopoverOverlayMixin = (superClass) => class PopoverOverlayMixinClass extends PositionMixin(OverlayMixin(superClass)) {
  static get properties() {
    return {
      position: {
        type: String,
        reflectToAttribute: true
      }
    };
  }
  /**
   * Tag name prefix used by custom properties.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-popover";
  }
  requestContentUpdate() {
    super.requestContentUpdate();
    if (this.positionTarget && this.owner) {
      const style = getComputedStyle(this.owner);
      ["top", "bottom", "start", "end"].forEach((prop) => {
        this.style.setProperty(
          `--${this._tagNamePrefix}-offset-${prop}`,
          style.getPropertyValue(`--${this._tagNamePrefix}-offset-${prop}`)
        );
      });
    }
  }
  /**
   * @protected
   * @override
   */
  _updatePosition() {
    super._updatePosition();
    if (!this.positionTarget || !this.opened) {
      return;
    }
    this.removeAttribute("arrow-centered");
    if (this.position === "bottom" || this.position === "top") {
      const targetRect = this.positionTarget.getBoundingClientRect();
      const overlayRect = this.$.overlay.getBoundingClientRect();
      const offset = targetRect.width / 2 - overlayRect.width / 2;
      if (this.style.left) {
        const left = overlayRect.left + offset;
        if (left > 0) {
          this.style.left = `${left}px`;
          this.setAttribute("arrow-centered", "");
        }
      }
      if (this.style.right) {
        const right = parseFloat(this.style.right) + offset;
        if (right > 0) {
          this.style.right = `${right}px`;
          this.setAttribute("arrow-centered", "");
        }
      }
    }
    if (this.position === "start" || this.position === "end") {
      const targetRect = this.positionTarget.getBoundingClientRect();
      const overlayRect = this.$.overlay.getBoundingClientRect();
      const offset = targetRect.height / 2 - overlayRect.height / 2;
      this.style.top = `${overlayRect.top + offset}px`;
    }
  }
};
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const tooltipOverlayStyles = css`
  [part='overlay'] {
    max-width: 40ch;
  }

  [part='content'] {
    white-space: pre-wrap;
  }

  :host([position^='top'][top-aligned]) [part='overlay'],
  :host([position^='bottom'][top-aligned]) [part='overlay'] {
    margin-top: var(--vaadin-tooltip-offset-top, 0);
  }

  :host([position^='top'][bottom-aligned]) [part='overlay'],
  :host([position^='bottom'][bottom-aligned]) [part='overlay'] {
    margin-bottom: var(--vaadin-tooltip-offset-bottom, 0);
  }

  :host([position^='start'][start-aligned]) [part='overlay'],
  :host([position^='end'][start-aligned]) [part='overlay'] {
    margin-inline-start: var(--vaadin-tooltip-offset-start, 0);
  }

  :host([position^='start'][end-aligned]) [part='overlay'],
  :host([position^='end'][end-aligned]) [part='overlay'] {
    margin-inline-end: var(--vaadin-tooltip-offset-end, 0);
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 1px dashed;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-tooltip-overlay", [overlayStyles, tooltipOverlayStyles], {
  moduleId: "vaadin-tooltip-overlay-styles"
});
class TooltipOverlay extends PopoverOverlayMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-tooltip-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden></div>
      <div part="overlay" id="overlay">
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
  }
  /**
   * Tag name prefix used by custom properties.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-tooltip";
  }
  /** @protected */
  ready() {
    super.ready();
    this.owner = this.__dataHost;
    this.owner._overlayElement = this;
  }
  requestContentUpdate() {
    super.requestContentUpdate();
    this.toggleAttribute("hidden", this.textContent.trim() === "");
  }
}
defineCustomElement(TooltipOverlay);
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const OverlayClassMixin = (superclass) => class OverlayClassMixinClass extends superclass {
  static get properties() {
    return {
      /**
       * A space-delimited list of CSS class names to set on the overlay element.
       * This property does not affect other CSS class names set manually via JS.
       *
       * Note, if the CSS class name was set with this property, clearing it will
       * remove it from the overlay, even if the same class name was also added
       * manually, e.g. by using `classList.add()` in the `renderer` function.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * An overlay element on which CSS class names are set.
       *
       * @protected
       */
      _overlayElement: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["__updateOverlayClassNames(overlayClass, _overlayElement)"];
  }
  /** @private */
  __updateOverlayClassNames(overlayClass, overlayElement) {
    if (!overlayElement) {
      return;
    }
    if (overlayClass === void 0) {
      return;
    }
    const { classList } = overlayElement;
    if (!this.__initialClasses) {
      this.__initialClasses = new Set(classList);
    }
    if (Array.isArray(this.__previousClasses)) {
      const classesToRemove = this.__previousClasses.filter((name) => !this.__initialClasses.has(name));
      if (classesToRemove.length > 0) {
        classList.remove(...classesToRemove);
      }
    }
    const classesToAdd = typeof overlayClass === "string" ? overlayClass.split(" ").filter(Boolean) : [];
    if (classesToAdd.length > 0) {
      classList.add(...classesToAdd);
    }
    this.__previousClasses = classesToAdd;
  }
};
/**
 * @license
 * Copyright (c) 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const PopoverPositionMixin = (superClass) => class PopoverPositionMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * Position of the overlay with respect to the target.
       * Supported values: `top-start`, `top`, `top-end`,
       * `bottom-start`, `bottom`, `bottom-end`, `start-top`,
       * `start`, `start-bottom`, `end-top`, `end`, `end-bottom`.
       */
      position: {
        type: String
      },
      /**
       * Default value used when `position` property is not set.
       * @protected
       */
      _position: {
        type: String,
        value: "bottom"
      },
      /** @private */
      __effectivePosition: {
        type: String,
        computed: "__computePosition(position, _position)"
      }
    };
  }
  /** @protected */
  __computeHorizontalAlign(position) {
    return ["top-end", "bottom-end", "start-top", "start", "start-bottom"].includes(position) ? "end" : "start";
  }
  /** @protected */
  __computeNoHorizontalOverlap(position) {
    return ["start-top", "start", "start-bottom", "end-top", "end", "end-bottom"].includes(position);
  }
  /** @protected */
  __computeNoVerticalOverlap(position) {
    return ["top-start", "top-end", "top", "bottom-start", "bottom", "bottom-end"].includes(position);
  }
  /** @protected */
  __computeVerticalAlign(position) {
    return ["top-start", "top-end", "top", "start-bottom", "end-bottom"].includes(position) ? "bottom" : "top";
  }
  /** @private */
  __computePosition(position, defaultPosition) {
    return position || defaultPosition;
  }
};
/**
 * @license
 * Copyright (c) 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const PopoverTargetMixin = (superClass) => class PopoverTargetMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * The id of the element to be used as `target` value.
       * The element should be in the DOM by the time when
       * the attribute is set, otherwise a warning is shown.
       */
      for: {
        type: String,
        observer: "__forChanged"
      },
      /**
       * Reference to the DOM element used both to trigger the overlay
       * by user interaction and to visually position it on the screen.
       *
       * Defaults to an element referenced with `for` attribute, in
       * which case it must be located in the same shadow scope.
       */
      target: {
        type: Object
      },
      /** @private */
      __isConnected: {
        type: Boolean,
        sync: true
      }
    };
  }
  static get observers() {
    return ["__targetOrConnectedChanged(target, __isConnected)"];
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__isConnected = true;
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__isConnected = false;
  }
  /** @private */
  __forChanged(forId) {
    if (forId) {
      this.__setTargetByIdDebouncer = Debouncer$1.debounce(
        this.__setTargetByIdDebouncer,
        microTask,
        () => this.__setTargetById(forId)
      );
    }
  }
  /** @private */
  __setTargetById(targetId) {
    if (!this.isConnected) {
      return;
    }
    const target = this.getRootNode().getElementById(targetId);
    if (target) {
      this.target = target;
    } else {
      console.warn(`No element with id="${targetId}" set via "for" property found on the page.`);
    }
  }
  /** @private */
  __targetOrConnectedChanged(target, isConnected) {
    if (this.__previousTarget && (this.__previousTarget !== target || !isConnected)) {
      this._removeTargetListeners(this.__previousTarget);
    }
    if (target && isConnected) {
      this._addTargetListeners(target);
    }
    this.__previousTarget = target;
  }
  /**
   * @param {HTMLElement} _target
   * @protected
   */
  _addTargetListeners(_target) {
  }
  /**
   * @param {HTMLElement} _target
   * @protected
   */
  _removeTargetListeners(_target) {
  }
};
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DEFAULT_DELAY$1 = 500;
let defaultFocusDelay$3 = DEFAULT_DELAY$1;
let defaultHoverDelay$3 = DEFAULT_DELAY$1;
let defaultHideDelay$3 = DEFAULT_DELAY$1;
const closing = /* @__PURE__ */ new Set();
let warmedUp = false;
let warmUpTimeout = null;
let cooldownTimeout = null;
class TooltipStateController {
  constructor(host) {
    this.host = host;
  }
  /** @private */
  get openedProp() {
    return this.host.manual ? "opened" : "_autoOpened";
  }
  /** @private */
  get focusDelay() {
    const tooltip = this.host;
    return tooltip.focusDelay != null && tooltip.focusDelay >= 0 ? tooltip.focusDelay : defaultFocusDelay$3;
  }
  /** @private */
  get hoverDelay() {
    const tooltip = this.host;
    return tooltip.hoverDelay != null && tooltip.hoverDelay >= 0 ? tooltip.hoverDelay : defaultHoverDelay$3;
  }
  /** @private */
  get hideDelay() {
    const tooltip = this.host;
    return tooltip.hideDelay != null && tooltip.hideDelay >= 0 ? tooltip.hideDelay : defaultHideDelay$3;
  }
  /**
   * Whether closing is currently in progress.
   * @return {boolean}
   */
  get isClosing() {
    return closing.has(this.host);
  }
  /**
   * Schedule opening the tooltip.
   * @param {Object} options
   */
  open(options = { immediate: false }) {
    const { immediate, hover, focus } = options;
    const isHover = hover && this.hoverDelay > 0;
    const isFocus = focus && this.focusDelay > 0;
    if (!immediate && (isHover || isFocus) && !this.__closeTimeout) {
      this.__warmupTooltip(isFocus);
    } else {
      this.__showTooltip();
    }
  }
  /**
   * Schedule closing the tooltip.
   * @param {boolean} immediate
   */
  close(immediate) {
    if (!immediate && this.hideDelay > 0) {
      this.__scheduleClose();
    } else {
      this.__abortClose();
      this._setOpened(false);
    }
    this.__abortWarmUp();
    if (warmedUp) {
      this.__abortCooldown();
      this.__scheduleCooldown();
    }
  }
  /** @private */
  _isOpened() {
    return this.host[this.openedProp];
  }
  /** @private */
  _setOpened(opened) {
    this.host[this.openedProp] = opened;
  }
  /** @private */
  __flushClosingTooltips() {
    closing.forEach((tooltip) => {
      tooltip._stateController.close(true);
      closing.delete(tooltip);
    });
  }
  /** @private */
  __showTooltip() {
    this.__abortClose();
    this.__flushClosingTooltips();
    this._setOpened(true);
    warmedUp = true;
    this.__abortWarmUp();
    this.__abortCooldown();
  }
  /** @private */
  __warmupTooltip(isFocus) {
    if (!this._isOpened()) {
      if (warmedUp) {
        this.__showTooltip();
      } else if (warmUpTimeout == null) {
        this.__scheduleWarmUp(isFocus);
      }
    }
  }
  /** @private */
  __abortClose() {
    if (this.__closeTimeout) {
      clearTimeout(this.__closeTimeout);
      this.__closeTimeout = null;
    }
    if (this.isClosing) {
      closing.delete(this.host);
    }
  }
  /** @private */
  __abortCooldown() {
    if (cooldownTimeout) {
      clearTimeout(cooldownTimeout);
      cooldownTimeout = null;
    }
  }
  /** @private */
  __abortWarmUp() {
    if (warmUpTimeout) {
      clearTimeout(warmUpTimeout);
      warmUpTimeout = null;
    }
  }
  /** @private */
  __scheduleClose() {
    if (this._isOpened() && !this.isClosing) {
      closing.add(this.host);
      this.__closeTimeout = setTimeout(() => {
        closing.delete(this.host);
        this.__closeTimeout = null;
        this._setOpened(false);
      }, this.hideDelay);
    }
  }
  /** @private */
  __scheduleCooldown() {
    cooldownTimeout = setTimeout(() => {
      cooldownTimeout = null;
      warmedUp = false;
    }, this.hideDelay);
  }
  /** @private */
  __scheduleWarmUp(isFocus) {
    const delay = isFocus ? this.focusDelay : this.hoverDelay;
    warmUpTimeout = setTimeout(() => {
      warmUpTimeout = null;
      warmedUp = true;
      this.__showTooltip();
    }, delay);
  }
}
const TooltipMixin = (superClass) => class TooltipMixinClass extends PopoverPositionMixin(PopoverTargetMixin(OverlayClassMixin(superClass))) {
  static get properties() {
    return {
      /**
       * Element used to link with the `aria-describedby`
       * attribute. Supports array of multiple elements.
       * When not set, defaults to `target`.
       */
      ariaTarget: {
        type: Object
      },
      /**
       * Object with properties passed to `generator` and
       * `shouldShow` functions for generating tooltip text
       * or detecting whether to show the tooltip or not.
       */
      context: {
        type: Object,
        value: () => {
          return {};
        }
      },
      /**
       * The delay in milliseconds before the tooltip
       * is opened on keyboard focus, when not in manual mode.
       * @attr {number} focus-delay
       */
      focusDelay: {
        type: Number
      },
      /**
       * Function used to generate the tooltip content.
       * When provided, it overrides the `text` property.
       * Use the `context` property to provide argument
       * that can be passed to the generator function.
       */
      generator: {
        type: Object
      },
      /**
       * The delay in milliseconds before the tooltip
       * is closed on losing hover, when not in manual mode.
       * On blur, the tooltip is closed immediately.
       * @attr {number} hide-delay
       */
      hideDelay: {
        type: Number
      },
      /**
       * The delay in milliseconds before the tooltip
       * is opened on hover, when not in manual mode.
       * @attr {number} hover-delay
       */
      hoverDelay: {
        type: Number
      },
      /**
       * When true, the tooltip is controlled programmatically
       * instead of reacting to focus and mouse events.
       */
      manual: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * When true, the tooltip is opened programmatically.
       * Only works if `manual` is set to `true`.
       */
      opened: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * Function used to detect whether to show the tooltip based on a condition,
       * called every time the tooltip is about to be shown on hover and focus.
       * The function takes two parameters: `target` and `context`, which contain
       * values of the corresponding tooltip properties at the time of calling.
       * The tooltip is only shown when the function invocation returns `true`.
       */
      shouldShow: {
        type: Object,
        value: () => {
          return (_target, _context) => true;
        }
      },
      /**
       * String used as a tooltip content.
       */
      text: {
        type: String,
        observer: "__textChanged"
      },
      /**
       * Set to true when the overlay is opened using auto-added
       * event listeners: mouseenter and focusin (keyboard only).
       * @protected
       */
      _autoOpened: {
        type: Boolean,
        observer: "__autoOpenedChanged",
        sync: true
      },
      /**
       * Element used to link with the `aria-describedby`
       * attribute. When not set, defaults to `target`.
       * @protected
       */
      _effectiveAriaTarget: {
        type: Object,
        computed: "__computeAriaTarget(ariaTarget, target)",
        observer: "__effectiveAriaTargetChanged"
      },
      /** @private */
      __isTargetHidden: {
        type: Boolean,
        value: false
      },
      /** @private */
      _isConnected: {
        type: Boolean,
        sync: true
      },
      /** @private */
      _srLabel: {
        type: Object
      },
      /** @private */
      _overlayContent: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "__generatorChanged(_overlayElement, generator, context)",
      "__updateSrLabelText(_srLabel, _overlayContent)"
    ];
  }
  /**
   * Sets the default focus delay to be used by all tooltip instances,
   * except for those that have focus delay configured using property.
   *
   * @param {number} focusDelay
   */
  static setDefaultFocusDelay(focusDelay) {
    defaultFocusDelay$3 = focusDelay != null && focusDelay >= 0 ? focusDelay : DEFAULT_DELAY$1;
  }
  /**
   * Sets the default hide delay to be used by all tooltip instances,
   * except for those that have hide delay configured using property.
   *
   * @param {number} hideDelay
   */
  static setDefaultHideDelay(hideDelay) {
    defaultHideDelay$3 = hideDelay != null && hideDelay >= 0 ? hideDelay : DEFAULT_DELAY$1;
  }
  /**
   * Sets the default hover delay to be used by all tooltip instances,
   * except for those that have hover delay configured using property.
   *
   * @param {number} hoverDelay
   */
  static setDefaultHoverDelay(hoverDelay) {
    defaultHoverDelay$3 = hoverDelay != null && hoverDelay >= 0 ? hoverDelay : DEFAULT_DELAY$1;
  }
  constructor() {
    super();
    this._uniqueId = `vaadin-tooltip-${generateUniqueId()}`;
    this._renderer = this.__tooltipRenderer.bind(this);
    this.__onFocusin = this.__onFocusin.bind(this);
    this.__onFocusout = this.__onFocusout.bind(this);
    this.__onMouseDown = this.__onMouseDown.bind(this);
    this.__onMouseEnter = this.__onMouseEnter.bind(this);
    this.__onMouseLeave = this.__onMouseLeave.bind(this);
    this.__onKeyDown = this.__onKeyDown.bind(this);
    this.__onOverlayOpen = this.__onOverlayOpen.bind(this);
    this.__targetVisibilityObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => this.__onTargetVisibilityChange(entry.isIntersecting));
      },
      { threshold: 0 }
    );
    this._stateController = new TooltipStateController(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this._isConnected = true;
    document.body.addEventListener("vaadin-overlay-open", this.__onOverlayOpen);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this._autoOpened) {
      this._stateController.close(true);
    }
    this._isConnected = false;
    document.body.removeEventListener("vaadin-overlay-open", this.__onOverlayOpen);
  }
  /** @protected */
  ready() {
    super.ready();
    this._srLabelController = new SlotController(this, "sr-label", "div", {
      initializer: (element) => {
        element.id = this._uniqueId;
        element.setAttribute("role", "tooltip");
        this._srLabel = element;
      }
    });
    this.addController(this._srLabelController);
  }
  /** @private */
  __computeOpened(manual, opened, autoOpened, connected) {
    return connected && (manual ? opened : autoOpened);
  }
  /** @private */
  __autoOpenedChanged(opened, oldOpened) {
    if (opened) {
      document.addEventListener("keydown", this.__onKeyDown, true);
    } else if (oldOpened) {
      document.removeEventListener("keydown", this.__onKeyDown, true);
    }
  }
  /**
   * @param {HTMLElement} target
   * @protected
   * @override
   */
  _addTargetListeners(target) {
    target.addEventListener("mouseenter", this.__onMouseEnter);
    target.addEventListener("mouseleave", this.__onMouseLeave);
    target.addEventListener("focusin", this.__onFocusin);
    target.addEventListener("focusout", this.__onFocusout);
    target.addEventListener("mousedown", this.__onMouseDown);
    requestAnimationFrame(() => {
      this.__targetVisibilityObserver.observe(target);
    });
  }
  /**
   * @param {HTMLElement} target
   * @protected
   * @override
   */
  _removeTargetListeners(target) {
    target.removeEventListener("mouseenter", this.__onMouseEnter);
    target.removeEventListener("mouseleave", this.__onMouseLeave);
    target.removeEventListener("focusin", this.__onFocusin);
    target.removeEventListener("focusout", this.__onFocusout);
    target.removeEventListener("mousedown", this.__onMouseDown);
    this.__targetVisibilityObserver.unobserve(target);
  }
  /** @private */
  __onFocusin(event) {
    if (this.manual) {
      return;
    }
    if (!isKeyboardActive()) {
      return;
    }
    if (this.target.contains(event.relatedTarget)) {
      return;
    }
    if (!this.__isShouldShow()) {
      return;
    }
    this.__focusInside = true;
    if (!this.__isTargetHidden && (!this.__hoverInside || !this._autoOpened)) {
      this._stateController.open({ focus: true });
    }
  }
  /** @private */
  __onFocusout(event) {
    if (this.manual) {
      return;
    }
    if (this.target.contains(event.relatedTarget)) {
      return;
    }
    this.__focusInside = false;
    if (!this.__hoverInside) {
      this._stateController.close(true);
    }
  }
  /** @private */
  __onKeyDown(event) {
    if (event.key === "Escape") {
      event.stopPropagation();
      this._stateController.close(true);
    }
  }
  /** @private */
  __onMouseDown() {
    if (this.manual) {
      return;
    }
    this._stateController.close(true);
  }
  /** @private */
  __onMouseEnter() {
    if (this.manual) {
      return;
    }
    if (!this.__isShouldShow()) {
      return;
    }
    if (this.__hoverInside) {
      return;
    }
    this.__hoverInside = true;
    if (!this.__isTargetHidden && (!this.__focusInside || !this._autoOpened)) {
      this._stateController.open({ hover: true });
    }
  }
  /** @private */
  __onMouseLeave(event) {
    if (event.relatedTarget !== this._overlayElement) {
      this.__handleMouseLeave();
    }
  }
  /** @protected */
  __onOverlayMouseEnter() {
    if (this._stateController.isClosing) {
      this._stateController.open({ immediate: true });
    }
  }
  /** @protected */
  __onOverlayMouseLeave(event) {
    if (event.relatedTarget !== this.target) {
      this.__handleMouseLeave();
    }
  }
  /** @private */
  __handleMouseLeave() {
    if (this.manual) {
      return;
    }
    this.__hoverInside = false;
    if (!this.__focusInside) {
      this._stateController.close();
    }
  }
  /** @private */
  __onOverlayOpen() {
    if (this.manual) {
      return;
    }
    if (this._overlayElement.opened && !this._overlayElement._last) {
      this._stateController.close(true);
    }
  }
  /** @private */
  __onTargetVisibilityChange(isVisible) {
    const oldHidden = this.__isTargetHidden;
    this.__isTargetHidden = !isVisible;
    if (oldHidden && isVisible && (this.__focusInside || this.__hoverInside)) {
      this._stateController.open({ immediate: true });
      return;
    }
    if (!isVisible && this._autoOpened) {
      this._stateController.close(true);
    }
  }
  /** @private */
  __isShouldShow() {
    if (typeof this.shouldShow === "function" && this.shouldShow(this.target, this.context) !== true) {
      return false;
    }
    return true;
  }
  /** @private */
  __textChanged(text, oldText) {
    if (this._overlayElement && (text || oldText)) {
      this._overlayElement.requestContentUpdate();
    }
  }
  /** @private */
  __tooltipRenderer(root2) {
    root2.textContent = typeof this.generator === "function" ? this.generator(this.context) : this.text;
    this._overlayContent = root2.textContent;
  }
  /** @private */
  __computeAriaTarget(ariaTarget, target) {
    const isElementNode = (el) => el && el.nodeType === Node.ELEMENT_NODE;
    const isAriaTargetSet = Array.isArray(ariaTarget) ? ariaTarget.some(isElementNode) : ariaTarget;
    return isAriaTargetSet ? ariaTarget : target;
  }
  /** @private */
  __effectiveAriaTargetChanged(ariaTarget, oldAriaTarget) {
    if (oldAriaTarget) {
      [oldAriaTarget].flat().forEach((target) => {
        removeValueFromAttribute(target, "aria-describedby", this._uniqueId);
      });
    }
    if (ariaTarget) {
      [ariaTarget].flat().forEach((target) => {
        addValueToAttribute(target, "aria-describedby", this._uniqueId);
      });
    }
  }
  /** @private */
  __generatorChanged(overlayElement, generator, context) {
    if (overlayElement) {
      if (generator !== this.__oldTextGenerator || context !== this.__oldContext) {
        overlayElement.requestContentUpdate();
      }
      this.__oldTextGenerator = generator;
      this.__oldContext = context;
    }
  }
  /** @private */
  __updateSrLabelText(srLabel, textContent) {
    if (srLabel) {
      srLabel.textContent = textContent;
    }
  }
};
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Tooltip extends TooltipMixin(ThemePropertyMixin(ElementMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-tooltip";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: none;
        }
      </style>
      <vaadin-tooltip-overlay
        renderer="[[_renderer]]"
        theme$="[[_theme]]"
        opened="[[__computeOpened(manual, opened, _autoOpened, _isConnected)]]"
        position-target="[[target]]"
        position="[[__effectivePosition]]"
        no-horizontal-overlap$="[[__computeNoHorizontalOverlap(__effectivePosition)]]"
        no-vertical-overlap$="[[__computeNoVerticalOverlap(__effectivePosition)]]"
        horizontal-align="[[__computeHorizontalAlign(__effectivePosition)]]"
        vertical-align="[[__computeVerticalAlign(__effectivePosition)]]"
        on-mouseenter="__onOverlayMouseEnter"
        on-mouseleave="__onOverlayMouseLeave"
        modeless
      ></vaadin-tooltip-overlay>

      <slot name="sr-label"></slot>
    `;
  }
}
defineCustomElement(Tooltip);
const globalStyle = document.createElement("style");
globalStyle.textContent = "html { --vaadin-avatar-size: var(--lumo-size-m); }";
document.head.appendChild(globalStyle);
registerStyles$1(
  "vaadin-avatar",
  css`
    :host {
      color: var(--lumo-secondary-text-color);
      background-color: var(--lumo-contrast-10pct);
      border-radius: 50%;
      outline: none;
      cursor: default;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    :host([has-color-index]) {
      color: var(--lumo-base-color);
    }

    :host([focus-ring]) {
      border-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    }

    [part='icon'],
    [part='abbr'] {
      fill: currentColor;
    }

    [part='abbr'] {
      font-family: var(--lumo-font-family);
      font-size: 2.4375em;
      font-weight: 500;
    }

    :host([theme~='xlarge']) [part='abbr'] {
      font-size: 2.5em;
    }

    :host([theme~='large']) [part='abbr'] {
      font-size: 2.375em;
    }

    :host([theme~='small']) [part='abbr'] {
      font-size: 2.75em;
    }

    :host([theme~='xsmall']) [part='abbr'] {
      font-size: 3em;
    }

    :host([theme~='xlarge']) {
      --vaadin-avatar-size: var(--lumo-size-xl);
    }

    :host([theme~='large']) {
      --vaadin-avatar-size: var(--lumo-size-l);
    }

    :host([theme~='small']) {
      --vaadin-avatar-size: var(--lumo-size-s);
    }

    :host([theme~='xsmall']) {
      --vaadin-avatar-size: var(--lumo-size-xs);
    }
  `,
  { moduleId: "lumo-avatar" }
);
/**
 * @license
 * Copyright (c) 2020 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const template$6 = document.createElement("template");
template$6.innerHTML = `
  <style>
    @font-face {
      font-family: 'vaadin-avatar-icons';
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAQAAAsAAAAABnwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADsAAABUIIslek9TLzIAAAFEAAAAQwAAAFZAIUmEY21hcAAAAYgAAABLAAABcOspwa1nbHlmAAAB1AAAAEUAAABMYO4o1WhlYWQAAAIcAAAALgAAADYYaAmGaGhlYQAAAkwAAAAdAAAAJAZsA1VobXR4AAACbAAAAAgAAAAIA+gAAGxvY2EAAAJ0AAAABgAAAAYAJgAAbWF4cAAAAnwAAAAeAAAAIAEOACFuYW1lAAACnAAAAUIAAAKavFDYrHBvc3QAAAPgAAAAHQAAAC52hGZ4eJxjYGRgYOBiMGCwY2BycfMJYeDLSSzJY5BiYGGAAJA8MpsxJzM9kYEDxgPKsYBpDiBmg4gCACY7BUgAeJxjYGT8wjiBgZWBgamKaQ8DA0MPhGZ8wGDIyAQUZWBlZsAKAtJcUxgcXjG+YmQO+p/FEMUcxDANKMwIkgMADiUMJQB4nGNgYGBlYGBgBmIdIGZhYGAMYWBkAAE/oCgjWJyZgQsszsKgBFbDAhJ/xfj/P4wE8lnAJAMjG8Mo4AGTMlAeOKwgmIERADU0CX0AeJxjYGIAAmYJpkgGHgYRBgZGJT1GEztGIzlGET5GKEuU8YuSpZKSpQuI+LfLv21emz9jHJQPJP7dsUywsEiwBACG8g9CAAAAeJxjYGRgYADicIOnh+P5bb4ycDO/AIow3JZ4rIJMM0swRQIpDgYmEA8AKwgJOwAAeJxjYGRgYA76nwUkXzAAAbMEAyMDKmACAE2GAskAAAAAAAAAA+gAAAAAAAAAJgAAeJxjYGRgYGBiEAViBjCLgYELCBkY/oP5DAAKuwEwAAB4nI2Qu07DMBSG//SGaCWEhMSAGDx1QU0vYyemdmDrUDEhuamTpkriyHEj9RF4B56Bh2Bg5mmY+8d4Qh3qo9jf+c45thQAt/hGgGYFuHN7s1q4YvbHbdKD5w555LmLAZ499+hfPPfxhDfPA/p33hB0rmmG+PDcwg2+PLfpfzx3yL+eu7gPHj33MAxmnvtYB6+eB/SftZTbtBjJWlppRmmki2qlkkMmzZnKGbVWpkp1Iabh5Ex1qQplpFVbsTmKqk5m1sYiNjoXC11YlWValEbvVWTDnbXlfDyOvQ8jnaOGZGyRouCfky63/AyzFBE0fYUVFBIckLnKZTOXda15s+GZulxgihCTC2eXnC3cfFNV7BfY4Mi9eT3BjNYiZh6zRyMnLdxs050xNE3panuaiD7Ezk2VmGPMiP/1h+71/ATcWYAhAAB4nGNgYoAALgbsgImRiZGZgaW0OLWIgQEACl4B2QAAAA==) format('woff');
      font-weight: normal;
      font-style: normal;
    }
  </style>
`;
document.head.appendChild(template$6.content);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const AvatarMixin = (superClass) => class AvatarMixinClass extends FocusMixin(superClass) {
  static get properties() {
    return {
      /**
       * The path to the image
       */
      img: {
        type: String,
        reflectToAttribute: true,
        observer: "__imgChanged"
      },
      /**
       * A shortened form of name that is displayed
       * in the avatar when `img` is not provided.
       */
      abbr: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Full name of the user
       * used for the tooltip of the avatar.
       */
      name: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Color index used for avatar background.
       * @attr {number} color-index
       */
      colorIndex: {
        type: Number,
        observer: "__colorIndexChanged"
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure and default values:
       *
       * ```
       * {
       *   // Translation of the anonymous user avatar tooltip.
       *   anonymous: 'anonymous'
       * }
       * ```
       *
       * @type {!AvatarI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value: () => {
          return {
            anonymous: "anonymous"
          };
        }
      },
      /**
       * When true, the avatar has tooltip shown on hover and focus.
       * The tooltip text is based on the `name` and `abbr` properties.
       * When neither is provided, `i18n.anonymous` is used instead.
       * @attr {boolean} with-tooltip
       */
      withTooltip: {
        type: Boolean,
        value: false,
        observer: "__withTooltipChanged"
      },
      /** @protected */
      __imgVisible: Boolean,
      /** @protected */
      __iconVisible: Boolean,
      /** @protected */
      __abbrVisible: Boolean,
      /** @private */
      __tooltipNode: Object
    };
  }
  static get observers() {
    return [
      "__imgOrAbbrOrNameChanged(img, abbr, name)",
      "__i18nChanged(i18n)",
      "__tooltipChanged(__tooltipNode, name, abbr)"
    ];
  }
  /** @protected */
  ready() {
    super.ready();
    this.__updateVisibility();
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", "img");
    }
    if (!this.hasAttribute("tabindex")) {
      this.setAttribute("tabindex", "0");
    }
    if (!this.name && !this.abbr) {
      this.__setTooltip();
    }
  }
  /** @private */
  __colorIndexChanged(index) {
    if (index != null) {
      const prop = `--vaadin-user-color-${index}`;
      const isValid2 = Boolean(getComputedStyle(document.documentElement).getPropertyValue(prop));
      if (isValid2) {
        this.setAttribute("has-color-index", "");
        this.style.setProperty("--vaadin-avatar-user-color", `var(${prop})`);
      } else {
        this.removeAttribute("has-color-index");
        console.warn(`The CSS property --vaadin-user-color-${index} is not defined`);
      }
    } else {
      this.removeAttribute("has-color-index");
    }
  }
  /** @private */
  __imgChanged() {
    this.__imgFailedToLoad = false;
  }
  /** @private */
  __imgOrAbbrOrNameChanged(_img, abbr, name) {
    this.__updateVisibility();
    if (abbr && abbr !== this.__generatedAbbr) {
      return;
    }
    if (name) {
      this.abbr = this.__generatedAbbr = name.split(" ").map((word) => word.charAt(0)).join("");
    } else {
      this.abbr = void 0;
    }
  }
  /** @private */
  __tooltipChanged(tooltipNode, name, abbr) {
    if (tooltipNode) {
      if (abbr && abbr !== this.__generatedAbbr) {
        this.__setTooltip(name ? `${name} (${abbr})` : abbr);
      } else {
        this.__setTooltip(name);
      }
    }
    if (abbr) {
      this.setAttribute("aria-label", !tooltipNode && name ? `${name} (${abbr})` : abbr);
    } else {
      this.removeAttribute("aria-label");
    }
  }
  /** @private */
  __withTooltipChanged(withTooltip, oldWithTooltip) {
    if (withTooltip) {
      const tooltipNode = document.createElement("vaadin-tooltip");
      tooltipNode.setAttribute("slot", "tooltip");
      this.appendChild(tooltipNode);
      this.__tooltipNode = tooltipNode;
    } else if (oldWithTooltip) {
      this.__tooltipNode.target = null;
      this.__tooltipNode.remove();
      this.__tooltipNode = null;
    }
  }
  /** @private */
  __i18nChanged(i18n) {
    if (i18n && i18n.anonymous) {
      if (this.__oldAnonymous && this.__tooltipNode && this.__tooltipNode.text === this.__oldAnonymous) {
        this.__setTooltip();
      }
      this.__oldAnonymous = i18n.anonymous;
    }
  }
  /** @private */
  __updateVisibility() {
    this.__imgVisible = !!this.img && !this.__imgFailedToLoad;
    this.__abbrVisible = !this.__imgVisible && !!this.abbr;
    this.__iconVisible = !this.__imgVisible && !this.abbr;
  }
  /** @private */
  __setTooltip(tooltip) {
    const tooltipNode = this.__tooltipNode;
    if (tooltipNode) {
      tooltipNode.text = tooltip || this.i18n.anonymous;
    }
  }
  /** @protected */
  __onImageLoadError() {
    if (this.img) {
      console.warn(`<vaadin-avatar> The specified image could not be loaded: ${this.img}`);
      this.__imgFailedToLoad = true;
      this.__updateVisibility();
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const avatarStyles = css`
  :host {
    display: inline-block;
    flex: none;
    border-radius: 50%;
    overflow: hidden;
    height: var(--vaadin-avatar-size, 64px);
    width: var(--vaadin-avatar-size, 64px);
    border: var(--vaadin-avatar-outline-width) solid transparent;
    margin: calc(var(--vaadin-avatar-outline-width) * -1);
    background-clip: content-box;
    --vaadin-avatar-outline-width: var(--vaadin-focus-ring-width, 2px);
  }

  img {
    height: 100%;
    width: 100%;
    object-fit: cover;
  }

  [part='icon'] {
    font-size: 5.6em;
  }

  [part='abbr'] {
    font-size: 2.2em;
  }

  [part='icon'] > text {
    font-family: 'vaadin-avatar-icons';
  }

  :host([hidden]) {
    display: none !important;
  }

  svg[hidden] {
    display: none !important;
  }

  :host([has-color-index]) {
    position: relative;
    background-color: var(--vaadin-avatar-user-color);
  }

  :host([has-color-index])::before {
    position: absolute;
    content: '';
    inset: 0;
    border-radius: inherit;
    box-shadow: inset 0 0 0 2px var(--vaadin-avatar-user-color);
  }
`;
/**
 * @license
 * Copyright (c) 2020 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-avatar", avatarStyles, { moduleId: "vaadin-avatar-styles" });
class Avatar extends AvatarMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <img
        hidden$="[[!__imgVisible]]"
        src$="[[img]]"
        aria-hidden="true"
        on-error="__onImageLoadError"
        draggable="false"
      />
      <svg
        part="icon"
        hidden$="[[!__iconVisible]]"
        id="avatar-icon"
        viewBox="-50 -50 100 100"
        preserveAspectRatio="xMidYMid meet"
        aria-hidden="true"
      >
        <text dy=".35em" text-anchor="middle">&#xea01;</text>
      </svg>
      <svg
        part="abbr"
        hidden$="[[!__abbrVisible]]"
        id="avatar-abbr"
        viewBox="-50 -50 100 100"
        preserveAspectRatio="xMidYMid meet"
        aria-hidden="true"
      >
        <text dy=".35em" text-anchor="middle">[[abbr]]</text>
      </svg>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-avatar";
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
  }
}
defineCustomElement(Avatar);
const item = css`
  :host {
    display: flex;
    align-items: center;
    box-sizing: border-box;
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-xs);
    padding: 0.5em calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4) 0.5em
      var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));
    min-height: var(--lumo-size-m);
    outline: none;
    border-radius: var(--lumo-border-radius-m);
    cursor: var(--lumo-clickable-cursor);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: var(--lumo-primary-color-10pct);
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
    --_selection-color-text: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
  }

  /* Checkmark */
  [part='checkmark']::before {
    display: var(--_lumo-item-selected-icon-display, none);
    content: var(--lumo-icons-checkmark);
    font-family: lumo-icons;
    font-size: var(--lumo-icon-size-m);
    line-height: 1;
    font-weight: normal;
    width: 1em;
    height: 1em;
    margin: calc((1 - var(--lumo-line-height-xs)) * var(--lumo-font-size-m) / 2) 0;
    color: var(--_selection-color-text);
    flex: none;
    opacity: 0;
    transition:
      transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2),
      opacity 0.1s;
  }

  :host([selected]) [part='checkmark']::before {
    opacity: 1;
  }

  :host([active]:not([selected])) [part='checkmark']::before {
    transform: scale(0.8);
    opacity: 0;
    transition-duration: 0s;
  }

  [part='content'] {
    flex: auto;
  }

  /* Disabled */
  :host([disabled]) {
    color: var(--lumo-disabled-text-color);
    cursor: default;
    pointer-events: none;
  }

  /* TODO a workaround until we have "focus-follows-mouse". After that, use the hover style for focus-ring as well */
  @media (any-hover: hover) {
    :host(:hover:not([disabled])) {
      background-color: var(--lumo-primary-color-10pct);
    }
  }

  :host([focus-ring]:not([disabled])) {
    box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  /* RTL specific styles */
  :host([dir='rtl']) {
    padding-left: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
    padding-right: var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));
  }

  /* Slotted icons */
  :host ::slotted(vaadin-icon) {
    width: var(--lumo-icon-size-m);
    height: var(--lumo-icon-size-m);
  }
`;
registerStyles$1("vaadin-item", item, { moduleId: "lumo-item" });
const listBox = css`
  :host {
    -webkit-tap-highlight-color: transparent;
    --_lumo-item-selected-icon-display: var(--_lumo-list-box-item-selected-icon-display, block);
  }

  /* Dividers */
  [part='items'] ::slotted(hr) {
    height: 1px;
    border: 0;
    padding: 0;
    margin: var(--lumo-space-s) var(--lumo-border-radius-m);
    background-color: var(--lumo-contrast-10pct);
  }
`;
registerStyles$1("vaadin-list-box", listBox, { moduleId: "lumo-list-box" });
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const menuOverlayCore = css`
  :host([opening]),
  :host([closing]) {
    animation: 0.14s lumo-overlay-dummy-animation;
  }

  [part='overlay'] {
    will-change: opacity, transform;
  }

  :host([opening]) [part='overlay'] {
    animation: 0.1s lumo-menu-overlay-enter ease-out both;
  }

  @keyframes lumo-menu-overlay-enter {
    0% {
      opacity: 0;
      transform: translateY(-4px);
    }
  }

  :host([closing]) [part='overlay'] {
    animation: 0.1s lumo-menu-overlay-exit both;
  }

  @keyframes lumo-menu-overlay-exit {
    100% {
      opacity: 0;
    }
  }
`;
registerStyles$1("", menuOverlayCore, { moduleId: "lumo-menu-overlay-core" });
const menuOverlayExt = css`
  /* Small viewport (bottom sheet) styles */
  /* Use direct media queries instead of the state attributes ([phone] and [fullscreen]) provided by the elements */
  @media (max-width: 450px), (max-height: 450px) {
    :host {
      top: 0 !important;
      right: 0 !important;
      bottom: var(--vaadin-overlay-viewport-bottom, 0) !important;
      left: 0 !important;
      align-items: stretch !important;
      justify-content: flex-end !important;
    }

    [part='overlay'] {
      max-height: 50vh;
      width: 100vw;
      border-radius: 0;
      box-shadow: var(--lumo-box-shadow-xl);
    }

    /* The content part scrolls instead of the overlay part, because of the gradient fade-out */
    [part='content'] {
      padding: 30px var(--lumo-space-m);
      max-height: inherit;
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      overflow: auto;
      -webkit-mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);
      mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);
    }

    [part='backdrop'] {
      display: block;
    }

    /* Animations */

    :host([opening]) [part='overlay'] {
      animation: 0.2s lumo-mobile-menu-overlay-enter cubic-bezier(0.215, 0.61, 0.355, 1) both;
    }

    :host([closing]),
    :host([closing]) [part='backdrop'] {
      animation-delay: 0.14s;
    }

    :host([closing]) [part='overlay'] {
      animation: 0.14s 0.14s lumo-mobile-menu-overlay-exit cubic-bezier(0.55, 0.055, 0.675, 0.19) both;
    }
  }

  @keyframes lumo-mobile-menu-overlay-enter {
    0% {
      transform: translateY(150%);
    }
  }

  @keyframes lumo-mobile-menu-overlay-exit {
    100% {
      transform: translateY(150%);
    }
  }
`;
const menuOverlay = [overlay, menuOverlayCore, menuOverlayExt];
registerStyles$1("", menuOverlay, { moduleId: "lumo-menu-overlay" });
registerStyles$1(
  "vaadin-avatar-group",
  css`
    :host {
      --vaadin-avatar-size: var(--lumo-size-m);
    }

    :host([theme~='xlarge']) {
      --vaadin-avatar-group-overlap: 12px;
      --vaadin-avatar-group-overlap-border: 3px;
      --vaadin-avatar-size: var(--lumo-size-xl);
    }

    :host([theme~='large']) {
      --vaadin-avatar-group-overlap: 10px;
      --vaadin-avatar-group-overlap-border: 3px;
      --vaadin-avatar-size: var(--lumo-size-l);
    }

    :host([theme~='small']) {
      --vaadin-avatar-group-overlap: 6px;
      --vaadin-avatar-group-overlap-border: 2px;
      --vaadin-avatar-size: var(--lumo-size-s);
    }

    :host([theme~='xsmall']) {
      --vaadin-avatar-group-overlap: 4px;
      --vaadin-avatar-group-overlap-border: 2px;
      --vaadin-avatar-size: var(--lumo-size-xs);
    }
  `,
  { moduleId: "lumo-avatar-group" }
);
const avatarGroupOverlay = css`
  :host {
    --_lumo-list-box-item-selected-icon-display: none;
    --_lumo-list-box-item-padding-left: calc(var(--lumo-space-m) + var(--lumo-border-radius-m) / 4);
  }

  [part='overlay'] {
    outline: none;
  }
`;
registerStyles$1("vaadin-avatar-group-overlay", [overlay, menuOverlayCore, avatarGroupOverlay], {
  moduleId: "lumo-avatar-group-overlay"
});
registerStyles$1("vaadin-avatar-group-menu", listBox, { moduleId: "lumo-avatar-group-menu" });
registerStyles$1(
  "vaadin-avatar-group-menu-item",
  [
    item,
    css`
      :host {
        padding: var(--lumo-space-xs);
        padding-inline-end: var(--lumo-space-m);
      }

      [part='content'] {
        display: flex;
        align-items: center;
      }

      [part='content'] ::slotted(vaadin-avatar) {
        width: var(--lumo-size-xs);
        height: var(--lumo-size-xs);
        margin-inline-end: var(--lumo-space-s);
      }
    `
  ],
  { moduleId: "lumo-avatar-group-menu-item" }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function getNormalizedScrollLeft(element, direction) {
  const { scrollLeft } = element;
  if (direction !== "rtl") {
    return scrollLeft;
  }
  return element.scrollWidth - element.clientWidth + scrollLeft;
}
function setNormalizedScrollLeft(element, direction, scrollLeft) {
  if (direction !== "rtl") {
    element.scrollLeft = scrollLeft;
  } else {
    element.scrollLeft = element.clientWidth - element.scrollWidth + scrollLeft;
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ListMixin = (superClass) => class ListMixinClass extends KeyboardDirectionMixin(superClass) {
  static get properties() {
    return {
      /**
       * If true, the user cannot interact with this element.
       * When the element is disabled, the selected item is
       * not updated when `selected` property is changed.
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * The index of the item selected in the items array.
       * Note: Not updated when used in `multiple` selection mode.
       */
      selected: {
        type: Number,
        reflectToAttribute: true,
        notify: true
      },
      /**
       * Define how items are disposed in the dom.
       * Possible values are: `horizontal|vertical`.
       * It also changes navigation keys from left/right to up/down.
       * @type {!ListOrientation}
       */
      orientation: {
        type: String,
        reflectToAttribute: true,
        value: ""
      },
      /**
       * The list of items from which a selection can be made.
       * It is populated from the elements passed to the light DOM,
       * and updated dynamically when adding or removing items.
       *
       * The item elements must implement `Vaadin.ItemMixin`.
       *
       * Note: unlike `<vaadin-combo-box>`, this property is read-only,
       * so if you want to provide items by iterating array of data,
       * you have to use `dom-repeat` and place it to the light DOM.
       * @type {!Array<!Element> | undefined}
       */
      items: {
        type: Array,
        readOnly: true,
        notify: true
      },
      /**
       * The search buffer for the keyboard selection feature.
       * @private
       */
      _searchBuf: {
        type: String,
        value: ""
      }
    };
  }
  static get observers() {
    return ["_enhanceItems(items, orientation, selected, disabled)"];
  }
  /**
   * @return {boolean}
   * @protected
   */
  get _isRTL() {
    return !this._vertical && this.getAttribute("dir") === "rtl";
  }
  /**
   * @return {!HTMLElement}
   * @protected
   */
  get _scrollerElement() {
    console.warn(`Please implement the '_scrollerElement' property in <${this.localName}>`);
    return this;
  }
  /**
   * @return {boolean}
   * @protected
   */
  get _vertical() {
    return this.orientation !== "horizontal";
  }
  focus() {
    if (this._observer) {
      this._observer.flush();
    }
    const items = Array.isArray(this.items) ? this.items : [];
    const idx = this._getAvailableIndex(items, 0, null, (item2) => item2.tabIndex === 0 && !isElementHidden(item2));
    if (idx >= 0) {
      this._focus(idx);
    } else {
      super.focus();
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("click", (e2) => this._onClick(e2));
    const slot = this.shadowRoot.querySelector("slot:not([name])");
    this._observer = new SlotObserver(slot, () => {
      this._setItems(this._filterItems(getFlattenedElements(this)));
    });
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin`
   * to use the stored list of item elements.
   *
   * @return {Element[]}
   * @protected
   * @override
   */
  _getItems() {
    return this.items;
  }
  /** @private */
  _enhanceItems(items, orientation, selected, disabled) {
    if (!disabled) {
      if (items) {
        this.setAttribute("aria-orientation", orientation || "vertical");
        items.forEach((item2) => {
          if (orientation) {
            item2.setAttribute("orientation", orientation);
          } else {
            item2.removeAttribute("orientation");
          }
        });
        this._setFocusable(selected < 0 || !selected ? 0 : selected);
        const itemToSelect = items[selected];
        items.forEach((item2) => {
          item2.selected = item2 === itemToSelect;
        });
        if (itemToSelect && !itemToSelect.disabled) {
          this._scrollToItem(selected);
        }
      }
    }
  }
  /**
   * @param {!Array<!Element>} array
   * @return {!Array<!Element>}
   * @protected
   */
  _filterItems(array) {
    return array.filter((e2) => e2._hasVaadinItemMixin);
  }
  /**
   * @param {!MouseEvent} event
   * @protected
   */
  _onClick(event) {
    if (event.metaKey || event.shiftKey || event.ctrlKey || event.defaultPrevented) {
      return;
    }
    const item2 = this._filterItems(event.composedPath())[0];
    let idx;
    if (item2 && !item2.disabled && (idx = this.items.indexOf(item2)) >= 0) {
      this.selected = idx;
    }
  }
  /**
   * @param {number} currentIdx
   * @param {string} key
   * @return {number}
   * @protected
   */
  _searchKey(currentIdx, key) {
    this._searchReset = Debouncer$1.debounce(this._searchReset, timeOut.after(500), () => {
      this._searchBuf = "";
    });
    this._searchBuf += key.toLowerCase();
    if (!this.items.some((item2) => this.__isMatchingKey(item2))) {
      this._searchBuf = key.toLowerCase();
    }
    const idx = this._searchBuf.length === 1 ? currentIdx + 1 : currentIdx;
    return this._getAvailableIndex(
      this.items,
      idx,
      1,
      (item2) => this.__isMatchingKey(item2) && getComputedStyle(item2).display !== "none"
    );
  }
  /** @private */
  __isMatchingKey(item2) {
    return item2.textContent.replace(/[^\p{L}\p{Nd}]/gu, "").toLowerCase().startsWith(this._searchBuf);
  }
  /**
   * Override an event listener from `KeyboardMixin`
   * to search items by key.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    if (event.metaKey || event.ctrlKey) {
      return;
    }
    const key = event.key;
    const currentIdx = this.items.indexOf(this.focused);
    if (/[\p{L}\p{Nd}]/u.test(key) && key.length === 1) {
      const idx = this._searchKey(currentIdx, key);
      if (idx >= 0) {
        this._focus(idx);
      }
      return;
    }
    super._onKeyDown(event);
  }
  /**
   * @param {!Element} item
   * @return {boolean}
   * @protected
   */
  _isItemHidden(item2) {
    return getComputedStyle(item2).display === "none";
  }
  /**
   * @param {number} idx
   * @protected
   */
  _setFocusable(idx) {
    idx = this._getAvailableIndex(this.items, idx, 1);
    const item2 = this.items[idx];
    this.items.forEach((e2) => {
      e2.tabIndex = e2 === item2 ? 0 : -1;
    });
  }
  /**
   * @param {number} idx
   * @protected
   */
  _focus(idx) {
    this.items.forEach((e2, index) => {
      e2.focused = index === idx;
    });
    this._setFocusable(idx);
    this._scrollToItem(idx);
    super._focus(idx);
  }
  /**
   * Scroll the container to have the next item by the edge of the viewport.
   * @param {number} idx
   * @protected
   */
  _scrollToItem(idx) {
    const item2 = this.items[idx];
    if (!item2) {
      return;
    }
    const props = this._vertical ? ["top", "bottom"] : this._isRTL ? ["right", "left"] : ["left", "right"];
    const scrollerRect = this._scrollerElement.getBoundingClientRect();
    const nextItemRect = (this.items[idx + 1] || item2).getBoundingClientRect();
    const prevItemRect = (this.items[idx - 1] || item2).getBoundingClientRect();
    let scrollDistance = 0;
    if (!this._isRTL && nextItemRect[props[1]] >= scrollerRect[props[1]] || this._isRTL && nextItemRect[props[1]] <= scrollerRect[props[1]]) {
      scrollDistance = nextItemRect[props[1]] - scrollerRect[props[1]];
    } else if (!this._isRTL && prevItemRect[props[0]] <= scrollerRect[props[0]] || this._isRTL && prevItemRect[props[0]] >= scrollerRect[props[0]]) {
      scrollDistance = prevItemRect[props[0]] - scrollerRect[props[0]];
    }
    this._scroll(scrollDistance);
  }
  /**
   * @param {number} pixels
   * @protected
   */
  _scroll(pixels) {
    if (this._vertical) {
      this._scrollerElement.scrollTop += pixels;
    } else {
      const dir = this.getAttribute("dir") || "ltr";
      const scrollLeft = getNormalizedScrollLeft(this._scrollerElement, dir) + pixels;
      setNormalizedScrollLeft(this._scrollerElement, dir, scrollLeft);
    }
  }
  /**
   * Fired when the selection is changed.
   * Not fired when used in `multiple` selection mode.
   *
   * @event selected-changed
   * @param {Object} detail
   * @param {Object} detail.value the index of the item selected in the items array.
   */
};
/**
 * @license
 * Copyright (c) 2020 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class AvatarGroupMenu extends ListMixin(ThemableMixin(DirMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-avatar-group-menu";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='items'] {
          height: 100%;
          width: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }
      </style>
      <div part="items">
        <slot></slot>
      </div>
    `;
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        readOnly: true
      }
    };
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menu");
  }
}
defineCustomElement(AvatarGroupMenu);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ItemMixin = (superClass) => class VaadinItemMixin extends ActiveMixin(FocusMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Used for mixin detection because `instanceof` does not work with mixins.
       * e.g. in VaadinListMixin it filters items by using the
       * `element._hasVaadinItemMixin` condition.
       * @type {boolean}
       */
      _hasVaadinItemMixin: {
        value: true
      },
      /**
       * If true, the item is in selected state.
       * @type {boolean}
       */
      selected: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_selectedChanged"
      },
      /** @private */
      _value: String
    };
  }
  /**
   * By default, `Space` is the only possible activation key for a focusable HTML element.
   * Nonetheless, the item is an exception as it can be also activated by pressing `Enter`.
   * See the "Keyboard Support" section in https://www.w3.org/TR/wai-aria-practices/examples/menubar/menubar-1/menubar-1.html.
   *
   * @protected
   * @override
   */
  get _activeKeys() {
    return ["Enter", " "];
  }
  /**
   * @return {string}
   */
  get value() {
    return this._value !== void 0 ? this._value : this.textContent.trim();
  }
  /**
   * @param {string} value
   */
  set value(value) {
    this._value = value;
  }
  /** @protected */
  ready() {
    super.ready();
    const attrValue = this.getAttribute("value");
    if (attrValue !== null) {
      this.value = attrValue;
    }
  }
  /**
   * Override native `focus` to set focused attribute
   * when focusing the item programmatically.
   * @protected
   * @override
   */
  focus() {
    if (this.disabled) {
      return;
    }
    super.focus();
    this._setFocused(true);
  }
  /**
   * @param {KeyboardEvent | MouseEvent} _event
   * @protected
   * @override
   */
  _shouldSetActive(event) {
    return !this.disabled && !(event.type === "keydown" && event.defaultPrevented);
  }
  /** @private */
  _selectedChanged(selected) {
    this.setAttribute("aria-selected", selected);
  }
  /**
   * Override an observer from `DisabledMixin`.
   * @protected
   * @override
   */
  _disabledChanged(disabled) {
    super._disabledChanged(disabled);
    if (disabled) {
      this.selected = false;
      this.blur();
    }
  }
  /**
   * In order to be fully accessible from the keyboard, the item should
   * manually fire the `click` event once an activation key is pressed.
   *
   * According to the UI Events specifications,
   * the `click` event should be fired exactly on `keydown`:
   * https://www.w3.org/TR/uievents/#event-type-keydown
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    if (this._activeKeys.includes(event.key) && !event.defaultPrevented) {
      event.preventDefault();
      this.click();
    }
  }
};
/**
 * @license
 * Copyright (c) 2020 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class AvatarGroupMenuItem extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-avatar-group-menu-item";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menuitem");
  }
}
defineCustomElement(AvatarGroupMenuItem);
/**
 * @license
 * Copyright (c) 2020 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-avatar-group-overlay", [overlayStyles], {
  moduleId: "vaadin-avatar-group-overlay-styles"
});
class AvatarGroupOverlay extends PositionMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-avatar-group-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
}
defineCustomElement(AvatarGroupOverlay);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ifDefined = (value) => value ?? nothing;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const observer = new ResizeObserver((entries) => {
  setTimeout(() => {
    entries.forEach((entry) => {
      if (entry.target.resizables) {
        entry.target.resizables.forEach((resizable) => {
          resizable._onResize(entry.contentRect);
        });
      } else {
        entry.target._onResize(entry.contentRect);
      }
    });
  });
});
const ResizeMixin = dedupingMixin(
  (superclass) => class ResizeMixinClass extends superclass {
    /**
     * When true, the parent element resize will be also observed.
     * Override this getter and return `true` to enable this.
     *
     * @protected
     */
    get _observeParent() {
      return false;
    }
    /** @protected */
    connectedCallback() {
      super.connectedCallback();
      observer.observe(this);
      if (this._observeParent) {
        const parent = this.parentNode instanceof ShadowRoot ? this.parentNode.host : this.parentNode;
        if (!parent.resizables) {
          parent.resizables = /* @__PURE__ */ new Set();
          observer.observe(parent);
        }
        parent.resizables.add(this);
        this.__parent = parent;
      }
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback();
      observer.unobserve(this);
      const parent = this.__parent;
      if (this._observeParent && parent) {
        const resizables = parent.resizables;
        if (resizables) {
          resizables.delete(this);
          if (resizables.size === 0) {
            observer.unobserve(parent);
          }
        }
        this.__parent = null;
      }
    }
    /**
     * A handler invoked on host resize. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @protected
     */
    _onResize(_contentRect) {
    }
  }
);
/**
 * @license
 * Copyright (c) 2020 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MINIMUM_DISPLAYED_AVATARS = 2;
const AvatarGroupMixin = (superClass) => class AvatarGroupMixinClass extends ResizeMixin(OverlayClassMixin(superClass)) {
  static get properties() {
    return {
      /**
       * An array containing the items which will be stamped as avatars.
       *
       * The items objects allow to configure [`name`](#/elements/vaadin-avatar#property-name),
       * [`abbr`](#/elements/vaadin-avatar#property-abbr), [`img`](#/elements/vaadin-avatar#property-img)
       * and [`colorIndex`](#/elements/vaadin-avatar#property-colorIndex) properties on the
       * stamped avatars, and set `className` to provide CSS class names.
       *
       * #### Example
       *
       * ```js
       * group.items = [
       *   {
       *     name: 'User name',
       *     img: 'url-to-image.png',
       *     className: 'even'
       *   },
       *   {
       *     abbr: 'JD',
       *     colorIndex: 1,
       *     className: 'odd'
       *   },
       * ];
       * ```
       *
       * @type {!Array<!AvatarGroupItem> | undefined}
       */
      items: {
        type: Array,
        observer: "__itemsChanged",
        sync: true
      },
      /**
       * The maximum number of avatars to display. By default, all the avatars are displayed.
       * When _maxItemsVisible_ is set, the overflowing avatars are grouped into one avatar with
       * a dropdown. Setting 0 or 1 has no effect so there are always at least two avatars visible.
       * @attr {number} max-items-visible
       */
      maxItemsVisible: {
        type: Number,
        sync: true
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure and default values:
       * ```
       * {
       *   // Translation of the anonymous user avatar tooltip.
       *   anonymous: 'anonymous',
       *   // Translation of the avatar group accessible label.
       *   // {count} is replaced with the actual count of users.
       *   activeUsers: {
       *     one: 'Currently one active user',
       *     many: 'Currently {count} active users'
       *   },
       *   // Screen reader announcement when user joins group.
       *   // {user} is replaced with the name or abbreviation.
       *   // When neither is set, "anonymous" is used instead.
       *   joined: '{user} joined',
       *   // Screen reader announcement when user leaves group.
       *   // {user} is replaced with the name or abbreviation.
       *   // When neither is set, "anonymous" is used instead.
       *   left: '{user} left'
       * }
       * ```
       * @type {!AvatarGroupI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        sync: true,
        value: () => {
          return {
            anonymous: "anonymous",
            activeUsers: {
              one: "Currently one active user",
              many: "Currently {count} active users"
            },
            joined: "{user} joined",
            left: "{user} left"
          };
        }
      },
      /** @private */
      _avatars: {
        type: Array,
        value: () => [],
        sync: true
      },
      /** @private */
      __itemsInView: {
        type: Number,
        value: null,
        sync: true
      },
      /** @private */
      _overflow: {
        type: Object,
        sync: true
      },
      /** @private */
      _overflowItems: {
        type: Array,
        observer: "__overflowItemsChanged",
        computed: "__computeOverflowItems(items, __itemsInView, maxItemsVisible)",
        sync: true
      },
      /** @private */
      _overflowTooltip: {
        type: Object,
        sync: true
      },
      /** @private */
      _opened: {
        type: Boolean,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "__i18nItemsChanged(i18n, items)",
      "__openedChanged(_opened, _overflow)",
      "__updateAvatarsTheme(_overflow, _avatars, _theme)",
      "__updateAvatars(items, __itemsInView, maxItemsVisible, _overflow, i18n)",
      "__updateOverflowAvatar(_overflow, items, __itemsInView, maxItemsVisible)",
      "__updateOverflowTooltip(_overflowTooltip, items, __itemsInView, maxItemsVisible)"
    ];
  }
  /** @protected */
  ready() {
    super.ready();
    this._overflowController = new SlotController(this, "overflow", "vaadin-avatar", {
      initializer: (overflow) => {
        overflow.setAttribute("role", "button");
        overflow.setAttribute("aria-haspopup", "menu");
        overflow.setAttribute("aria-expanded", "false");
        overflow.addEventListener("click", (e2) => this._onOverflowClick(e2));
        overflow.addEventListener("keydown", (e2) => this._onOverflowKeyDown(e2));
        const tooltip = document.createElement("vaadin-tooltip");
        tooltip.setAttribute("slot", "tooltip");
        overflow.appendChild(tooltip);
        this._overflow = overflow;
        this._overflowTooltip = tooltip;
      }
    });
    this.addController(this._overflowController);
    const overlay2 = this.$.overlay;
    overlay2.renderer = this.__overlayRenderer.bind(this);
    this._overlayElement = overlay2;
    afterNextRender(this, () => {
      this.__setItemsInView();
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this._opened = false;
  }
  /** @private */
  __getMessage(user, action) {
    return action.replace("{user}", user.name || user.abbr || this.i18n.anonymous);
  }
  /**
   * Renders items when they are provided by the `items` property and clears the content otherwise.
   * @param {!HTMLElement} root
   * @param {!Select} _select
   * @private
   */
  __overlayRenderer(root2) {
    let menu = root2.firstElementChild;
    if (!menu) {
      menu = document.createElement("vaadin-avatar-group-menu");
      menu.addEventListener("keydown", (event) => this._onListKeyDown(event));
      root2.appendChild(menu);
    }
    menu.textContent = "";
    if (!this._overflowItems) {
      return;
    }
    this._overflowItems.forEach((item2) => {
      menu.appendChild(this.__createItemElement(item2));
    });
  }
  /** @private */
  __createItemElement(item2) {
    const itemElement = document.createElement("vaadin-avatar-group-menu-item");
    const avatar = document.createElement("vaadin-avatar");
    itemElement.appendChild(avatar);
    avatar.setAttribute("aria-hidden", "true");
    avatar.setAttribute("tabindex", "-1");
    avatar.i18n = this.i18n;
    if (this._theme) {
      avatar.setAttribute("theme", this._theme);
    }
    avatar.name = item2.name;
    avatar.abbr = item2.abbr;
    avatar.img = item2.img;
    avatar.colorIndex = item2.colorIndex;
    if (item2.className) {
      avatar.className = item2.className;
    }
    if (item2.name) {
      const text = document.createTextNode(item2.name);
      itemElement.appendChild(text);
    }
    return itemElement;
  }
  /** @private */
  _onOverflowClick(e2) {
    e2.stopPropagation();
    if (this._opened) {
      this.$.overlay.close();
    } else if (!e2.defaultPrevented) {
      this._opened = true;
    }
  }
  /** @private */
  _onOverflowKeyDown(e2) {
    if (!this._opened) {
      if (/^(Enter|SpaceBar|\s)$/u.test(e2.key)) {
        e2.preventDefault();
        this._opened = true;
      }
    }
  }
  /** @private */
  _onListKeyDown(event) {
    if (event.key === "Escape" || event.key === "Tab") {
      this._opened = false;
    }
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this.__setItemsInView();
  }
  /** @private */
  _onVaadinOverlayClose(e2) {
    if (e2.detail.sourceEvent && e2.detail.sourceEvent.composedPath().includes(this)) {
      e2.preventDefault();
    }
  }
  /** @private */
  _onVaadinOverlayOpen() {
    if (this._menuElement) {
      this._menuElement.focus();
    }
  }
  /** @private */
  __renderAvatars(items) {
    render(
      html$1`
          ${items.map(
        (item2) => html$1`
              <vaadin-avatar
                .name="${item2.name}"
                .abbr="${item2.abbr}"
                .img="${item2.img}"
                .colorIndex="${item2.colorIndex}"
                .i18n="${this.i18n}"
                class="${ifDefined(item2.className)}"
                with-tooltip
              ></vaadin-avatar>
            `
      )}
        `,
      this,
      { renderBefore: this._overflow }
    );
  }
  /** @private */
  __updateAvatars(items, itemsInView, maxItemsVisible, overflow) {
    if (!overflow || !Array.isArray(items)) {
      return;
    }
    const limit = this.__getLimit(items.length, itemsInView, maxItemsVisible);
    this.__renderAvatars(limit ? items.slice(0, limit) : items);
    this._avatars = [...this.querySelectorAll("vaadin-avatar")];
  }
  /** @private */
  __computeOverflowItems(items, itemsInView, maxItemsVisible) {
    const count = Array.isArray(items) ? items.length : 0;
    const limit = this.__getLimit(count, itemsInView, maxItemsVisible);
    return limit ? items.slice(limit) : [];
  }
  /** @private */
  __updateOverflowAvatar(overflow, items, itemsInView, maxItemsVisible) {
    if (overflow) {
      const count = Array.isArray(items) ? items.length : 0;
      const maxReached = maxItemsVisible != null && count > this.__getMax(maxItemsVisible);
      overflow.abbr = `+${count - this.__getLimit(count, itemsInView, maxItemsVisible)}`;
      overflow.toggleAttribute("hidden", !maxReached && !(itemsInView && itemsInView < count));
    }
  }
  /** @private */
  __updateAvatarsTheme(overflow, avatars, theme) {
    if (overflow) {
      [overflow, ...avatars].forEach((avatar) => {
        if (theme) {
          avatar.setAttribute("theme", theme);
        } else {
          avatar.removeAttribute("theme");
        }
      });
    }
  }
  /** @private */
  __updateOverflowTooltip(tooltip, items, itemsInView, maxItemsVisible) {
    if (!tooltip || !Array.isArray(items)) {
      return;
    }
    const limit = this.__getLimit(items.length, itemsInView, maxItemsVisible);
    if (limit == null) {
      return;
    }
    const result = [];
    for (let i2 = limit; i2 < items.length; i2++) {
      const item2 = items[i2];
      if (item2) {
        result.push(item2.name || item2.abbr || "anonymous");
      }
    }
    tooltip.text = result.join("\n");
  }
  /** @private */
  __getLimit(items, itemsInView, maxItemsVisible) {
    let limit = null;
    const adjustedMax = this.__getMax(maxItemsVisible);
    if (maxItemsVisible != null && adjustedMax < items) {
      limit = adjustedMax - 1;
    } else if (itemsInView && itemsInView < items) {
      limit = itemsInView;
    }
    return Math.min(limit, this.__calculateAvatarsFitWidth());
  }
  /** @private */
  __getMax(maxItemsVisible) {
    return Math.max(maxItemsVisible, MINIMUM_DISPLAYED_AVATARS);
  }
  /** @private */
  __itemsChanged(items, oldItems) {
    this.__setItemsInView();
    let added = [];
    let removed = [];
    const hasNewItems = Array.isArray(items);
    const hasOldItems = Array.isArray(oldItems);
    if (hasOldItems) {
      removed = oldItems.filter((item2) => hasNewItems && !items.includes(item2));
    }
    if (hasNewItems) {
      added = items.filter((item2) => hasOldItems && !oldItems.includes(item2));
    }
    this.__announceItemsChange(added, removed);
  }
  /** @private */
  __announceItemsChange(added, removed) {
    let addedMsg = [];
    let removedMsg = [];
    if (added) {
      addedMsg = added.map((user) => this.__getMessage(user, this.i18n.joined || "{user} joined"));
    }
    if (removed) {
      removedMsg = removed.map((user) => this.__getMessage(user, this.i18n.left || "{user} left"));
    }
    const messages = removedMsg.concat(addedMsg);
    if (messages.length > 0) {
      announce(messages.join(", "));
    }
  }
  /** @private */
  __i18nItemsChanged(i18n, items) {
    if (i18n && i18n.activeUsers) {
      const count = Array.isArray(items) ? items.length : 0;
      const field = count === 1 ? "one" : "many";
      if (i18n.activeUsers[field]) {
        this.setAttribute("aria-label", i18n.activeUsers[field].replace("{count}", count || 0));
      }
      this._avatars.forEach((avatar) => {
        avatar.i18n = i18n;
      });
    }
  }
  /** @private */
  __openedChanged(opened, overflow) {
    if (!overflow) {
      return;
    }
    if (opened) {
      if (!this._menuElement) {
        this._menuElement = this.$.overlay.querySelector("vaadin-avatar-group-menu");
      }
      this._openedWithFocusRing = overflow.hasAttribute("focus-ring");
    } else if (this.__oldOpened) {
      overflow.focus();
      if (this._openedWithFocusRing) {
        overflow.setAttribute("focus-ring", "");
      }
    }
    overflow.setAttribute("aria-expanded", opened === true);
    this.__oldOpened = opened;
  }
  /** @private */
  __overflowItemsChanged(items, oldItems) {
    if (items || oldItems) {
      this.$.overlay.requestContentUpdate();
    }
  }
  /** @private */
  __setItemsInView() {
    const avatars = this._avatars;
    const items = this.items;
    if (!items || !avatars || avatars.length < 3) {
      return;
    }
    let result = this.__calculateAvatarsFitWidth();
    if (result === items.length - 1) {
      result = items.length;
    }
    if (result >= items.length && this._opened) {
      this.$.overlay.close();
      this.$.overlay._flushAnimation("closing");
    }
    this.__itemsInView = result;
  }
  /** @private */
  __calculateAvatarsFitWidth() {
    if (!this.shadowRoot || this._avatars.length < MINIMUM_DISPLAYED_AVATARS) {
      return MINIMUM_DISPLAYED_AVATARS;
    }
    const avatars = this._avatars;
    const avatarWidth = avatars[0].clientWidth;
    const { marginLeft, marginRight } = getComputedStyle(avatars[1]);
    const offset = this.__isRTL ? parseInt(marginRight, 0) - parseInt(marginLeft, 0) : parseInt(marginLeft, 0) - parseInt(marginRight, 0);
    return Math.floor((this.$.container.offsetWidth - avatarWidth) / (avatarWidth + offset));
  }
};
/**
 * @license
 * Copyright (c) 2020 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const avatarGroupStyles = css`
  :host {
    display: block;
    width: 100%; /* prevent collapsing inside non-stretching column flex */
    --vaadin-avatar-group-overlap: 8px;
    --vaadin-avatar-group-overlap-border: 2px;
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='container'] {
    display: flex;
    position: relative;
    width: 100%;
    flex-wrap: nowrap;
  }

  ::slotted(vaadin-avatar:not(:first-child)) {
    -webkit-mask-image: url('data:image/svg+xml;utf8,<svg viewBox=%220 0 300 300%22 fill=%22none%22 xmlns=%22http://www.w3.org/2000/svg%22><path fill-rule=%22evenodd%22 clip-rule=%22evenodd%22 d=%22M300 0H0V300H300V0ZM150 200C177.614 200 200 177.614 200 150C200 122.386 177.614 100 150 100C122.386 100 100 122.386 100 150C100 177.614 122.386 200 150 200Z%22 fill=%22black%22/></svg>');
    mask-image: url('data:image/svg+xml;utf8,<svg viewBox=%220 0 300 300%22 fill=%22none%22 xmlns=%22http://www.w3.org/2000/svg%22><path fill-rule=%22evenodd%22 clip-rule=%22evenodd%22 d=%22M300 0H0V300H300V0ZM150 200C177.614 200 200 177.614 200 150C200 122.386 177.614 100 150 100C122.386 100 100 122.386 100 150C100 177.614 122.386 200 150 200Z%22 fill=%22black%22/></svg>');
    -webkit-mask-size: calc(
      300% + var(--vaadin-avatar-group-overlap-border) * 6 - var(--vaadin-avatar-outline-width) * 6
    );
    mask-size: calc(300% + var(--vaadin-avatar-group-overlap-border) * 6 - var(--vaadin-avatar-outline-width) * 6);
  }

  ::slotted(vaadin-avatar:not([dir='rtl']):not(:first-child)) {
    margin-left: calc(var(--vaadin-avatar-group-overlap) * -1 - var(--vaadin-avatar-outline-width));
    -webkit-mask-position: calc(50% - var(--vaadin-avatar-size) + var(--vaadin-avatar-group-overlap));
    mask-position: calc(50% - var(--vaadin-avatar-size) + var(--vaadin-avatar-group-overlap));
  }

  ::slotted(vaadin-avatar[dir='rtl']:not(:first-child)) {
    margin-right: calc(var(--vaadin-avatar-group-overlap) * -1);
    -webkit-mask-position: calc(
      50% + var(--vaadin-avatar-size) - var(--vaadin-avatar-group-overlap) + var(--vaadin-avatar-outline-width)
    );
    mask-position: calc(
      50% + var(--vaadin-avatar-size) - var(--vaadin-avatar-group-overlap) + var(--vaadin-avatar-outline-width)
    );
  }
`;
/**
 * @license
 * Copyright (c) 2020 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-avatar-group", avatarGroupStyles, { moduleId: "vaadin-avatar-group-styles" });
class AvatarGroup extends AvatarGroupMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <div id="container" part="container">
        <slot></slot>
        <slot name="overflow"></slot>
      </div>
      <vaadin-avatar-group-overlay
        id="overlay"
        opened="{{_opened}}"
        position-target="[[_overflow]]"
        no-vertical-overlap
        on-vaadin-overlay-close="_onVaadinOverlayClose"
        on-vaadin-overlay-open="_onVaadinOverlayOpen"
      ></vaadin-avatar-group-overlay>
    `;
  }
  static get is() {
    return "vaadin-avatar-group";
  }
}
defineCustomElement(AvatarGroup);
registerStyles$1(
  "vaadin-checkbox",
  css`
    :host {
      color: var(--vaadin-checkbox-label-color, var(--lumo-body-text-color));
      font-size: var(--vaadin-checkbox-label-font-size, var(--lumo-font-size-m));
      font-family: var(--lumo-font-family);
      line-height: var(--lumo-line-height-s);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
      cursor: default;
      outline: none;
      --_checkbox-size: var(--vaadin-checkbox-size, calc(var(--lumo-size-m) / 2));
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      --_selection-color: var(--vaadin-selection-color, var(--lumo-primary-color));
      --_invalid-background: var(--vaadin-input-field-invalid-background, var(--lumo-error-color-10pct));
      --_disabled-checkmark-color: var(--vaadin-checkbox-disabled-checkmark-color, var(--lumo-contrast-30pct));
    }

    [part='label'] {
      display: flex;
      position: relative;
      max-width: max-content;
    }

    :host([has-label]) ::slotted(label) {
      padding: var(
        --vaadin-checkbox-label-padding,
        var(--lumo-space-xs) var(--lumo-space-s) var(--lumo-space-xs) var(--lumo-space-xs)
      );
    }

    :host([dir='rtl'][has-label]) ::slotted(label) {
      padding: var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-s);
    }

    :host([has-label][required]) ::slotted(label) {
      padding-inline-end: var(--lumo-space-m);
    }

    [part='checkbox'] {
      width: var(--_checkbox-size);
      height: var(--_checkbox-size);
      margin: var(--lumo-space-xs);
      position: relative;
      border-radius: var(--vaadin-checkbox-border-radius, var(--lumo-border-radius-s));
      background: var(--vaadin-checkbox-background, var(--lumo-contrast-20pct));
      transition:
        transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2),
        background-color 0.15s;
      cursor: var(--lumo-clickable-cursor);
      /* Default field border color */
      --_input-border-color: var(--vaadin-input-field-border-color, var(--lumo-contrast-50pct));
    }

    :host([indeterminate]),
    :host([checked]) {
      --vaadin-input-field-border-color: transparent;
    }

    :host([indeterminate]) [part='checkbox'],
    :host([checked]) [part='checkbox'] {
      background-color: var(--_selection-color);
    }

    /* Checkmark */
    [part='checkbox']::after {
      pointer-events: none;
      font-family: 'lumo-icons';
      content: var(--vaadin-checkbox-checkmark-char, var(--lumo-icons-checkmark));
      color: var(--vaadin-checkbox-checkmark-color, var(--lumo-primary-contrast-color));
      font-size: var(--vaadin-checkbox-checkmark-size, calc(var(--_checkbox-size) + 2px));
      line-height: 1;
      position: absolute;
      top: -1px;
      left: -1px;
      contain: content;
      opacity: 0;
    }

    :host([checked]) [part='checkbox']::after {
      opacity: 1;
    }

    :host([readonly]:not([checked]):not([indeterminate])) {
      color: var(--lumo-secondary-text-color);
    }

    :host([readonly]:not([checked]):not([indeterminate])) [part='checkbox'] {
      background: transparent;
      box-shadow: none;
    }

    :host([readonly]:not([checked]):not([indeterminate])) [part='checkbox']::after {
      content: '';
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      border-radius: inherit;
      top: 0;
      left: 0;
      opacity: 1;
      border: var(--vaadin-input-field-readonly-border, 1px dashed var(--lumo-contrast-50pct));
    }

    /* Indeterminate checkmark */
    :host([indeterminate]) [part='checkbox']::after {
      content: var(--vaadin-checkbox-checkmark-char-indeterminate, '');
      opacity: 1;
      top: 45%;
      height: 10%;
      left: 22%;
      right: 22%;
      width: auto;
      border: 0;
      background-color: var(--lumo-primary-contrast-color);
    }

    /* Focus ring */
    :host([focus-ring]) [part='checkbox'] {
      box-shadow:
        0 0 0 1px var(--lumo-base-color),
        0 0 0 calc(var(--_focus-ring-width) + 1px) var(--_focus-ring-color),
        inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
    }

    :host([focus-ring][readonly]:not([checked]):not([indeterminate])) [part='checkbox'] {
      box-shadow:
        0 0 0 1px var(--lumo-base-color),
        0 0 0 calc(var(--_focus-ring-width) + 1px) var(--_focus-ring-color);
    }

    /* Disabled */
    :host([disabled]) {
      pointer-events: none;
      --vaadin-input-field-border-color: var(--lumo-contrast-20pct);
    }

    :host([disabled]) ::slotted(label) {
      color: inherit;
    }

    :host([disabled]) [part='checkbox'] {
      background-color: var(--vaadin-checkbox-disabled-background, var(--lumo-contrast-10pct));
    }

    :host([disabled]) [part='checkbox']::after {
      color: var(--_disabled-checkmark-color);
    }

    :host([disabled]) [part='label'],
    :host([disabled]) [part='helper-text'] {
      color: var(--lumo-disabled-text-color);
      -webkit-text-fill-color: var(--lumo-disabled-text-color);
    }

    :host([indeterminate][disabled]) [part='checkbox']::after {
      background-color: var(--_disabled-checkmark-color);
    }

    :host([readonly][checked]:not([disabled])) [part='checkbox'],
    :host([readonly][indeterminate]:not([disabled])) [part='checkbox'] {
      background-color: var(--vaadin-checkbox-readonly-checked-background, var(--lumo-contrast-70pct));
    }

    /* Used for activation "halo" */
    [part='checkbox']::before {
      pointer-events: none;
      color: transparent;
      width: 100%;
      height: 100%;
      line-height: var(--_checkbox-size);
      border-radius: inherit;
      background-color: inherit;
      transform: scale(1.4);
      opacity: 0;
      transition:
        transform 0.1s,
        opacity 0.8s;
    }

    /* Hover */
    :host(:not([checked]):not([indeterminate]):not([disabled]):not([readonly]):not([invalid]):hover) [part='checkbox'] {
      background: var(--vaadin-checkbox-background-hover, var(--lumo-contrast-30pct));
    }

    /* Disable hover for touch devices */
    @media (pointer: coarse) {
      /* prettier-ignore */
      :host(:not([checked]):not([indeterminate]):not([disabled]):not([readonly]):not([invalid]):hover) [part='checkbox'] {
        background: var(--vaadin-checkbox-background, var(--lumo-contrast-20pct));
      }
    }

    /* Active */
    :host([active]) [part='checkbox'] {
      transform: scale(0.9);
      transition-duration: 0.05s;
    }

    :host([active][checked]) [part='checkbox'] {
      transform: scale(1.1);
    }

    :host([active]:not([checked])) [part='checkbox']::before {
      transition-duration: 0.01s, 0.01s;
      transform: scale(0);
      opacity: 0.4;
    }

    /* Required */
    :host([required]) [part='required-indicator'] {
      position: absolute;
      top: var(--lumo-space-xs);
      right: var(--lumo-space-xs);
    }

    :host([required][dir='rtl']) [part='required-indicator'] {
      right: auto;
      left: var(--lumo-space-xs);
    }

    :host([required]) [part='required-indicator']::after {
      content: var(--lumo-required-field-indicator, '\\2022');
      transition: opacity 0.2s;
      color: var(--lumo-required-field-indicator-color, var(--lumo-primary-text-color));
      width: 1em;
      text-align: center;
    }

    :host(:not([has-label])) [part='required-indicator'] {
      display: none;
    }

    /* Invalid */
    :host([invalid]) {
      --vaadin-input-field-border-color: var(--lumo-error-color);
    }

    :host([invalid]) [part='checkbox'] {
      background: var(--_invalid-background);
      background-image: linear-gradient(var(--_invalid-background) 0%, var(--_invalid-background) 100%);
    }

    :host([invalid]:hover) [part='checkbox'] {
      background-image: linear-gradient(var(--_invalid-background) 0%, var(--_invalid-background) 100%),
        linear-gradient(var(--_invalid-background) 0%, var(--_invalid-background) 100%);
    }

    :host([invalid][focus-ring]) {
      --_focus-ring-color: var(--lumo-error-color-50pct);
    }

    :host([invalid]) [part='required-indicator']::after {
      color: var(--lumo-required-field-indicator-color, var(--lumo-error-text-color));
    }

    /* Error message */
    [part='error-message'] {
      font-size: var(--vaadin-input-field-error-font-size, var(--lumo-font-size-xs));
      line-height: var(--lumo-line-height-xs);
      font-weight: var(--vaadin-input-field-error-font-weight, 400);
      color: var(--vaadin-input-field-error-color, var(--lumo-error-text-color));
      will-change: max-height;
      transition: 0.4s max-height;
      max-height: 5em;
      padding-inline-start: var(--lumo-space-xs);
    }

    :host([has-error-message]) [part='error-message']::after,
    :host([has-helper]) [part='helper-text']::after {
      content: '';
      display: block;
      height: 0.4em;
    }

    :host(:not([invalid])) [part='error-message'] {
      max-height: 0;
      overflow: hidden;
    }

    /* Helper */
    [part='helper-text'] {
      display: block;
      color: var(--vaadin-input-field-helper-color, var(--lumo-secondary-text-color));
      font-size: var(--vaadin-input-field-helper-font-size, var(--lumo-font-size-xs));
      line-height: var(--lumo-line-height-xs);
      font-weight: var(--vaadin-input-field-helper-font-weight, 400);
      margin-left: calc(var(--lumo-border-radius-m) / 4);
      transition: color 0.2s;
      padding-inline-start: var(--lumo-space-xs);
    }

    :host(:hover:not([readonly])) [part='helper-text'] {
      color: var(--lumo-body-text-color);
    }

    :host([has-error-message]) ::slotted(label),
    :host([has-helper]) ::slotted(label) {
      padding-bottom: 0;
    }
  `,
  { moduleId: "lumo-checkbox" }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const InputMixin = dedupingMixin(
  (superclass) => class InputMixinClass extends superclass {
    static get properties() {
      return {
        /**
         * A reference to the input element controlled by the mixin.
         * Any component implementing this mixin is expected to provide it
         * by using `this._setInputElement(input)` Polymer API.
         *
         * A typical case is using `InputController` that does this automatically.
         * However, the input element does not have to always be native <input>:
         * as an example, <vaadin-combo-box-light> accepts other components.
         *
         * @protected
         * @type {!HTMLElement}
         */
        inputElement: {
          type: Object,
          readOnly: true,
          observer: "_inputElementChanged"
        },
        /**
         * String used to define input type.
         * @protected
         */
        type: {
          type: String,
          readOnly: true
        },
        /**
         * The value of the field.
         */
        value: {
          type: String,
          value: "",
          observer: "_valueChanged",
          notify: true,
          sync: true
        },
        /**
         * Whether the input element has a non-empty value.
         *
         * @protected
         */
        _hasInputValue: {
          type: Boolean,
          value: false,
          observer: "_hasInputValueChanged"
        }
      };
    }
    constructor() {
      super();
      this._boundOnInput = this.__onInput.bind(this);
      this._boundOnChange = this._onChange.bind(this);
    }
    /**
     * Indicates whether the value is different from the default one.
     * Override if the `value` property has a type other than `string`.
     *
     * @protected
     */
    get _hasValue() {
      return this.value != null && this.value !== "";
    }
    /**
     * A property for accessing the input element's value.
     *
     * Override this getter if the property is different from the default `value` one.
     *
     * @protected
     * @return {string}
     */
    get _inputElementValueProperty() {
      return "value";
    }
    /**
     * The input element's value.
     *
     * @protected
     * @return {string}
     */
    get _inputElementValue() {
      return this.inputElement ? this.inputElement[this._inputElementValueProperty] : void 0;
    }
    /**
     * The input element's value.
     *
     * @protected
     */
    set _inputElementValue(value) {
      if (this.inputElement) {
        this.inputElement[this._inputElementValueProperty] = value;
      }
      this._hasInputValue = value && value.length > 0;
    }
    /**
     * Clear the value of the field.
     */
    clear() {
      this._hasInputValue = false;
      this.value = "";
      this._inputElementValue = "";
    }
    /**
     * Add event listeners to the input element instance.
     * Override this method to add custom listeners.
     * @param {!HTMLElement} input
     * @protected
     */
    _addInputListeners(input) {
      input.addEventListener("input", this._boundOnInput);
      input.addEventListener("change", this._boundOnChange);
    }
    /**
     * Remove event listeners from the input element instance.
     * @param {!HTMLElement} input
     * @protected
     */
    _removeInputListeners(input) {
      input.removeEventListener("input", this._boundOnInput);
      input.removeEventListener("change", this._boundOnChange);
    }
    /**
     * A method to forward the value property set on the field
     * programmatically back to the input element value.
     * Override this method to perform additional checks,
     * for example to skip this in certain conditions.
     * @param {string} value
     * @protected
     */
    _forwardInputValue(value) {
      if (!this.inputElement) {
        return;
      }
      this._inputElementValue = value != null ? value : "";
    }
    /**
     * @param {HTMLElement | undefined} input
     * @param {HTMLElement | undefined} oldInput
     * @protected
     */
    _inputElementChanged(input, oldInput) {
      if (input) {
        this._addInputListeners(input);
      } else if (oldInput) {
        this._removeInputListeners(oldInput);
      }
    }
    /**
     * Observer to notify about the change of private property.
     *
     * @private
     */
    _hasInputValueChanged(hasValue, oldHasValue) {
      if (hasValue || oldHasValue) {
        this.dispatchEvent(new CustomEvent("has-input-value-changed"));
      }
    }
    /**
     * An input event listener used to update `_hasInputValue` property.
     * Do not override this method.
     *
     * @param {Event} event
     * @private
     */
    __onInput(event) {
      this._setHasInputValue(event);
      this._onInput(event);
    }
    /**
     * An input event listener used to update the field value.
     *
     * @param {Event} event
     * @protected
     */
    _onInput(event) {
      const target = event.composedPath()[0];
      this.__userInput = event.isTrusted;
      this.value = target.value;
      this.__userInput = false;
    }
    /**
     * A change event listener.
     * Override this method with an actual implementation.
     * @param {Event} _event
     * @protected
     */
    _onChange(_event) {
    }
    /**
     * Toggle the has-value attribute based on the value property.
     *
     * @param {boolean} hasValue
     * @protected
     */
    _toggleHasValue(hasValue) {
      this.toggleAttribute("has-value", hasValue);
    }
    /**
     * Observer called when a value property changes.
     * @param {string | undefined} newVal
     * @param {string | undefined} oldVal
     * @protected
     */
    _valueChanged(newVal, oldVal) {
      this._toggleHasValue(this._hasValue);
      if (newVal === "" && oldVal === void 0) {
        return;
      }
      if (this.__userInput) {
        return;
      }
      this._forwardInputValue(newVal);
    }
    /**
     * Sets the `_hasInputValue` property based on the `input` event.
     *
     * @param {InputEvent} event
     * @protected
     */
    _setHasInputValue(event) {
      const target = event.composedPath()[0];
      this._hasInputValue = target.value.length > 0;
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const CheckedMixin = dedupingMixin(
  (superclass) => class CheckedMixinClass extends DelegateStateMixin(DisabledMixin(InputMixin(superclass))) {
    static get properties() {
      return {
        /**
         * True if the element is checked.
         * @type {boolean}
         */
        checked: {
          type: Boolean,
          value: false,
          notify: true,
          reflectToAttribute: true,
          sync: true
        }
      };
    }
    static get delegateProps() {
      return [...super.delegateProps, "checked"];
    }
    /**
     * @param {Event} event
     * @protected
     * @override
     */
    _onChange(event) {
      const input = event.target;
      this._toggleChecked(input.checked);
    }
    /** @protected */
    _toggleChecked(checked) {
      this.checked = checked;
    }
  }
);
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const attributeToTargets = /* @__PURE__ */ new Map();
function getAttrMap(attr) {
  if (!attributeToTargets.has(attr)) {
    attributeToTargets.set(attr, /* @__PURE__ */ new WeakMap());
  }
  return attributeToTargets.get(attr);
}
function cleanAriaIDReference(target, attr) {
  if (!target) {
    return;
  }
  target.removeAttribute(attr);
}
function storeAriaIDReference(target, attr) {
  if (!target || !attr) {
    return;
  }
  const attributeMap = getAttrMap(attr);
  if (attributeMap.has(target)) {
    return;
  }
  const values = deserializeAttributeValue(target.getAttribute(attr));
  attributeMap.set(target, new Set(values));
}
function restoreGeneratedAriaIDReference(target, attr) {
  if (!target || false) {
    return;
  }
  const attributeMap = getAttrMap(attr);
  const values = attributeMap.get(target);
  if (!values || values.size === 0) {
    target.removeAttribute(attr);
  } else {
    addValueToAttribute(target, attr, serializeAttributeValue(values));
  }
  attributeMap.delete(target);
}
function setAriaIDReference(target, attr, config = { newId: null, oldId: null, fromUser: false }) {
  if (!target || !attr) {
    return;
  }
  const { newId, oldId, fromUser } = config;
  const attributeMap = getAttrMap(attr);
  const storedValues = attributeMap.get(target);
  if (!fromUser && !!storedValues) {
    oldId && storedValues.delete(oldId);
    newId && storedValues.add(newId);
    return;
  }
  if (fromUser) {
    if (!storedValues) {
      storeAriaIDReference(target, attr);
    } else if (!newId) {
      attributeMap.delete(target);
    }
    cleanAriaIDReference(target, attr);
  }
  removeValueFromAttribute(target, attr, oldId);
  const attributeValue = !newId ? serializeAttributeValue(storedValues) : newId;
  if (attributeValue) {
    addValueToAttribute(target, attr, attributeValue);
  }
}
function removeAriaIDReference(target, attr) {
  storeAriaIDReference(target, attr);
  cleanAriaIDReference(target, attr);
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class FieldAriaController {
  constructor(host) {
    this.host = host;
    this.__required = false;
  }
  /**
   * Sets a target element to which ARIA attributes are added.
   *
   * @param {HTMLElement} target
   */
  setTarget(target) {
    this.__target = target;
    this.__setAriaRequiredAttribute(this.__required);
    this.__setLabelIdToAriaAttribute(this.__labelId, this.__labelId);
    if (this.__labelIdFromUser != null) {
      this.__setLabelIdToAriaAttribute(this.__labelIdFromUser, this.__labelIdFromUser, true);
    }
    this.__setErrorIdToAriaAttribute(this.__errorId);
    this.__setHelperIdToAriaAttribute(this.__helperId);
    this.setAriaLabel(this.__label);
  }
  /**
   * Toggles the `aria-required` attribute on the target element
   * if the target is the host component (e.g. a field group).
   * Otherwise, it does nothing.
   *
   * @param {boolean} required
   */
  setRequired(required) {
    this.__setAriaRequiredAttribute(required);
    this.__required = required;
  }
  /**
   * Defines the `aria-label` attribute of the target element.
   *
   * To remove the attribute, pass `null` as `label`.
   *
   * @param {string | null | undefined} label
   */
  setAriaLabel(label) {
    this.__setAriaLabelToAttribute(label);
    this.__label = label;
  }
  /**
   * Links the target element with a slotted label element
   * via the target's attribute `aria-labelledby`.
   *
   * To unlink the previous slotted label element, pass `null` as `labelId`.
   *
   * @param {string | null} labelId
   */
  setLabelId(labelId, fromUser = false) {
    const oldLabelId = fromUser ? this.__labelIdFromUser : this.__labelId;
    this.__setLabelIdToAriaAttribute(labelId, oldLabelId, fromUser);
    if (fromUser) {
      this.__labelIdFromUser = labelId;
    } else {
      this.__labelId = labelId;
    }
  }
  /**
   * Links the target element with a slotted error element via the target's attribute:
   * - `aria-labelledby` if the target is the host component (e.g a field group).
   * - `aria-describedby` otherwise.
   *
   * To unlink the previous slotted error element, pass `null` as `errorId`.
   *
   * @param {string | null} errorId
   */
  setErrorId(errorId) {
    this.__setErrorIdToAriaAttribute(errorId, this.__errorId);
    this.__errorId = errorId;
  }
  /**
   * Links the target element with a slotted helper element via the target's attribute:
   * - `aria-labelledby` if the target is the host component (e.g a field group).
   * - `aria-describedby` otherwise.
   *
   * To unlink the previous slotted helper element, pass `null` as `helperId`.
   *
   * @param {string | null} helperId
   */
  setHelperId(helperId) {
    this.__setHelperIdToAriaAttribute(helperId, this.__helperId);
    this.__helperId = helperId;
  }
  /**
   * @param {string | null | undefined} label
   * @private
   * */
  __setAriaLabelToAttribute(label) {
    if (!this.__target) {
      return;
    }
    if (label) {
      removeAriaIDReference(this.__target, "aria-labelledby");
      this.__target.setAttribute("aria-label", label);
    } else if (this.__label) {
      restoreGeneratedAriaIDReference(this.__target, "aria-labelledby");
      this.__target.removeAttribute("aria-label");
    }
  }
  /**
   * @param {string | null | undefined} labelId
   * @param {string | null | undefined} oldLabelId
   * @param {boolean | null | undefined} fromUser
   * @private
   */
  __setLabelIdToAriaAttribute(labelId, oldLabelId, fromUser) {
    setAriaIDReference(this.__target, "aria-labelledby", { newId: labelId, oldId: oldLabelId, fromUser });
  }
  /**
   * @param {string | null | undefined} errorId
   * @param {string | null | undefined} oldErrorId
   * @private
   */
  __setErrorIdToAriaAttribute(errorId, oldErrorId) {
    setAriaIDReference(this.__target, "aria-describedby", { newId: errorId, oldId: oldErrorId, fromUser: false });
  }
  /**
   * @param {string | null | undefined} helperId
   * @param {string | null | undefined} oldHelperId
   * @private
   */
  __setHelperIdToAriaAttribute(helperId, oldHelperId) {
    setAriaIDReference(this.__target, "aria-describedby", { newId: helperId, oldId: oldHelperId, fromUser: false });
  }
  /**
   * @param {boolean} required
   * @private
   */
  __setAriaRequiredAttribute(required) {
    if (!this.__target) {
      return;
    }
    if (["input", "textarea"].includes(this.__target.localName)) {
      return;
    }
    if (required) {
      this.__target.setAttribute("aria-required", "true");
    } else {
      this.__target.removeAttribute("aria-required");
    }
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ErrorController extends SlotChildObserveController {
  constructor(host) {
    super(host, "error-message", "div");
  }
  /**
   * Set the error message element text content.
   *
   * @param {string} errorMessage
   */
  setErrorMessage(errorMessage) {
    this.errorMessage = errorMessage;
    this.updateDefaultNode(this.node);
  }
  /**
   * Set invalid state for detecting whether to show error message.
   *
   * @param {boolean} invalid
   */
  setInvalid(invalid) {
    this.invalid = invalid;
    this.updateDefaultNode(this.node);
  }
  /**
   * Override method inherited from `SlotController` to not run
   * initializer on the custom slotted node unnecessarily.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initAddedNode(node) {
    if (node !== this.defaultNode) {
      this.initCustomNode(node);
    }
  }
  /**
   * Override to initialize the newly added default error message.
   *
   * @param {Node} errorNode
   * @protected
   * @override
   */
  initNode(errorNode) {
    this.updateDefaultNode(errorNode);
  }
  /**
   * Override to initialize the newly added custom error message.
   *
   * @param {Node} errorNode
   * @protected
   * @override
   */
  initCustomNode(errorNode) {
    if (errorNode.textContent && !this.errorMessage) {
      this.errorMessage = errorNode.textContent.trim();
    }
    super.initCustomNode(errorNode);
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to restore the default error message element.
   *
   * @protected
   * @override
   */
  restoreDefaultNode() {
    this.attachDefaultNode();
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the error message text and hidden state.
   *
   * Note: unlike with other controllers, this method is
   * called for both default and custom error message.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(errorNode) {
    const { errorMessage, invalid } = this;
    const hasError = Boolean(invalid && errorMessage && errorMessage.trim() !== "");
    if (errorNode) {
      errorNode.textContent = hasError ? errorMessage : "";
      errorNode.hidden = !hasError;
      if (hasError) {
        announce(errorMessage, { mode: "assertive" });
      }
    }
    super.updateDefaultNode(errorNode);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class HelperController extends SlotChildObserveController {
  constructor(host) {
    super(host, "helper", null);
  }
  /**
   * Set helper text based on corresponding host property.
   *
   * @param {string} helperText
   */
  setHelperText(helperText) {
    this.helperText = helperText;
    const helperNode = this.getSlotChild();
    if (!helperNode) {
      this.restoreDefaultNode();
    }
    if (this.node === this.defaultNode) {
      this.updateDefaultNode(this.node);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to create the default helper element lazily as needed.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  restoreDefaultNode() {
    const { helperText } = this;
    if (helperText && helperText.trim() !== "") {
      this.tagName = "div";
      const helperNode = this.attachDefaultNode();
      this.observeNode(helperNode);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the default helper element text content.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(node) {
    if (node) {
      node.textContent = this.helperText;
    }
    super.updateDefaultNode(node);
  }
  /**
   * Override to observe the newly added custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initCustomNode(node) {
    super.initCustomNode(node);
    this.observeNode(node);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class LabelController extends SlotChildObserveController {
  constructor(host) {
    super(host, "label", "label");
  }
  /**
   * Set label based on corresponding host property.
   *
   * @param {string} label
   */
  setLabel(label) {
    this.label = label;
    const labelNode = this.getSlotChild();
    if (!labelNode) {
      this.restoreDefaultNode();
    }
    if (this.node === this.defaultNode) {
      this.updateDefaultNode(this.node);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to restore and observe the default label element.
   *
   * @protected
   * @override
   */
  restoreDefaultNode() {
    const { label } = this;
    if (label && label.trim() !== "") {
      const labelNode = this.attachDefaultNode();
      this.observeNode(labelNode);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the default label element text content.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(node) {
    if (node) {
      node.textContent = this.label;
    }
    super.updateDefaultNode(node);
  }
  /**
   * Override to observe the newly added custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initCustomNode(node) {
    super.initCustomNode(node);
    this.observeNode(node);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const LabelMixin = dedupingMixin(
  (superclass) => class LabelMixinClass extends ControllerMixin(superclass) {
    static get properties() {
      return {
        /**
         * The label text for the input node.
         * When no light dom defined via [slot=label], this value will be used.
         */
        label: {
          type: String,
          observer: "_labelChanged"
        }
      };
    }
    constructor() {
      super();
      this._labelController = new LabelController(this);
      this._labelController.addEventListener("slot-content-changed", (event) => {
        this.toggleAttribute("has-label", event.detail.hasContent);
      });
    }
    /** @protected */
    get _labelId() {
      const node = this._labelNode;
      return node && node.id;
    }
    /** @protected */
    get _labelNode() {
      return this._labelController.node;
    }
    /** @protected */
    ready() {
      super.ready();
      this.addController(this._labelController);
    }
    /** @protected */
    _labelChanged(label) {
      this._labelController.setLabel(label);
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ValidateMixin = dedupingMixin(
  (superclass) => class ValidateMixinClass extends superclass {
    static get properties() {
      return {
        /**
         * Set to true when the field is invalid.
         */
        invalid: {
          type: Boolean,
          reflectToAttribute: true,
          notify: true,
          value: false
        },
        /**
         * Set to true to enable manual validation mode. This mode disables automatic
         * constraint validation, allowing you to control the validation process yourself.
         * You can still trigger constraint validation manually with the `validate()` method
         * or use `checkValidity()` to assess the component's validity without affecting
         * the invalid state. In manual validation mode, you can also manipulate
         * the `invalid` property directly through your application logic without conflicts
         * with the component's internal validation.
         *
         * @attr {boolean} manual-validation
         */
        manualValidation: {
          type: Boolean,
          value: false
        },
        /**
         * Specifies that the user must fill in a value.
         */
        required: {
          type: Boolean,
          reflectToAttribute: true
        }
      };
    }
    /**
     * Validates the field and sets the `invalid` property based on the result.
     *
     * The method fires a `validated` event with the result of the validation.
     *
     * @return {boolean} True if the value is valid.
     */
    validate() {
      const isValid2 = this.checkValidity();
      this._setInvalid(!isValid2);
      this.dispatchEvent(new CustomEvent("validated", { detail: { valid: isValid2 } }));
      return isValid2;
    }
    /**
     * Returns true if the field value satisfies all constraints (if any).
     *
     * @return {boolean}
     */
    checkValidity() {
      return !this.required || !!this.value;
    }
    /**
     * @param {boolean} invalid
     * @protected
     */
    _setInvalid(invalid) {
      if (this._shouldSetInvalid(invalid)) {
        this.invalid = invalid;
      }
    }
    /**
     * Override this method to define whether the given `invalid` state should be set.
     *
     * @param {boolean} _invalid
     * @return {boolean}
     * @protected
     */
    _shouldSetInvalid(_invalid) {
      return true;
    }
    /** @protected */
    _requestValidation() {
      if (!this.manualValidation) {
        this.validate();
      }
    }
    /**
     * Fired whenever the field is validated.
     *
     * @event validated
     * @param {Object} detail
     * @param {boolean} detail.valid the result of the validation.
     */
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const FieldMixin = (superclass) => class FieldMixinClass extends ValidateMixin(LabelMixin(ControllerMixin(superclass))) {
  static get properties() {
    return {
      /**
       * A target element to which ARIA attributes are set.
       * @protected
       */
      ariaTarget: {
        type: Object,
        observer: "_ariaTargetChanged"
      },
      /**
       * Error to show when the field is invalid.
       *
       * @attr {string} error-message
       */
      errorMessage: {
        type: String,
        observer: "_errorMessageChanged"
      },
      /**
       * String used for the helper text.
       * @attr {string} helper-text
       */
      helperText: {
        type: String,
        observer: "_helperTextChanged"
      },
      /**
       * String used to label the component to screen reader users.
       * @attr {string} accessible-name
       */
      accessibleName: {
        type: String,
        observer: "_accessibleNameChanged"
      },
      /**
       * Id of the element used as label of the component to screen reader users.
       * @attr {string} accessible-name-ref
       */
      accessibleNameRef: {
        type: String,
        observer: "_accessibleNameRefChanged"
      }
    };
  }
  static get observers() {
    return ["_invalidChanged(invalid)", "_requiredChanged(required)"];
  }
  constructor() {
    super();
    this._fieldAriaController = new FieldAriaController(this);
    this._helperController = new HelperController(this);
    this._errorController = new ErrorController(this);
    this._errorController.addEventListener("slot-content-changed", (event) => {
      this.toggleAttribute("has-error-message", event.detail.hasContent);
    });
    this._labelController.addEventListener("slot-content-changed", (event) => {
      const { hasContent, node } = event.detail;
      this.__labelChanged(hasContent, node);
    });
    this._helperController.addEventListener("slot-content-changed", (event) => {
      const { hasContent, node } = event.detail;
      this.toggleAttribute("has-helper", hasContent);
      this.__helperChanged(hasContent, node);
    });
  }
  /**
   * @protected
   * @return {HTMLElement}
   */
  get _errorNode() {
    return this._errorController.node;
  }
  /**
   * @protected
   * @return {HTMLElement}
   */
  get _helperNode() {
    return this._helperController.node;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(this._fieldAriaController);
    this.addController(this._helperController);
    this.addController(this._errorController);
  }
  /** @private */
  __helperChanged(hasHelper, helperNode) {
    if (hasHelper) {
      this._fieldAriaController.setHelperId(helperNode.id);
    } else {
      this._fieldAriaController.setHelperId(null);
    }
  }
  /** @protected */
  _accessibleNameChanged(accessibleName) {
    this._fieldAriaController.setAriaLabel(accessibleName);
  }
  /** @protected */
  _accessibleNameRefChanged(accessibleNameRef) {
    this._fieldAriaController.setLabelId(accessibleNameRef, true);
  }
  /** @private */
  __labelChanged(hasLabel, labelNode) {
    if (hasLabel) {
      this._fieldAriaController.setLabelId(labelNode.id);
    } else {
      this._fieldAriaController.setLabelId(null);
    }
  }
  /**
   * @param {string | null | undefined} errorMessage
   * @protected
   */
  _errorMessageChanged(errorMessage) {
    this._errorController.setErrorMessage(errorMessage);
  }
  /**
   * @param {string} helperText
   * @protected
   */
  _helperTextChanged(helperText) {
    this._helperController.setHelperText(helperText);
  }
  /**
   * @param {HTMLElement | null | undefined} target
   * @protected
   */
  _ariaTargetChanged(target) {
    if (target) {
      this._fieldAriaController.setTarget(target);
    }
  }
  /**
   * @param {boolean} required
   * @protected
   */
  _requiredChanged(required) {
    this._fieldAriaController.setRequired(required);
  }
  /**
   * @param {boolean} invalid
   * @protected
   */
  _invalidChanged(invalid) {
    this._errorController.setInvalid(invalid);
    setTimeout(() => {
      if (invalid) {
        const node = this._errorNode;
        this._fieldAriaController.setErrorId(node && node.id);
      } else {
        this._fieldAriaController.setErrorId(null);
      }
    });
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class InputController extends SlotController {
  constructor(host, callback, options = {}) {
    const { uniqueIdPrefix } = options;
    super(host, "input", "input", {
      initializer: (node, host2) => {
        if (host2.value) {
          node.value = host2.value;
        }
        if (host2.type) {
          node.setAttribute("type", host2.type);
        }
        node.id = this.defaultId;
        if (typeof callback === "function") {
          callback(node);
        }
      },
      useUniqueId: true,
      uniqueIdPrefix
    });
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class LabelledInputController {
  constructor(input, labelController) {
    this.input = input;
    this.__preventDuplicateLabelClick = this.__preventDuplicateLabelClick.bind(this);
    labelController.addEventListener("slot-content-changed", (event) => {
      this.__initLabel(event.detail.node);
    });
    this.__initLabel(labelController.node);
  }
  /**
   * @param {HTMLElement} label
   * @private
   */
  __initLabel(label) {
    if (label) {
      label.addEventListener("click", this.__preventDuplicateLabelClick);
      if (this.input) {
        label.setAttribute("for", this.input.id);
      }
    }
  }
  /**
   * The native platform fires an event for both the click on the label, and also
   * the subsequent click on the native input element caused by label click.
   * This results in two click events arriving at the host, but we only want one.
   * This method prevents the duplicate click and ensures the correct isTrusted event
   * with the correct event.target arrives at the host.
   * @private
   */
  __preventDuplicateLabelClick() {
    const inputClickHandler = (e2) => {
      e2.stopImmediatePropagation();
      this.input.removeEventListener("click", inputClickHandler);
    };
    this.input.addEventListener("click", inputClickHandler);
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const CheckboxMixin = (superclass) => class CheckboxMixinClass extends FieldMixin(CheckedMixin(DelegateFocusMixin(ActiveMixin(superclass)))) {
  static get properties() {
    return {
      /**
       * True if the checkbox is in the indeterminate state which means
       * it is not possible to say whether it is checked or unchecked.
       * The state is reset once the user switches the checkbox by hand.
       *
       * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Indeterminate_state_checkboxes
       *
       * @type {boolean}
       */
      indeterminate: {
        type: Boolean,
        notify: true,
        value: false,
        reflectToAttribute: true
      },
      /**
       * The name of the checkbox.
       *
       * @type {string}
       */
      name: {
        type: String,
        value: ""
      },
      /**
       * When true, the user cannot modify the value of the checkbox.
       * The difference between `disabled` and `readonly` is that the
       * read-only checkbox remains focusable, is announced by screen
       * readers and its value can be submitted as part of the form.
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       *
       * @override
       * @protected
       */
      tabindex: {
        type: Number,
        value: 0,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return ["__readonlyChanged(readonly, inputElement)"];
  }
  /** @override */
  static get delegateProps() {
    return [...super.delegateProps, "indeterminate"];
  }
  /** @override */
  static get delegateAttrs() {
    return [...super.delegateAttrs, "name", "invalid", "required"];
  }
  constructor() {
    super();
    this._setType("checkbox");
    this._boundOnInputClick = this._onInputClick.bind(this);
    this.value = "on";
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._createMethodObserver("_checkedChanged(checked)");
  }
  /**
   * Override method inherited from `ActiveMixin` to prevent setting `active`
   * attribute when readonly, or when clicking a link placed inside the label,
   * or when clicking slotted helper or error message element.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldSetActive(event) {
    if (this.readonly || event.target.localName === "a" || event.target === this._helperNode || event.target === this._errorNode) {
      return false;
    }
    return super._shouldSetActive(event);
  }
  /**
   * Override method inherited from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _addInputListeners(input) {
    super._addInputListeners(input);
    input.addEventListener("click", this._boundOnInputClick);
  }
  /**
   * Override method inherited from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _removeInputListeners(input) {
    super._removeInputListeners(input);
    input.removeEventListener("click", this._boundOnInputClick);
  }
  /** @private */
  _onInputClick(event) {
    if (this.readonly) {
      event.preventDefault();
    }
  }
  /** @private */
  __readonlyChanged(readonly, inputElement) {
    if (!inputElement) {
      return;
    }
    if (readonly) {
      inputElement.setAttribute("aria-readonly", "true");
    } else {
      inputElement.removeAttribute("aria-readonly");
    }
  }
  /**
   * Override method inherited from `CheckedMixin` to reset
   * `indeterminate` state checkbox is toggled by the user.
   *
   * @param {boolean} checked
   * @protected
   * @override
   */
  _toggleChecked(checked) {
    if (this.indeterminate) {
      this.indeterminate = false;
    }
    super._toggleChecked(checked);
  }
  /**
   * @override
   * @return {boolean}
   */
  checkValidity() {
    return !this.required || !!this.checked;
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
  /** @private */
  _checkedChanged(checked) {
    if (checked || this.__oldChecked) {
      this._requestValidation();
    }
    this.__oldChecked = checked;
  }
  /**
   * Override an observer from `FieldMixin`
   * to validate when required is removed.
   *
   * @protected
   * @override
   */
  _requiredChanged(required) {
    super._requiredChanged(required);
    if (required === false) {
      this._requestValidation();
    }
  }
  /** @private */
  _onRequiredIndicatorClick() {
    this._labelNode.click();
  }
  /**
   * Fired when the checkbox is checked or unchecked by the user.
   *
   * @event change
   */
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const checkboxStyles = css`
  :host {
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([disabled]) {
    -webkit-tap-highlight-color: transparent;
  }

  .vaadin-checkbox-container {
    display: grid;
    grid-template-columns: auto 1fr;
    align-items: baseline;
  }

  [part='checkbox'],
  ::slotted(input),
  [part='label'] {
    grid-row: 1;
  }

  [part='checkbox'],
  ::slotted(input) {
    grid-column: 1;
  }

  [part='helper-text'],
  [part='error-message'] {
    grid-column: 2;
  }

  :host(:not([has-helper])) [part='helper-text'],
  :host(:not([has-error-message])) [part='error-message'] {
    display: none;
  }

  [part='checkbox'] {
    width: var(--vaadin-checkbox-size, 1em);
    height: var(--vaadin-checkbox-size, 1em);
    --_input-border-width: var(--vaadin-input-field-border-width, 0);
    --_input-border-color: var(--vaadin-input-field-border-color, transparent);
    box-shadow: inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
  }

  [part='checkbox']::before {
    display: block;
    content: '\\202F';
    line-height: var(--vaadin-checkbox-size, 1em);
    contain: paint;
  }

  /* visually hidden */
  ::slotted(input) {
    opacity: 0;
    cursor: inherit;
    margin: 0;
    align-self: stretch;
    -webkit-appearance: none;
    width: initial;
    height: initial;
  }

  @media (forced-colors: active) {
    [part='checkbox'] {
      outline: 1px solid;
      outline-offset: -1px;
    }

    :host([disabled]) [part='checkbox'],
    :host([disabled]) [part='checkbox']::after {
      outline-color: GrayText;
    }

    :host(:is([checked], [indeterminate])) [part='checkbox']::after {
      outline: 1px solid;
      outline-offset: -1px;
      border-radius: inherit;
    }

    :host([focused]) [part='checkbox'],
    :host([focused]) [part='checkbox']::after {
      outline-width: 2px;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-checkbox", checkboxStyles, { moduleId: "vaadin-checkbox-styles" });
class Checkbox extends CheckboxMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-checkbox";
  }
  static get template() {
    return html`
      <div class="vaadin-checkbox-container">
        <div part="checkbox" aria-hidden="true"></div>
        <slot name="input"></slot>
        <div part="label">
          <slot name="label"></slot>
          <div part="required-indicator" on-click="_onRequiredIndicatorClick"></div>
        </div>
        <div part="helper-text">
          <slot name="helper"></slot>
        </div>
        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
      <slot name="tooltip"></slot>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setAriaTarget(this.inputElement);
    this.addController(this._tooltipController);
  }
}
defineCustomElement(Checkbox);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const helper = css`
  :host {
    --_helper-spacing: var(--vaadin-input-field-helper-spacing, 0.4em);
  }

  :host([has-helper]) [part='helper-text']::before {
    content: '';
    display: block;
    height: var(--_helper-spacing);
  }

  [part='helper-text'] {
    display: block;
    color: var(--vaadin-input-field-helper-color, var(--lumo-secondary-text-color));
    font-size: var(--vaadin-input-field-helper-font-size, var(--lumo-font-size-xs));
    line-height: var(--lumo-line-height-xs);
    font-weight: var(--vaadin-input-field-helper-font-weight, 400);
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    transition: color 0.2s;
  }

  :host(:hover:not([readonly])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  :host([disabled]) [part='helper-text'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text']::before {
    display: none;
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text']::after {
    content: '';
    display: block;
    height: var(--_helper-spacing);
  }

  :host([has-helper][theme~='helper-above-field']) [part='label'] {
    order: 0;
    padding-bottom: var(--_helper-spacing);
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text'] {
    order: 1;
  }

  :host([has-helper][theme~='helper-above-field']) [part='label'] + * {
    order: 2;
  }

  :host([has-helper][theme~='helper-above-field']) [part='error-message'] {
    order: 3;
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const requiredField = css`
  [part='label'] {
    align-self: flex-start;
    color: var(--vaadin-input-field-label-color, var(--lumo-secondary-text-color));
    font-weight: var(--vaadin-input-field-label-font-weight, 500);
    font-size: var(--vaadin-input-field-label-font-size, var(--lumo-font-size-s));
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    transition: color 0.2s;
    line-height: 1;
    padding-right: 1em;
    padding-bottom: 0.5em;
    /* As a workaround for diacritics being cut off, add a top padding and a
    negative margin to compensate */
    padding-top: 0.25em;
    margin-top: -0.25em;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    position: relative;
    max-width: 100%;
    box-sizing: border-box;
  }

  :host([focused]:not([readonly])) [part='label'] {
    color: var(--vaadin-input-field-focused-label-color, var(--lumo-primary-text-color));
  }

  :host(:hover:not([readonly]):not([focused])) [part='label'] {
    color: var(--vaadin-input-field-hovered-label-color, var(--lumo-body-text-color));
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused])) [part='label'] {
      color: var(--vaadin-input-field-label-color, var(--lumo-secondary-text-color));
    }
  }

  :host([has-label])::before {
    margin-top: calc(var(--lumo-font-size-s) * 1.5);
  }

  :host([has-label][theme~='small'])::before {
    margin-top: calc(var(--lumo-font-size-xs) * 1.5);
  }

  :host([has-label]) {
    padding-top: var(--lumo-space-m);
  }

  :host([has-label]) ::slotted([slot='tooltip']) {
    --vaadin-tooltip-offset-bottom: calc((var(--lumo-space-m) - var(--lumo-space-xs)) * -1);
  }

  :host([required]) [part='required-indicator']::after {
    content: var(--lumo-required-field-indicator, '\\2022');
    transition: opacity 0.2s;
    color: var(--lumo-required-field-indicator-color, var(--lumo-primary-text-color));
    position: absolute;
    right: 0;
    width: 1em;
    text-align: center;
  }

  :host([invalid]) [part='required-indicator']::after {
    color: var(--lumo-required-field-indicator-color, var(--lumo-error-text-color));
  }

  [part='error-message'] {
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    font-size: var(--vaadin-input-field-error-font-size, var(--lumo-font-size-xs));
    line-height: var(--lumo-line-height-xs);
    font-weight: var(--vaadin-input-field-error-font-weight, 400);
    color: var(--vaadin-input-field-error-color, var(--lumo-error-text-color));
    will-change: max-height;
    transition: 0.4s max-height;
    max-height: 5em;
  }

  :host([has-error-message]) [part='error-message']::before,
  :host([has-error-message]) [part='error-message']::after {
    content: '';
    display: block;
    height: 0.4em;
  }

  :host(:not([invalid])) [part='error-message'] {
    max-height: 0;
    overflow: hidden;
  }

  /* RTL specific styles */

  :host([dir='rtl']) [part='label'] {
    margin-left: 0;
    margin-right: calc(var(--lumo-border-radius-m) / 4);
  }

  :host([dir='rtl']) [part='label'] {
    padding-left: 1em;
    padding-right: 0;
  }

  :host([dir='rtl']) [part='required-indicator']::after {
    right: auto;
    left: 0;
  }

  :host([dir='rtl']) [part='error-message'] {
    margin-left: 0;
    margin-right: calc(var(--lumo-border-radius-m) / 4);
  }
`;
registerStyles$1("", requiredField, { moduleId: "lumo-required-field" });
const checkboxGroup = css`
  :host {
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-m);
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: var(--lumo-space-xs) 0;
  }

  :host::before {
    /* Effective height of vaadin-checkbox */
    height: var(--lumo-size-s);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  :host([theme~='vertical']) [part='group-field'] {
    flex-direction: column;
  }

  :host([disabled]) [part='label'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([focused]:not([readonly])) [part='label'] {
    color: var(--lumo-primary-text-color);
  }

  :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='label'],
  :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='label'] {
      color: var(--lumo-secondary-text-color);
    }
  }
`;
registerStyles$1("vaadin-checkbox-group", [requiredField, helper, checkboxGroup], {
  moduleId: "lumo-checkbox-group"
});
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const CheckboxGroupMixin = (superclass) => class CheckboxGroupMixinClass extends FieldMixin(FocusMixin(DisabledMixin(superclass))) {
  static get properties() {
    return {
      /**
       * An array containing values of the currently checked checkboxes.
       *
       * The array is immutable so toggling checkboxes always results in
       * creating a new array.
       *
       * @type {!Array<!string>}
       */
      value: {
        type: Array,
        value: () => [],
        notify: true,
        sync: true,
        observer: "__valueChanged"
      },
      /**
       * When true, the user cannot modify the value of the checkbox group.
       * The difference between `disabled` and `readonly` is that in the
       * read-only checkbox group, all the checkboxes are also read-only,
       * and therefore remain focusable and announced by screen readers.
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "__readonlyChanged"
      }
    };
  }
  constructor() {
    super();
    this.__registerCheckbox = this.__registerCheckbox.bind(this);
    this.__unregisterCheckbox = this.__unregisterCheckbox.bind(this);
    this.__onCheckboxCheckedChanged = this.__onCheckboxCheckedChanged.bind(this);
    this._tooltipController = new TooltipController(this);
    this._tooltipController.addEventListener("tooltip-changed", (event) => {
      const tooltip = event.detail.node;
      if (tooltip && tooltip.isConnected) {
        const inputs = this.__checkboxes.map((checkbox) => checkbox.inputElement);
        this._tooltipController.setAriaTarget(inputs);
      } else {
        this._tooltipController.setAriaTarget([]);
      }
    });
  }
  /**
   * A collection of the checkboxes.
   *
   * @return {!Array<!Checkbox>}
   * @private
   */
  get __checkboxes() {
    return this.__filterCheckboxes([...this.children]);
  }
  /** @protected */
  ready() {
    super.ready();
    this.ariaTarget = this;
    this.setAttribute("role", "group");
    const slot = this.shadowRoot.querySelector("slot:not([name])");
    this._observer = new SlotObserver(slot, ({ addedNodes, removedNodes }) => {
      const addedCheckboxes = this.__filterCheckboxes(addedNodes);
      const removedCheckboxes = this.__filterCheckboxes(removedNodes);
      addedCheckboxes.forEach(this.__registerCheckbox);
      removedCheckboxes.forEach(this.__unregisterCheckbox);
      const inputs = this.__checkboxes.map((checkbox) => checkbox.inputElement);
      this._tooltipController.setAriaTarget(inputs);
      this.__warnOfCheckboxesWithoutValue(addedCheckboxes);
    });
    this.addController(this._tooltipController);
  }
  /**
   * Override method inherited from `ValidateMixin`
   * to validate the value array.
   *
   * @override
   * @return {boolean}
   */
  checkValidity() {
    return !this.required || Boolean(this.value && this.value.length > 0);
  }
  /**
   * @param {!Array<!Node>} nodes
   * @return {!Array<!Checkbox>}
   * @private
   */
  __filterCheckboxes(nodes) {
    return nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE && node.localName === "vaadin-checkbox");
  }
  /**
   * @param {!Array<!Checkbox>} checkboxes
   * @private
   */
  __warnOfCheckboxesWithoutValue(checkboxes) {
    const hasCheckboxesWithoutValue = checkboxes.some((checkbox) => {
      const { value } = checkbox;
      return !checkbox.hasAttribute("value") && (!value || value === "on");
    });
    if (hasCheckboxesWithoutValue) {
      console.warn("Please provide the value attribute to all the checkboxes inside the checkbox group.");
    }
  }
  /**
   * Registers the checkbox after adding it to the group.
   *
   * @param {!Checkbox} checkbox
   * @private
   */
  __registerCheckbox(checkbox) {
    checkbox.addEventListener("checked-changed", this.__onCheckboxCheckedChanged);
    if (this.disabled) {
      checkbox.disabled = true;
    }
    if (this.readonly) {
      checkbox.readonly = true;
    }
    if (checkbox.checked) {
      this.__addCheckboxToValue(checkbox.value);
    } else if (this.value && this.value.includes(checkbox.value)) {
      checkbox.checked = true;
    }
  }
  /**
   * Unregisters the checkbox before removing it from the group.
   *
   * @param {!Checkbox} checkbox
   * @private
   */
  __unregisterCheckbox(checkbox) {
    checkbox.removeEventListener("checked-changed", this.__onCheckboxCheckedChanged);
    if (checkbox.checked) {
      this.__removeCheckboxFromValue(checkbox.value);
    }
  }
  /**
   * Override method inherited from `DisabledMixin`
   * to propagate the `disabled` property to the checkboxes.
   *
   * @param {boolean} newValue
   * @param {boolean} oldValue
   * @override
   * @protected
   */
  _disabledChanged(newValue, oldValue) {
    super._disabledChanged(newValue, oldValue);
    if (!newValue && oldValue === void 0) {
      return;
    }
    if (oldValue !== newValue) {
      this.__checkboxes.forEach((checkbox) => {
        checkbox.disabled = newValue;
      });
    }
  }
  /**
   * @param {string} value
   * @private
   */
  __addCheckboxToValue(value) {
    if (!this.value) {
      this.value = [value];
    } else if (!this.value.includes(value)) {
      this.value = [...this.value, value];
    }
  }
  /**
   * @param {string} value
   * @private
   */
  __removeCheckboxFromValue(value) {
    if (this.value && this.value.includes(value)) {
      this.value = this.value.filter((v) => v !== value);
    }
  }
  /**
   * @param {!CustomEvent} event
   * @private
   */
  __onCheckboxCheckedChanged(event) {
    const checkbox = event.target;
    if (checkbox.checked) {
      this.__addCheckboxToValue(checkbox.value);
    } else {
      this.__removeCheckboxFromValue(checkbox.value);
    }
  }
  /**
   * @param {string[] | null | undefined} value
   * @param {string[] | null | undefined} oldValue
   * @private
   */
  __valueChanged(value, oldValue) {
    if (value && value.length === 0 && oldValue === void 0) {
      return;
    }
    this.toggleAttribute("has-value", value && value.length > 0);
    this.__checkboxes.forEach((checkbox) => {
      checkbox.checked = value && value.includes(checkbox.value);
    });
    if (oldValue !== void 0) {
      this._requestValidation();
    }
  }
  /** @private */
  __readonlyChanged(readonly, oldReadonly) {
    if (readonly || oldReadonly) {
      this.__checkboxes.forEach((checkbox) => {
        checkbox.readonly = readonly;
      });
    }
  }
  /**
   * Override method inherited from `FocusMixin`
   * to prevent removing the `focused` attribute
   * when focus moves between checkboxes inside the group.
   *
   * @param {!FocusEvent} event
   * @return {boolean}
   * @protected
   */
  _shouldRemoveFocus(event) {
    return !this.contains(event.relatedTarget);
  }
  /**
   * Override method inherited from `FocusMixin`
   * to run validation when the group loses focus.
   *
   * @param {boolean} focused
   * @override
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const checkboxGroupStyles = css`
  :host {
    display: inline-flex;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  .vaadin-group-field-container {
    display: flex;
    flex-direction: column;
    width: 100%;
  }

  [part='group-field'] {
    display: flex;
    flex-wrap: wrap;
  }

  :host(:not([has-label])) [part='label'] {
    display: none;
  }
`;
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-checkbox-group", checkboxGroupStyles, { moduleId: "vaadin-checkbox-group-styles" });
class CheckboxGroup extends CheckboxGroupMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-checkbox-group";
  }
  static get template() {
    return html`
      <div class="vaadin-group-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div part="group-field">
          <slot></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
}
defineCustomElement(CheckboxGroup);
const comboBoxItem = css`
  :host {
    transition: background-color 100ms;
    overflow: hidden;
    --_lumo-item-selected-icon-display: block;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  :host([focused]:not([disabled])) {
    box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }
`;
registerStyles$1("vaadin-combo-box-item", [item, comboBoxItem], {
  moduleId: "lumo-combo-box-item"
});
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const loader = css`
  [part~='loader'] {
    box-sizing: border-box;
    width: var(--lumo-icon-size-s);
    height: var(--lumo-icon-size-s);
    border: 2px solid transparent;
    border-color: var(--lumo-primary-color-10pct) var(--lumo-primary-color-10pct) var(--lumo-primary-color)
      var(--lumo-primary-color);
    border-radius: calc(0.5 * var(--lumo-icon-size-s));
    opacity: 0;
    pointer-events: none;
  }

  :host(:not([loading])) [part~='loader'] {
    display: none;
  }

  :host([loading]) [part~='loader'] {
    animation:
      1s linear infinite lumo-loader-rotate,
      0.3s 0.1s lumo-loader-fade-in both;
  }

  @keyframes lumo-loader-fade-in {
    0% {
      opacity: 0;
    }

    100% {
      opacity: 1;
    }
  }

  @keyframes lumo-loader-rotate {
    0% {
      transform: rotate(0deg);
    }

    100% {
      transform: rotate(360deg);
    }
  }
`;
const comboBoxOverlay = css`
  [part='content'] {
    padding: 0;
  }

  /* When items are empty, the spinner needs some room */
  :host(:not([closing])) [part~='content'] {
    min-height: calc(2 * var(--lumo-space-s) + var(--lumo-icon-size-s));
  }

  [part~='overlay'] {
    position: relative;
  }

  :host([top-aligned]) [part~='overlay'] {
    margin-top: var(--lumo-space-xs);
  }

  :host([bottom-aligned]) [part~='overlay'] {
    margin-bottom: var(--lumo-space-xs);
  }
`;
const comboBoxLoader = css`
  [part~='loader'] {
    position: absolute;
    z-index: 1;
    inset-inline: var(--lumo-space-s);
    top: var(--lumo-space-s);
    margin-inline: auto 0;
  }
`;
registerStyles$1(
  "vaadin-combo-box-overlay",
  [
    overlay,
    menuOverlayCore,
    comboBoxOverlay,
    loader,
    comboBoxLoader,
    css`
      :host {
        --_vaadin-combo-box-items-container-border-width: var(--lumo-space-xs);
        --_vaadin-combo-box-items-container-border-style: solid;
      }
    `
  ],
  { moduleId: "lumo-combo-box-overlay" }
);
registerStyles$1(
  "vaadin-input-container",
  css`
    :host {
      background: var(--_background);
      padding: 0 calc(0.375em + var(--_input-container-radius) / 4 - 1px);
      font-weight: var(--vaadin-input-field-value-font-weight, 500);
      line-height: 1;
      position: relative;
      cursor: text;
      box-sizing: border-box;
      border-radius:
        /* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius#syntax */
        var(--vaadin-input-field-top-start-radius, var(--_input-container-radius))
        var(--vaadin-input-field-top-end-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-end-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-start-radius, var(--_input-container-radius));
      /* Fallback */
      --_input-container-radius: var(--vaadin-input-field-border-radius, var(--lumo-border-radius-m));
      --_input-height: var(--lumo-text-field-size, var(--lumo-size-m));
      /* Default values */
      --_background: var(--vaadin-input-field-background, var(--lumo-contrast-10pct));
      --_hover-highlight: var(--vaadin-input-field-hover-highlight, var(--lumo-contrast-50pct));
      --_input-border-color: var(--vaadin-input-field-border-color, var(--lumo-contrast-50pct));
      --_icon-color: var(--vaadin-input-field-icon-color, var(--lumo-contrast-60pct));
      --_icon-size: var(--vaadin-input-field-icon-size, var(--lumo-icon-size-m));
      --_invalid-background: var(--vaadin-input-field-invalid-background, var(--lumo-error-color-10pct));
      --_invalid-hover-highlight: var(--vaadin-input-field-invalid-hover-highlight, var(--lumo-error-color-50pct));
      --_disabled-background: var(--vaadin-input-field-disabled-background, var(--lumo-contrast-5pct));
      --_disabled-value-color: var(--vaadin-input-field-disabled-value-color, var(--lumo-disabled-text-color));
    }

    :host([dir='rtl']) {
      border-radius:
        /* Don't use logical props, see https://github.com/vaadin/vaadin-time-picker/issues/145 */
        var(--vaadin-input-field-top-end-radius, var(--_input-container-radius))
        var(--vaadin-input-field-top-start-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-start-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-end-radius, var(--_input-container-radius));
    }

    /* Used for hover and activation effects */
    :host::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      pointer-events: none;
      background: var(--_hover-highlight);
      opacity: 0;
      transition:
        transform 0.15s,
        opacity 0.2s;
      transform-origin: 100% 0;
    }

    ::slotted(:not([slot$='fix'])) {
      cursor: inherit;
      min-height: var(--vaadin-input-field-height, var(--_input-height));
      padding: 0 0.25em;
      --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
      -webkit-mask-image: var(--_lumo-text-field-overflow-mask-image);
      mask-image: var(--_lumo-text-field-overflow-mask-image);
    }

    /* Read-only */
    :host([readonly]) {
      color: var(--lumo-secondary-text-color);
      background-color: transparent;
      cursor: default;
    }

    :host([readonly])::after {
      background-color: transparent;
      opacity: 1;
      border: var(--vaadin-input-field-readonly-border, 1px dashed var(--lumo-contrast-30pct));
    }

    /* Disabled */
    :host([disabled]) {
      background: var(--_disabled-background);
    }

    :host([disabled]) ::slotted(:not([slot$='fix'])) {
      -webkit-text-fill-color: var(--_disabled-value-color);
      color: var(--_disabled-value-color);
    }

    /* Invalid */
    :host([invalid]) {
      background: var(--_invalid-background);
    }

    :host([invalid]:not([readonly]))::after {
      background: var(--_invalid-hover-highlight);
    }

    /* Slotted icons */
    ::slotted(vaadin-icon) {
      color: var(--_icon-color);
      width: var(--_icon-size);
      height: var(--_icon-size);
    }

    /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
    ::slotted(vaadin-icon[icon^='vaadin:']) {
      padding: 0.25em;
      box-sizing: border-box !important;
    }

    /* Text align */
    :host([dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent, #000 1.25em);
    }

    @-moz-document url-prefix() {
      :host([dir='rtl']) ::slotted(:not([slot$='fix'])) {
        mask-image: var(--_lumo-text-field-overflow-mask-image);
      }
    }

    :host([theme~='align-left']) ::slotted(:not([slot$='fix'])) {
      text-align: start;
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-center']) ::slotted(:not([slot$='fix'])) {
      text-align: center;
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-right']) ::slotted(:not([slot$='fix'])) {
      text-align: end;
      --_lumo-text-field-overflow-mask-image: none;
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-right']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent 0.25em, #000 1.5em);
      }
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-left']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent 0.25em, #000 1.5em);
      }
    }

    /* RTL specific styles */
    :host([dir='rtl'])::after {
      transform-origin: 0% 0;
    }

    :host([theme~='align-left'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-center'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-right'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-right'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent 0.25em, #000 1.5em);
      }
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-left'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent 0.25em, #000 1.5em);
      }
    }
  `,
  { moduleId: "lumo-input-container" }
);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const fieldButton = css`
  [part$='button'] {
    flex: none;
    width: 1em;
    height: 1em;
    line-height: 1;
    font-size: var(--lumo-icon-size-m);
    text-align: center;
    color: var(--lumo-contrast-60pct);
    transition: 0.2s color;
    cursor: var(--lumo-clickable-cursor);
  }

  [part$='button']:hover {
    color: var(--lumo-contrast-90pct);
  }

  :host([disabled]) [part$='button'],
  :host([readonly]) [part$='button'] {
    color: var(--lumo-contrast-20pct);
    cursor: default;
  }

  [part$='button']::before {
    font-family: 'lumo-icons';
    display: block;
  }
`;
registerStyles$1("", fieldButton, { moduleId: "lumo-field-button" });
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const inputField = css`
  :host {
    --lumo-text-field-size: var(--lumo-size-m);
    color: var(--vaadin-input-field-value-color, var(--lumo-body-text-color));
    font-size: var(--vaadin-input-field-value-font-size, var(--lumo-font-size-m));
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: var(--lumo-space-xs) 0;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
    --_input-height: var(--vaadin-input-field-height, var(--lumo-text-field-size));
    --_disabled-value-color: var(--vaadin-input-field-disabled-value-color, var(--lumo-disabled-text-color));
  }

  :host::before {
    height: var(--_input-height);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  :host([focused]) [part='input-field'] ::slotted(:is(input, textarea)) {
    -webkit-mask-image: none;
    mask-image: none;
  }

  ::slotted(:is(input, textarea):placeholder-shown) {
    color: var(--vaadin-input-field-placeholder-color, var(--lumo-secondary-text-color));
  }

  /* Hover */
  :host(:hover:not([readonly]):not([focused])) [part='input-field']::after {
    opacity: var(--vaadin-input-field-hover-highlight-opacity, 0.1);
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused])) [part='input-field']::after {
      opacity: 0;
    }

    :host(:active:not([readonly]):not([focused])) [part='input-field']::after {
      opacity: 0.2;
    }
  }

  /* Trigger when not focusing using the keyboard */
  :host([focused]:not([focus-ring]):not([readonly])) [part='input-field']::after {
    transform: scaleX(0);
    transition-duration: 0.15s, 1s;
  }

  /* Focus-ring */
  :host([focus-ring]) [part='input-field'] {
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  /* Read-only and disabled */
  :host(:is([readonly], [disabled])) ::slotted(:is(input, textarea):placeholder-shown) {
    opacity: 0;
  }

  /* Read-only style */
  :host([readonly]) {
    --vaadin-input-field-border-color: transparent;
  }

  /* Disabled style */
  :host([disabled]) {
    pointer-events: none;
    --vaadin-input-field-border-color: var(--lumo-contrast-20pct);
  }

  :host([disabled]) [part='label'],
  :host([disabled]) [part='input-field'] ::slotted([slot$='fix']) {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([disabled]) [part='input-field'] ::slotted(:not([slot$='fix'])) {
    color: var(--_disabled-value-color);
    -webkit-text-fill-color: var(--_disabled-value-color);
  }

  /* Invalid style */
  :host([invalid]) {
    --vaadin-input-field-border-color: var(--lumo-error-color);
  }

  :host([invalid][focus-ring]) [part='input-field'] {
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--lumo-error-color-50pct);
  }

  :host([input-prevented]) [part='input-field'] {
    animation: shake 0.15s infinite;
  }

  @keyframes shake {
    25% {
      transform: translateX(4px);
    }
    75% {
      transform: translateX(-4px);
    }
  }

  /* Small theme */
  :host([theme~='small']) {
    font-size: var(--lumo-font-size-s);
    --lumo-text-field-size: var(--lumo-size-s);
  }

  :host([theme~='small']) [part='label'] {
    font-size: var(--lumo-font-size-xs);
  }

  :host([theme~='small']) [part='error-message'] {
    font-size: var(--lumo-font-size-xxs);
  }

  /* Slotted content */
  [part='input-field'] ::slotted(:not(vaadin-icon):not(input):not(textarea)) {
    color: var(--lumo-secondary-text-color);
    font-weight: 400;
  }

  [part='clear-button']::before {
    content: var(--lumo-icons-cross);
  }
`;
const inputFieldShared$1 = [requiredField, fieldButton, helper, inputField];
registerStyles$1("", inputFieldShared$1, {
  moduleId: "lumo-input-field-shared-styles"
});
const comboBox = css`
  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
  }
`;
registerStyles$1("vaadin-combo-box", [inputFieldShared$1, comboBox], { moduleId: "lumo-combo-box" });
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const InputContainerMixin = (superClass) => class InputContainerMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        reflectToAttribute: true
      },
      /**
       * Set to true to make this element read-only.
       */
      readonly: {
        type: Boolean,
        reflectToAttribute: true
      },
      /**
       * Set to true when the element is invalid.
       */
      invalid: {
        type: Boolean,
        reflectToAttribute: true
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("pointerdown", (event) => {
      if (event.target === this) {
        event.preventDefault();
      }
    });
    this.addEventListener("click", (event) => {
      if (event.target === this) {
        this.shadowRoot.querySelector("slot:not([name])").assignedNodes({ flatten: true }).forEach((node) => node.focus && node.focus());
      }
    });
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const inputContainerStyles = css`
  :host {
    display: flex;
    align-items: center;
    flex: 0 1 auto;
    border-radius:
            /* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius */
      var(--vaadin-input-field-top-start-radius, var(--__border-radius))
      var(--vaadin-input-field-top-end-radius, var(--__border-radius))
      var(--vaadin-input-field-bottom-end-radius, var(--__border-radius))
      var(--vaadin-input-field-bottom-start-radius, var(--__border-radius));
    --_border-radius: var(--vaadin-input-field-border-radius, 0);
    --_input-border-width: var(--vaadin-input-field-border-width, 0);
    --_input-border-color: var(--vaadin-input-field-border-color, transparent);
    box-shadow: inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
  }

  :host([dir='rtl']) {
    border-radius:
            /* Don't use logical props, see https://github.com/vaadin/vaadin-time-picker/issues/145 */
      var(--vaadin-input-field-top-end-radius, var(--_border-radius))
      var(--vaadin-input-field-top-start-radius, var(--_border-radius))
      var(--vaadin-input-field-bottom-start-radius, var(--_border-radius))
      var(--vaadin-input-field-bottom-end-radius, var(--_border-radius));
  }

  :host([hidden]) {
    display: none !important;
  }

  /* Reset the native input styles */
  ::slotted(input) {
    -webkit-appearance: none;
    -moz-appearance: none;
    flex: auto;
    white-space: nowrap;
    overflow: hidden;
    width: 100%;
    height: 100%;
    outline: none;
    margin: 0;
    padding: 0;
    border: 0;
    border-radius: 0;
    min-width: 0;
    font: inherit;
    line-height: normal;
    color: inherit;
    background-color: transparent;
    /* Disable default invalid style in Firefox */
    box-shadow: none;
  }

  ::slotted(*) {
    flex: none;
  }

  ::slotted(:is(input, textarea))::placeholder {
    /* Use ::slotted(input:placeholder-shown) in themes to style the placeholder. */
    /* because ::slotted(...)::placeholder does not work in Safari. */
    font: inherit;
    color: inherit;
    /* Override default opacity in Firefox */
    opacity: 1;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-input-container", inputContainerStyles, { moduleId: "vaadin-input-container-styles" });
class InputContainer extends InputContainerMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-input-container";
  }
  static get template() {
    return html`
      <slot name="prefix"></slot>
      <slot></slot>
      <slot name="suffix"></slot>
    `;
  }
}
defineCustomElement(InputContainer);
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ComboBoxItemMixin = (superClass) => class ComboBoxItemMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * The index of the item.
       */
      index: {
        type: Number
      },
      /**
       * The item to render.
       */
      item: {
        type: Object
      },
      /**
       * The text to render in the item.
       */
      label: {
        type: String
      },
      /**
       * True when item is selected.
       */
      selected: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * True when item is focused.
       */
      focused: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Custom function for rendering the item content.
       */
      renderer: {
        type: Function
      }
    };
  }
  static get observers() {
    return ["__rendererOrItemChanged(renderer, index, item, selected, focused)", "__updateLabel(label, renderer)"];
  }
  static get observedAttributes() {
    return [...super.observedAttributes, "hidden"];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "hidden" && newValue !== null) {
      this.index = void 0;
    } else {
      super.attributeChangedCallback(name, oldValue, newValue);
    }
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this._owner = this.parentNode.owner;
    const hostDir = this._owner.getAttribute("dir");
    if (hostDir) {
      this.setAttribute("dir", hostDir);
    }
  }
  /**
   * Requests an update for the content of the item.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this.renderer || this.hidden) {
      return;
    }
    const model = {
      index: this.index,
      item: this.item,
      focused: this.focused,
      selected: this.selected
    };
    this.renderer(this, this._owner, model);
  }
  /** @private */
  __rendererOrItemChanged(renderer, index, item2) {
    if (item2 === void 0 || index === void 0) {
      return;
    }
    if (this._oldRenderer !== renderer) {
      this.innerHTML = "";
      delete this._$litPart$;
    }
    if (renderer) {
      this._oldRenderer = renderer;
      this.requestContentUpdate();
    }
  }
  /** @private */
  __updateLabel(label, renderer) {
    if (renderer) {
      return;
    }
    this.textContent = label;
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ComboBoxItem extends ComboBoxItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-combo-box-item";
  }
}
defineCustomElement(ComboBoxItem);
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ComboBoxOverlayMixin = (superClass) => class ComboBoxOverlayMixin extends PositionMixin(superClass) {
  static get observers() {
    return ["_setOverlayWidth(positionTarget, opened)"];
  }
  constructor() {
    super();
    this.requiredVerticalSpace = 200;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    const comboBox2 = this._comboBox;
    const hostDir = comboBox2 && comboBox2.getAttribute("dir");
    if (hostDir) {
      this.setAttribute("dir", hostDir);
    }
  }
  /**
   * Override method inherited from `Overlay`
   * to not close on position target click.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(event) {
    const eventPath = event.composedPath();
    return !eventPath.includes(this.positionTarget) && !eventPath.includes(this);
  }
  /**
   * @protected
   * @override
   */
  _mouseDownListener(event) {
    super._mouseDownListener(event);
    if (this._shouldCloseOnOutsideClick(event) && !isElementFocusable(event.composedPath()[0])) {
      event.preventDefault();
    }
  }
  /** @protected */
  _updateOverlayWidth() {
    const propPrefix = this.localName;
    this.style.setProperty(`--_${propPrefix}-default-width`, `${this.positionTarget.clientWidth}px`);
    const customWidth = getComputedStyle(this._comboBox).getPropertyValue(`--${propPrefix}-width`);
    if (customWidth === "") {
      this.style.removeProperty(`--${propPrefix}-width`);
    } else {
      this.style.setProperty(`--${propPrefix}-width`, customWidth);
    }
  }
  /** @private */
  _setOverlayWidth(positionTarget, opened) {
    if (positionTarget && opened) {
      this._updateOverlayWidth();
      this._updatePosition();
    }
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const comboBoxOverlayStyles = css`
  #overlay {
    width: var(--vaadin-combo-box-overlay-width, var(--_vaadin-combo-box-overlay-default-width, auto));
  }

  [part='content'] {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
`;
registerStyles$1("vaadin-combo-box-overlay", [overlayStyles, comboBoxOverlayStyles], {
  moduleId: "vaadin-combo-box-overlay-styles"
});
class ComboBoxOverlay extends ComboBoxOverlayMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-combo-box-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden></div>
      <div part="overlay" id="overlay">
        <div part="loader"></div>
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
  }
}
defineCustomElement(ComboBoxOverlay);
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function get$1(path, object) {
  return path.split(".").reduce((obj, property) => obj ? obj[property] : void 0, object);
}
function set(path, value, object) {
  const pathParts = path.split(".");
  const lastPart = pathParts.pop();
  const target = pathParts.reduce((target2, part) => target2[part], object);
  target[lastPart] = value;
}
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
const IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/u);
const IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;
const DEFAULT_PHYSICAL_COUNT = 3;
const ironList = {
  /**
   * The ratio of hidden tiles that should remain in the scroll direction.
   * Recommended value ~0.5, so it will distribute tiles evenly in both
   * directions.
   */
  _ratio: 0.5,
  /**
   * The padding-top value for the list.
   */
  _scrollerPaddingTop: 0,
  /**
   * This value is a cached value of `scrollTop` from the last `scroll` event.
   */
  _scrollPosition: 0,
  /**
   * The sum of the heights of all the tiles in the DOM.
   */
  _physicalSize: 0,
  /**
   * The average `offsetHeight` of the tiles observed till now.
   */
  _physicalAverage: 0,
  /**
   * The number of tiles which `offsetHeight` > 0 observed until now.
   */
  _physicalAverageCount: 0,
  /**
   * The Y position of the item rendered in the `_physicalStart`
   * tile relative to the scrolling list.
   */
  _physicalTop: 0,
  /**
   * The number of items in the list.
   */
  _virtualCount: 0,
  /**
   * The estimated scroll height based on `_physicalAverage`
   */
  _estScrollHeight: 0,
  /**
   * The scroll height of the dom node
   */
  _scrollHeight: 0,
  /**
   * The height of the list. This is referred as the viewport in the context of
   * list.
   */
  _viewportHeight: 0,
  /**
   * The width of the list. This is referred as the viewport in the context of
   * list.
   */
  _viewportWidth: 0,
  /**
   * An array of DOM nodes that are currently in the tree
   * @type {?Array<!HTMLElement>}
   */
  _physicalItems: null,
  /**
   * An array of heights for each item in `_physicalItems`
   * @type {?Array<number>}
   */
  _physicalSizes: null,
  /**
   * A cached value for the first visible index.
   * See `firstVisibleIndex`
   * @type {?number}
   */
  _firstVisibleIndexVal: null,
  /**
   * A cached value for the last visible index.
   * See `lastVisibleIndex`
   * @type {?number}
   */
  _lastVisibleIndexVal: null,
  /**
   * The max number of pages to render. One page is equivalent to the height of
   * the list.
   */
  _maxPages: 2,
  /**
   * The cost of stamping a template in ms.
   */
  _templateCost: 0,
  /**
   * The bottom of the physical content.
   */
  get _physicalBottom() {
    return this._physicalTop + this._physicalSize;
  },
  /**
   * The bottom of the scroll.
   */
  get _scrollBottom() {
    return this._scrollPosition + this._viewportHeight;
  },
  /**
   * The n-th item rendered in the last physical item.
   */
  get _virtualEnd() {
    return this._virtualStart + this._physicalCount - 1;
  },
  /**
   * The height of the physical content that isn't on the screen.
   */
  get _hiddenContentSize() {
    return this._physicalSize - this._viewportHeight;
  },
  /**
   * The maximum scroll top value.
   */
  get _maxScrollTop() {
    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;
  },
  /**
   * The largest n-th value for an item such that it can be rendered in
   * `_physicalStart`.
   */
  get _maxVirtualStart() {
    const virtualCount = this._virtualCount;
    return Math.max(0, virtualCount - this._physicalCount);
  },
  get _virtualStart() {
    return this._virtualStartVal || 0;
  },
  set _virtualStart(val) {
    val = this._clamp(val, 0, this._maxVirtualStart);
    this._virtualStartVal = val;
  },
  get _physicalStart() {
    return this._physicalStartVal || 0;
  },
  /**
   * The k-th tile that is at the top of the scrolling list.
   */
  set _physicalStart(val) {
    val %= this._physicalCount;
    if (val < 0) {
      val = this._physicalCount + val;
    }
    this._physicalStartVal = val;
  },
  /**
   * The k-th tile that is at the bottom of the scrolling list.
   */
  get _physicalEnd() {
    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
  },
  get _physicalCount() {
    return this._physicalCountVal || 0;
  },
  set _physicalCount(val) {
    this._physicalCountVal = val;
  },
  /**
   * An optimal physical size such that we will have enough physical items
   * to fill up the viewport and recycle when the user scrolls.
   *
   * This default value assumes that we will at least have the equivalent
   * to a viewport of physical items above and below the user's viewport.
   */
  get _optPhysicalSize() {
    return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;
  },
  /**
   * True if the current list is visible.
   */
  get _isVisible() {
    return Boolean(this.offsetWidth || this.offsetHeight);
  },
  /**
   * Gets the index of the first visible item in the viewport.
   *
   * @type {number}
   */
  get firstVisibleIndex() {
    let idx = this._firstVisibleIndexVal;
    if (idx == null) {
      let physicalOffset = this._physicalTop + this._scrollOffset;
      idx = this._iterateItems((pidx, vidx) => {
        physicalOffset += this._getPhysicalSizeIncrement(pidx);
        if (physicalOffset > this._scrollPosition) {
          return vidx;
        }
      }) || 0;
      this._firstVisibleIndexVal = idx;
    }
    return idx;
  },
  /**
   * Gets the index of the last visible item in the viewport.
   *
   * @type {number}
   */
  get lastVisibleIndex() {
    let idx = this._lastVisibleIndexVal;
    if (idx == null) {
      let physicalOffset = this._physicalTop + this._scrollOffset;
      this._iterateItems((pidx, vidx) => {
        if (physicalOffset < this._scrollBottom) {
          idx = vidx;
        }
        physicalOffset += this._getPhysicalSizeIncrement(pidx);
      });
      this._lastVisibleIndexVal = idx;
    }
    return idx;
  },
  get _scrollOffset() {
    return this._scrollerPaddingTop + this.scrollOffset;
  },
  /**
   * Recycles the physical items when needed.
   */
  _scrollHandler() {
    const scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));
    let delta = scrollTop - this._scrollPosition;
    const isScrollingDown = delta >= 0;
    this._scrollPosition = scrollTop;
    this._firstVisibleIndexVal = null;
    this._lastVisibleIndexVal = null;
    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {
      delta -= this._scrollOffset;
      const idxAdjustment = Math.round(delta / this._physicalAverage);
      this._virtualStart += idxAdjustment;
      this._physicalStart += idxAdjustment;
      this._physicalTop = Math.min(Math.floor(this._virtualStart) * this._physicalAverage, this._scrollPosition);
      this._update();
    } else if (this._physicalCount > 0) {
      const reusables = this._getReusables(isScrollingDown);
      if (isScrollingDown) {
        this._physicalTop = reusables.physicalTop;
        this._virtualStart += reusables.indexes.length;
        this._physicalStart += reusables.indexes.length;
      } else {
        this._virtualStart -= reusables.indexes.length;
        this._physicalStart -= reusables.indexes.length;
      }
      this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);
      this._debounce("_increasePoolIfNeeded", this._increasePoolIfNeeded.bind(this, 0), microTask);
    }
  },
  /**
   * Returns an object that contains the indexes of the physical items
   * that might be reused and the physicalTop.
   *
   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.
   */
  _getReusables(fromTop) {
    let ith, offsetContent, physicalItemHeight;
    const idxs = [];
    const protectedOffsetContent = this._hiddenContentSize * this._ratio;
    const virtualStart = this._virtualStart;
    const virtualEnd = this._virtualEnd;
    const physicalCount = this._physicalCount;
    let top = this._physicalTop + this._scrollOffset;
    const bottom = this._physicalBottom + this._scrollOffset;
    const scrollTop = this._scrollPosition;
    const scrollBottom = this._scrollBottom;
    if (fromTop) {
      ith = this._physicalStart;
      offsetContent = scrollTop - top;
    } else {
      ith = this._physicalEnd;
      offsetContent = bottom - scrollBottom;
    }
    while (true) {
      physicalItemHeight = this._getPhysicalSizeIncrement(ith);
      offsetContent -= physicalItemHeight;
      if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {
        break;
      }
      if (fromTop) {
        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {
          break;
        }
        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {
          break;
        }
        idxs.push(ith);
        top += physicalItemHeight;
        ith = (ith + 1) % physicalCount;
      } else {
        if (virtualStart - idxs.length <= 0) {
          break;
        }
        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {
          break;
        }
        idxs.push(ith);
        top -= physicalItemHeight;
        ith = ith === 0 ? physicalCount - 1 : ith - 1;
      }
    }
    return { indexes: idxs, physicalTop: top - this._scrollOffset };
  },
  /**
   * Update the list of items, starting from the `_virtualStart` item.
   * @param {!Array<number>=} itemSet
   * @param {!Array<number>=} movingUp
   */
  _update(itemSet, movingUp) {
    if (itemSet && itemSet.length === 0 || this._physicalCount === 0) {
      return;
    }
    this._assignModels(itemSet);
    this._updateMetrics(itemSet);
    if (movingUp) {
      while (movingUp.length) {
        const idx = movingUp.pop();
        this._physicalTop -= this._getPhysicalSizeIncrement(idx);
      }
    }
    this._positionItems();
    this._updateScrollerSize();
  },
  _isClientFull() {
    return this._scrollBottom !== 0 && this._physicalBottom - 1 >= this._scrollBottom && this._physicalTop <= this._scrollPosition;
  },
  /**
   * Increases the pool size.
   */
  _increasePoolIfNeeded(count) {
    const nextPhysicalCount = this._clamp(
      this._physicalCount + count,
      DEFAULT_PHYSICAL_COUNT,
      this._virtualCount - this._virtualStart
    );
    const delta = nextPhysicalCount - this._physicalCount;
    let nextIncrease = Math.round(this._physicalCount * 0.5);
    if (delta < 0) {
      return;
    }
    if (delta > 0) {
      const ts = window.performance.now();
      [].push.apply(this._physicalItems, this._createPool(delta));
      for (let i2 = 0; i2 < delta; i2++) {
        this._physicalSizes.push(0);
      }
      this._physicalCount += delta;
      if (this._physicalStart > this._physicalEnd && this._isIndexRendered(this._focusedVirtualIndex) && this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd) {
        this._physicalStart += delta;
      }
      this._update();
      this._templateCost = (window.performance.now() - ts) / delta;
      nextIncrease = Math.round(this._physicalCount * 0.5);
    }
    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) ;
    else if (!this._isClientFull()) {
      this._debounce("_increasePoolIfNeeded", this._increasePoolIfNeeded.bind(this, nextIncrease), microTask);
    } else if (this._physicalSize < this._optPhysicalSize) {
      this._debounce(
        "_increasePoolIfNeeded",
        this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, nextIncrease)),
        idlePeriod
      );
    }
  },
  /**
   * Renders the a new list.
   */
  _render() {
    if (!this.isAttached || !this._isVisible) {
      return;
    }
    if (this._physicalCount !== 0) {
      const reusables = this._getReusables(true);
      this._physicalTop = reusables.physicalTop;
      this._virtualStart += reusables.indexes.length;
      this._physicalStart += reusables.indexes.length;
      this._update(reusables.indexes);
      this._update();
      this._increasePoolIfNeeded(0);
    } else if (this._virtualCount > 0) {
      this.updateViewportBoundaries();
      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);
    }
  },
  /**
   * Called when the items have changed. That is, reassignments
   * to `items`, splices or updates to a single item.
   */
  _itemsChanged(change) {
    if (change.path === "items") {
      this._virtualStart = 0;
      this._physicalTop = 0;
      this._virtualCount = this.items ? this.items.length : 0;
      this._physicalIndexForKey = {};
      this._firstVisibleIndexVal = null;
      this._lastVisibleIndexVal = null;
      if (!this._physicalItems) {
        this._physicalItems = [];
      }
      if (!this._physicalSizes) {
        this._physicalSizes = [];
      }
      this._physicalStart = 0;
      if (this._scrollTop > this._scrollOffset) {
        this._resetScrollPosition(0);
      }
      this._debounce("_render", this._render, animationFrame);
    }
  },
  /**
   * Executes a provided function per every physical index in `itemSet`
   * `itemSet` default value is equivalent to the entire set of physical
   * indexes.
   *
   * @param {!function(number, number)} fn
   * @param {!Array<number>=} itemSet
   */
  _iterateItems(fn, itemSet) {
    let pidx, vidx, rtn, i2;
    if (arguments.length === 2 && itemSet) {
      for (i2 = 0; i2 < itemSet.length; i2++) {
        pidx = itemSet[i2];
        vidx = this._computeVidx(pidx);
        if ((rtn = fn.call(this, pidx, vidx)) != null) {
          return rtn;
        }
      }
    } else {
      pidx = this._physicalStart;
      vidx = this._virtualStart;
      for (; pidx < this._physicalCount; pidx++, vidx++) {
        if ((rtn = fn.call(this, pidx, vidx)) != null) {
          return rtn;
        }
      }
      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {
        if ((rtn = fn.call(this, pidx, vidx)) != null) {
          return rtn;
        }
      }
    }
  },
  /**
   * Returns the virtual index for a given physical index
   *
   * @param {number} pidx Physical index
   * @return {number}
   */
  _computeVidx(pidx) {
    if (pidx >= this._physicalStart) {
      return this._virtualStart + (pidx - this._physicalStart);
    }
    return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;
  },
  /**
   * Updates the position of the physical items.
   */
  _positionItems() {
    this._adjustScrollPosition();
    let y3 = this._physicalTop;
    this._iterateItems((pidx) => {
      this.translate3d(0, `${y3}px`, 0, this._physicalItems[pidx]);
      y3 += this._physicalSizes[pidx];
    });
  },
  _getPhysicalSizeIncrement(pidx) {
    return this._physicalSizes[pidx];
  },
  /**
   * Adjusts the scroll position when it was overestimated.
   */
  _adjustScrollPosition() {
    const deltaHeight = this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);
    if (deltaHeight !== 0) {
      this._physicalTop -= deltaHeight;
      const scrollTop = this._scrollPosition;
      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {
        this._resetScrollPosition(scrollTop - deltaHeight);
      }
    }
  },
  /**
   * Sets the position of the scroll.
   */
  _resetScrollPosition(pos) {
    if (this.scrollTarget && pos >= 0) {
      this._scrollTop = pos;
      this._scrollPosition = this._scrollTop;
    }
  },
  /**
   * Sets the scroll height, that's the height of the content,
   *
   * @param {boolean=} forceUpdate If true, updates the height no matter what.
   */
  _updateScrollerSize(forceUpdate) {
    const estScrollHeight = this._physicalBottom + Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;
    this._estScrollHeight = estScrollHeight;
    if (forceUpdate || this._scrollHeight === 0 || this._scrollPosition >= estScrollHeight - this._physicalSize || Math.abs(estScrollHeight - this._scrollHeight) >= this._viewportHeight) {
      this.$.items.style.height = `${estScrollHeight}px`;
      this._scrollHeight = estScrollHeight;
    }
  },
  /**
   * Scroll to a specific index in the virtual list regardless
   * of the physical items in the DOM tree.
   *
   * @method scrollToIndex
   * @param {number} idx The index of the item
   */
  scrollToIndex(idx) {
    if (typeof idx !== "number" || idx < 0 || idx > this.items.length - 1) {
      return;
    }
    flush$1();
    if (this._physicalCount === 0) {
      return;
    }
    idx = this._clamp(idx, 0, this._virtualCount - 1);
    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {
      this._virtualStart = idx - 1;
    }
    this._assignModels();
    this._updateMetrics();
    this._physicalTop = this._virtualStart * this._physicalAverage;
    let currentTopItem = this._physicalStart;
    let currentVirtualItem = this._virtualStart;
    let targetOffsetTop = 0;
    const hiddenContentSize = this._hiddenContentSize;
    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {
      targetOffsetTop += this._getPhysicalSizeIncrement(currentTopItem);
      currentTopItem = (currentTopItem + 1) % this._physicalCount;
      currentVirtualItem += 1;
    }
    this._updateScrollerSize(true);
    this._positionItems();
    this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);
    this._increasePoolIfNeeded(0);
    this._firstVisibleIndexVal = null;
    this._lastVisibleIndexVal = null;
  },
  /**
   * Reset the physical average and the average count.
   */
  _resetAverage() {
    this._physicalAverage = 0;
    this._physicalAverageCount = 0;
  },
  /**
   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`
   * when the element is resized.
   */
  _resizeHandler() {
    this._debounce(
      "_render",
      () => {
        this._firstVisibleIndexVal = null;
        this._lastVisibleIndexVal = null;
        if (this._isVisible) {
          this.updateViewportBoundaries();
          this.toggleScrollListener(true);
          this._resetAverage();
          this._render();
        } else {
          this.toggleScrollListener(false);
        }
      },
      animationFrame
    );
  },
  _isIndexRendered(idx) {
    return idx >= this._virtualStart && idx <= this._virtualEnd;
  },
  _getPhysicalIndex(vidx) {
    return (this._physicalStart + (vidx - this._virtualStart)) % this._physicalCount;
  },
  _clamp(v, min, max) {
    return Math.min(max, Math.max(min, v));
  },
  _debounce(name, cb, asyncModule) {
    if (!this._debouncers) {
      this._debouncers = {};
    }
    this._debouncers[name] = Debouncer$1.debounce(this._debouncers[name], asyncModule, cb.bind(this));
    enqueueDebouncer$1(this._debouncers[name]);
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MAX_VIRTUAL_COUNT = 1e5;
const OFFSET_ADJUST_MIN_THRESHOLD = 1e3;
class IronListAdapter {
  constructor({ createElements, updateElement, scrollTarget, scrollContainer, elementsContainer, reorderElements }) {
    this.isAttached = true;
    this._vidxOffset = 0;
    this.createElements = createElements;
    this.updateElement = updateElement;
    this.scrollTarget = scrollTarget;
    this.scrollContainer = scrollContainer;
    this.elementsContainer = elementsContainer || scrollContainer;
    this.reorderElements = reorderElements;
    this._maxPages = 1.3;
    this.__placeholderHeight = 200;
    this.__elementHeightQueue = Array(10);
    this.timeouts = {
      SCROLL_REORDER: 500,
      IGNORE_WHEEL: 500,
      FIX_INVALID_ITEM_POSITIONING: 100
    };
    this.__resizeObserver = new ResizeObserver(() => this._resizeHandler());
    if (getComputedStyle(this.scrollTarget).overflow === "visible") {
      this.scrollTarget.style.overflow = "auto";
    }
    if (getComputedStyle(this.scrollContainer).position === "static") {
      this.scrollContainer.style.position = "relative";
    }
    this.__resizeObserver.observe(this.scrollTarget);
    this.scrollTarget.addEventListener("scroll", () => this._scrollHandler());
    this._scrollLineHeight = this._getScrollLineHeight();
    this.scrollTarget.addEventListener("wheel", (e2) => this.__onWheel(e2));
    this.scrollTarget.addEventListener("virtualizer-element-focused", (e2) => this.__onElementFocused(e2));
    this.elementsContainer.addEventListener("focusin", () => {
      this.scrollTarget.dispatchEvent(
        new CustomEvent("virtualizer-element-focused", { detail: { element: this.__getFocusedElement() } })
      );
    });
    if (this.reorderElements) {
      this.scrollTarget.addEventListener("mousedown", () => {
        this.__mouseDown = true;
      });
      this.scrollTarget.addEventListener("mouseup", () => {
        this.__mouseDown = false;
        if (this.__pendingReorder) {
          this.__reorderElements();
        }
      });
    }
  }
  get scrollOffset() {
    return 0;
  }
  get adjustedFirstVisibleIndex() {
    return this.firstVisibleIndex + this._vidxOffset;
  }
  get adjustedLastVisibleIndex() {
    return this.lastVisibleIndex + this._vidxOffset;
  }
  get _maxVirtualIndexOffset() {
    return this.size - this._virtualCount;
  }
  __hasPlaceholders() {
    return this.__getVisibleElements().some((el) => el.__virtualizerPlaceholder);
  }
  scrollToIndex(index) {
    if (typeof index !== "number" || isNaN(index) || this.size === 0 || !this.scrollTarget.offsetHeight) {
      return;
    }
    delete this.__pendingScrollToIndex;
    if (this._physicalCount <= 3) {
      this.flush();
    }
    index = this._clamp(index, 0, this.size - 1);
    const visibleElementCount = this.__getVisibleElements().length;
    let targetVirtualIndex = Math.floor(index / this.size * this._virtualCount);
    if (this._virtualCount - targetVirtualIndex < visibleElementCount) {
      targetVirtualIndex = this._virtualCount - (this.size - index);
      this._vidxOffset = this._maxVirtualIndexOffset;
    } else if (targetVirtualIndex < visibleElementCount) {
      if (index < OFFSET_ADJUST_MIN_THRESHOLD) {
        targetVirtualIndex = index;
        this._vidxOffset = 0;
      } else {
        targetVirtualIndex = OFFSET_ADJUST_MIN_THRESHOLD;
        this._vidxOffset = index - targetVirtualIndex;
      }
    } else {
      this._vidxOffset = index - targetVirtualIndex;
    }
    this.__skipNextVirtualIndexAdjust = true;
    super.scrollToIndex(targetVirtualIndex);
    if (this.adjustedFirstVisibleIndex !== index && this._scrollTop < this._maxScrollTop && !this.grid) {
      this._scrollTop -= this.__getIndexScrollOffset(index) || 0;
    }
    this._scrollHandler();
    if (this.__hasPlaceholders()) {
      this.__pendingScrollToIndex = index;
    }
  }
  flush() {
    if (this.scrollTarget.offsetHeight === 0) {
      return;
    }
    this._resizeHandler();
    flush$1();
    this._scrollHandler();
    if (this.__fixInvalidItemPositioningDebouncer) {
      this.__fixInvalidItemPositioningDebouncer.flush();
    }
    if (this.__scrollReorderDebouncer) {
      this.__scrollReorderDebouncer.flush();
    }
    if (this.__debouncerWheelAnimationFrame) {
      this.__debouncerWheelAnimationFrame.flush();
    }
  }
  update(startIndex = 0, endIndex = this.size - 1) {
    const updatedElements = [];
    this.__getVisibleElements().forEach((el) => {
      if (el.__virtualIndex >= startIndex && el.__virtualIndex <= endIndex) {
        this.__updateElement(el, el.__virtualIndex, true);
        updatedElements.push(el);
      }
    });
    this.__afterElementsUpdated(updatedElements);
  }
  /**
   * Updates the height for a given set of items.
   *
   * @param {!Array<number>=} itemSet
   */
  _updateMetrics(itemSet) {
    flush$1();
    let newPhysicalSize = 0;
    let oldPhysicalSize = 0;
    const prevAvgCount = this._physicalAverageCount;
    const prevPhysicalAvg = this._physicalAverage;
    this._iterateItems((pidx, vidx) => {
      oldPhysicalSize += this._physicalSizes[pidx];
      this._physicalSizes[pidx] = Math.ceil(this.__getBorderBoxHeight(this._physicalItems[pidx]));
      newPhysicalSize += this._physicalSizes[pidx];
      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;
    }, itemSet);
    this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;
    if (this._physicalAverageCount !== prevAvgCount) {
      this._physicalAverage = Math.round(
        (prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount
      );
    }
  }
  __getBorderBoxHeight(el) {
    const style = getComputedStyle(el);
    const itemHeight = parseFloat(style.height) || 0;
    if (style.boxSizing === "border-box") {
      return itemHeight;
    }
    const paddingBottom = parseFloat(style.paddingBottom) || 0;
    const paddingTop = parseFloat(style.paddingTop) || 0;
    const borderBottomWidth = parseFloat(style.borderBottomWidth) || 0;
    const borderTopWidth = parseFloat(style.borderTopWidth) || 0;
    return itemHeight + paddingBottom + paddingTop + borderBottomWidth + borderTopWidth;
  }
  __updateElement(el, index, forceSameIndexUpdates) {
    if (el.__virtualizerPlaceholder) {
      el.style.paddingTop = "";
      el.style.opacity = "";
      el.__virtualizerPlaceholder = false;
    }
    if (!this.__preventElementUpdates && (el.__lastUpdatedIndex !== index || forceSameIndexUpdates)) {
      this.updateElement(el, index);
      el.__lastUpdatedIndex = index;
    }
  }
  /**
   * Called synchronously right after elements have been updated.
   * This is a good place to do any post-update work.
   *
   * @param {!Array<!HTMLElement>} updatedElements
   */
  __afterElementsUpdated(updatedElements) {
    updatedElements.forEach((el) => {
      const elementHeight = el.offsetHeight;
      if (elementHeight === 0) {
        el.style.paddingTop = `${this.__placeholderHeight}px`;
        el.style.opacity = "0";
        el.__virtualizerPlaceholder = true;
        this.__placeholderClearDebouncer = Debouncer$1.debounce(
          this.__placeholderClearDebouncer,
          animationFrame,
          () => this._resizeHandler()
        );
      } else {
        this.__elementHeightQueue.push(elementHeight);
        this.__elementHeightQueue.shift();
        const filteredHeights = this.__elementHeightQueue.filter((h3) => h3 !== void 0);
        this.__placeholderHeight = Math.round(filteredHeights.reduce((a3, b2) => a3 + b2, 0) / filteredHeights.length);
      }
    });
    if (this.__pendingScrollToIndex !== void 0 && !this.__hasPlaceholders()) {
      this.scrollToIndex(this.__pendingScrollToIndex);
    }
  }
  __getIndexScrollOffset(index) {
    const element = this.__getVisibleElements().find((el) => el.__virtualIndex === index);
    return element ? this.scrollTarget.getBoundingClientRect().top - element.getBoundingClientRect().top : void 0;
  }
  get size() {
    return this.__size;
  }
  set size(size) {
    if (size === this.size) {
      return;
    }
    if (this.__fixInvalidItemPositioningDebouncer) {
      this.__fixInvalidItemPositioningDebouncer.cancel();
    }
    if (this._debouncers && this._debouncers._increasePoolIfNeeded) {
      this._debouncers._increasePoolIfNeeded.cancel();
    }
    this.__preventElementUpdates = true;
    let fvi;
    let fviOffsetBefore;
    if (size > 0) {
      fvi = this.adjustedFirstVisibleIndex;
      fviOffsetBefore = this.__getIndexScrollOffset(fvi);
    }
    this.__size = size;
    this._itemsChanged({
      path: "items"
    });
    flush$1();
    if (size > 0) {
      fvi = Math.min(fvi, size - 1);
      this.scrollToIndex(fvi);
      const fviOffsetAfter = this.__getIndexScrollOffset(fvi);
      if (fviOffsetBefore !== void 0 && fviOffsetAfter !== void 0) {
        this._scrollTop += fviOffsetBefore - fviOffsetAfter;
      }
    }
    this.__preventElementUpdates = false;
    if (!this._isVisible) {
      this._assignModels();
    }
    if (!this.elementsContainer.children.length) {
      requestAnimationFrame(() => this._resizeHandler());
    }
    this._resizeHandler();
    flush$1();
    this._debounce("_update", this._update, microTask);
  }
  /** @private */
  get _scrollTop() {
    return this.scrollTarget.scrollTop;
  }
  /** @private */
  set _scrollTop(top) {
    this.scrollTarget.scrollTop = top;
  }
  /** @private */
  get items() {
    return {
      length: Math.min(this.size, MAX_VIRTUAL_COUNT)
    };
  }
  /** @private */
  get offsetHeight() {
    return this.scrollTarget.offsetHeight;
  }
  /** @private */
  get $() {
    return {
      items: this.scrollContainer
    };
  }
  /** @private */
  updateViewportBoundaries() {
    const styles2 = window.getComputedStyle(this.scrollTarget);
    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles2["padding-top"], 10);
    this._isRTL = Boolean(styles2.direction === "rtl");
    this._viewportWidth = this.elementsContainer.offsetWidth;
    this._viewportHeight = this.scrollTarget.offsetHeight;
    this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight;
    if (this.grid) {
      this._updateGridMetrics();
    }
  }
  /** @private */
  setAttribute() {
  }
  /** @private */
  _createPool(size) {
    const physicalItems = this.createElements(size);
    const fragment = document.createDocumentFragment();
    physicalItems.forEach((el) => {
      el.style.position = "absolute";
      fragment.appendChild(el);
      this.__resizeObserver.observe(el);
    });
    this.elementsContainer.appendChild(fragment);
    return physicalItems;
  }
  /** @private */
  _assignModels(itemSet) {
    const updatedElements = [];
    this._iterateItems((pidx, vidx) => {
      const el = this._physicalItems[pidx];
      el.hidden = vidx >= this.size;
      if (!el.hidden) {
        el.__virtualIndex = vidx + (this._vidxOffset || 0);
        this.__updateElement(el, el.__virtualIndex);
        updatedElements.push(el);
      } else {
        delete el.__lastUpdatedIndex;
      }
    }, itemSet);
    this.__afterElementsUpdated(updatedElements);
  }
  /** @private */
  _isClientFull() {
    setTimeout(() => {
      this.__clientFull = true;
    });
    return this.__clientFull || super._isClientFull();
  }
  /** @private */
  translate3d(_x, y3, _z, el) {
    el.style.transform = `translateY(${y3})`;
  }
  /** @private */
  toggleScrollListener() {
  }
  /** @private */
  __getFocusedElement(visibleElements = this.__getVisibleElements()) {
    return visibleElements.find(
      (element) => element.contains(this.elementsContainer.getRootNode().activeElement) || element.contains(this.scrollTarget.getRootNode().activeElement)
    );
  }
  /** @private */
  __nextFocusableSiblingMissing(focusedElement, visibleElements) {
    return (
      // Check if focused element is the last visible DOM element
      visibleElements.indexOf(focusedElement) === visibleElements.length - 1 && // ...while there are more items available
      this.size > focusedElement.__virtualIndex + 1
    );
  }
  /** @private */
  __previousFocusableSiblingMissing(focusedElement, visibleElements) {
    return (
      // Check if focused element is the first visible DOM element
      visibleElements.indexOf(focusedElement) === 0 && // ...while there are preceding items available
      focusedElement.__virtualIndex > 0
    );
  }
  /** @private */
  __onElementFocused(e2) {
    if (!this.reorderElements) {
      return;
    }
    const focusedElement = e2.detail.element;
    if (!focusedElement) {
      return;
    }
    const visibleElements = this.__getVisibleElements();
    if (this.__previousFocusableSiblingMissing(focusedElement, visibleElements) || this.__nextFocusableSiblingMissing(focusedElement, visibleElements)) {
      this.flush();
    }
    const reorderedVisibleElements = this.__getVisibleElements();
    if (this.__nextFocusableSiblingMissing(focusedElement, reorderedVisibleElements)) {
      this._scrollTop += Math.ceil(focusedElement.getBoundingClientRect().bottom) - Math.floor(this.scrollTarget.getBoundingClientRect().bottom - 1);
      this.flush();
    } else if (this.__previousFocusableSiblingMissing(focusedElement, reorderedVisibleElements)) {
      this._scrollTop -= Math.ceil(this.scrollTarget.getBoundingClientRect().top + 1) - Math.floor(focusedElement.getBoundingClientRect().top);
      this.flush();
    }
  }
  _scrollHandler() {
    if (this.scrollTarget.offsetHeight === 0) {
      return;
    }
    this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));
    const delta = this.scrollTarget.scrollTop - this._scrollPosition;
    super._scrollHandler();
    if (this._physicalCount !== 0) {
      const isScrollingDown = delta >= 0;
      const reusables = this._getReusables(!isScrollingDown);
      if (reusables.indexes.length) {
        this._physicalTop = reusables.physicalTop;
        if (isScrollingDown) {
          this._virtualStart -= reusables.indexes.length;
          this._physicalStart -= reusables.indexes.length;
        } else {
          this._virtualStart += reusables.indexes.length;
          this._physicalStart += reusables.indexes.length;
        }
        this._resizeHandler();
      }
    }
    if (delta) {
      this.__fixInvalidItemPositioningDebouncer = Debouncer$1.debounce(
        this.__fixInvalidItemPositioningDebouncer,
        timeOut.after(this.timeouts.FIX_INVALID_ITEM_POSITIONING),
        () => this.__fixInvalidItemPositioning()
      );
    }
    if (this.reorderElements) {
      this.__scrollReorderDebouncer = Debouncer$1.debounce(
        this.__scrollReorderDebouncer,
        timeOut.after(this.timeouts.SCROLL_REORDER),
        () => this.__reorderElements()
      );
    }
    this.__previousScrollTop = this._scrollTop;
    if (this._scrollTop === 0 && this.firstVisibleIndex !== 0 && Math.abs(delta) > 0) {
      this.scrollToIndex(0);
    }
  }
  /**
   * Work around an iron-list issue with invalid item positioning.
   * See https://github.com/vaadin/flow-components/issues/4306
   * @private
   */
  __fixInvalidItemPositioning() {
    if (!this.scrollTarget.isConnected) {
      return;
    }
    const physicalTopBelowTop = this._physicalTop > this._scrollTop;
    const physicalBottomAboveBottom = this._physicalBottom < this._scrollBottom;
    const firstIndexVisible = this.adjustedFirstVisibleIndex === 0;
    const lastIndexVisible = this.adjustedLastVisibleIndex === this.size - 1;
    if (physicalTopBelowTop && !firstIndexVisible || physicalBottomAboveBottom && !lastIndexVisible) {
      const isScrollingDown = physicalBottomAboveBottom;
      const originalRatio = this._ratio;
      this._ratio = 0;
      this._scrollPosition = this._scrollTop + (isScrollingDown ? -1 : 1);
      this._scrollHandler();
      this._ratio = originalRatio;
    }
  }
  /** @private */
  __onWheel(e2) {
    if (e2.ctrlKey || this._hasScrolledAncestor(e2.target, e2.deltaX, e2.deltaY)) {
      return;
    }
    let deltaY = e2.deltaY;
    if (e2.deltaMode === WheelEvent.DOM_DELTA_LINE) {
      deltaY *= this._scrollLineHeight;
    } else if (e2.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
      deltaY *= this._scrollPageHeight;
    }
    if (!this._deltaYAcc) {
      this._deltaYAcc = 0;
    }
    if (this._wheelAnimationFrame) {
      this._deltaYAcc += deltaY;
      e2.preventDefault();
      return;
    }
    deltaY += this._deltaYAcc;
    this._deltaYAcc = 0;
    this._wheelAnimationFrame = true;
    this.__debouncerWheelAnimationFrame = Debouncer$1.debounce(
      this.__debouncerWheelAnimationFrame,
      animationFrame,
      () => {
        this._wheelAnimationFrame = false;
      }
    );
    const momentum = Math.abs(e2.deltaX) + Math.abs(deltaY);
    if (this._canScroll(this.scrollTarget, e2.deltaX, deltaY)) {
      e2.preventDefault();
      this.scrollTarget.scrollTop += deltaY;
      this.scrollTarget.scrollLeft += e2.deltaX;
      this._hasResidualMomentum = true;
      this._ignoreNewWheel = true;
      this._debouncerIgnoreNewWheel = Debouncer$1.debounce(
        this._debouncerIgnoreNewWheel,
        timeOut.after(this.timeouts.IGNORE_WHEEL),
        () => {
          this._ignoreNewWheel = false;
        }
      );
    } else if (this._hasResidualMomentum && momentum <= this._previousMomentum || this._ignoreNewWheel) {
      e2.preventDefault();
    } else if (momentum > this._previousMomentum) {
      this._hasResidualMomentum = false;
    }
    this._previousMomentum = momentum;
  }
  /**
   * Determines if the element has an ancestor that handles the scroll delta prior to this
   *
   * @private
   */
  _hasScrolledAncestor(el, deltaX, deltaY) {
    if (el === this.scrollTarget || el === this.scrollTarget.getRootNode().host) {
      return false;
    } else if (this._canScroll(el, deltaX, deltaY) && ["auto", "scroll"].indexOf(getComputedStyle(el).overflow) !== -1) {
      return true;
    } else if (el !== this && el.parentElement) {
      return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);
    }
  }
  _canScroll(el, deltaX, deltaY) {
    return deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight || deltaY < 0 && el.scrollTop > 0 || deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth || deltaX < 0 && el.scrollLeft > 0;
  }
  /**
   * Increases the pool size.
   * @override
   */
  _increasePoolIfNeeded(count) {
    if (this._physicalCount > 2 && count) {
      const totalItemCount = Math.ceil(this._optPhysicalSize / this._physicalAverage);
      const missingItemCount = totalItemCount - this._physicalCount;
      super._increasePoolIfNeeded(Math.max(count, Math.min(100, missingItemCount)));
    } else {
      super._increasePoolIfNeeded(count);
    }
  }
  /**
   * An optimal physical size such that we will have enough physical items
   * to fill up the viewport and recycle when the user scrolls.
   *
   * This default value assumes that we will at least have the equivalent
   * to a viewport of physical items above and below the user's viewport.
   * @override
   */
  get _optPhysicalSize() {
    const optPhysicalSize = super._optPhysicalSize;
    if (optPhysicalSize <= 0 || this.__hasPlaceholders()) {
      return optPhysicalSize;
    }
    return optPhysicalSize + this.__getItemHeightBuffer();
  }
  /**
   * Extra item height buffer used when calculating optimal physical size.
   *
   * The iron list core uses the optimal physical size when determining whether to increase the item pool.
   * For the cases where some items are much larger than the average, the iron list core might not increase item pool.
   * This can lead to the large item not being rendered.
   *
   * @returns {Number} - Extra item height buffer
   * @private
   */
  __getItemHeightBuffer() {
    if (this._physicalCount === 0) {
      return 0;
    }
    const bufferZoneHeight = Math.ceil(this._viewportHeight * (this._maxPages - 1) / 2);
    const maxItemHeight = Math.max(...this._physicalSizes);
    if (maxItemHeight > Math.min(...this._physicalSizes)) {
      return Math.max(0, maxItemHeight - bufferZoneHeight);
    }
    return 0;
  }
  /**
   * @returns {Number|undefined} - The browser's default font-size in pixels
   * @private
   */
  _getScrollLineHeight() {
    const el = document.createElement("div");
    el.style.fontSize = "initial";
    el.style.display = "none";
    document.body.appendChild(el);
    const fontSize = window.getComputedStyle(el).fontSize;
    document.body.removeChild(el);
    return fontSize ? window.parseInt(fontSize) : void 0;
  }
  __getVisibleElements() {
    return Array.from(this.elementsContainer.children).filter((element) => !element.hidden);
  }
  /** @private */
  __reorderElements() {
    if (this.__mouseDown) {
      this.__pendingReorder = true;
      return;
    }
    this.__pendingReorder = false;
    const adjustedVirtualStart = this._virtualStart + (this._vidxOffset || 0);
    const visibleElements = this.__getVisibleElements();
    const targetElement = this.__getFocusedElement(visibleElements) || visibleElements[0];
    if (!targetElement) {
      return;
    }
    const targetPhysicalIndex = targetElement.__virtualIndex - adjustedVirtualStart;
    const delta = visibleElements.indexOf(targetElement) - targetPhysicalIndex;
    if (delta > 0) {
      for (let i2 = 0; i2 < delta; i2++) {
        this.elementsContainer.appendChild(visibleElements[i2]);
      }
    } else if (delta < 0) {
      for (let i2 = visibleElements.length + delta; i2 < visibleElements.length; i2++) {
        this.elementsContainer.insertBefore(visibleElements[i2], visibleElements[0]);
      }
    }
    if (isSafari) {
      const { transform } = this.scrollTarget.style;
      this.scrollTarget.style.transform = "translateZ(0)";
      setTimeout(() => {
        this.scrollTarget.style.transform = transform;
      });
    }
  }
  /** @private */
  _adjustVirtualIndexOffset(delta) {
    const maxOffset = this._maxVirtualIndexOffset;
    if (this._virtualCount >= this.size) {
      this._vidxOffset = 0;
    } else if (this.__skipNextVirtualIndexAdjust) {
      this.__skipNextVirtualIndexAdjust = false;
    } else if (Math.abs(delta) > 1e4) {
      const scale = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.clientHeight);
      this._vidxOffset = Math.round(scale * maxOffset);
    } else {
      const oldOffset = this._vidxOffset;
      const threshold = OFFSET_ADJUST_MIN_THRESHOLD;
      const maxShift = 100;
      if (this._scrollTop === 0) {
        this._vidxOffset = 0;
        if (oldOffset !== this._vidxOffset) {
          super.scrollToIndex(0);
        }
      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {
        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);
        super.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset));
      }
      if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {
        this._vidxOffset = maxOffset;
        if (oldOffset !== this._vidxOffset) {
          super.scrollToIndex(this._virtualCount - 1);
        }
      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {
        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);
        super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));
      }
    }
  }
}
Object.setPrototypeOf(IronListAdapter.prototype, ironList);
class Virtualizer {
  /**
   * @typedef {Object} VirtualizerConfig
   * @property {Function} createElements Function that returns the given number of new elements
   * @property {Function} updateElement Function that updates the element at a specific index
   * @property {HTMLElement} scrollTarget Reference to the scrolling element
   * @property {HTMLElement} scrollContainer Reference to a wrapper for the item elements (or a slot) inside the scrollTarget
   * @property {HTMLElement | undefined} elementsContainer Reference to the container in which the item elements are placed, defaults to scrollContainer
   * @property {boolean | undefined} reorderElements Determines whether the physical item elements should be kept in order in the DOM
   * @param {VirtualizerConfig} config Configuration for the virtualizer
   */
  constructor(config) {
    this.__adapter = new IronListAdapter(config);
  }
  /**
   * Gets the index of the first visible item in the viewport.
   *
   * @return {number}
   */
  get firstVisibleIndex() {
    return this.__adapter.adjustedFirstVisibleIndex;
  }
  /**
   * Gets the index of the last visible item in the viewport.
   *
   * @return {number}
   */
  get lastVisibleIndex() {
    return this.__adapter.adjustedLastVisibleIndex;
  }
  /**
   * The size of the virtualizer
   * @return {number | undefined} The size of the virtualizer
   */
  get size() {
    return this.__adapter.size;
  }
  /**
   * The size of the virtualizer
   * @param {number} size The size of the virtualizer
   */
  set size(size) {
    this.__adapter.size = size;
  }
  /**
   * Scroll to a specific index in the virtual list
   *
   * @method scrollToIndex
   * @param {number} index The index of the item
   */
  scrollToIndex(index) {
    this.__adapter.scrollToIndex(index);
  }
  /**
   * Requests the virtualizer to re-render the item elements on an index range, if currently in the DOM
   *
   * @method update
   * @param {number | undefined} startIndex The start index of the range
   * @param {number | undefined} endIndex The end index of the range
   */
  update(startIndex = 0, endIndex = this.size - 1) {
    this.__adapter.update(startIndex, endIndex);
  }
  /**
   * Flushes active asynchronous tasks so that the component and the DOM end up in a stable state
   *
   * @method update
   * @param {number | undefined} startIndex The start index of the range
   * @param {number | undefined} endIndex The end index of the range
   */
  flush() {
    this.__adapter.flush();
  }
}
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ComboBoxPlaceholder = class ComboBoxPlaceholder2 {
  toString() {
    return "";
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ComboBoxScrollerMixin = (superClass) => class ComboBoxScrollerMixin extends superClass {
  static get properties() {
    return {
      /**
       * A full set of items to filter the visible options from.
       * Set to an empty array when combo-box is not opened.
       */
      items: {
        type: Array,
        sync: true,
        observer: "__itemsChanged"
      },
      /**
       * Index of an item that has focus outline and is scrolled into view.
       * The actual focus still remains in the input field.
       */
      focusedIndex: {
        type: Number,
        sync: true,
        observer: "__focusedIndexChanged"
      },
      /**
       * Set to true while combo-box fetches new page from the data provider.
       */
      loading: {
        type: Boolean,
        sync: true,
        observer: "__loadingChanged"
      },
      /**
       * Whether the combo-box is currently opened or not. If set to false,
       * calling `scrollIntoView` does not have any effect.
       */
      opened: {
        type: Boolean,
        sync: true,
        observer: "__openedChanged"
      },
      /**
       * The selected item from the `items` array.
       */
      selectedItem: {
        type: Object,
        sync: true,
        observer: "__selectedItemChanged"
      },
      /**
       * A function used to generate CSS class names for dropdown
       * items based on the item. The return value should be the
       * generated class name as a string, or multiple class names
       * separated by whitespace characters.
       */
      itemClassNameGenerator: {
        type: Object,
        observer: "__itemClassNameGeneratorChanged"
      },
      /**
       * Path for the id of the item, used to detect whether the item is selected.
       */
      itemIdPath: {
        type: String
      },
      /**
       * Reference to the owner (combo-box owner), used by the item elements.
       */
      owner: {
        type: Object
      },
      /**
       * Function used to set a label for every combo-box item.
       */
      getItemLabel: {
        type: Object
      },
      /**
       * Function used to render the content of every combo-box item.
       */
      renderer: {
        type: Object,
        sync: true,
        observer: "__rendererChanged"
      },
      /**
       * Used to propagate the `theme` attribute from the host element.
       */
      theme: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.__boundOnItemClick = this.__onItemClick.bind(this);
  }
  /** @private */
  get _viewportTotalPaddingBottom() {
    if (this._cachedViewportTotalPaddingBottom === void 0) {
      const itemsStyle = window.getComputedStyle(this.$.selector);
      this._cachedViewportTotalPaddingBottom = [itemsStyle.paddingBottom, itemsStyle.borderBottomWidth].map((v) => {
        return parseInt(v, 10);
      }).reduce((sum, v) => {
        return sum + v;
      });
    }
    return this._cachedViewportTotalPaddingBottom;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "listbox");
    this.id = `${this.localName}-${generateUniqueId()}`;
    this.__hostTagName = this.constructor.is.replace("-scroller", "");
    this.addEventListener("click", (e2) => e2.stopPropagation());
    this.__patchWheelOverScrolling();
  }
  /**
   * Updates the virtualizer's size and items.
   */
  requestContentUpdate() {
    if (!this.__virtualizer) {
      return;
    }
    if (this.items) {
      this.__virtualizer.size = this.items.length;
    }
    if (this.opened) {
      this.__virtualizer.update();
    }
  }
  /**
   * Scrolls an item at given index into view and adjusts `scrollTop`
   * so that the element gets fully visible on Arrow Down key press.
   * @param {number} index
   */
  scrollIntoView(index) {
    if (!this.__virtualizer || !(this.opened && index >= 0)) {
      return;
    }
    const visibleItemsCount = this._visibleItemsCount();
    let targetIndex = index;
    if (index > this.__virtualizer.lastVisibleIndex - 1) {
      this.__virtualizer.scrollToIndex(index);
      targetIndex = index - visibleItemsCount + 1;
    } else if (index > this.__virtualizer.firstVisibleIndex) {
      targetIndex = this.__virtualizer.firstVisibleIndex;
    }
    this.__virtualizer.scrollToIndex(Math.max(0, targetIndex));
    const lastPhysicalItem = [...this.children].find(
      (el) => !el.hidden && el.index === this.__virtualizer.lastVisibleIndex
    );
    if (!lastPhysicalItem || index !== lastPhysicalItem.index) {
      return;
    }
    const lastPhysicalItemRect = lastPhysicalItem.getBoundingClientRect();
    const scrollerRect = this.getBoundingClientRect();
    const scrollTopAdjust = lastPhysicalItemRect.bottom - scrollerRect.bottom + this._viewportTotalPaddingBottom;
    if (scrollTopAdjust > 0) {
      this.scrollTop += scrollTopAdjust;
    }
  }
  /**
   * @param {string | object} item
   * @param {string | object} selectedItem
   * @param {string} itemIdPath
   * @protected
   */
  _isItemSelected(item2, selectedItem, itemIdPath) {
    if (item2 instanceof ComboBoxPlaceholder) {
      return false;
    } else if (itemIdPath && item2 !== void 0 && selectedItem !== void 0) {
      return get$1(itemIdPath, item2) === get$1(itemIdPath, selectedItem);
    }
    return item2 === selectedItem;
  }
  /** @private */
  __initVirtualizer() {
    this.__virtualizer = new Virtualizer({
      createElements: this.__createElements.bind(this),
      updateElement: this._updateElement.bind(this),
      elementsContainer: this,
      scrollTarget: this,
      scrollContainer: this.$.selector,
      reorderElements: true
    });
  }
  /** @private */
  __itemsChanged(items) {
    if (items && this.__virtualizer) {
      this.requestContentUpdate();
    }
  }
  /** @private */
  __loadingChanged() {
    this.requestContentUpdate();
  }
  /** @private */
  __openedChanged(opened) {
    if (opened) {
      if (!this.__virtualizer) {
        this.__initVirtualizer();
      }
      this.requestContentUpdate();
    }
  }
  /** @private */
  __selectedItemChanged() {
    this.requestContentUpdate();
  }
  /** @private */
  __itemClassNameGeneratorChanged(generator, oldGenerator) {
    if (generator || oldGenerator) {
      this.requestContentUpdate();
    }
  }
  /** @private */
  __focusedIndexChanged(index, oldIndex) {
    if (index !== oldIndex) {
      this.requestContentUpdate();
    }
    if (index >= 0 && !this.loading) {
      this.scrollIntoView(index);
    }
  }
  /** @private */
  __rendererChanged(renderer, oldRenderer) {
    if (renderer || oldRenderer) {
      this.requestContentUpdate();
    }
  }
  /** @private */
  __createElements(count) {
    return [...Array(count)].map(() => {
      const item2 = document.createElement(`${this.__hostTagName}-item`);
      item2.addEventListener("click", this.__boundOnItemClick);
      item2.tabIndex = "-1";
      item2.style.width = "100%";
      return item2;
    });
  }
  /**
   * @param {HTMLElement} el
   * @param {number} index
   * @protected
   */
  _updateElement(el, index) {
    const item2 = this.items[index];
    const focusedIndex = this.focusedIndex;
    const selected = this._isItemSelected(item2, this.selectedItem, this.itemIdPath);
    el.setProperties({
      item: item2,
      index,
      label: this.getItemLabel(item2),
      selected,
      renderer: this.renderer,
      focused: !this.loading && focusedIndex === index
    });
    if (typeof this.itemClassNameGenerator === "function") {
      el.className = this.itemClassNameGenerator(item2);
    } else if (el.className !== "") {
      el.className = "";
    }
    if (el.performUpdate && !el.hasUpdated) {
      el.performUpdate();
    }
    el.id = `${this.__hostTagName}-item-${index}`;
    el.setAttribute("role", index !== void 0 ? "option" : false);
    el.setAttribute("aria-selected", selected.toString());
    el.setAttribute("aria-posinset", index + 1);
    el.setAttribute("aria-setsize", this.items.length);
    if (this.theme) {
      el.setAttribute("theme", this.theme);
    } else {
      el.removeAttribute("theme");
    }
    if (item2 instanceof ComboBoxPlaceholder) {
      this.__requestItemByIndex(index);
    }
  }
  /** @private */
  __onItemClick(e2) {
    this.dispatchEvent(new CustomEvent("selection-changed", { detail: { item: e2.currentTarget.item } }));
  }
  /**
   * We want to prevent the kinetic scrolling energy from being transferred from the overlay contents over to the parent.
   * Further improvement ideas: after the contents have been scrolled to the top or bottom and scrolling has stopped, it could allow
   * scrolling the parent similarly to touch scrolling.
   * @private
   */
  __patchWheelOverScrolling() {
    this.$.selector.addEventListener("wheel", (e2) => {
      const scrolledToTop = this.scrollTop === 0;
      const scrolledToBottom = this.scrollHeight - this.scrollTop - this.clientHeight <= 1;
      if (scrolledToTop && e2.deltaY < 0) {
        e2.preventDefault();
      } else if (scrolledToBottom && e2.deltaY > 0) {
        e2.preventDefault();
      }
    });
  }
  /**
   * Dispatches an `index-requested` event for the given index to notify
   * the data provider that it should start loading the page containing the requested index.
   *
   * The event is dispatched asynchronously to prevent an immediate page request and therefore
   * a possible infinite recursion in case the data provider implements page request cancelation logic
   * by invoking data provider page callbacks with an empty array.
   * The infinite recursion may occur otherwise since invoking a data provider page callback with an empty array
   * triggers a synchronous scroller update and, if the callback corresponds to the currently visible page,
   * the scroller will synchronously request the page again which may lead to looping in the end.
   * That was the case for the Flow counterpart:
   * https://github.com/vaadin/flow-components/issues/3553#issuecomment-1239344828
   * @private
   */
  __requestItemByIndex(index) {
    requestAnimationFrame(() => {
      this.dispatchEvent(
        new CustomEvent("index-requested", {
          detail: {
            index
          }
        })
      );
    });
  }
  /** @private */
  _visibleItemsCount() {
    this.__virtualizer.scrollToIndex(this.__virtualizer.firstVisibleIndex);
    const hasItems = this.__virtualizer.size > 0;
    return hasItems ? this.__virtualizer.lastVisibleIndex - this.__virtualizer.firstVisibleIndex + 1 : 0;
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ComboBoxScroller extends ComboBoxScrollerMixin(PolymerElement) {
  static get is() {
    return "vaadin-combo-box-scroller";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          min-height: 1px;
          overflow: auto;

          /* Fixes item background from getting on top of scrollbars on Safari */
          transform: translate3d(0, 0, 0);

          /* Enable momentum scrolling on iOS */
          -webkit-overflow-scrolling: touch;

          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */
          box-shadow: 0 0 0 white;
        }

        #selector {
          border-width: var(--_vaadin-combo-box-items-container-border-width);
          border-style: var(--_vaadin-combo-box-items-container-border-style);
          border-color: var(--_vaadin-combo-box-items-container-border-color, transparent);
          position: relative;
        }
      </style>
      <div id="selector">
        <slot></slot>
      </div>
    `;
  }
}
defineCustomElement(ComboBoxScroller);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const stylesMap = /* @__PURE__ */ new WeakMap();
function getRootStyles(root2) {
  if (!stylesMap.has(root2)) {
    stylesMap.set(root2, /* @__PURE__ */ new Set());
  }
  return stylesMap.get(root2);
}
function insertStyles(styles2, root2) {
  const style = document.createElement("style");
  style.textContent = styles2;
  if (root2 === document) {
    document.head.appendChild(style);
  } else {
    root2.insertBefore(style, root2.firstChild);
  }
}
const SlotStylesMixin = dedupingMixin(
  (superclass) => class SlotStylesMixinClass extends superclass {
    /**
     * List of styles to insert into root.
     * @protected
     */
    get slotStyles() {
      return {};
    }
    /** @protected */
    connectedCallback() {
      super.connectedCallback();
      this.__applySlotStyles();
    }
    /** @private */
    __applySlotStyles() {
      const root2 = this.getRootNode();
      const rootStyles = getRootStyles(root2);
      this.slotStyles.forEach((styles2) => {
        if (!rootStyles.has(styles2)) {
          insertStyles(styles2, root2);
          rootStyles.add(styles2);
        }
      });
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ClearButtonMixin = (superclass) => class ClearButtonMixinClass extends InputMixin(KeyboardMixin(superclass)) {
  static get properties() {
    return {
      /**
       * Set to true to display the clear icon which clears the input.
       *
       * It is up to the component to choose where to place the clear icon:
       * in the Shadow DOM or in the light DOM. In any way, a reference to
       * the clear icon element should be provided via the `clearElement` getter.
       *
       * @attr {boolean} clear-button-visible
       */
      clearButtonVisible: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      }
    };
  }
  /**
   * Any element extending this mixin is required to implement this getter.
   * It returns the reference to the clear button element.
   *
   * @protected
   * @return {Element | null | undefined}
   */
  get clearElement() {
    console.warn(`Please implement the 'clearElement' property in <${this.localName}>`);
    return null;
  }
  /** @protected */
  ready() {
    super.ready();
    if (this.clearElement) {
      this.clearElement.addEventListener("mousedown", (event) => this._onClearButtonMouseDown(event));
      this.clearElement.addEventListener("click", (event) => this._onClearButtonClick(event));
    }
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onClearButtonClick(event) {
    event.preventDefault();
    this._onClearAction();
  }
  /**
   * @param {MouseEvent} event
   * @protected
   */
  _onClearButtonMouseDown(event) {
    event.preventDefault();
    if (!isTouch) {
      this.inputElement.focus();
    }
  }
  /**
   * Override an event listener inherited from `KeydownMixin` to clear on Esc.
   * Components that extend this mixin can prevent this behavior by overriding
   * this method without calling `super._onEscape` to provide custom logic.
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(event) {
    super._onEscape(event);
    if (this.clearButtonVisible && !!this.value && !this.readonly) {
      event.stopPropagation();
      this._onClearAction();
    }
  }
  /**
   * Clears the value and dispatches `input` and `change` events
   * on the input element. This method should be called
   * when the clear action originates from the user.
   *
   * @protected
   */
  _onClearAction() {
    this._inputElementValue = "";
    this.inputElement.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
    this.inputElement.dispatchEvent(new Event("change", { bubbles: true }));
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const InputConstraintsMixin = dedupingMixin(
  (superclass) => class InputConstraintsMixinClass extends DelegateStateMixin(ValidateMixin(InputMixin(superclass))) {
    /**
     * An array of attributes which participate in the input validation.
     * Changing these attributes will cause the input to re-validate.
     *
     * IMPORTANT: The attributes should be properly delegated to the input element
     * from the host using `delegateAttrs` getter (see `DelegateStateMixin`).
     * The `required` attribute is already delegated.
     */
    static get constraints() {
      return ["required"];
    }
    static get delegateAttrs() {
      return [...super.delegateAttrs, "required"];
    }
    /** @protected */
    ready() {
      super.ready();
      this._createConstraintsObserver();
    }
    /**
     * Returns true if the current input value satisfies all constraints (if any).
     * @return {boolean}
     */
    checkValidity() {
      if (this.inputElement && this._hasValidConstraints(this.constructor.constraints.map((c2) => this[c2]))) {
        return this.inputElement.checkValidity();
      }
      return !this.invalid;
    }
    /**
     * Returns true if some of the provided set of constraints are valid.
     * @param {Array} constraints
     * @return {boolean}
     * @protected
     */
    _hasValidConstraints(constraints) {
      return constraints.some((c2) => this.__isValidConstraint(c2));
    }
    /**
     * Override this method to customize setting up constraints observer.
     * @protected
     */
    _createConstraintsObserver() {
      this._createMethodObserver(`_constraintsChanged(stateTarget, ${this.constructor.constraints.join(", ")})`);
    }
    /**
     * Override this method to implement custom validation constraints.
     * @param {HTMLElement | undefined} stateTarget
     * @param {unknown[]} constraints
     * @protected
     */
    _constraintsChanged(stateTarget, ...constraints) {
      if (!stateTarget) {
        return;
      }
      const hasConstraints = this._hasValidConstraints(constraints);
      const isLastConstraintRemoved = this.__previousHasConstraints && !hasConstraints;
      if ((this._hasValue || this.invalid) && hasConstraints) {
        this._requestValidation();
      } else if (isLastConstraintRemoved && !this.manualValidation) {
        this._setInvalid(false);
      }
      this.__previousHasConstraints = hasConstraints;
    }
    /**
     * Override an event listener inherited from `InputMixin`
     * to capture native `change` event and make sure that
     * a new one is dispatched after validation runs.
     * @param {Event} event
     * @protected
     * @override
     */
    _onChange(event) {
      event.stopPropagation();
      this._requestValidation();
      this.dispatchEvent(
        new CustomEvent("change", {
          detail: {
            sourceEvent: event
          },
          bubbles: event.bubbles,
          cancelable: event.cancelable
        })
      );
    }
    /** @private */
    __isValidConstraint(constraint) {
      return Boolean(constraint) || constraint === 0;
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const InputControlMixin = (superclass) => class InputControlMixinClass extends SlotStylesMixin(
  DelegateFocusMixin(InputConstraintsMixin(FieldMixin(ClearButtonMixin(KeyboardMixin(superclass)))))
) {
  static get properties() {
    return {
      /**
       * A pattern matched against individual characters the user inputs.
       *
       * When set, the field will prevent:
       * - `keydown` events if the entered key doesn't match `/^allowedCharPattern$/`
       * - `paste` events if the pasted text doesn't match `/^allowedCharPattern*$/`
       * - `drop` events if the dropped text doesn't match `/^allowedCharPattern*$/`
       *
       * For example, to allow entering only numbers and minus signs, use:
       * `allowedCharPattern = "[\\d-]"`
       * @attr {string} allowed-char-pattern
       */
      allowedCharPattern: {
        type: String,
        observer: "_allowedCharPatternChanged"
      },
      /**
       * If true, the input text gets fully selected when the field is focused using click or touch / tap.
       */
      autoselect: {
        type: Boolean,
        value: false
      },
      /**
       * The name of this field.
       */
      name: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * A hint to the user of what can be entered in the field.
       */
      placeholder: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * When present, it specifies that the field is read-only.
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * The text usually displayed in a tooltip popup when the mouse is over the field.
       */
      title: {
        type: String,
        reflectToAttribute: true
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "name", "type", "placeholder", "readonly", "invalid", "title"];
  }
  constructor() {
    super();
    this._boundOnPaste = this._onPaste.bind(this);
    this._boundOnDrop = this._onDrop.bind(this);
    this._boundOnBeforeInput = this._onBeforeInput.bind(this);
  }
  /** @protected */
  get slotStyles() {
    return [
      `
          :is(input[slot='input'], textarea[slot='textarea'])::placeholder {
            font: inherit;
            color: inherit;
          }
        `
    ];
  }
  /**
   * Override an event listener from `DelegateFocusMixin`.
   * @param {FocusEvent} event
   * @protected
   * @override
   */
  _onFocus(event) {
    super._onFocus(event);
    if (this.autoselect && this.inputElement) {
      this.inputElement.select();
    }
  }
  /**
   * Override a method from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _addInputListeners(input) {
    super._addInputListeners(input);
    input.addEventListener("paste", this._boundOnPaste);
    input.addEventListener("drop", this._boundOnDrop);
    input.addEventListener("beforeinput", this._boundOnBeforeInput);
  }
  /**
   * Override a method from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _removeInputListeners(input) {
    super._removeInputListeners(input);
    input.removeEventListener("paste", this._boundOnPaste);
    input.removeEventListener("drop", this._boundOnDrop);
    input.removeEventListener("beforeinput", this._boundOnBeforeInput);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    if (this.allowedCharPattern && !this.__shouldAcceptKey(event) && event.target === this.inputElement) {
      event.preventDefault();
      this._markInputPrevented();
    }
  }
  /** @protected */
  _markInputPrevented() {
    this.setAttribute("input-prevented", "");
    this._preventInputDebouncer = Debouncer$1.debounce(this._preventInputDebouncer, timeOut.after(200), () => {
      this.removeAttribute("input-prevented");
    });
  }
  /** @private */
  __shouldAcceptKey(event) {
    return event.metaKey || event.ctrlKey || !event.key || // Allow typing anything if event.key is not supported
    event.key.length !== 1 || // Allow "Backspace", "ArrowLeft" etc.
    this.__allowedCharRegExp.test(event.key);
  }
  /** @private */
  _onPaste(e2) {
    if (this.allowedCharPattern) {
      const pastedText = e2.clipboardData.getData("text");
      if (!this.__allowedTextRegExp.test(pastedText)) {
        e2.preventDefault();
        this._markInputPrevented();
      }
    }
  }
  /** @private */
  _onDrop(e2) {
    if (this.allowedCharPattern) {
      const draggedText = e2.dataTransfer.getData("text");
      if (!this.__allowedTextRegExp.test(draggedText)) {
        e2.preventDefault();
        this._markInputPrevented();
      }
    }
  }
  /** @private */
  _onBeforeInput(e2) {
    if (this.allowedCharPattern && e2.data && !this.__allowedTextRegExp.test(e2.data)) {
      e2.preventDefault();
      this._markInputPrevented();
    }
  }
  /** @private */
  _allowedCharPatternChanged(charPattern) {
    if (charPattern) {
      try {
        this.__allowedCharRegExp = new RegExp(`^${charPattern}$`, "u");
        this.__allowedTextRegExp = new RegExp(`^${charPattern}*$`, "u");
      } catch (e2) {
        console.error(e2);
      }
    }
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
  /**
   * Fired when the value is changed by the user: on every typing keystroke,
   * and the value is cleared using the clear button.
   *
   * @event input
   */
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const PatternMixin = (superclass) => class PatternMixinClass extends InputConstraintsMixin(superclass) {
  static get properties() {
    return {
      /**
       * A regular expression that the value is checked against.
       * The pattern must match the entire value, not just some subset.
       */
      pattern: {
        type: String
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "pattern"];
  }
  static get constraints() {
    return [...super.constraints, "pattern"];
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const clearButton = css`
  [part='clear-button'] {
    display: none;
    cursor: default;
  }

  [part='clear-button']::before {
    content: '\\2715';
  }

  :host([clear-button-visible][has-value]:not([disabled]):not([readonly])) [part='clear-button'] {
    display: block;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const fieldShared = css`
  :host {
    display: inline-flex;
    outline: none;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
    /* Size and position this element on the same vertical position as the input-field element
          to make vertical align for the host element work as expected */
  }

  :host([hidden]) {
    display: none !important;
  }

  :host(:not([has-label])) [part='label'] {
    display: none;
  }

  @media (forced-colors: active) {
    :host(:not([readonly])) [part='input-field'] {
      outline: 1px solid;
      outline-offset: -1px;
    }
    :host([focused]) [part='input-field'] {
      outline-width: 2px;
    }
    :host([disabled]) [part='input-field'] {
      outline-color: GrayText;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const inputFieldContainer = css`
  [class$='container'] {
    display: flex;
    flex-direction: column;
    min-width: 100%;
    max-width: 100%;
    width: var(--vaadin-field-default-width, 12em);
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const inputFieldShared = [fieldShared, inputFieldContainer, clearButton];
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function getFlatIndexContext(cache, flatIndex, level = 0) {
  let levelIndex = flatIndex;
  for (const subCache of cache.subCaches) {
    const index = subCache.parentCacheIndex;
    if (levelIndex <= index) {
      break;
    } else if (levelIndex <= index + subCache.flatSize) {
      return getFlatIndexContext(subCache, levelIndex - index - 1, level + 1);
    }
    levelIndex -= subCache.flatSize;
  }
  return {
    cache,
    item: cache.items[levelIndex],
    index: levelIndex,
    page: Math.floor(levelIndex / cache.pageSize),
    level
  };
}
function getItemContext({ getItemId }, cache, targetItem, level = 0, levelFlatIndex = 0) {
  for (let index = 0; index < cache.items.length; index++) {
    const item2 = cache.items[index];
    if (!!item2 && getItemId(item2) === getItemId(targetItem)) {
      return {
        cache,
        level,
        item: item2,
        index,
        page: Math.floor(index / cache.pageSize),
        subCache: cache.getSubCache(index),
        flatIndex: levelFlatIndex + cache.getFlatIndex(index)
      };
    }
  }
  for (const subCache of cache.subCaches) {
    const parentItemFlatIndex = levelFlatIndex + cache.getFlatIndex(subCache.parentCacheIndex);
    const result = getItemContext({ getItemId }, subCache, targetItem, level + 1, parentItemFlatIndex + 1);
    if (result) {
      return result;
    }
  }
}
function getFlatIndexByPath(cache, [levelIndex, ...subIndexes], flatIndex = 0) {
  if (levelIndex === Infinity) {
    levelIndex = cache.size - 1;
  }
  const flatIndexOnLevel = cache.getFlatIndex(levelIndex);
  const subCache = cache.getSubCache(levelIndex);
  if (subCache && subCache.flatSize > 0 && subIndexes.length) {
    return getFlatIndexByPath(subCache, subIndexes, flatIndex + flatIndexOnLevel + 1);
  }
  return flatIndex + flatIndexOnLevel;
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Cache {
  /**
   * @param {Cache['context']} context
   * @param {number} pageSize
   * @param {number | undefined} size
   * @param {Cache | undefined} parentCache
   * @param {number | undefined} parentCacheIndex
   */
  constructor(context, pageSize, size, parentCache, parentCacheIndex) {
    /**
     * A context object.
     *
     * @type {{ isExpanded: (item: unknown) => boolean }}
     */
    __publicField(this, "context");
    /**
     * The number of items to display per page.
     *
     * @type {number}
     */
    __publicField(this, "pageSize");
    /**
     * An array of cached items.
     *
     * @type {object[]}
     */
    __publicField(this, "items", []);
    /**
     * A map where the key is a requested page and the value is a callback
     * that will be called with data once the request is complete.
     *
     * @type {Record<number, Function>}
     */
    __publicField(this, "pendingRequests", {});
    /**
     * A map where the key is the index of an item in the `items` array
     * and the value is a sub-cache associated with that item.
     *
     * Note, it's intentionally defined as an object instead of a Map
     * to ensure that Object.entries() returns an array with keys sorted
     * in alphabetical order, rather than the order they were added.
     *
     * @type {Record<number, Cache>}
     * @private
     */
    __publicField(this, "__subCacheByIndex", {});
    /**
     * The number of items.
     *
     * @type {number}
     * @private
     */
    __publicField(this, "__size", 0);
    /**
     * The total number of items, including items from expanded sub-caches.
     *
     * @type {number}
     * @private
     */
    __publicField(this, "__flatSize", 0);
    this.context = context;
    this.pageSize = pageSize;
    this.size = size;
    this.parentCache = parentCache;
    this.parentCacheIndex = parentCacheIndex;
    this.__flatSize = size || 0;
  }
  /**
   * An item in the parent cache that the current cache is associated with.
   *
   * @return {object | undefined}
   */
  get parentItem() {
    return this.parentCache && this.parentCache.items[this.parentCacheIndex];
  }
  /**
   * An array of sub-caches sorted in the same order as their associated items
   * appear in the `items` array.
   *
   * @return {Cache[]}
   */
  get subCaches() {
    return Object.values(this.__subCacheByIndex);
  }
  /**
   * Whether the cache or any of its descendant caches have pending requests.
   *
   * @return {boolean}
   */
  get isLoading() {
    if (Object.keys(this.pendingRequests).length > 0) {
      return true;
    }
    return this.subCaches.some((subCache) => subCache.isLoading);
  }
  /**
   * The total number of items, including items from expanded sub-caches.
   *
   * @return {number}
   */
  get flatSize() {
    return this.__flatSize;
  }
  /**
   * The total number of items, including items from expanded sub-caches.
   *
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get effectiveSize() {
    console.warn(
      "<vaadin-grid> The `effectiveSize` property of ItemCache is deprecated and will be removed in Vaadin 25."
    );
    return this.flatSize;
  }
  /**
   * The number of items.
   *
   * @return {number}
   */
  get size() {
    return this.__size;
  }
  /**
   * Sets the number of items.
   *
   * @param {number} size
   */
  set size(size) {
    var _a2;
    const oldSize = this.__size;
    if (oldSize === size) {
      return;
    }
    this.__size = size;
    if (this.context.placeholder !== void 0) {
      this.items.length = size || 0;
      for (let i2 = 0; i2 < size || 0; i2++) {
        (_a2 = this.items)[i2] || (_a2[i2] = this.context.placeholder);
      }
    }
    Object.keys(this.pendingRequests).forEach((page) => {
      const startIndex = parseInt(page) * this.pageSize;
      if (startIndex >= this.size || 0) {
        delete this.pendingRequests[page];
      }
    });
  }
  /**
   * Recalculates the flattened size for the cache and its descendant caches recursively.
   */
  recalculateFlatSize() {
    this.__flatSize = !this.parentItem || this.context.isExpanded(this.parentItem) ? this.size + this.subCaches.reduce((total, subCache) => {
      subCache.recalculateFlatSize();
      return total + subCache.flatSize;
    }, 0) : 0;
  }
  /**
   * Adds an array of items corresponding to the given page
   * to the `items` array.
   *
   * @param {number} page
   * @param {object[]} items
   */
  setPage(page, items) {
    const startIndex = page * this.pageSize;
    items.forEach((item2, i2) => {
      const itemIndex = startIndex + i2;
      if (this.size === void 0 || itemIndex < this.size) {
        this.items[itemIndex] = item2;
      }
    });
  }
  /**
   * Retrieves the sub-cache associated with the item at the given index
   * in the `items` array.
   *
   * @param {number} index
   * @return {Cache | undefined}
   */
  getSubCache(index) {
    return this.__subCacheByIndex[index];
  }
  /**
   * Removes the sub-cache associated with the item at the given index
   * in the `items` array.
   *
   * @param {number} index
   */
  removeSubCache(index) {
    delete this.__subCacheByIndex[index];
  }
  /**
   * Removes all sub-caches.
   */
  removeSubCaches() {
    this.__subCacheByIndex = {};
  }
  /**
   * Creates and associates a sub-cache for the item at the given index
   * in the `items` array.
   *
   * @param {number} index
   * @return {Cache}
   */
  createSubCache(index) {
    const subCache = new Cache(this.context, this.pageSize, 0, this, index);
    this.__subCacheByIndex[index] = subCache;
    return subCache;
  }
  /**
   * Retrieves the flattened index corresponding to the given index
   * of an item in the `items` array.
   *
   * @param {number} index
   * @return {number}
   */
  getFlatIndex(index) {
    const clampedIndex = Math.max(0, Math.min(this.size - 1, index));
    return this.subCaches.reduce((prev, subCache) => {
      const index2 = subCache.parentCacheIndex;
      return clampedIndex > index2 ? prev + subCache.flatSize : prev;
    }, clampedIndex);
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  getItemForIndex(index) {
    console.warn(
      "<vaadin-grid> The `getItemForIndex` method of ItemCache is deprecated and will be removed in Vaadin 25."
    );
    const { item: item2 } = getFlatIndexContext(this, index);
    return item2;
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  getCacheAndIndex(index) {
    console.warn(
      "<vaadin-grid> The `getCacheAndIndex` method of ItemCache is deprecated and will be removed in Vaadin 25."
    );
    const { cache, index: scaledIndex } = getFlatIndexContext(this, index);
    return { cache, scaledIndex };
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  updateSize() {
    console.warn("<vaadin-grid> The `updateSize` method of ItemCache is deprecated and will be removed in Vaadin 25.");
    this.recalculateFlatSize();
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  ensureSubCacheForScaledIndex(scaledIndex) {
    console.warn(
      "<vaadin-grid> The `ensureSubCacheForScaledIndex` method of ItemCache is deprecated and will be removed in Vaadin 25."
    );
    if (!this.getSubCache(scaledIndex)) {
      const subCache = this.createSubCache(scaledIndex);
      this.context.__controller.__loadCachePage(subCache, 0);
    }
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get grid() {
    console.warn("<vaadin-grid> The `grid` property of ItemCache is deprecated and will be removed in Vaadin 25.");
    return this.context.__controller.host;
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get itemCaches() {
    console.warn(
      "<vaadin-grid> The `itemCaches` property of ItemCache is deprecated and will be removed in Vaadin 25."
    );
    return this.__subCacheByIndex;
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class DataProviderController extends EventTarget {
  constructor(host, { size, pageSize, isExpanded, getItemId, isPlaceholder, placeholder, dataProvider, dataProviderParams }) {
    super();
    /**
     * The controller host element.
     *
     * @param {HTMLElement}
     */
    __publicField(this, "host");
    /**
     * A callback that returns data based on the passed params such as
     * `page`, `pageSize`, `parentItem`, etc.
     */
    __publicField(this, "dataProvider");
    /**
     * A callback that returns additional params that need to be passed
     * to the data provider callback with every request.
     */
    __publicField(this, "dataProviderParams");
    /**
     * A number of items to display per page.
     *
     * @type {number}
     */
    __publicField(this, "pageSize");
    /**
     * A callback that returns whether the given item is expanded.
     *
     * @type {(item: unknown) => boolean}
     */
    __publicField(this, "isExpanded");
    /**
     * A callback that returns the id for the given item and that
     * is used when checking object items for equality.
     *
     * @type { (item: unknown) => unknown}
     */
    __publicField(this, "getItemId");
    /**
     * A reference to the root cache instance.
     *
     * @param {Cache}
     */
    __publicField(this, "rootCache");
    /**
     * A placeholder item that is used to indicate that the item is not loaded yet.
     *
     * @type {unknown}
     */
    __publicField(this, "placeholder");
    /**
     * A callback that returns whether the given item is a placeholder.
     *
     * @type {(item: unknown) => boolean}
     */
    __publicField(this, "isPlaceholder");
    this.host = host;
    this.pageSize = pageSize;
    this.getItemId = getItemId;
    this.isExpanded = isExpanded;
    this.placeholder = placeholder;
    this.isPlaceholder = isPlaceholder;
    this.dataProvider = dataProvider;
    this.dataProviderParams = dataProviderParams;
    this.rootCache = this.__createRootCache(size);
  }
  /**
   * The total number of items, including items from expanded sub-caches.
   */
  get flatSize() {
    return this.rootCache.flatSize;
  }
  /** @private */
  get __cacheContext() {
    return {
      isExpanded: this.isExpanded,
      placeholder: this.placeholder,
      // The controller instance is needed to ensure deprecated cache methods work.
      __controller: this
    };
  }
  /**
   * Whether the root cache or any of its decendant caches have pending requests.
   *
   * @return {boolean}
   */
  isLoading() {
    return this.rootCache.isLoading;
  }
  /**
   * Sets the page size and clears the cache.
   *
   * @param {number} pageSize
   */
  setPageSize(pageSize) {
    this.pageSize = pageSize;
    this.clearCache();
  }
  /**
   * Sets the data provider callback and clears the cache.
   *
   * @type {Function}
   */
  setDataProvider(dataProvider) {
    this.dataProvider = dataProvider;
    this.clearCache();
  }
  /**
   * Recalculates the flattened size.
   */
  recalculateFlatSize() {
    this.rootCache.recalculateFlatSize();
  }
  /**
   * Clears the cache.
   */
  clearCache() {
    this.rootCache = this.__createRootCache(this.rootCache.size);
  }
  /**
   * Returns context for the given flattened index, including:
   * - the corresponding cache
   * - the cache level
   * - the corresponding item (if loaded)
   * - the item's index in the cache's items array
   * - the page containing the item
   *
   * @param {number} flatIndex
   */
  getFlatIndexContext(flatIndex) {
    return getFlatIndexContext(this.rootCache, flatIndex);
  }
  /**
   * Returns context for the given item, including:
   * - the cache containing the item
   * - the cache level
   * - the item
   * - the item's index in the cache's items array
   * - the item's flattened index
   * - the item's sub-cache (if exists)
   * - the page containing the item
   *
   * If the item isn't found, the method returns undefined.
   */
  getItemContext(item2) {
    return getItemContext({ getItemId: this.getItemId }, this.rootCache, item2);
  }
  /**
   * Returns the flattened index for the item that the given indexes point to.
   * Each index in the path array points to a sub-item of the previous index.
   * Using `Infinity` as an index will point to the last item on the level.
   *
   * @param {number[]} path
   * @return {number}
   */
  getFlatIndexByPath(path) {
    return getFlatIndexByPath(this.rootCache, path);
  }
  /**
   * Requests the data provider to load the page with the item corresponding
   * to the given flattened index. If the item is already loaded, the method
   * returns immediatelly.
   *
   * @param {number} flatIndex
   */
  ensureFlatIndexLoaded(flatIndex) {
    const { cache, page, item: item2 } = this.getFlatIndexContext(flatIndex);
    if (!this.__isItemLoaded(item2)) {
      this.__loadCachePage(cache, page);
    }
  }
  /**
   * Creates a sub-cache for the item corresponding to the given flattened index and
   * requests the data provider to load the first page into the created sub-cache.
   * If the sub-cache already exists, the method returns immediatelly.
   *
   * @param {number} flatIndex
   */
  ensureFlatIndexHierarchy(flatIndex) {
    const { cache, item: item2, index } = this.getFlatIndexContext(flatIndex);
    if (this.__isItemLoaded(item2) && this.isExpanded(item2) && !cache.getSubCache(index)) {
      const subCache = cache.createSubCache(index);
      this.__loadCachePage(subCache, 0);
    }
  }
  /**
   * Loads the first page into the root cache.
   */
  loadFirstPage() {
    this.__loadCachePage(this.rootCache, 0);
  }
  /** @private */
  __createRootCache(size) {
    return new Cache(this.__cacheContext, this.pageSize, size);
  }
  /** @private */
  __loadCachePage(cache, page) {
    if (!this.dataProvider || cache.pendingRequests[page]) {
      return;
    }
    let params = {
      page,
      pageSize: this.pageSize,
      parentItem: cache.parentItem
    };
    if (this.dataProviderParams) {
      params = { ...params, ...this.dataProviderParams() };
    }
    const callback = (items, size) => {
      if (cache.pendingRequests[page] !== callback) {
        return;
      }
      if (size !== void 0) {
        cache.size = size;
      } else if (params.parentItem) {
        cache.size = items.length;
      }
      cache.setPage(page, items);
      this.recalculateFlatSize();
      this.dispatchEvent(new CustomEvent("page-received"));
      delete cache.pendingRequests[page];
      this.dispatchEvent(new CustomEvent("page-loaded"));
    };
    cache.pendingRequests[page] = callback;
    this.dispatchEvent(new CustomEvent("page-requested"));
    this.dataProvider(params, callback);
  }
  /** @private */
  __isItemLoaded(item2) {
    if (this.isPlaceholder) {
      return !this.isPlaceholder(item2);
    } else if (this.placeholder) {
      return item2 !== this.placeholder;
    }
    return !!item2;
  }
}
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ComboBoxDataProviderMixin = (superClass) => class DataProviderMixin extends superClass {
  static get properties() {
    return {
      /**
       * Number of items fetched at a time from the dataprovider.
       * @attr {number} page-size
       * @type {number}
       */
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged",
        sync: true
      },
      /**
       * Total number of items.
       * @type {number | undefined}
       */
      size: {
        type: Number,
        observer: "_sizeChanged",
        sync: true
      },
      /**
       * Function that provides items lazily. Receives arguments `params`, `callback`
       *
       * `params.page` Requested page index
       *
       * `params.pageSize` Current page size
       *
       * `params.filter` Currently applied filter
       *
       * `callback(items, size)` Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items.
       * @type {ComboBoxDataProvider | undefined}
       */
      dataProvider: {
        type: Object,
        observer: "_dataProviderChanged",
        sync: true
      },
      /** @private */
      __dataProviderInitialized: {
        type: Boolean,
        value: false
      },
      /** @private */
      __previousDataProviderFilter: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "_dataProviderFilterChanged(filter)",
      "_warnDataProviderValue(dataProvider, value)",
      "_ensureFirstPage(opened)"
    ];
  }
  constructor() {
    super();
    this.__dataProviderController = new DataProviderController(this, {
      placeholder: new ComboBoxPlaceholder(),
      isPlaceholder: (item2) => item2 instanceof ComboBoxPlaceholder,
      dataProviderParams: () => ({ filter: this.filter })
    });
    this.__dataProviderController.addEventListener("page-requested", this.__onDataProviderPageRequested.bind(this));
    this.__dataProviderController.addEventListener("page-loaded", this.__onDataProviderPageLoaded.bind(this));
  }
  /** @protected */
  ready() {
    super.ready();
    this._scroller.addEventListener("index-requested", (e2) => {
      if (!this._shouldFetchData()) {
        return;
      }
      const index = e2.detail.index;
      if (index !== void 0) {
        this.__dataProviderController.ensureFlatIndexLoaded(index);
      }
    });
    this.__dataProviderInitialized = true;
    if (this.dataProvider) {
      this.__synchronizeControllerState();
    }
  }
  /** @private */
  _dataProviderFilterChanged(filter2) {
    if (this.__previousDataProviderFilter === void 0 && filter2 === "") {
      this.__previousDataProviderFilter = filter2;
      return;
    }
    if (this.__previousDataProviderFilter !== filter2) {
      this.__previousDataProviderFilter = filter2;
      this.__keepOverlayOpened = true;
      this.size = void 0;
      this.clearCache();
      this.__keepOverlayOpened = false;
    }
  }
  /** @protected */
  _shouldFetchData() {
    if (!this.dataProvider) {
      return false;
    }
    return this.opened || this.filter && this.filter.length;
  }
  /** @private */
  _ensureFirstPage(opened) {
    if (!this._shouldFetchData() || !opened) {
      return;
    }
    if (this._forceNextRequest || this.size === void 0) {
      this._forceNextRequest = false;
      this.__dataProviderController.loadFirstPage();
    } else if (this.size > 0) {
      this.__dataProviderController.ensureFlatIndexLoaded(0);
    }
  }
  /** @private */
  __onDataProviderPageRequested() {
    this.loading = true;
  }
  /** @private */
  __onDataProviderPageLoaded() {
    const { rootCache } = this.__dataProviderController;
    rootCache.items = [...rootCache.items];
    this.__synchronizeControllerState();
    if (!this.opened && !this._isInputFocused()) {
      this._commitValue();
    }
  }
  /**
   * Clears the cached pages and reloads data from dataprovider when needed.
   */
  clearCache() {
    if (!this.dataProvider) {
      return;
    }
    this.__dataProviderController.clearCache();
    this.__synchronizeControllerState();
    if (this._shouldFetchData()) {
      this._forceNextRequest = false;
      this.__dataProviderController.loadFirstPage();
    } else {
      this._forceNextRequest = true;
    }
  }
  /**
   * When the size change originates externally, synchronizes the new size with
   * the controller and request a content update to re-render the scroller.
   *
   * @private
   */
  _sizeChanged(size) {
    const { rootCache } = this.__dataProviderController;
    if (rootCache.size !== size) {
      rootCache.size = size;
      rootCache.items = [...rootCache.items];
      this.__synchronizeControllerState();
    }
  }
  /**
   * When the items change originates externally, synchronizes the new items with
   * the controller and requests a content update to re-render the scroller.
   *
   * @private
   * @override
   */
  _filteredItemsChanged(items) {
    super._filteredItemsChanged(items);
    if (this.dataProvider && items) {
      const { rootCache } = this.__dataProviderController;
      if (rootCache.items !== items) {
        rootCache.items = items;
        this.__synchronizeControllerState();
      }
    }
  }
  /**
   * Synchronizes the controller's state with the component, which can be
   * out of sync after the controller receives new data from the data provider
   * or if the state in the controller is directly manipulated.
   *
   * @private
   */
  __synchronizeControllerState() {
    if (this.__dataProviderInitialized && this.dataProvider) {
      const { rootCache } = this.__dataProviderController;
      this.size = rootCache.size;
      this.filteredItems = rootCache.items;
      this.loading = this.__dataProviderController.isLoading();
    }
  }
  /** @private */
  _pageSizeChanged(pageSize, oldPageSize) {
    if (Math.floor(pageSize) !== pageSize || pageSize < 1) {
      this.pageSize = oldPageSize;
      throw new Error("`pageSize` value must be an integer > 0");
    }
    this.__dataProviderController.setPageSize(pageSize);
    this.clearCache();
  }
  /** @private */
  _dataProviderChanged(dataProvider, oldDataProvider) {
    this._ensureItemsOrDataProvider(() => {
      this.dataProvider = oldDataProvider;
    });
    this.__dataProviderController.setDataProvider(dataProvider);
    this.clearCache();
  }
  /** @private */
  _ensureItemsOrDataProvider(restoreOldValueCallback) {
    if (this.items !== void 0 && this.dataProvider !== void 0) {
      restoreOldValueCallback();
      throw new Error("Using `items` and `dataProvider` together is not supported");
    }
  }
  /** @private */
  _warnDataProviderValue(dataProvider, value) {
    if (dataProvider && value !== "" && (this.selectedItem === void 0 || this.selectedItem === null)) {
      const valueIndex = this.__getItemIndexByValue(this.filteredItems, value);
      if (valueIndex < 0 || !this._getItemLabel(this.filteredItems[valueIndex])) {
        console.warn(
          "Warning: unable to determine the label for the provided `value`. Nothing to display in the text field. This usually happens when setting an initial `value` before any items are returned from the `dataProvider` callback. Consider setting `selectedItem` instead of `value`"
        );
      }
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function processTemplates(component) {
  if (window.Vaadin && window.Vaadin.templateRendererCallback) {
    window.Vaadin.templateRendererCallback(component);
    return;
  }
  if (component.querySelector("template")) {
    console.warn(
      `WARNING: <template> inside <${component.localName}> is no longer supported. Import @vaadin/polymer-legacy-adapter/template-renderer.js to enable compatibility.`
    );
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class VirtualKeyboardController {
  /**
   * @param {{ inputElement?: HTMLElement; opened: boolean } & HTMLElement} host
   */
  constructor(host) {
    this.host = host;
    host.addEventListener("opened-changed", () => {
      if (!host.opened) {
        this.__setVirtualKeyboardEnabled(false);
      }
    });
    host.addEventListener("blur", () => this.__setVirtualKeyboardEnabled(true));
    host.addEventListener("touchstart", () => this.__setVirtualKeyboardEnabled(true));
  }
  /** @private */
  __setVirtualKeyboardEnabled(value) {
    if (this.host.inputElement) {
      this.host.inputElement.inputMode = value ? "" : "none";
    }
  }
}
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function isValidValue(value) {
  return value !== void 0 && value !== null;
}
function findItemIndex(items, callback) {
  return items.findIndex((item2) => {
    if (item2 instanceof ComboBoxPlaceholder) {
      return false;
    }
    return callback(item2);
  });
}
const ComboBoxMixin = (subclass) => class ComboBoxMixinClass extends OverlayClassMixin(
  ControllerMixin(ValidateMixin(FocusMixin(KeyboardMixin(InputMixin(DisabledMixin(subclass))))))
) {
  static get properties() {
    return {
      /**
       * True if the dropdown is open, false otherwise.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        notify: true,
        value: false,
        reflectToAttribute: true,
        sync: true,
        observer: "_openedChanged"
      },
      /**
       * Set true to prevent the overlay from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: {
        type: Boolean,
        sync: true
      },
      /**
       * When present, it specifies that the field is read-only.
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Custom function for rendering the content of every item.
       * Receives three arguments:
       *
       * - `root` The `<vaadin-combo-box-item>` internal container DOM element.
       * - `comboBox` The reference to the `<vaadin-combo-box>` element.
       * - `model` The object with the properties related with the rendered
       *   item, contains:
       *   - `model.index` The index of the rendered item.
       *   - `model.item` The item.
       * @type {ComboBoxRenderer | undefined}
       */
      renderer: {
        type: Object,
        sync: true
      },
      /**
       * A full set of items to filter the visible options from.
       * The items can be of either `String` or `Object` type.
       * @type {!Array<!ComboBoxItem | string> | undefined}
       */
      items: {
        type: Array,
        sync: true,
        observer: "_itemsChanged"
      },
      /**
       * If `true`, the user can input a value that is not present in the items list.
       * `value` property will be set to the input value in this case.
       * Also, when `value` is set programmatically, the input value will be set
       * to reflect that value.
       * @attr {boolean} allow-custom-value
       * @type {boolean}
       */
      allowCustomValue: {
        type: Boolean,
        value: false
      },
      /**
       * A subset of items, filtered based on the user input. Filtered items
       * can be assigned directly to omit the internal filtering functionality.
       * The items can be of either `String` or `Object` type.
       * @type {!Array<!ComboBoxItem | string> | undefined}
       */
      filteredItems: {
        type: Array,
        observer: "_filteredItemsChanged",
        sync: true
      },
      /**
       * Used to detect user value changes and fire `change` events.
       * @private
       */
      _lastCommittedValue: String,
      /**
       * When set to `true`, "loading" attribute is added to host and the overlay element.
       * @type {boolean}
       */
      loading: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * @type {number}
       * @protected
       */
      _focusedIndex: {
        type: Number,
        observer: "_focusedIndexChanged",
        value: -1,
        sync: true
      },
      /**
       * Filtering string the user has typed into the input field.
       * @type {string}
       */
      filter: {
        type: String,
        value: "",
        notify: true,
        sync: true
      },
      /**
       * The selected item from the `items` array.
       * @type {ComboBoxItem | string | undefined}
       */
      selectedItem: {
        type: Object,
        notify: true,
        sync: true
      },
      /**
       * A function used to generate CSS class names for dropdown
       * items based on the item. The return value should be the
       * generated class name as a string, or multiple class names
       * separated by whitespace characters.
       */
      itemClassNameGenerator: {
        type: Object
      },
      /**
       * Path for label of the item. If `items` is an array of objects, the
       * `itemLabelPath` is used to fetch the displayed string label for each
       * item.
       *
       * The item label is also used for matching items when processing user
       * input, i.e., for filtering and selecting items.
       * @attr {string} item-label-path
       * @type {string}
       */
      itemLabelPath: {
        type: String,
        value: "label",
        observer: "_itemLabelPathChanged",
        sync: true
      },
      /**
       * Path for the value of the item. If `items` is an array of objects, the
       * `itemValuePath:` is used to fetch the string value for the selected
       * item.
       *
       * The item value is used in the `value` property of the combo box,
       * to provide the form value.
       * @attr {string} item-value-path
       * @type {string}
       */
      itemValuePath: {
        type: String,
        value: "value",
        sync: true
      },
      /**
       * Path for the id of the item. If `items` is an array of objects,
       * the `itemIdPath` is used to compare and identify the same item
       * in `selectedItem` and `filteredItems` (items given by the
       * `dataProvider` callback).
       * @attr {string} item-id-path
       */
      itemIdPath: {
        type: String,
        sync: true
      },
      /**
       * @type {!HTMLElement | undefined}
       * @protected
       */
      _toggleElement: {
        type: Object,
        observer: "_toggleElementChanged"
      },
      /**
       * Set of items to be rendered in the dropdown.
       * @protected
       */
      _dropdownItems: {
        type: Array,
        sync: true
      },
      /** @private */
      _closeOnBlurIsPrevented: Boolean,
      /** @private */
      _scroller: {
        type: Object,
        sync: true
      },
      /** @private */
      _overlayOpened: {
        type: Boolean,
        sync: true,
        observer: "_overlayOpenedChanged"
      },
      /** @private */
      __keepOverlayOpened: {
        type: Boolean,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "_selectedItemChanged(selectedItem, itemValuePath, itemLabelPath)",
      "_openedOrItemsChanged(opened, _dropdownItems, loading, __keepOverlayOpened)",
      "_updateScroller(_scroller, _dropdownItems, opened, loading, selectedItem, itemIdPath, _focusedIndex, renderer, _theme, itemClassNameGenerator)"
    ];
  }
  constructor() {
    super();
    this._boundOverlaySelectedItemChanged = this._overlaySelectedItemChanged.bind(this);
    this._boundOnClearButtonMouseDown = this.__onClearButtonMouseDown.bind(this);
    this._boundOnClick = this._onClick.bind(this);
    this._boundOnOverlayTouchAction = this._onOverlayTouchAction.bind(this);
    this._boundOnTouchend = this._onTouchend.bind(this);
  }
  /**
   * Tag name prefix used by scroller and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-combo-box";
  }
  /**
   * Get a reference to the native `<input>` element.
   * Override to provide a custom input.
   * @protected
   * @return {HTMLInputElement | undefined}
   */
  get _nativeInput() {
    return this.inputElement;
  }
  /**
   * Override method inherited from `InputMixin`
   * to customize the input element.
   * @protected
   * @override
   */
  _inputElementChanged(inputElement) {
    super._inputElementChanged(inputElement);
    const input = this._nativeInput;
    if (input) {
      input.autocomplete = "off";
      input.autocapitalize = "off";
      input.setAttribute("role", "combobox");
      input.setAttribute("aria-autocomplete", "list");
      input.setAttribute("aria-expanded", !!this.opened);
      input.setAttribute("spellcheck", "false");
      input.setAttribute("autocorrect", "off");
      this._revertInputValueToValue();
      if (this.clearElement) {
        this.clearElement.addEventListener("mousedown", this._boundOnClearButtonMouseDown);
      }
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this._initOverlay();
    this._initScroller();
    this._lastCommittedValue = this.value;
    this.addEventListener("click", this._boundOnClick);
    this.addEventListener("touchend", this._boundOnTouchend);
    const bringToFrontListener = () => {
      requestAnimationFrame(() => {
        this._overlayElement.bringToFront();
      });
    };
    this.addEventListener("mousedown", bringToFrontListener);
    this.addEventListener("touchstart", bringToFrontListener);
    processTemplates(this);
    this.addController(new VirtualKeyboardController(this));
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.close();
  }
  /**
   * Requests an update for the content of items.
   * While performing the update, it invokes the renderer (passed in the `renderer` property) once an item.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this._scroller) {
      return;
    }
    this._scroller.requestContentUpdate();
    this._getItemElements().forEach((item2) => {
      item2.requestContentUpdate();
    });
  }
  /**
   * Opens the dropdown list.
   */
  open() {
    if (!this.disabled && !this.readonly) {
      this.opened = true;
    }
  }
  /**
   * Closes the dropdown list.
   */
  close() {
    this.opened = false;
  }
  /**
   * Override Polymer lifecycle callback to handle `filter` property change after
   * the observer for `opened` property is triggered. This is needed when opening
   * combo-box on user input to ensure the focused index is set correctly.
   *
   * @param {!Object} currentProps Current accessor values
   * @param {?Object} changedProps Properties changed since the last call
   * @param {?Object} oldProps Previous values for each changed property
   * @protected
   * @override
   */
  _propertiesChanged(currentProps, changedProps, oldProps) {
    super._propertiesChanged(currentProps, changedProps, oldProps);
    if (changedProps.filter !== void 0) {
      this._filterChanged(changedProps.filter);
    }
  }
  /**
   * Override LitElement lifecycle callback to handle filter property change.
   * @param {Object} props
   * @protected
   */
  updated(props) {
    super.updated(props);
    if (props.has("filter")) {
      this._filterChanged(this.filter);
    }
  }
  /** @private */
  _initOverlay() {
    const overlay2 = this.$.overlay;
    overlay2._comboBox = this;
    overlay2.addEventListener("touchend", this._boundOnOverlayTouchAction);
    overlay2.addEventListener("touchmove", this._boundOnOverlayTouchAction);
    overlay2.addEventListener("mousedown", (e2) => e2.preventDefault());
    overlay2.addEventListener("opened-changed", (e2) => {
      this._overlayOpened = e2.detail.value;
    });
    this._overlayElement = overlay2;
  }
  /**
   * Create and initialize the scroller element.
   * Override to provide custom host reference.
   *
   * @protected
   */
  _initScroller(host) {
    const scroller2 = document.createElement(`${this._tagNamePrefix}-scroller`);
    scroller2.owner = host || this;
    scroller2.getItemLabel = this._getItemLabel.bind(this);
    scroller2.addEventListener("selection-changed", this._boundOverlaySelectedItemChanged);
    const overlay2 = this._overlayElement;
    overlay2.renderer = (root2) => {
      if (!root2.innerHTML) {
        root2.appendChild(scroller2);
      }
    };
    overlay2.requestContentUpdate();
    this._scroller = scroller2;
  }
  /** @private */
  // eslint-disable-next-line @typescript-eslint/max-params
  _updateScroller(scroller2, items, opened, loading, selectedItem, itemIdPath, focusedIndex, renderer, theme, itemClassNameGenerator) {
    if (scroller2) {
      if (opened) {
        scroller2.style.maxHeight = getComputedStyle(this).getPropertyValue(`--${this._tagNamePrefix}-overlay-max-height`) || "65vh";
      }
      scroller2.setProperties({
        items: opened ? items : [],
        opened,
        loading,
        selectedItem,
        itemIdPath,
        focusedIndex,
        renderer,
        theme,
        itemClassNameGenerator
      });
      if (scroller2.performUpdate && !scroller2.hasUpdated) {
        try {
          scroller2.performUpdate();
        } catch (_) {
        }
      }
    }
  }
  /** @private */
  _openedOrItemsChanged(opened, items, loading, keepOverlayOpened) {
    this._overlayOpened = opened && (keepOverlayOpened || loading || !!(items && items.length));
  }
  /** @private */
  _overlayOpenedChanged(opened, wasOpened) {
    if (opened) {
      this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-opened", { bubbles: true, composed: true }));
      this._onOpened();
    } else if (wasOpened && this._dropdownItems && this._dropdownItems.length) {
      this.close();
      this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-closed", { bubbles: true, composed: true }));
    }
  }
  /** @private */
  _focusedIndexChanged(index, oldIndex) {
    if (oldIndex === void 0) {
      return;
    }
    this._updateActiveDescendant(index);
  }
  /** @protected */
  _isInputFocused() {
    return this.inputElement && isElementFocused(this.inputElement);
  }
  /** @private */
  _updateActiveDescendant(index) {
    const input = this._nativeInput;
    if (!input) {
      return;
    }
    const item2 = this._getItemElements().find((el) => el.index === index);
    if (item2) {
      input.setAttribute("aria-activedescendant", item2.id);
    } else {
      input.removeAttribute("aria-activedescendant");
    }
  }
  /** @private */
  _openedChanged(opened, wasOpened) {
    if (wasOpened === void 0) {
      return;
    }
    if (opened) {
      if (!this._isInputFocused() && !isTouch) {
        if (this.inputElement) {
          this.inputElement.focus();
        }
      }
    } else {
      this._onClosed();
    }
    const input = this._nativeInput;
    if (input) {
      input.setAttribute("aria-expanded", !!opened);
      if (opened) {
        input.setAttribute("aria-controls", this._scroller.id);
      } else {
        input.removeAttribute("aria-controls");
      }
    }
  }
  /** @private */
  _onOverlayTouchAction() {
    this._closeOnBlurIsPrevented = true;
    this.inputElement.blur();
    this._closeOnBlurIsPrevented = false;
  }
  /** @protected */
  _isClearButton(event) {
    return event.composedPath()[0] === this.clearElement;
  }
  /** @private */
  __onClearButtonMouseDown(event) {
    event.preventDefault();
    this.inputElement.focus();
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onClearButtonClick(event) {
    event.preventDefault();
    this._onClearAction();
    if (this.opened) {
      this.requestContentUpdate();
    }
  }
  /**
   * @param {Event} event
   * @private
   */
  _onToggleButtonClick(event) {
    event.preventDefault();
    if (this.opened) {
      this.close();
    } else {
      this.open();
    }
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onHostClick(event) {
    if (!this.autoOpenDisabled) {
      event.preventDefault();
      this.open();
    }
  }
  /** @private */
  _onClick(event) {
    if (this._isClearButton(event)) {
      this._onClearButtonClick(event);
    } else if (event.composedPath().includes(this._toggleElement)) {
      this._onToggleButtonClick(event);
    } else {
      this._onHostClick(event);
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onKeyDown(e2) {
    super._onKeyDown(e2);
    if (e2.key === "ArrowDown") {
      this._onArrowDown();
      e2.preventDefault();
    } else if (e2.key === "ArrowUp") {
      this._onArrowUp();
      e2.preventDefault();
    }
  }
  /** @private */
  _getItemLabel(item2) {
    let label = item2 && this.itemLabelPath ? get$1(this.itemLabelPath, item2) : void 0;
    if (label === void 0 || label === null) {
      label = item2 ? item2.toString() : "";
    }
    return label;
  }
  /** @private */
  _getItemValue(item2) {
    let value = item2 && this.itemValuePath ? get$1(this.itemValuePath, item2) : void 0;
    if (value === void 0) {
      value = item2 ? item2.toString() : "";
    }
    return value;
  }
  /** @private */
  _onArrowDown() {
    if (this.opened) {
      const items = this._dropdownItems;
      if (items) {
        this._focusedIndex = Math.min(items.length - 1, this._focusedIndex + 1);
        this._prefillFocusedItemLabel();
      }
    } else {
      this.open();
    }
  }
  /** @private */
  _onArrowUp() {
    if (this.opened) {
      if (this._focusedIndex > -1) {
        this._focusedIndex = Math.max(0, this._focusedIndex - 1);
      } else {
        const items = this._dropdownItems;
        if (items) {
          this._focusedIndex = items.length - 1;
        }
      }
      this._prefillFocusedItemLabel();
    } else {
      this.open();
    }
  }
  /** @private */
  _prefillFocusedItemLabel() {
    if (this._focusedIndex > -1) {
      const focusedItem = this._dropdownItems[this._focusedIndex];
      this._inputElementValue = this._getItemLabel(focusedItem);
      this._markAllSelectionRange();
    }
  }
  /** @private */
  _setSelectionRange(start, end) {
    if (this._isInputFocused() && this.inputElement.setSelectionRange) {
      this.inputElement.setSelectionRange(start, end);
    }
  }
  /** @private */
  _markAllSelectionRange() {
    if (this._inputElementValue !== void 0) {
      this._setSelectionRange(0, this._inputElementValue.length);
    }
  }
  /** @private */
  _clearSelectionRange() {
    if (this._inputElementValue !== void 0) {
      const pos = this._inputElementValue ? this._inputElementValue.length : 0;
      this._setSelectionRange(pos, pos);
    }
  }
  /** @private */
  _closeOrCommit() {
    if (!this.opened && !this.loading) {
      this._commitValue();
    } else {
      this.close();
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onEnter(e2) {
    if (!this._hasValidInputValue()) {
      e2.preventDefault();
      e2.stopPropagation();
      return;
    }
    if (this.opened) {
      e2.preventDefault();
      e2.stopPropagation();
    }
    this._closeOrCommit();
  }
  /**
   * @protected
   */
  _hasValidInputValue() {
    const hasInvalidOption = this._focusedIndex < 0 && this._inputElementValue !== "" && this._getItemLabel(this.selectedItem) !== this._inputElementValue;
    return this.allowCustomValue || !hasInvalidOption;
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * Do not call `super` in order to override clear
   * button logic defined in `InputControlMixin`.
   *
   * @param {!KeyboardEvent} e
   * @protected
   * @override
   */
  _onEscape(e2) {
    if (this.autoOpenDisabled && (this.opened || this.value !== this._inputElementValue && this._inputElementValue.length > 0)) {
      e2.stopPropagation();
      this._focusedIndex = -1;
      this.cancel();
    } else if (this.opened) {
      e2.stopPropagation();
      if (this._focusedIndex > -1) {
        this._focusedIndex = -1;
        this._revertInputValue();
      } else {
        this.cancel();
      }
    } else if (this.clearButtonVisible && !!this.value && !this.readonly) {
      e2.stopPropagation();
      this._onClearAction();
    }
  }
  /** @private */
  _toggleElementChanged(toggleElement) {
    if (toggleElement) {
      toggleElement.addEventListener("mousedown", (e2) => e2.preventDefault());
      toggleElement.addEventListener("click", () => {
        if (isTouch && !this._isInputFocused()) {
          document.activeElement.blur();
        }
      });
    }
  }
  /**
   * Clears the current value.
   * @protected
   */
  _onClearAction() {
    this.selectedItem = null;
    if (this.allowCustomValue) {
      this.value = "";
    }
    this._detectAndDispatchChange();
  }
  /**
   * Clears the current filter. Should be used instead of setting the property
   * directly in order to allow overriding this in multi-select combo box.
   * @protected
   */
  _clearFilter() {
    this.filter = "";
  }
  /**
   * Reverts back to original value.
   */
  cancel() {
    this._revertInputValueToValue();
    this._lastCommittedValue = this.value;
    this._closeOrCommit();
  }
  /** @private */
  _onOpened() {
    this._lastCommittedValue = this.value;
  }
  /** @private */
  _onClosed() {
    if (!this.loading || this.allowCustomValue) {
      this._commitValue();
    }
  }
  /** @private */
  _commitValue() {
    if (this._focusedIndex > -1) {
      const focusedItem = this._dropdownItems[this._focusedIndex];
      if (this.selectedItem !== focusedItem) {
        this.selectedItem = focusedItem;
      }
      this._inputElementValue = this._getItemLabel(this.selectedItem);
      this._focusedIndex = -1;
    } else if (this._inputElementValue === "" || this._inputElementValue === void 0) {
      this.selectedItem = null;
      if (this.allowCustomValue) {
        this.value = "";
      }
    } else {
      const items = [this.selectedItem, ...this._dropdownItems || []];
      const itemMatchingInputValue = items[this.__getItemIndexByLabel(items, this._inputElementValue)];
      if (this.allowCustomValue && // To prevent a repetitive input value being saved after pressing ESC and Tab.
      !itemMatchingInputValue) {
        const customValue = this._inputElementValue;
        this._lastCustomValue = customValue;
        const e2 = new CustomEvent("custom-value-set", {
          detail: customValue,
          composed: true,
          cancelable: true,
          bubbles: true
        });
        this.dispatchEvent(e2);
        if (!e2.defaultPrevented) {
          this.value = customValue;
        }
      } else if (!this.allowCustomValue && !this.opened && itemMatchingInputValue) {
        this.value = this._getItemValue(itemMatchingInputValue);
      } else {
        this._revertInputValueToValue();
      }
    }
    this._detectAndDispatchChange();
    this._clearSelectionRange();
    this._clearFilter();
  }
  /**
   * Override an event listener from `InputMixin`.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onInput(event) {
    const filter2 = this._inputElementValue;
    const props = {};
    if (this.filter === filter2) {
      this._filterChanged(this.filter);
    } else {
      props.filter = filter2;
    }
    if (!this.opened && !this._isClearButton(event) && !this.autoOpenDisabled) {
      props.opened = true;
    }
    this.setProperties(props);
  }
  /**
   * Override an event listener from `InputMixin`.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onChange(event) {
    event.stopPropagation();
  }
  /** @private */
  _itemLabelPathChanged(itemLabelPath) {
    if (typeof itemLabelPath !== "string") {
      console.error("You should set itemLabelPath to a valid string");
    }
  }
  /** @private */
  _filterChanged(filter2) {
    this._scrollIntoView(0);
    this._focusedIndex = -1;
    if (this.items) {
      this.filteredItems = this._filterItems(this.items, filter2);
    } else {
      this._filteredItemsChanged(this.filteredItems);
    }
  }
  /** @protected */
  _revertInputValue() {
    if (this.filter !== "") {
      this._inputElementValue = this.filter;
    } else {
      this._revertInputValueToValue();
    }
    this._clearSelectionRange();
  }
  /** @private */
  _revertInputValueToValue() {
    if (this.allowCustomValue && !this.selectedItem) {
      this._inputElementValue = this.value;
    } else {
      this._inputElementValue = this._getItemLabel(this.selectedItem);
    }
  }
  /** @private */
  _selectedItemChanged(selectedItem) {
    if (selectedItem === null || selectedItem === void 0) {
      if (this.filteredItems) {
        if (!this.allowCustomValue) {
          this.value = "";
        }
        this._toggleHasValue(this._hasValue);
        this._inputElementValue = this.value;
      }
    } else {
      const value = this._getItemValue(selectedItem);
      if (this.value !== value) {
        this.value = value;
        if (this.value !== value) {
          return;
        }
      }
      this._toggleHasValue(true);
      this._inputElementValue = this._getItemLabel(selectedItem);
    }
  }
  /**
   * Override an observer from `InputMixin`.
   * @protected
   * @override
   */
  _valueChanged(value, oldVal) {
    if (value === "" && oldVal === void 0) {
      return;
    }
    if (isValidValue(value)) {
      if (this._getItemValue(this.selectedItem) !== value) {
        this._selectItemForValue(value);
      }
      if (!this.selectedItem && this.allowCustomValue) {
        this._inputElementValue = value;
      }
      this._toggleHasValue(this._hasValue);
    } else {
      this.selectedItem = null;
    }
    this._clearFilter();
    this._lastCommittedValue = void 0;
  }
  /** @private */
  _detectAndDispatchChange() {
    if (document.hasFocus()) {
      this._requestValidation();
    }
    if (this.value !== this._lastCommittedValue) {
      this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
      this._lastCommittedValue = this.value;
    }
  }
  /** @private */
  _itemsChanged(items, oldItems) {
    this._ensureItemsOrDataProvider(() => {
      this.items = oldItems;
    });
    if (items) {
      this.filteredItems = items.slice(0);
    } else if (oldItems) {
      this.filteredItems = null;
    }
  }
  /** @private */
  _filteredItemsChanged(filteredItems) {
    this._setDropdownItems(filteredItems);
  }
  /** @private */
  _filterItems(arr, filter2) {
    if (!arr) {
      return arr;
    }
    const filteredItems = arr.filter((item2) => {
      filter2 = filter2 ? filter2.toString().toLowerCase() : "";
      return this._getItemLabel(item2).toString().toLowerCase().indexOf(filter2) > -1;
    });
    return filteredItems;
  }
  /** @private */
  _selectItemForValue(value) {
    const valueIndex = this.__getItemIndexByValue(this.filteredItems, value);
    const previouslySelectedItem = this.selectedItem;
    if (valueIndex >= 0) {
      this.selectedItem = this.filteredItems[valueIndex];
    } else if (this.dataProvider && this.selectedItem === void 0) {
      this.selectedItem = void 0;
    } else {
      this.selectedItem = null;
    }
    if (this.selectedItem === null && previouslySelectedItem === null) {
      this._selectedItemChanged(this.selectedItem);
    }
  }
  /**
   * Provide items to be rendered in the dropdown.
   * Override this method to show custom items.
   *
   * @protected
   */
  _setDropdownItems(newItems) {
    const oldItems = this._dropdownItems;
    this._dropdownItems = newItems;
    const focusedItem = oldItems ? oldItems[this._focusedIndex] : null;
    const valueIndex = this.__getItemIndexByValue(newItems, this.value);
    if ((this.selectedItem === null || this.selectedItem === void 0) && valueIndex >= 0) {
      this.selectedItem = newItems[valueIndex];
    }
    const focusedItemIndex = this.__getItemIndexByValue(newItems, this._getItemValue(focusedItem));
    if (focusedItemIndex > -1) {
      this._focusedIndex = focusedItemIndex;
    } else {
      this._focusedIndex = this.__getItemIndexByLabel(newItems, this.filter);
    }
  }
  /** @private */
  _getItemElements() {
    return Array.from(this._scroller.querySelectorAll(`${this._tagNamePrefix}-item`));
  }
  /** @private */
  _scrollIntoView(index) {
    if (!this._scroller) {
      return;
    }
    this._scroller.scrollIntoView(index);
  }
  /**
   * Returns the first item that matches the provided value.
   *
   * @private
   */
  __getItemIndexByValue(items, value) {
    if (!items || !isValidValue(value)) {
      return -1;
    }
    return findItemIndex(items, (item2) => {
      return this._getItemValue(item2) === value;
    });
  }
  /**
   * Returns the first item that matches the provided label.
   * Labels are matched against each other case insensitively.
   *
   * @private
   */
  __getItemIndexByLabel(items, label) {
    if (!items || !label) {
      return -1;
    }
    return findItemIndex(items, (item2) => {
      return this._getItemLabel(item2).toString().toLowerCase() === label.toString().toLowerCase();
    });
  }
  /** @private */
  _overlaySelectedItemChanged(e2) {
    e2.stopPropagation();
    if (e2.detail.item instanceof ComboBoxPlaceholder) {
      return;
    }
    if (this.opened) {
      this._focusedIndex = this.filteredItems.indexOf(e2.detail.item);
      this.close();
    }
  }
  /**
   * Override method inherited from `FocusMixin`
   * to close the overlay on blur and commit the value.
   *
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && !this.readonly && !this._closeOnBlurIsPrevented) {
      if (!this.opened && this.allowCustomValue && this._inputElementValue === this._lastCustomValue) {
        delete this._lastCustomValue;
        return;
      }
      if (isKeyboardActive()) {
        this._closeOrCommit();
        return;
      }
      if (!this.opened) {
        this._commitValue();
      } else if (!this._overlayOpened) {
        this.close();
      }
    }
  }
  /**
   * Override method inherited from `FocusMixin` to not remove focused
   * state when focus moves to the overlay.
   *
   * @param {FocusEvent} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldRemoveFocus(event) {
    if (event.relatedTarget && event.relatedTarget.localName === `${this._tagNamePrefix}-item`) {
      return false;
    }
    if (event.relatedTarget === this._overlayElement) {
      event.composedPath()[0].focus();
      return false;
    }
    return true;
  }
  /** @private */
  _onTouchend(event) {
    if (!this.clearElement || event.composedPath()[0] !== this.clearElement) {
      return;
    }
    event.preventDefault();
    this._onClearAction();
  }
  /**
   * Fired when the value changes.
   *
   * @event value-changed
   * @param {Object} detail
   * @param {String} detail.value the combobox value
   */
  /**
   * Fired when selected item changes.
   *
   * @event selected-item-changed
   * @param {Object} detail
   * @param {Object|String} detail.value the selected item. Type is the same as the type of `items`.
   */
  /**
   * Fired when the user sets a custom value.
   * @event custom-value-set
   * @param {String} detail the custom value
   */
  /**
   * Fired when value changes.
   * To comply with https://developer.mozilla.org/en-US/docs/Web/Events/change
   * @event change
   */
  /**
   * Fired after the `vaadin-combo-box-overlay` opens.
   *
   * @event vaadin-combo-box-dropdown-opened
   */
  /**
   * Fired after the `vaadin-combo-box-overlay` closes.
   *
   * @event vaadin-combo-box-dropdown-closed
   */
};
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-combo-box", inputFieldShared, { moduleId: "vaadin-combo-box-styles" });
class ComboBox extends ComboBoxDataProviderMixin(
  ComboBoxMixin(PatternMixin(InputControlMixin(ThemableMixin(ElementMixin(PolymerElement)))))
) {
  static get is() {
    return "vaadin-combo-box";
  }
  static get template() {
    return html`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <div class="vaadin-combo-box-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div id="toggleButton" part="toggle-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-combo-box-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[_positionTarget]]"
        no-vertical-overlap
      ></vaadin-combo-box-overlay>

      <slot name="tooltip"></slot>
    `;
  }
  static get properties() {
    return {
      /**
       * @protected
       */
      _positionTarget: {
        type: Object
      }
    };
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this._tooltipController.setShouldShow((target) => !target.opened);
    this._positionTarget = this.shadowRoot.querySelector('[part="input-field"]');
    this._toggleElement = this.$.toggleButton;
  }
  /**
   * Override the method from `InputControlMixin`
   * to stop event propagation to prevent `ComboBoxMixin`
   * from handling this click event also on its own.
   *
   * @param {Event} event
   * @protected
   * @override
   */
  _onClearButtonClick(event) {
    event.stopPropagation();
    super._onClearButtonClick(event);
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onHostClick(event) {
    const path = event.composedPath();
    if (path.includes(this._labelNode) || path.includes(this._positionTarget)) {
      super._onHostClick(event);
    }
  }
}
defineCustomElement(ComboBox);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
class Debouncer2 {
  constructor() {
    this._asyncModule = null;
    this._callback = null;
    this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncInterface} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   * @return {void}
   */
  setConfig(asyncModule, callback) {
    this._asyncModule = asyncModule;
    this._callback = callback;
    this._timer = this._asyncModule.run(() => {
      this._timer = null;
      debouncerQueue.delete(this);
      this._callback();
    });
  }
  /**
   * Cancels an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  cancel() {
    if (this.isActive()) {
      this._cancelAsync();
      debouncerQueue.delete(this);
    }
  }
  /**
   * Cancels a debouncer's async callback.
   *
   * @return {void}
   */
  _cancelAsync() {
    if (this.isActive()) {
      this._asyncModule.cancel(
        /** @type {number} */
        this._timer
      );
      this._timer = null;
    }
  }
  /**
   * Flushes an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  flush() {
    if (this.isActive()) {
      this.cancel();
      this._callback();
    }
  }
  /**
   * Returns true if the debouncer is active.
   *
   * @return {boolean} True if active.
   */
  isActive() {
    return this._timer != null;
  }
  /**
   * Creates a debouncer if no debouncer is passed as a parameter
   * or it cancels an active debouncer otherwise. The following
   * example shows how a debouncer can be called multiple times within a
   * microtask and "debounced" such that the provided callback function is
   * called once. Add this method to a custom element:
   *
   * ```js
   * import {microTask} from '@polymer/polymer/lib/utils/async.js';
   * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';
   * // ...
   *
   * _debounceWork() {
   *   this._debounceJob = Debouncer.debounce(this._debounceJob,
   *       microTask, () => this._doWork());
   * }
   * ```
   *
   * If the `_debounceWork` method is called multiple times within the same
   * microtask, the `_doWork` function will be called only once at the next
   * microtask checkpoint.
   *
   * Note: In testing it is often convenient to avoid asynchrony. To accomplish
   * this with a debouncer, you can use `enqueueDebouncer` and
   * `flush`. For example, extend the above example by adding
   * `enqueueDebouncer(this._debounceJob)` at the end of the
   * `_debounceWork` method. Then in a test, call `flush` to ensure
   * the debouncer has completed.
   *
   * @param {Debouncer?} debouncer Debouncer object.
   * @param {!AsyncInterface} asyncModule Object with Async interface
   * @param {function()} callback Callback to run.
   * @return {!Debouncer} Returns a debouncer object.
   */
  static debounce(debouncer, asyncModule, callback) {
    if (debouncer instanceof Debouncer2) {
      debouncer._cancelAsync();
    } else {
      debouncer = new Debouncer2();
    }
    debouncer.setConfig(asyncModule, callback);
    return debouncer;
  }
}
let debouncerQueue = /* @__PURE__ */ new Set();
const enqueueDebouncer = function(debouncer) {
  debouncerQueue.add(debouncer);
};
const flushDebouncers = function() {
  const didFlush = Boolean(debouncerQueue.size);
  debouncerQueue.forEach((debouncer) => {
    try {
      debouncer.flush();
    } catch (e2) {
      setTimeout(() => {
        throw e2;
      });
    }
  });
  return didFlush;
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const flush = function() {
  let shadyDOM, debouncers;
  do {
    shadyDOM = window.ShadyDOM && ShadyDOM.flush();
    if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
      window.ShadyCSS.ScopingShim.flush();
    }
    debouncers = flushDebouncers();
  } while (shadyDOM || debouncers);
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let elementsHidden = false;
function hideElementsGlobally() {
  if (legacyOptimizations && !useShadow) {
    if (!elementsHidden) {
      elementsHidden = true;
      const style = document.createElement("style");
      style.textContent = "dom-bind,dom-if,dom-repeat{display:none;}";
      document.head.appendChild(style);
    }
    return true;
  }
  return false;
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function mutablePropertyChange(inst, property, value, old, mutableData) {
  let isObject;
  if (mutableData) {
    isObject = typeof value === "object" && value !== null;
    if (isObject) {
      old = inst.__dataTemp[property];
    }
  }
  let shouldChange = old !== value && (old === old || value === value);
  if (isObject && shouldChange) {
    inst.__dataTemp[property] = value;
  }
  return shouldChange;
}
const MutableData = dedupingMixin((superClass) => {
  class MutableData2 extends superClass {
    /**
     * Overrides `PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * This method pulls the value to dirty check against from the `__dataTemp`
     * cache (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, true);
    }
  }
  return MutableData2;
});
const OptionalMutableData = dedupingMixin((superClass) => {
  class OptionalMutableData2 extends superClass {
    /** @nocollapse */
    static get properties() {
      return {
        /**
         * Instance-level flag for configuring the dirty-checking strategy
         * for this element.  When true, Objects and Arrays will skip dirty
         * checking, otherwise strict equality checking will be used.
         */
        mutableData: Boolean
      };
    }
    /**
     * Overrides `PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * When `this.mutableData` is true on this instance, this method
     * pulls the value to dirty check against from the `__dataTemp` cache
     * (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, this.mutableData);
    }
  }
  return OptionalMutableData2;
});
MutableData._mutablePropertyChange = mutablePropertyChange;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let newInstance = null;
function HTMLTemplateElementExtension() {
  return newInstance;
}
HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
  constructor: {
    value: HTMLTemplateElementExtension,
    writable: true
  }
});
const DataTemplate = PropertyEffects(HTMLTemplateElementExtension);
const MutableDataTemplate = MutableData(DataTemplate);
function upgradeTemplate(template2, constructor) {
  newInstance = template2;
  Object.setPrototypeOf(template2, constructor.prototype);
  new constructor();
  newInstance = null;
}
const templateInstanceBase = PropertyEffects(class {
});
function showHideChildren(hide, children) {
  for (let i2 = 0; i2 < children.length; i2++) {
    let n = children[i2];
    if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
      if (n.nodeType === Node.TEXT_NODE) {
        if (hide) {
          n.__polymerTextContent__ = n.textContent;
          n.textContent = "";
        } else {
          n.textContent = n.__polymerTextContent__;
        }
      } else if (n.localName === "slot") {
        if (hide) {
          n.__polymerReplaced__ = document.createComment("hidden-slot");
          wrap$1(wrap$1(n).parentNode).replaceChild(n.__polymerReplaced__, n);
        } else {
          const replace = n.__polymerReplaced__;
          if (replace) {
            wrap$1(wrap$1(replace).parentNode).replaceChild(n, replace);
          }
        }
      } else if (n.style) {
        if (hide) {
          n.__polymerDisplay__ = n.style.display;
          n.style.display = "none";
        } else {
          n.style.display = n.__polymerDisplay__;
        }
      }
    }
    n.__hideTemplateChildren__ = hide;
    if (n._showHideChildren) {
      n._showHideChildren(hide);
    }
  }
}
class TemplateInstanceBase extends templateInstanceBase {
  constructor(props) {
    super();
    this._configureProperties(props);
    this.root = this._stampTemplate(this.__dataHost);
    let children = [];
    this.children = /** @type {!NodeList} */
    children;
    for (let n = this.root.firstChild; n; n = n.nextSibling) {
      children.push(n);
      n.__templatizeInstance = this;
    }
    if (this.__templatizeOwner && this.__templatizeOwner.__hideTemplateChildren__) {
      this._showHideChildren(true);
    }
    let options = this.__templatizeOptions;
    if (props && options.instanceProps || !options.instanceProps) {
      this._enableProperties();
    }
  }
  /**
   * Configure the given `props` by calling `_setPendingProperty`. Also
   * sets any properties stored in `__hostProps`.
   * @private
   * @param {Object} props Object of property name-value pairs to set.
   * @return {void}
   */
  _configureProperties(props) {
    let options = this.__templatizeOptions;
    if (options.forwardHostProp) {
      for (let hprop in this.__hostProps) {
        this._setPendingProperty(hprop, this.__dataHost["_host_" + hprop]);
      }
    }
    for (let iprop in props) {
      this._setPendingProperty(iprop, props[iprop]);
    }
  }
  /**
   * Forwards a host property to this instance.  This method should be
   * called on instances from the `options.forwardHostProp` callback
   * to propagate changes of host properties to each instance.
   *
   * Note this method enqueues the change, which are flushed as a batch.
   *
   * @param {string} prop Property or path name
   * @param {*} value Value of the property to forward
   * @return {void}
   */
  forwardHostProp(prop, value) {
    if (this._setPendingPropertyOrPath(prop, value, false, true)) {
      this.__dataHost._enqueueClient(this);
    }
  }
  /**
   * Override point for adding custom or simulated event handling.
   *
   * @override
   * @param {!Node} node Node to add event listener to
   * @param {string} eventName Name of event
   * @param {function(!Event):void} handler Listener function to add
   * @return {void}
   */
  _addEventListenerToNode(node, eventName, handler) {
    if (this._methodHost && this.__templatizeOptions.parentModel) {
      this._methodHost._addEventListenerToNode(node, eventName, (e2) => {
        e2.model = this;
        handler(e2);
      });
    } else {
      let templateHost = this.__dataHost.__dataHost;
      if (templateHost) {
        templateHost._addEventListenerToNode(node, eventName, handler);
      }
    }
  }
  /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @param {boolean} hide Set to true to hide the children;
   * set to false to show them.
   * @return {void}
   * @protected
   */
  _showHideChildren(hide) {
    showHideChildren(hide, this.children);
  }
  /**
   * Overrides default property-effects implementation to intercept
   * textContent bindings while children are "hidden" and cache in
   * private storage for later retrieval.
   *
   * @override
   * @param {!Node} node The node to set a property on
   * @param {string} prop The property to set
   * @param {*} value The value to set
   * @return {void}
   * @protected
   */
  _setUnmanagedPropertyToNode(node, prop, value) {
    if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == "textContent") {
      node.__polymerTextContent__ = value;
    } else {
      super._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
  /**
   * Find the parent model of this template instance.  The parent model
   * is either another templatize instance that had option `parentModel: true`,
   * or else the host element.
   *
   * @return {!Polymer_PropertyEffects} The parent model of this instance
   */
  get parentModel() {
    let model = this.__parentModel;
    if (!model) {
      let options;
      model = this;
      do {
        model = model.__dataHost.__dataHost;
      } while ((options = model.__templatizeOptions) && !options.parentModel);
      this.__parentModel = model;
    }
    return model;
  }
  /**
   * Stub of HTMLElement's `dispatchEvent`, so that effects that may
   * dispatch events safely no-op.
   *
   * @param {Event} event Event to dispatch
   * @return {boolean} Always true.
   * @override
   */
  dispatchEvent(event) {
    return true;
  }
}
TemplateInstanceBase.prototype.__dataHost;
TemplateInstanceBase.prototype.__templatizeOptions;
TemplateInstanceBase.prototype._methodHost;
TemplateInstanceBase.prototype.__templatizeOwner;
TemplateInstanceBase.prototype.__hostProps;
const MutableTemplateInstanceBase = MutableData(
  // This cast shouldn't be neccessary, but Closure doesn't understand that
  // TemplateInstanceBase is a constructor function.
  /** @type {function(new:TemplateInstanceBase)} */
  TemplateInstanceBase
);
function findMethodHost(template2) {
  let templateHost = template2.__dataHost;
  return templateHost && templateHost._methodHost || templateHost;
}
function createTemplatizerClass(template2, templateInfo, options) {
  let templatizerBase = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;
  if (templatize.mixin) {
    templatizerBase = templatize.mixin(templatizerBase);
  }
  let klass = class extends templatizerBase {
  };
  klass.prototype.__templatizeOptions = options;
  klass.prototype._bindTemplate(template2);
  addNotifyEffects(klass, template2, templateInfo, options);
  return klass;
}
function addPropagateEffects(target, templateInfo, options, methodHost) {
  let userForwardHostProp = options.forwardHostProp;
  if (userForwardHostProp && templateInfo.hasHostProps) {
    const isTemplate = target.localName == "template";
    let klass = templateInfo.templatizeTemplateClass;
    if (!klass) {
      if (isTemplate) {
        let templatizedBase = options.mutableData ? MutableDataTemplate : DataTemplate;
        class TemplatizedTemplate extends templatizedBase {
        }
        klass = templateInfo.templatizeTemplateClass = TemplatizedTemplate;
      } else {
        const templatizedBase = target.constructor;
        class TemplatizedTemplateExtension extends templatizedBase {
        }
        klass = templateInfo.templatizeTemplateClass = TemplatizedTemplateExtension;
      }
      let hostProps = templateInfo.hostProps;
      for (let prop in hostProps) {
        klass.prototype._addPropertyEffect(
          "_host_" + prop,
          klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE,
          { fn: createForwardHostPropEffect(prop, userForwardHostProp) }
        );
        klass.prototype._createNotifyingProperty("_host_" + prop);
      }
      if (legacyWarnings && methodHost) {
        warnOnUndeclaredProperties(templateInfo, options, methodHost);
      }
    }
    if (target.__dataProto) {
      Object.assign(target.__data, target.__dataProto);
    }
    if (isTemplate) {
      upgradeTemplate(target, klass);
      target.__dataTemp = {};
      target.__dataPending = null;
      target.__dataOld = null;
      target._enableProperties();
    } else {
      Object.setPrototypeOf(target, klass.prototype);
      const hostProps = templateInfo.hostProps;
      for (let prop in hostProps) {
        prop = "_host_" + prop;
        if (prop in target) {
          const val = target[prop];
          delete target[prop];
          target.__data[prop] = val;
        }
      }
    }
  }
}
function createForwardHostPropEffect(hostProp, userForwardHostProp) {
  return function forwardHostProp(template2, prop, props) {
    userForwardHostProp.call(
      template2.__templatizeOwner,
      prop.substring("_host_".length),
      props[prop]
    );
  };
}
function addNotifyEffects(klass, template2, templateInfo, options) {
  let hostProps = templateInfo.hostProps || {};
  for (let iprop in options.instanceProps) {
    delete hostProps[iprop];
    let userNotifyInstanceProp = options.notifyInstanceProp;
    if (userNotifyInstanceProp) {
      klass.prototype._addPropertyEffect(
        iprop,
        klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        { fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp) }
      );
    }
  }
  if (options.forwardHostProp && template2.__dataHost) {
    for (let hprop in hostProps) {
      if (!templateInfo.hasHostProps) {
        templateInfo.hasHostProps = true;
      }
      klass.prototype._addPropertyEffect(
        hprop,
        klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        { fn: createNotifyHostPropEffect() }
      );
    }
  }
}
function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
  return function notifyInstanceProp(inst, prop, props) {
    userNotifyInstanceProp.call(
      inst.__templatizeOwner,
      inst,
      prop,
      props[prop]
    );
  };
}
function createNotifyHostPropEffect() {
  return function notifyHostProp(inst, prop, props) {
    inst.__dataHost._setPendingPropertyOrPath("_host_" + prop, props[prop], true, true);
  };
}
function templatize(template2, owner, options) {
  if (strictTemplatePolicy && !findMethodHost(template2)) {
    throw new Error("strictTemplatePolicy: template owner not trusted");
  }
  options = /** @type {!TemplatizeOptions} */
  options || {};
  if (template2.__templatizeOwner) {
    throw new Error("A <template> can only be templatized once");
  }
  template2.__templatizeOwner = owner;
  const ctor = owner ? owner.constructor : TemplateInstanceBase;
  let templateInfo = ctor._parseTemplate(template2);
  let baseClass = templateInfo.templatizeInstanceClass;
  if (!baseClass) {
    baseClass = createTemplatizerClass(template2, templateInfo, options);
    templateInfo.templatizeInstanceClass = baseClass;
  }
  const methodHost = findMethodHost(template2);
  addPropagateEffects(template2, templateInfo, options, methodHost);
  let klass = class TemplateInstance extends baseClass {
  };
  klass.prototype._methodHost = methodHost;
  klass.prototype.__dataHost = /** @type {!DataTemplate} */
  template2;
  klass.prototype.__templatizeOwner = /** @type {!Object} */
  owner;
  klass.prototype.__hostProps = templateInfo.hostProps;
  klass = /** @type {function(new:TemplateInstanceBase)} */
  klass;
  return klass;
}
function warnOnUndeclaredProperties(templateInfo, options, methodHost) {
  const declaredProps = methodHost.constructor._properties;
  const { propertyEffects } = templateInfo;
  const { instanceProps } = options;
  for (let prop in propertyEffects) {
    if (!declaredProps[prop] && !(instanceProps && instanceProps[prop])) {
      const effects = propertyEffects[prop];
      for (let i2 = 0; i2 < effects.length; i2++) {
        const { part } = effects[i2].info;
        if (!(part.signature && part.signature.static)) {
          console.warn(`Property '${prop}' used in template but not declared in 'properties'; attribute will not be observed.`);
          break;
        }
      }
    }
  }
}
function modelForElement(template2, node) {
  let model;
  while (node) {
    if (model = node.__dataHost ? node : node.__templatizeInstance) {
      if (model.__dataHost != template2) {
        node = model.__dataHost;
      } else {
        return model;
      }
    } else {
      node = wrap$1(node).parentNode;
    }
  }
  return null;
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
class DomIfBase extends PolymerElement {
  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() {
    return "dom-if";
  }
  static get template() {
    return null;
  }
  static get properties() {
    return {
      /**
       * Fired whenever DOM is added or removed/hidden by this template (by
       * default, rendering occurs lazily).  To force immediate rendering, call
       * `render`.
       *
       * @event dom-change
       */
      /**
       * A boolean indicating whether this template should stamp.
       */
      if: {
        type: Boolean,
        observer: "__debounceRender"
      },
      /**
       * When true, elements will be removed from DOM and discarded when `if`
       * becomes false and re-created and added back to the DOM when `if`
       * becomes true.  By default, stamped elements will be hidden but left
       * in the DOM when `if` becomes false, which is generally results
       * in better performance.
       */
      restamp: {
        type: Boolean,
        observer: "__debounceRender"
      },
      /**
       * When the global `suppressTemplateNotifications` setting is used, setting
       * `notifyDomChange: true` will enable firing `dom-change` events on this
       * element.
       */
      notifyDomChange: {
        type: Boolean
      }
    };
  }
  constructor() {
    super();
    this.__renderDebouncer = null;
    this._lastIf = false;
    this.__hideTemplateChildren__ = false;
    this.__template;
    this._templateInfo;
  }
  __debounceRender() {
    this.__renderDebouncer = Debouncer2.debounce(
      this.__renderDebouncer,
      microTask$1,
      () => this.__render()
    );
    enqueueDebouncer(this.__renderDebouncer);
  }
  /**
   * @override
   * @return {void}
   */
  disconnectedCallback() {
    super.disconnectedCallback();
    const parent = wrap$1(this).parentNode;
    if (!parent || parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !wrap$1(parent).host) {
      this.__teardownInstance();
    }
  }
  /**
   * @override
   * @return {void}
   */
  connectedCallback() {
    super.connectedCallback();
    if (!hideElementsGlobally()) {
      this.style.display = "none";
    }
    if (this.if) {
      this.__debounceRender();
    }
  }
  /**
   * Ensures a template has been assigned to `this.__template`.  If it has not
   * yet been, it querySelectors for it in its children and if it does not yet
   * exist (e.g. in parser-generated case), opens a mutation observer and
   * waits for it to appear (returns false if it has not yet been found,
   * otherwise true).  In the `removeNestedTemplates` case, the "template" will
   * be the `dom-if` element itself.
   *
   * @return {boolean} True when a template has been found, false otherwise
   */
  __ensureTemplate() {
    if (!this.__template) {
      const thisAsTemplate = (
        /** @type {!HTMLTemplateElement} */
        /** @type {!HTMLElement} */
        this
      );
      let template2 = thisAsTemplate._templateInfo ? thisAsTemplate : (
        /** @type {!HTMLTemplateElement} */
        wrap$1(thisAsTemplate).querySelector("template")
      );
      if (!template2) {
        let observer2 = new MutationObserver(() => {
          if (wrap$1(this).querySelector("template")) {
            observer2.disconnect();
            this.__render();
          } else {
            throw new Error("dom-if requires a <template> child");
          }
        });
        observer2.observe(this, { childList: true });
        return false;
      }
      this.__template = template2;
    }
    return true;
  }
  /**
   * Ensures a an instance of the template has been created and inserted. This
   * method may return false if the template has not yet been found or if
   * there is no `parentNode` to insert the template into (in either case,
   * connection or the template-finding mutation observer firing will queue
   * another render, causing this method to be called again at a more
   * appropriate time).
   *
   * Subclasses should implement the following methods called here:
   * - `__hasInstance`
   * - `__createAndInsertInstance`
   * - `__getInstanceNodes`
   *
   * @return {boolean} True if the instance was created, false otherwise.
   */
  __ensureInstance() {
    let parentNode = wrap$1(this).parentNode;
    if (!this.__hasInstance()) {
      if (!parentNode) {
        return false;
      }
      if (!this.__ensureTemplate()) {
        return false;
      }
      this.__createAndInsertInstance(parentNode);
    } else {
      let children = this.__getInstanceNodes();
      if (children && children.length) {
        let lastChild = wrap$1(this).previousSibling;
        if (lastChild !== children[children.length - 1]) {
          for (let i2 = 0, n; i2 < children.length && (n = children[i2]); i2++) {
            wrap$1(parentNode).insertBefore(n, this);
          }
        }
      }
    }
    return true;
  }
  /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   *
   * @return {void}
   */
  render() {
    flush();
  }
  /**
   * Performs the key rendering steps:
   * 1. Ensure a template instance has been stamped (when true)
   * 2. Remove the template instance (when false and restamp:true)
   * 3. Sync the hidden state of the instance nodes with the if/restamp state
   * 4. Fires the `dom-change` event when necessary
   *
   * @return {void}
   */
  __render() {
    if (this.if) {
      if (!this.__ensureInstance()) {
        return;
      }
    } else if (this.restamp) {
      this.__teardownInstance();
    }
    this._showHideChildren();
    if ((!suppressTemplateNotifications || this.notifyDomChange) && this.if != this._lastIf) {
      this.dispatchEvent(new CustomEvent("dom-change", {
        bubbles: true,
        composed: true
      }));
      this._lastIf = this.if;
    }
  }
  // Ideally these would be annotated as abstract methods in an abstract class,
  // but closure compiler is finnicky
  /* eslint-disable valid-jsdoc */
  /**
   * Abstract API to be implemented by subclass: Returns true if a template
   * instance has been created and inserted.
   *
   * @protected
   * @return {boolean} True when an instance has been created.
   */
  __hasInstance() {
  }
  /**
   * Abstract API to be implemented by subclass: Returns the child nodes stamped
   * from a template instance.
   *
   * @protected
   * @return {Array<Node>} Array of child nodes stamped from the template
   * instance.
   */
  __getInstanceNodes() {
  }
  /**
   * Abstract API to be implemented by subclass: Creates an instance of the
   * template and inserts it into the given parent node.
   *
   * @protected
   * @param {Node} parentNode The parent node to insert the instance into
   * @return {void}
   */
  __createAndInsertInstance(parentNode) {
  }
  // eslint-disable-line no-unused-vars
  /**
   * Abstract API to be implemented by subclass: Removes nodes created by an
   * instance of a template and any associated cleanup.
   *
   * @protected
   * @return {void}
   */
  __teardownInstance() {
  }
  /**
   * Abstract API to be implemented by subclass: Shows or hides any template
   * instance childNodes based on the `if` state of the element and its
   * `__hideTemplateChildren__` property.
   *
   * @protected
   * @return {void}
   */
  _showHideChildren() {
  }
  /* eslint-enable valid-jsdoc */
}
class DomIfFast extends DomIfBase {
  constructor() {
    super();
    this.__instance = null;
    this.__syncInfo = null;
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {boolean} True when an instance has been created.
   */
  __hasInstance() {
    return Boolean(this.__instance);
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {Array<Node>} Array of child nodes stamped from the template
   * instance.
   */
  __getInstanceNodes() {
    return this.__instance.templateInfo.childNodes;
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Stamps the template by calling `_stampTemplate` on the `__dataHost` of this
   * element and then inserts the resulting nodes into the given `parentNode`.
   *
   * @override
   * @param {Node} parentNode The parent node to insert the instance into
   * @return {void}
   */
  __createAndInsertInstance(parentNode) {
    const host = this.__dataHost || this;
    if (strictTemplatePolicy) {
      if (!this.__dataHost) {
        throw new Error("strictTemplatePolicy: template owner not trusted");
      }
    }
    const templateInfo = host._bindTemplate(
      /** @type {!HTMLTemplateElement} */
      this.__template,
      true
    );
    templateInfo.runEffects = (runEffects2, changedProps, hasPaths) => {
      let syncInfo = this.__syncInfo;
      if (this.if) {
        if (syncInfo) {
          this.__syncInfo = null;
          this._showHideChildren();
          changedProps = Object.assign(syncInfo.changedProps, changedProps);
        }
        runEffects2(changedProps, hasPaths);
      } else {
        if (this.__instance) {
          if (!syncInfo) {
            syncInfo = this.__syncInfo = { runEffects: runEffects2, changedProps: {} };
          }
          if (hasPaths) {
            for (const p in changedProps) {
              const rootProp = root(p);
              syncInfo.changedProps[rootProp] = this.__dataHost[rootProp];
            }
          } else {
            Object.assign(syncInfo.changedProps, changedProps);
          }
        }
      }
    };
    this.__instance = host._stampTemplate(
      /** @type {!HTMLTemplateElement} */
      this.__template,
      templateInfo
    );
    wrap$1(parentNode).insertBefore(this.__instance, this);
  }
  /**
   * Run effects for any properties that changed while the `if` was false.
   *
   * @return {void}
   */
  __syncHostProperties() {
    const syncInfo = this.__syncInfo;
    if (syncInfo) {
      this.__syncInfo = null;
      syncInfo.runEffects(syncInfo.changedProps, false);
    }
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Remove the instance and any nodes it created.  Uses the `__dataHost`'s
   * runtime `_removeBoundDom` method.
   *
   * @override
   * @return {void}
   */
  __teardownInstance() {
    const host = this.__dataHost || this;
    if (this.__instance) {
      host._removeBoundDom(this.__instance);
      this.__instance = null;
      this.__syncInfo = null;
    }
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Shows or hides the template instance top level child nodes. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   *
   * @override
   * @return {void}
   * @protected
   * @suppress {visibility}
   */
  _showHideChildren() {
    const hidden = this.__hideTemplateChildren__ || !this.if;
    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {
      this.__instance.__hidden = hidden;
      showHideChildren(hidden, this.__instance.templateInfo.childNodes);
    }
    if (!hidden) {
      this.__syncHostProperties();
    }
  }
}
class DomIfLegacy extends DomIfBase {
  constructor() {
    super();
    this.__ctor = null;
    this.__instance = null;
    this.__invalidProps = null;
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {boolean} True when an instance has been created.
   */
  __hasInstance() {
    return Boolean(this.__instance);
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {Array<Node>} Array of child nodes stamped from the template
   * instance.
   */
  __getInstanceNodes() {
    return this.__instance.children;
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Stamps the template by creating a new instance of the templatized
   * constructor (which is created lazily if it does not yet exist), and then
   * inserts its resulting `root` doc fragment into the given `parentNode`.
   *
   * @override
   * @param {Node} parentNode The parent node to insert the instance into
   * @return {void}
   */
  __createAndInsertInstance(parentNode) {
    if (!this.__ctor) {
      this.__ctor = templatize(
        /** @type {!HTMLTemplateElement} */
        this.__template,
        this,
        {
          // dom-if templatizer instances require `mutable: true`, as
          // `__syncHostProperties` relies on that behavior to sync objects
          mutableData: true,
          /**
           * @param {string} prop Property to forward
           * @param {*} value Value of property
           * @this {DomIfLegacy}
           */
          forwardHostProp: function(prop, value) {
            if (this.__instance) {
              if (this.if) {
                this.__instance.forwardHostProp(prop, value);
              } else {
                this.__invalidProps = this.__invalidProps || /* @__PURE__ */ Object.create(null);
                this.__invalidProps[root(prop)] = true;
              }
            }
          }
        }
      );
    }
    this.__instance = new this.__ctor();
    wrap$1(parentNode).insertBefore(this.__instance.root, this);
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Removes the instance and any nodes it created.
   *
   * @override
   * @return {void}
   */
  __teardownInstance() {
    if (this.__instance) {
      let c$ = this.__instance.children;
      if (c$ && c$.length) {
        let parent = wrap$1(c$[0]).parentNode;
        if (parent) {
          parent = wrap$1(parent);
          for (let i2 = 0, n; i2 < c$.length && (n = c$[i2]); i2++) {
            parent.removeChild(n);
          }
        }
      }
      this.__invalidProps = null;
      this.__instance = null;
    }
  }
  /**
   * Forwards any properties that changed while the `if` was false into the
   * template instance and flushes it.
   *
   * @return {void}
   */
  __syncHostProperties() {
    let props = this.__invalidProps;
    if (props) {
      this.__invalidProps = null;
      for (let prop in props) {
        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
      }
      this.__instance._flushProperties();
    }
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   *
   * @override
   * @protected
   * @return {void}
   * @suppress {visibility}
   */
  _showHideChildren() {
    const hidden = this.__hideTemplateChildren__ || !this.if;
    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {
      this.__instance.__hidden = hidden;
      this.__instance._showHideChildren(hidden);
    }
    if (!hidden) {
      this.__syncHostProperties();
    }
  }
}
const DomIf = fastDomIf ? DomIfFast : DomIfLegacy;
customElements.define(DomIf.is, DomIf);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
((_a = window.ShadyDOM) == null ? void 0 : _a.inUse) && ((_b = window.ShadyDOM) == null ? void 0 : _b.noPatch) === true ? window.ShadyDOM.wrap : (node) => node;
const TemplateResultType = {
  HTML: 1,
  SVG: 2,
  MATHML: 3
};
const isTemplateResult = (value, type) => type === void 0 ? (
  // This property needs to remain unminified.
  (value == null ? void 0 : value["_$litType$"]) !== void 0
) : (value == null ? void 0 : value["_$litType$"]) === type;
const isSingleExpression = (part) => part.strings === void 0;
const RESET_VALUE = {};
const setCommittedValue = (part, value = RESET_VALUE) => part._$committedValue = value;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const notifyChildrenConnectedChanged = (parent, isConnected) => {
  var _a2;
  const children = parent._$disconnectableChildren;
  if (children === void 0) {
    return false;
  }
  for (const obj of children) {
    (_a2 = obj["_$notifyDirectiveConnectionChanged"]) == null ? void 0 : _a2.call(obj, isConnected, false);
    notifyChildrenConnectedChanged(obj, isConnected);
  }
  return true;
};
const removeDisconnectableFromParent = (obj) => {
  let parent, children;
  do {
    if ((parent = obj._$parent) === void 0) {
      break;
    }
    children = parent._$disconnectableChildren;
    children.delete(obj);
    obj = parent;
  } while ((children == null ? void 0 : children.size) === 0);
};
const addDisconnectableToParent = (obj) => {
  for (let parent; parent = obj._$parent; obj = parent) {
    let children = parent._$disconnectableChildren;
    if (children === void 0) {
      parent._$disconnectableChildren = children = /* @__PURE__ */ new Set();
    } else if (children.has(obj)) {
      break;
    }
    children.add(obj);
    installDisconnectAPI(parent);
  }
};
function reparentDisconnectables(newParent) {
  if (this._$disconnectableChildren !== void 0) {
    removeDisconnectableFromParent(this);
    this._$parent = newParent;
    addDisconnectableToParent(this);
  } else {
    this._$parent = newParent;
  }
}
function notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {
  const value = this._$committedValue;
  const children = this._$disconnectableChildren;
  if (children === void 0 || children.size === 0) {
    return;
  }
  if (isClearingValue) {
    if (Array.isArray(value)) {
      for (let i2 = fromPartIndex; i2 < value.length; i2++) {
        notifyChildrenConnectedChanged(value[i2], false);
        removeDisconnectableFromParent(value[i2]);
      }
    } else if (value != null) {
      notifyChildrenConnectedChanged(value, false);
      removeDisconnectableFromParent(value);
    }
  } else {
    notifyChildrenConnectedChanged(this, isConnected);
  }
}
const installDisconnectAPI = (obj) => {
  if (obj.type == PartType.CHILD) {
    obj._$notifyConnectionChanged ?? (obj._$notifyConnectionChanged = notifyChildPartConnectedChanged);
    obj._$reparentDisconnectables ?? (obj._$reparentDisconnectables = reparentDisconnectables);
  }
};
class AsyncDirective extends Directive {
  constructor() {
    super(...arguments);
    this._$disconnectableChildren = void 0;
  }
  /**
   * Initialize the part with internal fields
   * @param part
   * @param parent
   * @param attributeIndex
   */
  _$initialize(part, parent, attributeIndex) {
    super._$initialize(part, parent, attributeIndex);
    addDisconnectableToParent(this);
    this.isConnected = part._$isConnected;
  }
  // This property needs to remain unminified.
  /**
   * Called from the core code when a directive is going away from a part (in
   * which case `shouldRemoveFromParent` should be true), and from the
   * `setChildrenConnected` helper function when recursively changing the
   * connection state of a tree (in which case `shouldRemoveFromParent` should
   * be false).
   *
   * @param isConnected
   * @param isClearingDirective - True when the directive itself is being
   *     removed; false when the tree is being disconnected
   * @internal
   */
  ["_$notifyDirectiveConnectionChanged"](isConnected, isClearingDirective = true) {
    var _a2, _b2;
    if (isConnected !== this.isConnected) {
      this.isConnected = isConnected;
      if (isConnected) {
        (_a2 = this.reconnected) == null ? void 0 : _a2.call(this);
      } else {
        (_b2 = this.disconnected) == null ? void 0 : _b2.call(this);
      }
    }
    if (isClearingDirective) {
      notifyChildrenConnectedChanged(this, isConnected);
      removeDisconnectableFromParent(this);
    }
  }
  /**
   * Sets the value of the directive's Part outside the normal `update`/`render`
   * lifecycle of a directive.
   *
   * This method should not be called synchronously from a directive's `update`
   * or `render`.
   *
   * @param directive The directive to update
   * @param value The value to set
   */
  setValue(value) {
    if (isSingleExpression(this.__part)) {
      this.__part._$setValue(value, this);
    } else {
      if (this.__attributeIndex === void 0) {
        throw new Error(`Expected this.__attributeIndex to be a number`);
      }
      const newValues = [...this.__part._$committedValue];
      newValues[this.__attributeIndex] = value;
      this.__part._$setValue(newValues, this, 0);
    }
  }
  /**
   * User callbacks for implementing logic to release any resources/subscriptions
   * that may have been retained by this directive. Since directives may also be
   * re-connected, `reconnected` should also be implemented to restore the
   * working state of the directive prior to the next render.
   */
  disconnected() {
  }
  reconnected() {
  }
}
class FlowComponentDirective extends AsyncDirective {
  constructor(partInfo) {
    super(partInfo);
    if (partInfo.type !== PartType.CHILD) {
      throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);
    }
  }
  update(part, [appid, nodeid]) {
    this.updateContent(part, appid, nodeid);
    return noChange;
  }
  updateContent(part, appid, nodeid) {
    const { parentNode, startNode } = part;
    this.__parentNode = parentNode;
    const hasNewNodeId = nodeid !== void 0 && nodeid !== null;
    const newNode = hasNewNodeId ? this.getNewNode(appid, nodeid) : null;
    const oldNode = this.getOldNode(part);
    clearTimeout(this.__parentNode.__nodeRetryTimeout);
    if (hasNewNodeId && !newNode) {
      this.__parentNode.__nodeRetryTimeout = setTimeout(() => this.updateContent(part, appid, nodeid));
    } else if (oldNode === newNode) {
      return;
    } else if (oldNode && newNode) {
      parentNode.replaceChild(newNode, oldNode);
    } else if (oldNode) {
      parentNode.removeChild(oldNode);
    } else if (newNode) {
      startNode.after(newNode);
    }
  }
  getNewNode(appid, nodeid) {
    return window.Vaadin.Flow.clients[appid].getByNodeId(nodeid);
  }
  getOldNode(part) {
    const { startNode, endNode } = part;
    if (startNode.nextSibling === endNode) {
      return;
    }
    return startNode.nextSibling;
  }
  disconnected() {
    clearTimeout(this.__parentNode.__nodeRetryTimeout);
  }
}
const flowComponentDirective = directive(FlowComponentDirective);
function getNode(appid, nodeid) {
  return flowComponentDirective(appid, nodeid);
}
function setChildNodes(appid, nodeIds, root2) {
  render(html$1`${nodeIds.map((id) => flowComponentDirective(appid, id))}`, root2);
}
function patchVirtualContainer(container) {
  const originalInsertBefore = container.insertBefore;
  container.insertBefore = function(newNode, referenceNode) {
    if (referenceNode && referenceNode.parentNode === this) {
      return originalInsertBefore.call(this, newNode, referenceNode);
    } else {
      return originalInsertBefore.call(this, newNode, null);
    }
  };
}
window.Vaadin || (window.Vaadin = {});
(_c = window.Vaadin).FlowComponentHost || (_c.FlowComponentHost = { patchVirtualContainer, getNode, setChildNodes });
class FlowComponentRenderer extends PolymerElement {
  static get template() {
    return html`
      <style>
        :host {
          animation: 1ms flow-component-renderer-appear;
        }

        @keyframes flow-component-renderer-appear {
          to {
            opacity: 1;
          }
        }
      </style>
      <slot></slot>
    `;
  }
  static get is() {
    return "flow-component-renderer";
  }
  static get properties() {
    return {
      nodeid: Number,
      appid: String
    };
  }
  static get observers() {
    return ["_attachRenderedComponentIfAble(appid, nodeid)"];
  }
  ready() {
    super.ready();
    this.addEventListener("click", function(event) {
      if (this.firstChild && typeof this.firstChild.click === "function" && event.target === this) {
        event.stopPropagation();
        this.firstChild.click();
      }
    });
    this.addEventListener("animationend", this._onAnimationEnd);
  }
  _asyncAttachRenderedComponentIfAble() {
    this._debouncer = Debouncer2.debounce(
      this._debouncer,
      idlePeriod$1,
      () => this._attachRenderedComponentIfAble()
    );
  }
  _attachRenderedComponentIfAble() {
    if (this.appid == null) {
      return;
    }
    if (this.nodeid == null) {
      if (this.firstChild) {
        this.removeChild(this.firstChild);
      }
      return;
    }
    const renderedComponent = this._getRenderedComponent();
    if (this.firstChild) {
      if (!renderedComponent) {
        this._asyncAttachRenderedComponentIfAble();
      } else if (this.firstChild !== renderedComponent) {
        this.replaceChild(renderedComponent, this.firstChild);
        this._defineFocusTarget();
        this.onComponentRendered();
      } else {
        this._defineFocusTarget();
        this.onComponentRendered();
      }
    } else {
      if (renderedComponent) {
        this.appendChild(renderedComponent);
        this._defineFocusTarget();
        this.onComponentRendered();
      } else {
        this._asyncAttachRenderedComponentIfAble();
      }
    }
  }
  _getRenderedComponent() {
    try {
      return window.Vaadin.Flow.clients[this.appid].getByNodeId(this.nodeid);
    } catch (error) {
      console.error(
        "Could not get node %s from app %s",
        this.nodeid,
        this.appid
      );
      console.error(error);
    }
    return null;
  }
  onComponentRendered() {
  }
  /* Setting the `focus-target` attribute to the first focusable descendant
  starting from the firstChild necessary for the focus to be delegated
  within the flow-component-renderer when used inside a vaadin-grid cell  */
  _defineFocusTarget() {
    var focusable = this._getFirstFocusableDescendant(this.firstChild);
    if (focusable !== null) {
      focusable.setAttribute("focus-target", "true");
    }
  }
  _getFirstFocusableDescendant(node) {
    if (this._isFocusable(node)) {
      return node;
    }
    if (node.hasAttribute && (node.hasAttribute("disabled") || node.hasAttribute("hidden"))) {
      return null;
    }
    if (!node.children) {
      return null;
    }
    for (var i2 = 0; i2 < node.children.length; i2++) {
      var focusable = this._getFirstFocusableDescendant(node.children[i2]);
      if (focusable !== null) {
        return focusable;
      }
    }
    return null;
  }
  _isFocusable(node) {
    if (node.hasAttribute && typeof node.hasAttribute === "function" && (node.hasAttribute("disabled") || node.hasAttribute("hidden"))) {
      return false;
    }
    return node.tabIndex === 0;
  }
  _onAnimationEnd(e2) {
    if (e2.animationName.indexOf("flow-component-renderer-appear") === 0) {
      this._attachRenderedComponentIfAble();
    }
  }
}
window.customElements.define(FlowComponentRenderer.is, FlowComponentRenderer);
window.Vaadin.Flow.comboBoxConnector = {};
window.Vaadin.Flow.comboBoxConnector.initLazy = (comboBox2) => {
  if (comboBox2.$connector) {
    return;
  }
  comboBox2.$connector = {};
  const pageCallbacks = {};
  let cache = {};
  let lastFilter = "";
  const placeHolder = new window.Vaadin.ComboBoxPlaceholder();
  const serverFacade = /* @__PURE__ */ (() => {
    let lastFilterSentToServer = "";
    let dataCommunicatorResetNeeded = false;
    const needsDataCommunicatorReset = () => dataCommunicatorResetNeeded = true;
    const getLastFilterSentToServer = () => lastFilterSentToServer;
    const requestData = (startIndex, endIndex, params) => {
      const count = endIndex - startIndex;
      const filter2 = params.filter;
      comboBox2.$server.setRequestedRange(startIndex, count, filter2);
      lastFilterSentToServer = filter2;
      if (dataCommunicatorResetNeeded) {
        comboBox2.$server.resetDataCommunicator();
        dataCommunicatorResetNeeded = false;
      }
    };
    return {
      needsDataCommunicatorReset,
      getLastFilterSentToServer,
      requestData
    };
  })();
  const clearPageCallbacks = (pages = Object.keys(pageCallbacks)) => {
    pages.forEach((page) => {
      pageCallbacks[page]([], comboBox2.size);
      delete pageCallbacks[page];
      const pageStart = parseInt(page) * comboBox2.pageSize;
      const pageEnd = pageStart + comboBox2.pageSize;
      const end = Math.min(pageEnd, comboBox2.filteredItems.length);
      for (let i2 = pageStart; i2 < end; i2++) {
        comboBox2.filteredItems[i2] = placeHolder;
      }
    });
  };
  comboBox2.dataProvider = function(params, callback) {
    if (params.pageSize != comboBox2.pageSize) {
      throw "Invalid pageSize";
    }
    if (comboBox2._clientSideFilter) {
      if (cache[0]) {
        performClientSideFilter(cache[0], params.filter, callback);
        return;
      } else {
        params.filter = "";
      }
    }
    const filterChanged = params.filter !== lastFilter;
    if (filterChanged) {
      cache = {};
      lastFilter = params.filter;
      this._filterDebouncer = Debouncer2.debounce(this._filterDebouncer, timeOut$1.after(500), () => {
        if (serverFacade.getLastFilterSentToServer() === params.filter) {
          serverFacade.needsDataCommunicatorReset();
        }
        if (params.filter !== lastFilter) {
          throw new Error("Expected params.filter to be '" + lastFilter + "' but was '" + params.filter + "'");
        }
        this._filterDebouncer = void 0;
        clearPageCallbacks();
        comboBox2.dataProvider(params, callback);
      });
      return;
    }
    if (this._filterDebouncer) {
      pageCallbacks[params.page] = callback;
      return;
    }
    if (cache[params.page]) {
      commitPage(params.page, callback);
    } else {
      pageCallbacks[params.page] = callback;
      const maxRangeCount = Math.max(params.pageSize * 2, 500);
      const activePages = Object.keys(pageCallbacks).map((page) => parseInt(page));
      const rangeMin = Math.min(...activePages);
      const rangeMax = Math.max(...activePages);
      if (activePages.length * params.pageSize > maxRangeCount) {
        if (params.page === rangeMin) {
          clearPageCallbacks([String(rangeMax)]);
        } else {
          clearPageCallbacks([String(rangeMin)]);
        }
        comboBox2.dataProvider(params, callback);
      } else if (rangeMax - rangeMin + 1 !== activePages.length) {
        clearPageCallbacks();
      } else {
        const startIndex = params.pageSize * rangeMin;
        const endIndex = params.pageSize * (rangeMax + 1);
        serverFacade.requestData(startIndex, endIndex, params);
      }
    }
  };
  comboBox2.$connector.clear = (start, length) => {
    const firstPageToClear = Math.floor(start / comboBox2.pageSize);
    const numberOfPagesToClear = Math.ceil(length / comboBox2.pageSize);
    for (let i2 = firstPageToClear; i2 < firstPageToClear + numberOfPagesToClear; i2++) {
      delete cache[i2];
    }
  };
  comboBox2.$connector.filter = (item2, filter2) => {
    filter2 = filter2 ? filter2.toString().toLowerCase() : "";
    return comboBox2._getItemLabel(item2, comboBox2.itemLabelPath).toString().toLowerCase().indexOf(filter2) > -1;
  };
  comboBox2.$connector.set = (index, items, filter2) => {
    if (filter2 != serverFacade.getLastFilterSentToServer()) {
      return;
    }
    if (index % comboBox2.pageSize != 0) {
      throw "Got new data to index " + index + " which is not aligned with the page size of " + comboBox2.pageSize;
    }
    if (index === 0 && items.length === 0 && pageCallbacks[0]) {
      cache[0] = [];
      return;
    }
    const firstPageToSet = index / comboBox2.pageSize;
    const updatedPageCount = Math.ceil(items.length / comboBox2.pageSize);
    for (let i2 = 0; i2 < updatedPageCount; i2++) {
      let page = firstPageToSet + i2;
      let slice = items.slice(i2 * comboBox2.pageSize, (i2 + 1) * comboBox2.pageSize);
      cache[page] = slice;
    }
  };
  comboBox2.$connector.updateData = (items) => {
    const itemsMap = new Map(items.map((item2) => [item2.key, item2]));
    comboBox2.filteredItems = comboBox2.filteredItems.map((item2) => {
      return itemsMap.get(item2.key) || item2;
    });
  };
  comboBox2.$connector.updateSize = function(newSize) {
    if (!comboBox2._clientSideFilter) {
      comboBox2.size = newSize;
    }
  };
  comboBox2.$connector.reset = function() {
    clearPageCallbacks();
    cache = {};
    comboBox2.clearCache();
  };
  comboBox2.$connector.confirm = function(id, filter2) {
    if (filter2 != serverFacade.getLastFilterSentToServer()) {
      return;
    }
    let activePages = Object.getOwnPropertyNames(pageCallbacks);
    for (let i2 = 0; i2 < activePages.length; i2++) {
      let page = activePages[i2];
      if (cache[page]) {
        commitPage(page, pageCallbacks[page]);
      }
    }
    comboBox2.$server.confirmUpdate(id);
  };
  const commitPage = function(page, callback) {
    let data = cache[page];
    if (comboBox2._clientSideFilter) {
      performClientSideFilter(data, comboBox2.filter, callback);
    } else {
      delete cache[page];
      callback(data, comboBox2.size);
    }
  };
  const performClientSideFilter = function(page, filter2, callback) {
    let filteredItems = page;
    if (filter2) {
      filteredItems = page.filter((item2) => comboBox2.$connector.filter(item2, filter2));
    }
    callback(filteredItems, filteredItems.length);
  };
  comboBox2.addEventListener("custom-value-set", (e2) => e2.preventDefault());
  comboBox2.itemClassNameGenerator = function(item2) {
    return item2.className || "";
  };
};
window.Vaadin.ComboBoxPlaceholder = ComboBoxPlaceholder;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const chip = css`
  :host {
    font-size: var(--lumo-font-size-xxs);
    line-height: 1;
    color: var(--lumo-body-text-color);
    border-radius: var(--lumo-border-radius-s);
    background-color: var(--lumo-contrast-20pct);
    cursor: var(--lumo-clickable-cursor);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  :host([disabled]) {
    background-color: var(--lumo-contrast-10pct);
  }

  :host([focused]) [part='remove-button'] {
    color: inherit;
  }

  :host([slot='overflow']) {
    position: relative;
    min-width: var(--lumo-size-xxs);
    margin-inline-start: var(--lumo-space-s);
  }

  :host([slot='overflow'])::before,
  :host([slot='overflow'])::after {
    position: absolute;
    content: '';
    width: 100%;
    height: 100%;
    border-left: calc(var(--lumo-space-s) / 4) solid;
    border-radius: var(--lumo-border-radius-s);
    border-color: var(--lumo-contrast-30pct);
  }

  :host([slot='overflow'])::before {
    left: calc(-1 * var(--lumo-space-s) / 2);
  }

  :host([slot='overflow'])::after {
    left: calc(-1 * var(--lumo-space-s));
  }

  :host([count='2']) {
    margin-inline-start: calc(var(--lumo-space-s) / 2);
  }

  :host([count='2'])::after {
    display: none;
  }

  :host([count='1']) {
    margin-inline-start: 0;
  }

  :host([count='1'])::before,
  :host([count='1'])::after {
    display: none;
  }

  [part='label'] {
    font-weight: 500;
    line-height: 1.25;
  }

  [part='remove-button'] {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-top: -0.3125em;
    margin-bottom: -0.3125em;
    margin-inline-start: auto;
    width: 1.25em;
    height: 1.25em;
    font-size: 1.5em;
    transition: none;
  }

  [part='remove-button']::before {
    content: var(--lumo-icons-cross);
  }

  :host([disabled]) [part='label'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
    pointer-events: none;
  }
`;
registerStyles$1("vaadin-multi-select-combo-box-chip", [fieldButton, chip], {
  moduleId: "lumo-multi-select-combo-box-chip"
});
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const multiSelectComboBoxItem = css`
  @media (any-hover: hover) {
    :host(:hover[readonly]) {
      background-color: transparent;
      cursor: default;
    }
  }
`;
registerStyles$1("vaadin-multi-select-combo-box-item", [item, comboBoxItem, multiSelectComboBoxItem], {
  moduleId: "lumo-multi-select-combo-box-item"
});
registerStyles$1(
  "vaadin-multi-select-combo-box-overlay",
  [
    overlay,
    menuOverlayCore,
    comboBoxOverlay,
    loader,
    comboBoxLoader,
    css`
      :host {
        --_vaadin-multi-select-combo-box-items-container-border-width: var(--lumo-space-xs);
        --_vaadin-multi-select-combo-box-items-container-border-style: solid;
      }
    `
  ],
  { moduleId: "lumo-multi-select-combo-box-overlay" }
);
registerStyles$1(
  "vaadin-multi-select-combo-box-container",
  css`
    :host([auto-expand-vertically]) {
      padding-block: var(--lumo-space-xs);
    }
  `,
  { moduleId: "lumo-multi-select-combo-box-container" }
);
const multiSelectComboBox$1 = css`
  :host([has-value]) {
    padding-inline-start: 0;
  }

  :host([has-value]) ::slotted(input:placeholder-shown) {
    caret-color: var(--lumo-body-text-color) !important;
  }

  [part='label'] {
    flex-shrink: 0;
  }

  /* Override input-container styles */
  [part='input-field'] ::slotted([slot='chip']),
  [part='input-field'] ::slotted([slot='overflow']) {
    min-height: auto;
    padding: 0.3125em calc(0.5em + var(--lumo-border-radius-s) / 4);
    color: var(--lumo-body-text-color);
    -webkit-mask-image: none;
    mask-image: none;
  }

  :host([auto-expand-vertically]) ::slotted([slot='chip']) {
    margin-block: calc(var(--lumo-space-xs) / 2);
  }

  ::slotted([slot='chip']:not([readonly]):not([disabled])) {
    padding-inline-end: 0;
  }

  :host([auto-expand-vertically]) ::slotted([slot='input']) {
    min-height: calc(var(--lumo-text-field-size, var(--lumo-size-m)) - 2 * var(--lumo-space-xs));
  }

  ::slotted([slot='chip']:not(:last-of-type)),
  ::slotted([slot='overflow']:not(:last-of-type)) {
    margin-inline-end: var(--lumo-space-xs);
  }

  ::slotted([slot='chip'][focused]) {
    background-color: var(--vaadin-selection-color, var(--lumo-primary-color));
    color: var(--lumo-primary-contrast-color);
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
  }

  :host([readonly][has-value]) [part='toggle-button'] {
    color: var(--lumo-contrast-60pct);
    cursor: var(--lumo-clickable-cursor);
  }
`;
registerStyles$1("vaadin-multi-select-combo-box", [inputFieldShared$1, multiSelectComboBox$1], {
  moduleId: "lumo-multi-select-combo-box"
});
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const multiSelectComboBox = css`
  :host {
    --input-min-width: var(--vaadin-multi-select-combo-box-input-min-width, 4em);
    --_chip-min-width: var(--vaadin-multi-select-combo-box-chip-min-width, 50px);
  }

  #chips {
    display: flex;
    align-items: center;
  }

  ::slotted(input) {
    box-sizing: border-box;
    flex: 1 0 var(--input-min-width);
  }

  ::slotted([slot='chip']),
  ::slotted([slot='overflow']) {
    flex: 0 1 auto;
  }

  ::slotted([slot='chip']) {
    overflow: hidden;
  }

  :host(:is([readonly], [disabled])) ::slotted(input) {
    flex-grow: 0;
    flex-basis: 0;
    padding: 0;
  }

  :host([auto-expand-vertically]) #chips {
    display: contents;
  }

  :host([auto-expand-horizontally]) [class$='container'] {
    width: auto;
  }
`;
const multiSelectComboBoxChip = css`
  :host {
    display: inline-flex;
    align-items: center;
    align-self: center;
    white-space: nowrap;
    box-sizing: border-box;
  }

  [part='label'] {
    overflow: hidden;
    text-overflow: ellipsis;
  }

  :host([hidden]),
  :host(:is([readonly], [disabled], [slot='overflow'])) [part='remove-button'] {
    display: none !important;
  }

  @media (forced-colors: active) {
    :host {
      outline: 1px solid;
      outline-offset: -1px;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-multi-select-combo-box-chip", multiSelectComboBoxChip, {
  moduleId: "vaadin-multi-select-combo-box-chip"
});
class MultiSelectComboBoxChip extends ThemableMixin(PolymerElement) {
  static get is() {
    return "vaadin-multi-select-combo-box-chip";
  }
  static get properties() {
    return {
      disabled: {
        type: Boolean,
        reflectToAttribute: true
      },
      readonly: {
        type: Boolean,
        reflectToAttribute: true
      },
      label: {
        type: String
      },
      item: {
        type: Object
      }
    };
  }
  static get template() {
    return html`
      <div part="label">[[label]]</div>
      <div part="remove-button" on-click="_onRemoveClick"></div>
    `;
  }
  /** @private */
  _onRemoveClick(event) {
    event.stopPropagation();
    this.dispatchEvent(
      new CustomEvent("item-removed", {
        detail: {
          item: this.item
        },
        bubbles: true,
        composed: true
      })
    );
  }
}
defineCustomElement(MultiSelectComboBoxChip);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1(
  "vaadin-multi-select-combo-box-container",
  css`
    #wrapper {
      display: flex;
      width: 100%;
      min-width: 0;
    }

    :host([auto-expand-vertically]) #wrapper {
      flex-wrap: wrap;
    }
  `,
  {
    moduleId: "vaadin-multi-select-combo-box-container-styles"
  }
);
let memoizedTemplate$2;
class MultiSelectComboBoxContainer extends InputContainer {
  static get is() {
    return "vaadin-multi-select-combo-box-container";
  }
  static get template() {
    if (!memoizedTemplate$2) {
      memoizedTemplate$2 = super.template.cloneNode(true);
      const content = memoizedTemplate$2.content;
      const slots = content.querySelectorAll("slot");
      const wrapper = document.createElement("div");
      wrapper.setAttribute("id", "wrapper");
      content.insertBefore(wrapper, slots[2]);
      wrapper.appendChild(slots[0]);
      wrapper.appendChild(slots[1]);
    }
    return memoizedTemplate$2;
  }
  static get properties() {
    return {
      /**
       * Set to true to not collapse selected items chips into the overflow
       * chip and instead always expand vertically, causing input field to
       * wrap into multiple lines when width is limited.
       * @attr {boolean} auto-expand-vertically
       */
      autoExpandVertically: {
        type: Boolean,
        reflectToAttribute: true
      }
    };
  }
}
defineCustomElement(MultiSelectComboBoxContainer);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MultiSelectComboBoxItem extends ComboBoxItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-multi-select-combo-box-item";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
}
defineCustomElement(MultiSelectComboBoxItem);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const multiSelectComboBoxOverlayStyles = css`
  #overlay {
    width: var(
      --vaadin-multi-select-combo-box-overlay-width,
      var(--_vaadin-multi-select-combo-box-overlay-default-width, auto)
    );
  }

  [part='content'] {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
`;
registerStyles$1("vaadin-multi-select-combo-box-overlay", [overlayStyles, multiSelectComboBoxOverlayStyles], {
  moduleId: "vaadin-multi-select-combo-box-overlay-styles"
});
class MultiSelectComboBoxOverlay extends ComboBoxOverlayMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-multi-select-combo-box-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden></div>
      <div part="overlay" id="overlay">
        <div part="loader"></div>
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
  }
}
defineCustomElement(MultiSelectComboBoxOverlay);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MultiSelectComboBoxScroller extends ComboBoxScrollerMixin(PolymerElement) {
  static get is() {
    return "vaadin-multi-select-combo-box-scroller";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          min-height: 1px;
          overflow: auto;

          /* Fixes item background from getting on top of scrollbars on Safari */
          transform: translate3d(0, 0, 0);

          /* Enable momentum scrolling on iOS */
          -webkit-overflow-scrolling: touch;

          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */
          box-shadow: 0 0 0 white;
        }

        #selector {
          border-width: var(--_vaadin-multi-select-combo-box-items-container-border-width);
          border-style: var(--_vaadin-multi-select-combo-box-items-container-border-style);
          border-color: var(--_vaadin-multi-select-combo-box-items-container-border-color, transparent);
          position: relative;
        }
      </style>
      <div id="selector">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("aria-multiselectable", "true");
  }
  /**
   * @protected
   * @override
   */
  _isItemSelected(item2, _selectedItem, itemIdPath) {
    if (item2 instanceof ComboBoxPlaceholder) {
      return false;
    }
    if (this.owner.readonly) {
      return false;
    }
    return this.owner._findIndex(item2, this.owner.selectedItems, itemIdPath) > -1;
  }
  /**
   * @param {HTMLElement} el
   * @param {number} index
   * @protected
   * @override
   */
  _updateElement(el, index) {
    super._updateElement(el, index);
    el.toggleAttribute("readonly", this.owner.readonly);
  }
}
defineCustomElement(MultiSelectComboBoxScroller);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MultiSelectComboBoxInternalMixin = (superClass) => class MultiSelectComboBoxInternalMixinClass extends ComboBoxDataProviderMixin(ComboBoxMixin(superClass)) {
  static get properties() {
    return {
      /**
       * A subset of items, filtered based on the user input.
       */
      filteredItems: {
        type: Array,
        notify: true,
        sync: true
      },
      /**
       * When true, filter string isn't cleared after selecting an item.
       */
      keepFilter: {
        type: Boolean,
        value: false
      },
      /**
       * When set to `true`, "loading" attribute is set
       * on the host and the overlay element.
       * @type {boolean}
       */
      loading: {
        type: Boolean,
        notify: true,
        sync: true
      },
      /**
       * Total number of items.
       * @type {number | undefined}
       */
      size: {
        type: Number,
        notify: true,
        observer: "_sizeChanged",
        sync: true
      },
      /**
       * Selected items to render in the dropdown
       * when the component is read-only.
       */
      selectedItems: {
        type: Array,
        value: () => []
      },
      /**
       * Set to true to group selected items at the top of the overlay.
       * @attr {boolean} selected-items-on-top
       */
      selectedItemsOnTop: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * Last input value entered by the user before value is updated.
       * Used to store `filter` property value before clearing it.
       */
      lastFilter: {
        type: String,
        notify: true,
        sync: true
      },
      /**
       * A subset of items to be shown at the top of the overlay.
       */
      topGroup: {
        type: Array,
        observer: "_topGroupChanged",
        sync: true
      },
      _target: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["_readonlyChanged(readonly)"];
  }
  /**
   * Reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.querySelector('[part="clear-button"]');
  }
  /**
   * Tag name prefix used by scroller and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-multi-select-combo-box";
  }
  constructor() {
    super();
    this.addEventListener("custom-value-set", this.__onCustomValueSet.bind(this));
  }
  /**
   * Override method inherited from the combo-box
   * to allow opening dropdown when readonly.
   * @override
   */
  open() {
    if (!this.disabled && !(this.readonly && this.selectedItems.length === 0)) {
      this.opened = true;
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this._target = this;
    this._toggleElement = this.querySelector(".toggle-button");
  }
  /** @protected */
  async _updateOverlayWidth() {
    if (!this.$ && this.updateComplete) {
      await this.updateComplete;
    }
    this.$.overlay._updateOverlayWidth();
  }
  /** @private */
  _readonlyChanged() {
    this._setDropdownItems(this.filteredItems);
  }
  /**
   * Override combo-box method to group selected
   * items at the top of the overlay.
   *
   * @protected
   * @override
   */
  _setDropdownItems(items) {
    if (this.readonly) {
      super._setDropdownItems(this.selectedItems);
      return;
    }
    if (this.filter || !this.selectedItemsOnTop) {
      super._setDropdownItems(items);
      return;
    }
    if (items && items.length && this.topGroup && this.topGroup.length) {
      const filteredItems = items.filter(
        (item2) => this._comboBox._findIndex(item2, this.topGroup, this.itemIdPath) === -1
      );
      super._setDropdownItems(this.topGroup.concat(filteredItems));
      return;
    }
    super._setDropdownItems(items);
  }
  /** @private */
  _topGroupChanged(topGroup) {
    if (topGroup) {
      this._setDropdownItems(this.filteredItems);
    }
  }
  /**
   * Override combo-box method to set correct owner for using by item renderers.
   * This needs to be done before the scroller gets added to the DOM to ensure
   * Lit directive works in case when combo-box is opened using attribute.
   *
   * @protected
   * @override
   */
  _initScroller() {
    const comboBox2 = this.getRootNode().host;
    this._comboBox = comboBox2;
    super._initScroller(comboBox2);
  }
  /**
   * Override Enter handler to keep overlay open
   * when item is selected or unselected.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onEnter(event) {
    if (this.opened) {
      event.preventDefault();
      event.stopPropagation();
      if (this.readonly) {
        this.close();
      } else if (this._hasValidInputValue()) {
        const focusedItem = this._dropdownItems[this._focusedIndex];
        this._commitValue();
        this._focusedIndex = this._dropdownItems.indexOf(focusedItem);
      }
      return;
    }
    super._onEnter(event);
  }
  /**
   * Override Escape handler to not clear
   * selected items when readonly.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (this.readonly) {
      event.stopPropagation();
      if (this.opened) {
        this.close();
      }
      return;
    }
    super._onEscape(event);
  }
  /**
   * Override from combo-box to ignore requests to clear the filter if the
   * keepFilter option is enabled. Exceptions are when the dropdown is closed,
   * so the filter is still cleared on cancel and focus out.
   * @protected
   * @override
   */
  _clearFilter() {
    if (!this.keepFilter || !this.opened) {
      super._clearFilter();
    }
  }
  /**
   * Override method from combo-box to always clear the filter when reverting
   * the input value, regardless of the keepFilter option.
   * @override
   * @protected
   */
  _revertInputValueToValue() {
    super._revertInputValueToValue();
    this.filter = "";
  }
  /**
   * @protected
   * @override
   */
  _commitValue() {
    this.lastFilter = this.filter;
    super._commitValue();
  }
  /**
   * Override method inherited from the combo-box
   * to not update focused item when readonly.
   * @protected
   * @override
   */
  _onArrowDown() {
    if (!this.readonly) {
      super._onArrowDown();
    } else if (!this.opened) {
      this.open();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not update focused item when readonly.
   * @protected
   * @override
   */
  _onArrowUp() {
    if (!this.readonly) {
      super._onArrowUp();
    } else if (!this.opened) {
      this.open();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to close dropdown on blur when readonly.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    if (!focused) {
      this._ignoreCommitValue = true;
    }
    super._setFocused(focused);
    if (!focused && this.readonly && !this._closeOnBlurIsPrevented) {
      this.close();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not commit an already selected item again
   * after closing overlay on outside click.
   * @protected
   * @override
   */
  _onClosed() {
    this._ignoreCommitValue = true;
    super._onClosed();
  }
  /**
   * Override method inherited from the combo-box
   * to not commit an already selected item again
   * on blur, which would result in un-selecting.
   * @protected
   * @override
   */
  _detectAndDispatchChange() {
    if (this._ignoreCommitValue) {
      this._ignoreCommitValue = false;
      this.clear();
      this._inputElementValue = "";
      return;
    }
    super._detectAndDispatchChange();
  }
  /**
   * @param {CustomEvent} event
   * @protected
   * @override
   */
  _overlaySelectedItemChanged(event) {
    event.stopPropagation();
    if (this.readonly) {
      return;
    }
    if (event.detail.item instanceof ComboBoxPlaceholder) {
      return;
    }
    if (this.opened) {
      this.lastFilter = this.filter;
      this.dispatchEvent(
        new CustomEvent("combo-box-item-selected", {
          detail: {
            item: event.detail.item
          }
        })
      );
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not request data provider when read-only.
   *
   * @protected
   * @override
   */
  _shouldFetchData() {
    if (this.readonly) {
      return false;
    }
    return super._shouldFetchData();
  }
  /**
   * Override method inherited from the combo-box
   * to not clear the data provider cache when read-only.
   *
   * @protected
   * @override
   */
  clearCache() {
    if (this.readonly) {
      return;
    }
    super.clearCache();
  }
  /** @private */
  __onCustomValueSet(event) {
    if (this._ignoreCommitValue) {
      event.stopImmediatePropagation();
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MultiSelectComboBoxInternal extends MultiSelectComboBoxInternalMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-multi-select-combo-box-internal";
  }
  static get template() {
    return html`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <slot></slot>

      <vaadin-multi-select-combo-box-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[_target]]"
        no-vertical-overlap
        restore-focus-node="[[inputElement]]"
      ></vaadin-multi-select-combo-box-overlay>
    `;
  }
}
defineCustomElement(MultiSelectComboBoxInternal);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MultiSelectComboBoxMixin = (superClass) => class MultiSelectComboBoxMixinClass extends InputControlMixin(ResizeMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Set to true to auto expand horizontally, causing input field to
       * grow until max width is reached.
       * @attr {boolean} auto-expand-horizontally
       */
      autoExpandHorizontally: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_autoExpandHorizontallyChanged",
        sync: true
      },
      /**
       * Set to true to not collapse selected items chips into the overflow
       * chip and instead always expand vertically, causing input field to
       * wrap into multiple lines when width is limited.
       * @attr {boolean} auto-expand-vertically
       */
      autoExpandVertically: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_autoExpandVerticallyChanged",
        sync: true
      },
      /**
       * Set true to prevent the overlay from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: {
        type: Boolean,
        sync: true
      },
      /**
       * Set to true to display the clear icon which clears the input.
       * @attr {boolean} clear-button-visible
       */
      clearButtonVisible: {
        type: Boolean,
        reflectToAttribute: true,
        observer: "_clearButtonVisibleChanged",
        value: false,
        sync: true
      },
      /**
       * A full set of items to filter the visible options from.
       * The items can be of either `String` or `Object` type.
       */
      items: {
        type: Array,
        sync: true
      },
      /**
       * A function used to generate CSS class names for dropdown
       * items and selected chips based on the item. The return
       * value should be the generated class name as a string, or
       * multiple class names separated by whitespace characters.
       */
      itemClassNameGenerator: {
        type: Object,
        observer: "__itemClassNameGeneratorChanged",
        sync: true
      },
      /**
       * The item property used for a visual representation of the item.
       * @attr {string} item-label-path
       */
      itemLabelPath: {
        type: String,
        value: "label",
        sync: true
      },
      /**
       * Path for the value of the item. If `items` is an array of objects,
       * this property is used as a string value for the selected item.
       * @attr {string} item-value-path
       */
      itemValuePath: {
        type: String,
        value: "value",
        sync: true
      },
      /**
       * Path for the id of the item, used to detect whether the item is selected.
       * @attr {string} item-id-path
       */
      itemIdPath: {
        type: String,
        sync: true
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure and default values:
       * ```
       * {
       *   // Screen reader announcement on clear button click.
       *   cleared: 'Selection cleared',
       *   // Screen reader announcement when a chip is focused.
       *   focused: ' focused. Press Backspace to remove',
       *   // Screen reader announcement when item is selected.
       *   selected: 'added to selection',
       *   // Screen reader announcement when item is deselected.
       *   deselected: 'removed from selection',
       *   // Screen reader announcement of the selected items count.
       *   // {count} is replaced with the actual count of items.
       *   total: '{count} items selected',
       * }
       * ```
       * @type {!MultiSelectComboBoxI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value: () => {
          return {
            cleared: "Selection cleared",
            focused: "focused. Press Backspace to remove",
            selected: "added to selection",
            deselected: "removed from selection",
            total: "{count} items selected"
          };
        }
      },
      /**
       * When true, filter string isn't cleared after selecting an item.
       */
      keepFilter: {
        type: Boolean,
        value: false
      },
      /**
       * True when loading items from the data provider, false otherwise.
       */
      loading: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * A space-delimited list of CSS class names to set on the overlay element.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String,
        sync: true
      },
      /**
       * When present, it specifies that the field is read-only.
       */
      readonly: {
        type: Boolean,
        value: false,
        observer: "_readonlyChanged",
        reflectToAttribute: true,
        sync: true
      },
      /**
       * The list of selected items.
       * Note: modifying the selected items creates a new array each time.
       */
      selectedItems: {
        type: Array,
        value: () => [],
        notify: true,
        sync: true
      },
      /**
       * True if the dropdown is open, false otherwise.
       */
      opened: {
        type: Boolean,
        notify: true,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Total number of items.
       */
      size: {
        type: Number,
        sync: true
      },
      /**
       * Number of items fetched at a time from the data provider.
       * @attr {number} page-size
       */
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged",
        sync: true
      },
      /**
       * Function that provides items lazily. Receives two arguments:
       *
       * - `params` - Object with the following properties:
       *   - `params.page` Requested page index
       *   - `params.pageSize` Current page size
       *   - `params.filter` Currently applied filter
       *
       * - `callback(items, size)` - Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items.
       */
      dataProvider: {
        type: Object,
        sync: true
      },
      /**
       * When true, the user can input a value that is not present in the items list.
       * @attr {boolean} allow-custom-value
       */
      allowCustomValue: {
        type: Boolean,
        value: false
      },
      /**
       * A hint to the user of what can be entered in the control.
       * The placeholder will be only displayed in the case when
       * there is no item selected.
       */
      placeholder: {
        type: String,
        observer: "_placeholderChanged",
        sync: true
      },
      /**
       * Custom function for rendering the content of every item.
       * Receives three arguments:
       *
       * - `root` The `<vaadin-multi-select-combo-box-item>` internal container DOM element.
       * - `comboBox` The reference to the `<vaadin-multi-select-combo-box>` element.
       * - `model` The object with the properties related with the rendered
       *   item, contains:
       *   - `model.index` The index of the rendered item.
       *   - `model.item` The item.
       */
      renderer: {
        type: Function,
        sync: true
      },
      /**
       * Filtering string the user has typed into the input field.
       */
      filter: {
        type: String,
        value: "",
        notify: true,
        sync: true
      },
      /**
       * A subset of items, filtered based on the user input. Filtered items
       * can be assigned directly to omit the internal filtering functionality.
       * The items can be of either `String` or `Object` type.
       */
      filteredItems: {
        type: Array,
        sync: true
      },
      /**
       * Set to true to group selected items at the top of the overlay.
       * @attr {boolean} selected-items-on-top
       */
      selectedItemsOnTop: {
        type: Boolean,
        value: false,
        sync: true
      },
      /** @private */
      value: {
        type: String
      },
      /** @private */
      _overflowItems: {
        type: Array,
        value: () => [],
        sync: true
      },
      /** @private */
      _focusedChipIndex: {
        type: Number,
        value: -1,
        observer: "_focusedChipIndexChanged"
      },
      /** @private */
      _lastFilter: {
        type: String,
        sync: true
      },
      /** @private */
      _topGroup: {
        type: Array
      }
    };
  }
  static get observers() {
    return [
      "_selectedItemsChanged(selectedItems)",
      "__updateOverflowChip(_overflow, _overflowItems, disabled, readonly)",
      "__updateTopGroup(selectedItemsOnTop, selectedItems, opened)"
    ];
  }
  /** @protected */
  get slotStyles() {
    const tag = this.localName;
    return [
      ...super.slotStyles,
      `
        ${tag}[has-value] input::placeholder {
          color: transparent !important;
          forced-color-adjust: none;
        }
      `
    ];
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  get _chips() {
    return [...this.querySelectorAll('[slot="chip"]')];
  }
  /**
   * Override a getter from `InputMixin` to compute
   * the presence of value based on `selectedItems`.
   *
   * @protected
   * @override
   */
  get _hasValue() {
    return this.selectedItems && this.selectedItems.length > 0;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this._tooltipController.setShouldShow((target) => !target.opened);
    this._inputField = this.shadowRoot.querySelector('[part="input-field"]');
    this._overflowController = new SlotController(this, "overflow", "vaadin-multi-select-combo-box-chip", {
      initializer: (chip2) => {
        chip2.addEventListener("mousedown", (e2) => this._preventBlur(e2));
        this._overflow = chip2;
      }
    });
    this.addController(this._overflowController);
    this.__updateChips();
    processTemplates(this);
  }
  /**
   * Returns true if the current input value satisfies all constraints (if any).
   * @return {boolean}
   */
  checkValidity() {
    return this.required && !this.readonly ? this._hasValue : true;
  }
  /**
   * Clears the selected items.
   */
  clear() {
    this.__updateSelection([]);
    announce(this.i18n.cleared);
  }
  /**
   * Clears the cached pages and reloads data from data provider when needed.
   */
  clearCache() {
    if (this.$ && this.$.comboBox) {
      this.$.comboBox.clearCache();
    }
  }
  /**
   * Requests an update for the content of items.
   * While performing the update, it invokes the renderer (passed in the `renderer` property) once an item.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (this.$ && this.$.comboBox) {
      this.$.comboBox.requestContentUpdate();
    }
  }
  /**
   * Override method inherited from `DisabledMixin` to forward disabled to chips.
   * @protected
   * @override
   */
  _disabledChanged(disabled, oldDisabled) {
    super._disabledChanged(disabled, oldDisabled);
    if (disabled || oldDisabled) {
      this.__updateChips();
    }
  }
  /**
   * Override method inherited from `InputMixin` to forward the input to combo-box.
   * @protected
   * @override
   */
  _inputElementChanged(input) {
    super._inputElementChanged(input);
    if (input) {
      this.$.comboBox._setInputElement(input);
    }
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._focusedChipIndex = -1;
      this._requestValidation();
    }
  }
  /**
   * Implement callback from `ResizeMixin` to update chips.
   * @protected
   * @override
   */
  _onResize() {
    this.__updateChips();
  }
  /**
   * Override method from `DelegateStateMixin` to set required state
   * using `aria-required` attribute instead of `required`, in order
   * to prevent screen readers from announcing "invalid entry".
   * @protected
   * @override
   */
  _delegateAttribute(name, value) {
    if (!this.stateTarget) {
      return;
    }
    if (name === "required") {
      this._delegateAttribute("aria-required", value ? "true" : false);
      return;
    }
    super._delegateAttribute(name, value);
  }
  /** @private */
  _autoExpandHorizontallyChanged(autoExpand, oldAutoExpand) {
    if (autoExpand || oldAutoExpand) {
      this.__updateChips();
    }
  }
  /** @private */
  _autoExpandVerticallyChanged(autoExpand, oldAutoExpand) {
    if (autoExpand || oldAutoExpand) {
      this.__updateChips();
    }
  }
  /**
   * Setting clear button visible reduces total space available
   * for rendering chips, and making it hidden increases it.
   * @private
   */
  _clearButtonVisibleChanged(visible, oldVisible) {
    if (visible || oldVisible) {
      this.__updateChips();
    }
  }
  /**
   * Implement two-way binding for the `filteredItems` property
   * that can be set on the internal combo-box element.
   *
   * @param {CustomEvent} event
   * @private
   */
  _onFilteredItemsChanged(event) {
    const { value } = event.detail;
    if (Array.isArray(value) || value == null) {
      this.filteredItems = value;
    }
  }
  /** @private */
  _readonlyChanged(readonly, oldReadonly) {
    if (readonly || oldReadonly) {
      this.__updateChips();
    }
    if (this.dataProvider) {
      this.clearCache();
    }
  }
  /** @private */
  __itemClassNameGeneratorChanged(generator, oldGenerator) {
    if (generator || oldGenerator) {
      this.__updateChips();
    }
  }
  /** @private */
  _pageSizeChanged(pageSize, oldPageSize) {
    if (Math.floor(pageSize) !== pageSize || pageSize <= 0) {
      this.pageSize = oldPageSize;
      console.error('"pageSize" value must be an integer > 0');
    }
    this.$.comboBox.pageSize = this.pageSize;
  }
  /** @private */
  _placeholderChanged(placeholder) {
    const tmpPlaceholder = this.__tmpA11yPlaceholder;
    if (tmpPlaceholder !== placeholder) {
      this.__savedPlaceholder = placeholder;
      if (tmpPlaceholder) {
        this.placeholder = tmpPlaceholder;
      }
    }
  }
  /** @private */
  _selectedItemsChanged(selectedItems) {
    this._toggleHasValue(this._hasValue);
    if (this._hasValue) {
      const tmpPlaceholder = this._mergeItemLabels(selectedItems);
      if (this.__tmpA11yPlaceholder === void 0) {
        this.__savedPlaceholder = this.placeholder;
      }
      this.__tmpA11yPlaceholder = tmpPlaceholder;
      this.placeholder = tmpPlaceholder;
    } else if (this.__tmpA11yPlaceholder !== void 0) {
      delete this.__tmpA11yPlaceholder;
      this.placeholder = this.__savedPlaceholder;
    }
    this.__updateChips();
    this.requestContentUpdate();
    if (this.opened) {
      this.$.comboBox._updateOverlayWidth();
    }
  }
  /** @private */
  _getItemLabel(item2) {
    return this.$.comboBox._getItemLabel(item2);
  }
  /** @private */
  _mergeItemLabels(items) {
    return items.map((item2) => this._getItemLabel(item2)).join(", ");
  }
  /** @private */
  _findIndex(item2, selectedItems, itemIdPath) {
    if (itemIdPath && item2) {
      for (let index = 0; index < selectedItems.length; index++) {
        if (selectedItems[index] && selectedItems[index][itemIdPath] === item2[itemIdPath]) {
          return index;
        }
      }
      return -1;
    }
    return selectedItems.indexOf(item2);
  }
  /**
   * Clear the internal combo box value and filter. Filter will not be cleared
   * when the `keepFilter` option is enabled. Using `force` can enforce clearing
   * the filter.
   * @param {boolean} force overrides the keepFilter option
   * @private
   */
  __clearInternalValue(force = false) {
    if (!this.keepFilter || force) {
      this.filter = "";
      this.$.comboBox.clear();
    } else {
      this.$.comboBox.clear();
      this._inputElementValue = this.filter;
    }
  }
  /** @private */
  __announceItem(itemLabel, isSelected, itemCount) {
    const state = isSelected ? "selected" : "deselected";
    const total = this.i18n.total.replace("{count}", itemCount || 0);
    announce(`${itemLabel} ${this.i18n[state]} ${total}`);
  }
  /** @private */
  __removeItem(item2) {
    const itemsCopy = [...this.selectedItems];
    itemsCopy.splice(itemsCopy.indexOf(item2), 1);
    this.__updateSelection(itemsCopy);
    const itemLabel = this._getItemLabel(item2);
    this.__announceItem(itemLabel, false, itemsCopy.length);
  }
  /** @private */
  __selectItem(item2) {
    const itemsCopy = [...this.selectedItems];
    const index = this._findIndex(item2, itemsCopy, this.itemIdPath);
    const itemLabel = this._getItemLabel(item2);
    let isSelected = false;
    if (index !== -1) {
      const lastFilter = this._lastFilter;
      if (lastFilter && lastFilter.toLowerCase() === itemLabel.toLowerCase()) {
        this.__clearInternalValue();
        return;
      }
      itemsCopy.splice(index, 1);
    } else {
      itemsCopy.push(item2);
      isSelected = true;
    }
    this.__updateSelection(itemsCopy);
    this.__clearInternalValue();
    this.__announceItem(itemLabel, isSelected, itemsCopy.length);
  }
  /** @private */
  __updateSelection(selectedItems) {
    this.selectedItems = selectedItems;
    this._requestValidation();
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
  }
  /** @private */
  __updateTopGroup(selectedItemsOnTop, selectedItems, opened) {
    if (!selectedItemsOnTop) {
      this._topGroup = [];
    } else if (!opened) {
      this._topGroup = [...selectedItems];
    }
  }
  /** @private */
  __createChip(item2) {
    const chip2 = document.createElement("vaadin-multi-select-combo-box-chip");
    chip2.setAttribute("slot", "chip");
    chip2.item = item2;
    chip2.disabled = this.disabled;
    chip2.readonly = this.readonly;
    const label = this._getItemLabel(item2);
    chip2.label = label;
    chip2.setAttribute("title", label);
    if (typeof this.itemClassNameGenerator === "function") {
      chip2.className = this.itemClassNameGenerator(item2);
    }
    chip2.addEventListener("item-removed", (e2) => this._onItemRemoved(e2));
    chip2.addEventListener("mousedown", (e2) => this._preventBlur(e2));
    return chip2;
  }
  /** @private */
  __getOverflowWidth() {
    const chip2 = this._overflow;
    chip2.style.visibility = "hidden";
    chip2.removeAttribute("hidden");
    const count = chip2.getAttribute("count");
    chip2.setAttribute("count", "99");
    const overflowStyle = getComputedStyle(chip2);
    const overflowWidth = chip2.clientWidth + parseInt(overflowStyle.marginInlineStart);
    chip2.setAttribute("count", count);
    chip2.setAttribute("hidden", "");
    chip2.style.visibility = "";
    return overflowWidth;
  }
  /** @private */
  async __updateChips() {
    if (!this._inputField || !this.inputElement) {
      return;
    }
    if (!this._inputField.$) {
      await this._inputField.updateComplete;
    }
    this._chips.forEach((chip2) => {
      chip2.remove();
    });
    const items = [...this.selectedItems];
    const totalWidth = this._inputField.$.wrapper.clientWidth;
    const inputWidth = parseInt(getComputedStyle(this.inputElement).flexBasis);
    let remainingWidth = totalWidth - inputWidth;
    if (items.length > 1) {
      remainingWidth -= this.__getOverflowWidth();
    }
    const chipMinWidth = parseInt(getComputedStyle(this).getPropertyValue("--_chip-min-width"));
    if (this.autoExpandHorizontally) {
      const chips = [];
      for (let i2 = items.length - 1, refNode = null; i2 >= 0; i2--) {
        const chip2 = this.__createChip(items[i2]);
        this.insertBefore(chip2, refNode);
        if (chip2.performUpdate) {
          chip2.performUpdate();
        }
        refNode = chip2;
        chips.unshift(chip2);
      }
      const overflowItems = [];
      const availableWidth = this._inputField.$.wrapper.clientWidth - this.$.chips.clientWidth;
      if (!this.autoExpandVertically && availableWidth < inputWidth) {
        while (chips.length > 1) {
          const lastChip = chips.pop();
          lastChip.remove();
          overflowItems.unshift(items.pop());
          const neededWidth = overflowItems.length > 0 ? inputWidth + this.__getOverflowWidth() : inputWidth;
          if (this._inputField.$.wrapper.clientWidth - this.$.chips.clientWidth >= neededWidth) {
            break;
          }
        }
        if (chips.length === 1) {
          chips[0].style.maxWidth = `${Math.max(chipMinWidth, remainingWidth)}px`;
        }
      }
      this._overflowItems = overflowItems;
      return;
    }
    for (let i2 = items.length - 1, refNode = null; i2 >= 0; i2--) {
      const chip2 = this.__createChip(items[i2]);
      this.insertBefore(chip2, refNode);
      if (chip2.performUpdate) {
        chip2.performUpdate();
      }
      if (!this.autoExpandVertically && this.$.chips.clientWidth > remainingWidth) {
        if (refNode === null) {
          chip2.style.maxWidth = `${Math.max(chipMinWidth, remainingWidth)}px`;
        } else {
          chip2.remove();
          break;
        }
      }
      items.pop();
      refNode = chip2;
    }
    this._overflowItems = items;
  }
  /** @private */
  __updateOverflowChip(overflow, items, disabled, readonly) {
    if (overflow) {
      const count = items.length;
      overflow.label = `${count}`;
      overflow.setAttribute("count", `${count}`);
      overflow.setAttribute("title", this._mergeItemLabels(items));
      overflow.toggleAttribute("hidden", count === 0);
      overflow.disabled = disabled;
      overflow.readonly = readonly;
    }
  }
  /** @private */
  _onClearButtonTouchend(event) {
    event.preventDefault();
    event.stopPropagation();
    this.clear();
  }
  /**
   * Override method inherited from `InputControlMixin` and clear items.
   * @protected
   * @override
   */
  _onClearButtonClick(event) {
    event.stopPropagation();
    this.clear();
  }
  /**
   * Override an event listener from `InputControlMixin` to
   * stop the change event re-targeted from the input.
   *
   * @param {!Event} event
   * @protected
   * @override
   */
  _onChange(event) {
    event.stopPropagation();
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * Do not call `super` in order to override clear
   * button logic defined in `InputControlMixin`.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (this.clearButtonVisible && this.selectedItems && this.selectedItems.length) {
      event.stopPropagation();
      this.selectedItems = [];
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    const chips = this._chips;
    if (!this.readonly && chips.length > 0) {
      switch (event.key) {
        case "Backspace":
          this._onBackSpace(chips);
          break;
        case "ArrowLeft":
          this._onArrowLeft(chips, event);
          break;
        case "ArrowRight":
          this._onArrowRight(chips, event);
          break;
        default:
          this._focusedChipIndex = -1;
          break;
      }
    }
  }
  /** @private */
  _onArrowLeft(chips, event) {
    if (this.inputElement.selectionStart !== 0) {
      return;
    }
    const idx = this._focusedChipIndex;
    if (idx !== -1) {
      event.preventDefault();
    }
    let newIdx;
    if (!this.__isRTL) {
      if (idx === -1) {
        newIdx = chips.length - 1;
      } else if (idx > 0) {
        newIdx = idx - 1;
      }
    } else if (idx === chips.length - 1) {
      newIdx = -1;
    } else if (idx > -1) {
      newIdx = idx + 1;
    }
    if (newIdx !== void 0) {
      this._focusedChipIndex = newIdx;
    }
  }
  /** @private */
  _onArrowRight(chips, event) {
    if (this.inputElement.selectionStart !== 0) {
      return;
    }
    const idx = this._focusedChipIndex;
    if (idx !== -1) {
      event.preventDefault();
    }
    let newIdx;
    if (this.__isRTL) {
      if (idx === -1) {
        newIdx = chips.length - 1;
      } else if (idx > 0) {
        newIdx = idx - 1;
      }
    } else if (idx === chips.length - 1) {
      newIdx = -1;
    } else if (idx > -1) {
      newIdx = idx + 1;
    }
    if (newIdx !== void 0) {
      this._focusedChipIndex = newIdx;
    }
  }
  /** @private */
  _onBackSpace(chips) {
    if (this.inputElement.selectionStart !== 0) {
      return;
    }
    const idx = this._focusedChipIndex;
    if (idx === -1) {
      this._focusedChipIndex = chips.length - 1;
    } else {
      this.__removeItem(chips[idx].item);
      this._focusedChipIndex = -1;
    }
  }
  /** @private */
  _focusedChipIndexChanged(focusedIndex, oldFocusedIndex) {
    if (focusedIndex > -1 || oldFocusedIndex > -1) {
      const chips = this._chips;
      chips.forEach((chip2, index) => {
        chip2.toggleAttribute("focused", index === focusedIndex);
      });
      if (focusedIndex > -1) {
        const item2 = chips[focusedIndex].item;
        const itemLabel = this._getItemLabel(item2);
        announce(`${itemLabel} ${this.i18n.focused}`);
      }
    }
  }
  /** @private */
  _onComboBoxChange() {
    const item2 = this.$.comboBox.selectedItem;
    if (item2) {
      this.__selectItem(item2);
    }
  }
  /** @private */
  _onComboBoxItemSelected(event) {
    this.__selectItem(event.detail.item);
  }
  /** @private */
  _onCustomValueSet(event) {
    event.preventDefault();
    event.stopPropagation();
    this.__clearInternalValue(true);
    this.dispatchEvent(
      new CustomEvent("custom-value-set", {
        detail: event.detail,
        composed: true,
        bubbles: true
      })
    );
  }
  /** @private */
  _onItemRemoved(event) {
    this.__removeItem(event.detail.item);
  }
  /** @private */
  _preventBlur(event) {
    event.preventDefault();
  }
  /**
   * Fired when the user sets a custom value.
   * @event custom-value-set
   * @param {string} detail the custom value
   */
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-multi-select-combo-box", [inputFieldShared, multiSelectComboBox], {
  moduleId: "vaadin-multi-select-combo-box-styles"
});
class MultiSelectComboBox extends MultiSelectComboBoxMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-multi-select-combo-box";
  }
  static get template() {
    return html`
      <div class="vaadin-multi-select-combo-box-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-multi-select-combo-box-internal
          id="comboBox"
          items="[[items]]"
          item-id-path="[[itemIdPath]]"
          item-label-path="[[itemLabelPath]]"
          item-value-path="[[itemValuePath]]"
          disabled="[[disabled]]"
          readonly="[[readonly]]"
          auto-open-disabled="[[autoOpenDisabled]]"
          allow-custom-value="[[allowCustomValue]]"
          overlay-class="[[overlayClass]]"
          data-provider="[[dataProvider]]"
          filter="{{filter}}"
          last-filter="{{_lastFilter}}"
          loading="{{loading}}"
          size="{{size}}"
          filtered-items="[[filteredItems]]"
          selected-items="[[selectedItems]]"
          selected-items-on-top="[[selectedItemsOnTop]]"
          item-class-name-generator="[[itemClassNameGenerator]]"
          top-group="[[_topGroup]]"
          opened="{{opened}}"
          renderer="[[renderer]]"
          keep-filter="[[keepFilter]]"
          theme$="[[_theme]]"
          on-combo-box-item-selected="_onComboBoxItemSelected"
          on-change="_onComboBoxChange"
          on-custom-value-set="_onCustomValueSet"
          on-filtered-items-changed="_onFilteredItemsChanged"
        >
          <vaadin-multi-select-combo-box-container
            part="input-field"
            auto-expand-vertically="[[autoExpandVertically]]"
            readonly="[[readonly]]"
            disabled="[[disabled]]"
            invalid="[[invalid]]"
            theme$="[[_theme]]"
          >
            <slot name="overflow" slot="prefix"></slot>
            <div id="chips" part="chips" slot="prefix">
              <slot name="chip"></slot>
            </div>
            <slot name="input"></slot>
            <div
              id="clearButton"
              part="clear-button"
              slot="suffix"
              on-touchend="_onClearButtonTouchend"
              aria-hidden="true"
            ></div>
            <div id="toggleButton" class="toggle-button" part="toggle-button" slot="suffix" aria-hidden="true"></div>
          </vaadin-multi-select-combo-box-container>
        </vaadin-multi-select-combo-box-internal>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
}
defineCustomElement(MultiSelectComboBox);
const dialogOverlay$1 = css`
  /* Optical centering */
  :host::before,
  :host::after {
    content: '';
    flex-basis: 0;
    flex-grow: 1;
  }

  :host::after {
    flex-grow: 1.1;
  }

  [part='overlay'] {
    border-radius: var(--lumo-border-radius-l);
    box-shadow:
      0 0 0 1px var(--lumo-shade-5pct),
      var(--lumo-box-shadow-xl);
    background-image: none;
    outline: none;
    -webkit-tap-highlight-color: transparent;
  }

  [part='content'] {
    padding: var(--lumo-space-l);
  }

  :host(:is([has-header], [has-title])) [part='header'] + [part='content'] {
    padding-top: 0;
  }

  [part='header'],
  [part='header-content'],
  [part='footer'] {
    gap: var(--lumo-space-xs) var(--lumo-space-s);
    line-height: var(--lumo-line-height-s);
  }

  [part='header'] {
    padding: var(--lumo-space-m);
    background-color: var(--lumo-base-color);
    border-radius: var(--lumo-border-radius-l) var(--lumo-border-radius-l) 0 0; /* Needed for Safari */
  }

  [part='footer'] {
    padding: var(--lumo-space-s) var(--lumo-space-m);
    background-color: var(--lumo-contrast-5pct);
    border-radius: 0 0 var(--lumo-border-radius-l) var(--lumo-border-radius-l); /* Needed for Safari */
  }

  [part='title'] {
    font-size: var(--lumo-font-size-xl);
    font-weight: 600;
    color: var(--lumo-header-text-color);
    margin-inline-start: calc(var(--lumo-space-l) - var(--lumo-space-m));
  }

  /* No padding */
  :host([theme~='no-padding']) [part='content'] {
    padding: 0 !important;
  }

  @media (min-height: 320px) {
    :host([overflow~='top']) [part='header'] {
      box-shadow: 0 1px 0 0 var(--lumo-contrast-10pct);
    }
  }

  /* Animations */

  :host([opening]),
  :host([closing]) {
    animation: 0.25s lumo-overlay-dummy-animation;
  }

  :host([opening]) [part='overlay'] {
    animation: 0.12s 0.05s vaadin-dialog-enter cubic-bezier(0.215, 0.61, 0.355, 1) both;
  }

  @keyframes vaadin-dialog-enter {
    0% {
      opacity: 0;
      transform: scale(0.95);
    }
  }

  :host([closing]) [part='overlay'] {
    animation: 0.1s 0.03s vaadin-dialog-exit cubic-bezier(0.55, 0.055, 0.675, 0.19) both;
  }

  :host([closing]) [part='backdrop'] {
    animation-delay: 0.05s;
  }

  @keyframes vaadin-dialog-exit {
    100% {
      opacity: 0;
      transform: scale(1.02);
    }
  }
`;
registerStyles$1("vaadin-dialog-overlay", [overlay, dialogOverlay$1], { moduleId: "lumo-dialog" });
registerStyles$1(
  "vaadin-confirm-dialog-overlay",
  [
    overlay,
    dialogOverlay$1,
    css`
      [part='header'] ::slotted(h3) {
        margin-top: 0 !important;
        margin-bottom: 0 !important;
        margin-inline-start: calc(var(--lumo-space-l) - var(--lumo-space-m));
      }

      [part='message'] {
        width: 25em;
        min-width: 100%;
        max-width: 100%;
      }

      ::slotted([slot$='button'][theme~='tertiary']) {
        padding-left: var(--lumo-space-s);
        padding-right: var(--lumo-space-s);
      }

      [part='cancel-button'] {
        flex-grow: 1;
      }

      @media (max-width: 360px) {
        [part='footer'] {
          flex-direction: column-reverse;
          align-items: stretch;
          padding: var(--lumo-space-s) var(--lumo-space-l);
          gap: var(--lumo-space-s);
        }

        ::slotted([slot$='button']) {
          width: 100%;
          margin: 0;
        }
      }
    `
  ],
  { moduleId: "lumo-confirm-dialog-overlay" }
);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DialogBaseMixin = (superClass) => class DialogBaseMixin extends superClass {
  static get properties() {
    return {
      /**
       * True if the overlay is currently displayed.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true
      },
      /**
       * Set to true to disable closing dialog on outside click
       * @attr {boolean} no-close-on-outside-click
       * @type {boolean}
       */
      noCloseOnOutsideClick: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to disable closing dialog on Escape press
       * @attr {boolean} no-close-on-esc
       * @type {boolean}
       */
      noCloseOnEsc: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to remove backdrop and allow click events on background elements.
       * @type {boolean}
       */
      modeless: {
        type: Boolean,
        value: false
      },
      /**
       * Set the distance of the overlay from the top of its container.
       * If a unitless number is provided, pixels are assumed.
       *
       * Note that the overlay top edge may not be the same as the viewport
       * top edge (e.g. the Lumo theme defines some spacing to prevent the
       * overlay from stretching all the way to the top of the viewport).
       */
      top: {
        type: String
      },
      /**
       * Set the distance of the overlay from the left of its container.
       * If a unitless number is provided, pixels are assumed.
       *
       * Note that the overlay left edge may not be the same as the viewport
       * left edge (e.g. the Lumo theme defines some spacing to prevent the
       * overlay from stretching all the way to the left of the viewport).
       */
      left: {
        type: String
      },
      /**
       * Set the width of the overlay.
       * If a unitless number is provided, pixels are assumed.
       */
      width: {
        type: String
      },
      /**
       * Set the height of the overlay.
       * If a unitless number is provided, pixels are assumed.
       */
      height: {
        type: String
      },
      /**
       * The `role` attribute value to be set on the overlay. Defaults to "dialog".
       *
       * @attr {string} overlay-role
       */
      overlayRole: {
        type: String,
        value: "dialog"
      }
    };
  }
  static get observers() {
    return ["__positionChanged(top, left)", "__sizeChanged(width, height)"];
  }
  /** @protected */
  ready() {
    super.ready();
    const overlay2 = this.$.overlay;
    overlay2.addEventListener("vaadin-overlay-outside-click", this._handleOutsideClick.bind(this));
    overlay2.addEventListener("vaadin-overlay-escape-press", this._handleEscPress.bind(this));
    overlay2.addEventListener("vaadin-overlay-closed", this.__handleOverlayClosed.bind(this));
    this._overlayElement = overlay2;
  }
  /** @private */
  __handleOverlayClosed() {
    this.dispatchEvent(new CustomEvent("closed"));
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this.__restoreOpened) {
      this.opened = true;
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    setTimeout(() => {
      if (!this.isConnected) {
        this.__restoreOpened = this.opened;
        this.opened = false;
      }
    });
  }
  /** @protected */
  _onOverlayOpened(e2) {
    if (e2.detail.value === false) {
      this.opened = false;
    }
  }
  /**
   * Close the dialog if `noCloseOnOutsideClick` isn't set to true
   * @private
   */
  _handleOutsideClick(e2) {
    if (this.noCloseOnOutsideClick) {
      e2.preventDefault();
    }
  }
  /**
   * Close the dialog if `noCloseOnEsc` isn't set to true
   * @private
   */
  _handleEscPress(e2) {
    if (this.noCloseOnEsc) {
      e2.preventDefault();
    }
  }
  /** @private */
  _bringOverlayToFront() {
    if (this.modeless) {
      this._overlayElement.bringToFront();
    }
  }
  /** @private */
  __positionChanged(top, left) {
    requestAnimationFrame(() => this.$.overlay.setBounds({ top, left }));
  }
  /** @private */
  __sizeChanged(width, height) {
    requestAnimationFrame(() => this.$.overlay.setBounds({ width, height }));
  }
  /**
   * Fired when the dialog is closed.
   *
   * @event closed
   */
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const dialogOverlay = css`
  [part='header'],
  [part='header-content'],
  [part='footer'] {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    flex: none;
    pointer-events: none;
    z-index: 1;
  }

  [part='header'] {
    flex-wrap: nowrap;
  }

  ::slotted([slot='header-content']),
  ::slotted([slot='title']),
  ::slotted([slot='footer']) {
    display: contents;
    pointer-events: auto;
  }

  ::slotted([slot='title']) {
    font: inherit !important;
    overflow-wrap: anywhere;
  }

  [part='header-content'] {
    flex: 1;
  }

  :host([has-title]) [part='header-content'],
  [part='footer'] {
    justify-content: flex-end;
  }

  :host(:not([has-title]):not([has-header])) [part='header'],
  :host(:not([has-header])) [part='header-content'],
  :host(:not([has-title])) [part='title'],
  :host(:not([has-footer])) [part='footer'] {
    display: none !important;
  }

  :host(:is([has-title], [has-header], [has-footer])) [part='content'] {
    height: auto;
  }

  @media (min-height: 320px) {
    :host(:is([has-title], [has-header], [has-footer])) .resizer-container {
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    :host(:is([has-title], [has-header], [has-footer])) [part='content'] {
      flex: 1;
      overflow: auto;
    }
  }

  /*
      NOTE(platosha): Make some min-width to prevent collapsing of the content
      taking the parent width, e. g., <vaadin-grid> and such.
    */
  [part='content'] {
    min-width: 12em; /* matches the default <vaadin-text-field> width */
  }

  :host([has-bounds-set]) [part='overlay'] {
    max-width: none;
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 3px solid !important;
    }
  }
`;
const resizableOverlay = css`
  [part='overlay'] {
    position: relative;
    overflow: visible;
    max-height: 100%;
    display: flex;
  }

  [part='content'] {
    box-sizing: border-box;
    height: 100%;
  }

  .resizer-container {
    overflow: auto;
    flex-grow: 1;
    border-radius: inherit; /* prevent child elements being drawn outside part=overlay */
  }

  [part='overlay'][style] .resizer-container {
    min-height: 100%;
    width: 100%;
  }

  :host(:not([resizable])) .resizer {
    display: none;
  }

  :host([resizable]) [part='title'] {
    cursor: move;
    -webkit-user-select: none;
    user-select: none;
  }

  .resizer {
    position: absolute;
    height: 16px;
    width: 16px;
  }

  .resizer.edge {
    height: 8px;
    width: 8px;
    inset: -4px;
  }

  .resizer.edge.n {
    width: auto;
    bottom: auto;
    cursor: ns-resize;
  }

  .resizer.ne {
    top: -4px;
    right: -4px;
    cursor: nesw-resize;
  }

  .resizer.edge.e {
    height: auto;
    left: auto;
    cursor: ew-resize;
  }

  .resizer.se {
    bottom: -4px;
    right: -4px;
    cursor: nwse-resize;
  }

  .resizer.edge.s {
    width: auto;
    top: auto;
    cursor: ns-resize;
  }

  .resizer.sw {
    bottom: -4px;
    left: -4px;
    cursor: nesw-resize;
  }

  .resizer.edge.w {
    height: auto;
    right: auto;
    cursor: ew-resize;
  }

  .resizer.nw {
    top: -4px;
    left: -4px;
    cursor: nwse-resize;
  }
`;
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ConfirmDialogBaseMixin = (superClass) => class ConfirmDialogBaseMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * Set the `aria-label` attribute for assistive technologies like
       * screen readers. An empty string value for this property (the
       * default) means that the `aria-label` attribute is not present.
       */
      ariaLabel: {
        type: String,
        value: ""
      },
      /**
       * Height to be set on the overlay content.
       */
      contentHeight: {
        type: String
      },
      /**
       * Width to be set on the overlay content.
       */
      contentWidth: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "__updateContentHeight(contentHeight, _overlayElement)",
      "__updateContentWidth(contentWidth, _overlayElement)"
    ];
  }
  /** @private */
  __updateDimension(overlay2, dimension, value) {
    const prop = `--_vaadin-confirm-dialog-content-${dimension}`;
    if (value) {
      overlay2.style.setProperty(prop, value);
    } else {
      overlay2.style.removeProperty(prop);
    }
  }
  /** @private */
  __updateContentHeight(height, overlay2) {
    if (overlay2) {
      this.__updateDimension(overlay2, "height", height);
    }
  }
  /** @private */
  __updateContentWidth(width, overlay2) {
    if (overlay2) {
      this.__updateDimension(overlay2, "width", width);
    }
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const confirmDialogOverlay = css`
  :host {
    --_vaadin-confirm-dialog-content-width: auto;
    --_vaadin-confirm-dialog-content-height: auto;
  }

  [part='overlay'] {
    width: var(--_vaadin-confirm-dialog-content-width);
    height: var(--_vaadin-confirm-dialog-content-height);
  }

  ::slotted([slot='header']) {
    pointer-events: auto;
  }

  /* Make buttons clickable */
  [part='footer'] > * {
    pointer-events: all;
  }
`;
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-confirm-dialog-overlay", [overlayStyles, dialogOverlay, confirmDialogOverlay], {
  moduleId: "vaadin-confirm-dialog-overlay-styles"
});
class ConfirmDialogOverlay extends OverlayMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-confirm-dialog-overlay";
  }
  static get template() {
    return html`
      <div part="backdrop" id="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <section id="resizerContainer" class="resizer-container">
          <header part="header"><slot name="header"></slot></header>
          <div part="content" id="content">
            <div part="message"><slot></slot></div>
          </div>
          <footer part="footer" role="toolbar">
            <div part="cancel-button">
              <slot name="cancel-button"></slot>
            </div>
            <div part="reject-button">
              <slot name="reject-button"></slot>
            </div>
            <div part="confirm-button">
              <slot name="confirm-button"></slot>
            </div>
          </footer>
        </section>
      </div>
    `;
  }
  /**
   * @protected
   * @override
   */
  ready() {
    super.ready();
    this.setAttribute("has-header", "");
    this.setAttribute("has-footer", "");
  }
}
defineCustomElement(ConfirmDialogOverlay);
class ConfirmDialogDialog extends ConfirmDialogBaseMixin(
  DialogBaseMixin(OverlayClassMixin(ThemePropertyMixin(PolymerElement)))
) {
  static get is() {
    return "vaadin-confirm-dialog-dialog";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: none;
        }
      </style>

      <vaadin-confirm-dialog-overlay
        id="overlay"
        opened="[[opened]]"
        on-opened-changed="_onOverlayOpened"
        on-mousedown="_bringOverlayToFront"
        on-touchstart="_bringOverlayToFront"
        theme$="[[_theme]]"
        modeless="[[modeless]]"
        with-backdrop="[[!modeless]]"
        resizable$="[[resizable]]"
        aria-label$="[[ariaLabel]]"
        restore-focus-on-close
        focus-trap
      ></vaadin-confirm-dialog-overlay>
    `;
  }
}
defineCustomElement(ConfirmDialogDialog);
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ConfirmDialogMixin = (superClass) => class ConfirmDialogMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * Sets the `aria-describedby` attribute of the overlay element.
       *
       * By default, all elements inside the message area are linked
       * through the `aria-describedby` attribute. However, there are
       * cases where this can confuse screen reader users (e.g. the dialog
       * may present a password confirmation form). For these cases,
       * it's better to associate only the elements that will help describe
       * the confirmation dialog through this API.
       */
      accessibleDescriptionRef: {
        type: String
      },
      /**
       * True if the overlay is currently displayed.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true
      },
      /**
       * Set the confirmation dialog title.
       * @type {string}
       */
      header: {
        type: String,
        value: ""
      },
      /**
       * Set the message or confirmation question.
       */
      message: {
        type: String,
        value: ""
      },
      /**
       * Text displayed on confirm-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} confirm-text
       * @type {string}
       */
      confirmText: {
        type: String,
        value: "Confirm"
      },
      /**
       * Theme for a confirm-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} confirm-theme
       * @type {string}
       */
      confirmTheme: {
        type: String,
        value: "primary"
      },
      /**
       * Set to true to disable closing dialog on Escape press
       * @attr {boolean} no-close-on-esc
       * @type {boolean}
       */
      noCloseOnEsc: {
        type: Boolean,
        value: false
      },
      /**
       * Whether to show reject button or not.
       * @attr {boolean} reject-button-visible
       * @type {boolean}
       */
      rejectButtonVisible: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      },
      /**
       * Text displayed on reject-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} reject-text
       * @type {string}
       */
      rejectText: {
        type: String,
        value: "Reject"
      },
      /**
       * Theme for a reject-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} reject-theme
       * @type {string}
       */
      rejectTheme: {
        type: String,
        value: "error tertiary"
      },
      /**
       * Whether to show cancel button or not.
       * @attr {boolean} cancel-button-visible
       * @type {boolean}
       */
      cancelButtonVisible: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      },
      /**
       * Text displayed on cancel-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} cancel-text
       * @type {string}
       */
      cancelText: {
        type: String,
        value: "Cancel"
      },
      /**
       * Theme for a cancel-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} cancel-theme
       * @type {string}
       */
      cancelTheme: {
        type: String,
        value: "tertiary"
      },
      /**
       * A space-delimited list of CSS class names
       * to set on the underlying overlay element.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * A reference to the "Cancel" button which will be teleported to the overlay.
       * @private
       */
      _cancelButton: {
        type: Object
      },
      /**
       * A reference to the "Confirm" button which will be teleported to the overlay.
       * @private
       */
      _confirmButton: {
        type: Object
      },
      /**
       * A reference to the "header" node which will be teleported to the overlay.
       * @private
       */
      _headerNode: {
        type: Object
      },
      /**
       * A list of message nodes which will be placed in the overlay default slot.
       * @private
       */
      _messageNodes: {
        type: Array,
        value: () => []
      },
      /**
       * A reference to the overlay element.
       * @private
       */
      _overlayElement: {
        type: Object,
        sync: true
      },
      /**
       * A reference to the "Reject" button which will be teleported to the overlay.
       * @private
       */
      _rejectButton: {
        type: Object
      },
      /**
       * Height to be set on the overlay content.
       * @protected
       */
      _contentHeight: {
        type: String
      },
      /**
       * Width to be set on the overlay content.
       * @protected
       */
      _contentWidth: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "__updateConfirmButton(_confirmButton, confirmText, confirmTheme)",
      "__updateCancelButton(_cancelButton, cancelText, cancelTheme, cancelButtonVisible)",
      "__updateHeaderNode(_headerNode, header)",
      "__updateMessageNodes(_messageNodes, message)",
      "__updateRejectButton(_rejectButton, rejectText, rejectTheme, rejectButtonVisible)",
      "__accessibleDescriptionRefChanged(_overlayElement, _messageNodes, accessibleDescriptionRef)"
    ];
  }
  constructor() {
    super();
    this.__cancel = this.__cancel.bind(this);
    this.__confirm = this.__confirm.bind(this);
    this.__reject = this.__reject.bind(this);
  }
  get __slottedNodes() {
    return [this._headerNode, ...this._messageNodes, this._cancelButton, this._confirmButton, this._rejectButton];
  }
  /** @protected */
  ready() {
    super.ready();
    this._headerController = new SlotController(this, "header", "h3", {
      initializer: (node) => {
        this._headerNode = node;
      }
    });
    this.addController(this._headerController);
    this._messageController = new SlotController(this, "", "div", {
      // Allow providing multiple custom nodes in the default slot
      multiple: true,
      observe: false,
      initializer: (node) => {
        const wrapper = document.createElement("div");
        wrapper.style.display = "contents";
        const wrapperId = `confirm-dialog-message-${generateUniqueId()}`;
        wrapper.id = wrapperId;
        this.appendChild(wrapper);
        wrapper.appendChild(node);
        this._messageNodes = [...this._messageNodes, wrapper];
      }
    });
    this.addController(this._messageController);
    this._cancelController = new SlotController(this, "cancel-button", "vaadin-button", {
      initializer: (button2) => {
        this.__setupSlottedButton("cancel", button2);
      }
    });
    this.addController(this._cancelController);
    this._rejectController = new SlotController(this, "reject-button", "vaadin-button", {
      initializer: (button2) => {
        this.__setupSlottedButton("reject", button2);
      }
    });
    this.addController(this._rejectController);
    this._confirmController = new SlotController(this, "confirm-button", "vaadin-button", {
      initializer: (button2) => {
        this.__setupSlottedButton("confirm", button2);
      }
    });
    this.addController(this._confirmController);
  }
  /** @protected */
  _initOverlay(overlay2) {
    overlay2.addEventListener("vaadin-overlay-escape-press", this._escPressed.bind(this));
    overlay2.addEventListener("vaadin-overlay-open", () => this.__onDialogOpened());
    overlay2.addEventListener("vaadin-overlay-closed", () => this.__onDialogClosed());
    overlay2.setAttribute("role", "alertdialog");
  }
  /** @private */
  __onDialogOpened() {
    const overlay2 = this._overlayElement;
    this.__slottedNodes.forEach((node) => {
      overlay2.appendChild(node);
    });
    const confirmButton = overlay2.querySelector('[slot="confirm-button"]');
    if (confirmButton) {
      confirmButton.focus();
    }
  }
  /** @private */
  __onDialogClosed() {
    this.__slottedNodes.forEach((node) => {
      this.appendChild(node);
    });
    this.dispatchEvent(new CustomEvent("closed"));
  }
  /** @private */
  __accessibleDescriptionRefChanged(overlay2, messageNodes, accessibleDescriptionRef) {
    if (!overlay2 || !messageNodes) {
      return;
    }
    if (accessibleDescriptionRef !== void 0) {
      setAriaIDReference(overlay2, "aria-describedby", {
        newId: accessibleDescriptionRef,
        oldId: this.__oldAccessibleDescriptionRef,
        fromUser: true
      });
    } else {
      messageNodes.forEach((node) => {
        setAriaIDReference(overlay2, "aria-describedby", { newId: node.id });
      });
    }
    this.__oldAccessibleDescriptionRef = accessibleDescriptionRef;
  }
  /** @private */
  __setupSlottedButton(type, button2) {
    const property = `_${type}Button`;
    const listener = `__${type}`;
    if (this[property] && this[property] !== button2) {
      this[property].remove();
    }
    button2.addEventListener("click", this[listener]);
    this[property] = button2;
  }
  /** @private */
  __updateCancelButton(button2, cancelText, cancelTheme, showCancel) {
    if (button2) {
      if (button2 === this._cancelController.defaultNode) {
        button2.textContent = cancelText;
        button2.setAttribute("theme", cancelTheme);
      }
      button2.toggleAttribute("hidden", !showCancel);
    }
  }
  /** @private */
  __updateConfirmButton(button2, confirmText, confirmTheme) {
    if (button2 && button2 === this._confirmController.defaultNode) {
      button2.textContent = confirmText;
      button2.setAttribute("theme", confirmTheme);
    }
  }
  /** @private */
  __updateHeaderNode(headerNode, header) {
    if (headerNode && headerNode === this._headerController.defaultNode) {
      headerNode.textContent = header;
    }
  }
  /** @private */
  __updateMessageNodes(nodes, message) {
    if (nodes && nodes.length > 0) {
      const defaultWrapperNode = nodes.find(
        (node) => this._messageController.defaultNode && node === this._messageController.defaultNode.parentElement
      );
      if (defaultWrapperNode) {
        defaultWrapperNode.firstChild.textContent = message;
      }
    }
  }
  /** @private */
  __updateRejectButton(button2, rejectText, rejectTheme, showReject) {
    if (button2) {
      if (button2 === this._rejectController.defaultNode) {
        button2.textContent = rejectText;
        button2.setAttribute("theme", rejectTheme);
      }
      button2.toggleAttribute("hidden", !showReject);
    }
  }
  /** @private */
  _escPressed(event) {
    if (!event.defaultPrevented) {
      this.__cancel();
    }
  }
  /** @private */
  __confirm() {
    this.dispatchEvent(new CustomEvent("confirm"));
    this.opened = false;
  }
  /** @private */
  __cancel() {
    this.dispatchEvent(new CustomEvent("cancel"));
    this.opened = false;
  }
  /** @private */
  __reject() {
    this.dispatchEvent(new CustomEvent("reject"));
    this.opened = false;
  }
  /** @private */
  _getAriaLabel(header) {
    return header || "confirmation";
  }
  /**
   * Fired when the confirm dialog is closed.
   *
   * @event closed
   */
};
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ConfirmDialog extends ConfirmDialogMixin(ElementMixin(ThemePropertyMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host,
        [hidden] {
          display: none !important;
        }
      </style>

      <vaadin-confirm-dialog-dialog
        id="dialog"
        opened="{{opened}}"
        overlay-class="[[overlayClass]]"
        aria-label="[[_getAriaLabel(header)]]"
        theme$="[[_theme]]"
        no-close-on-outside-click
        no-close-on-esc="[[noCloseOnEsc]]"
        content-height="[[_contentHeight]]"
        content-width="[[_contentWidth]]"
      ></vaadin-confirm-dialog-dialog>

      <div hidden>
        <slot name="header"></slot>
        <slot></slot>
        <slot name="cancel-button"></slot>
        <slot name="reject-button"></slot>
        <slot name="confirm-button"></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-confirm-dialog";
  }
  /** @protected */
  ready() {
    super.ready();
    this._overlayElement = this.$.dialog.$.overlay;
    this._initOverlay(this._overlayElement);
  }
  /**
   * @event confirm
   * fired when Confirm button was pressed.
   */
  /**
   * @event cancel
   * fired when Cancel button or Escape key was pressed.
   */
  /**
   * @event reject
   * fired when Reject button was pressed.
   */
}
defineCustomElement(ConfirmDialog);
const contextMenuItem = css`
  /* :hover needed to workaround https://github.com/vaadin/web-components/issues/3133 */
  :host(:hover) {
    user-select: none;
    -ms-user-select: none;
    -webkit-user-select: none;
  }

  :host([role='menuitem'][menu-item-checked]) [part='checkmark']::before {
    opacity: 1;
  }

  :host([aria-haspopup='true'])::after {
    font-family: lumo-icons;
    font-size: var(--lumo-icon-size-xs);
    content: var(--lumo-icons-angle-right);
    color: var(--lumo-tertiary-text-color);
  }

  :host(:not([dir='rtl'])[aria-haspopup='true'])::after {
    margin-right: calc(var(--lumo-space-m) * -1);
    padding-left: var(--lumo-space-m);
  }

  :host([expanded]) {
    background-color: var(--lumo-primary-color-10pct);
  }

  /* RTL styles */
  :host([dir='rtl'][aria-haspopup='true'])::after {
    content: var(--lumo-icons-angle-left);
    margin-left: calc(var(--lumo-space-m) * -1);
    padding-right: var(--lumo-space-m);
  }
`;
registerStyles$1("vaadin-context-menu-item", [item, contextMenuItem], { moduleId: "lumo-context-menu-item" });
const contextMenuListBox = css`
  :host {
    --_lumo-list-box-item-selected-icon-display: block;
  }

  /* Normal item */
  [part='items'] ::slotted([role='menuitem']) {
    -webkit-tap-highlight-color: var(--lumo-primary-color-10pct);
    cursor: default;
    outline: none;
    border-radius: var(--lumo-border-radius-m);
    padding-left: calc(var(--lumo-border-radius-m) / 4);
    padding-right: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
  }

  /* Hovered item */
  /* TODO a workaround until we have "focus-follows-mouse". After that, use the hover style for focus-ring as well */
  [part='items'] ::slotted([role='menuitem']:hover:not([disabled])),
  [part='items'] ::slotted([role='menuitem'][expanded]:not([disabled])) {
    background-color: var(--lumo-primary-color-10pct);
  }

  /* RTL styles */
  :host([dir='rtl']) [part='items'] ::slotted([role='menuitem']) {
    padding-left: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
    padding-right: calc(var(--lumo-border-radius-m) / 4);
  }

  /* Focused item */
  @media (pointer: coarse) {
    [part='items'] ::slotted([role='menuitem']:hover:not([expanded]):not([disabled])) {
      background-color: transparent;
    }
  }
`;
registerStyles$1("vaadin-context-menu-list-box", [listBox, contextMenuListBox], {
  moduleId: "lumo-context-menu-list-box"
});
const contextMenuOverlay = css`
  :host([phone]) {
    /* stylelint-disable declaration-block-no-redundant-longhand-properties */
    top: 0 !important;
    right: 0 !important;
    bottom: var(--vaadin-overlay-viewport-bottom) !important;
    left: 0 !important;
    /* stylelint-enable declaration-block-no-redundant-longhand-properties */
    align-items: stretch;
    justify-content: flex-end;
  }

  /* TODO These style overrides should not be needed.
   We should instead offer a way to have non-selectable items inside the context menu. */

  :host {
    --_lumo-list-box-item-selected-icon-display: none;
    --_lumo-list-box-item-padding-left: calc(var(--lumo-space-m) + var(--lumo-border-radius-m) / 4);
  }

  [part='overlay'] {
    outline: none;
  }
`;
registerStyles$1("vaadin-context-menu-overlay", [menuOverlay, contextMenuOverlay], {
  moduleId: "lumo-context-menu-overlay"
});
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
register({
  name: "vaadin-contextmenu",
  deps: ["touchstart", "touchmove", "touchend", "contextmenu"],
  flow: {
    start: ["touchstart", "contextmenu"],
    end: ["contextmenu"]
  },
  emits: ["vaadin-contextmenu"],
  info: {
    sourceEvent: null
  },
  reset() {
    this.info.sourceEvent = null;
    this._cancelTimer();
    this.info.touchJob = null;
    this.info.touchStartCoords = null;
  },
  _cancelTimer() {
    if (this._timerId) {
      clearTimeout(this._timerId);
      delete this._fired;
    }
  },
  _setSourceEvent(e2) {
    this.info.sourceEvent = e2;
    const path = e2.composedPath();
    this.info.sourceEvent.__composedPath = path;
  },
  touchstart(e2) {
    this._setSourceEvent(e2);
    this.info.touchStartCoords = {
      x: e2.changedTouches[0].clientX,
      y: e2.changedTouches[0].clientY
    };
    const t2 = e2.composedPath()[0] || e2.target;
    this._timerId = setTimeout(() => {
      const ct = e2.changedTouches[0];
      if (!e2.shiftKey) {
        if (isIOS) {
          this._fired = true;
          this.fire(t2, ct.clientX, ct.clientY);
        }
        prevent("tap");
      }
    }, 500);
  },
  touchmove(e2) {
    const moveThreshold = 15;
    const touchStartCoords = this.info.touchStartCoords;
    if (Math.abs(touchStartCoords.x - e2.changedTouches[0].clientX) > moveThreshold || Math.abs(touchStartCoords.y - e2.changedTouches[0].clientY) > moveThreshold) {
      this._cancelTimer();
    }
  },
  touchend(e2) {
    if (this._fired) {
      e2.preventDefault();
    }
    this._cancelTimer();
  },
  contextmenu(e2) {
    if (!e2.shiftKey) {
      this._setSourceEvent(e2);
      this.fire(e2.target, e2.clientX, e2.clientY);
      prevent("tap");
    }
  },
  fire(target, x2, y3) {
    const sourceEvent = this.info.sourceEvent;
    const ev = new Event("vaadin-contextmenu", { bubbles: true, cancelable: true, composed: true });
    ev.detail = { x: x2, y: y3, sourceEvent };
    target.dispatchEvent(ev);
    if (ev.defaultPrevented && sourceEvent && sourceEvent.preventDefault) {
      sourceEvent.preventDefault();
    }
  }
});
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ContextMenuItem extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-context-menu-item";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menuitem");
  }
}
defineCustomElement(ContextMenuItem);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ContextMenuListBox extends ListMixin(ThemableMixin(DirMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-context-menu-list-box";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='items'] {
          height: 100%;
          width: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }
      </style>
      <div part="items">
        <slot></slot>
      </div>
    `;
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        readOnly: true
      }
    };
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menu");
  }
}
defineCustomElement(ContextMenuListBox);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MenuOverlayMixin = (superClass) => class MenuOverlayMixin extends OverlayFocusMixin(PositionMixin(superClass)) {
  static get properties() {
    return {
      /**
       * @protected
       */
      parentOverlay: {
        type: Object,
        readOnly: true
      },
      /**
       * @protected
       */
      _theme: {
        type: String,
        readOnly: true,
        sync: true
      }
    };
  }
  static get observers() {
    return ["_themeChanged(_theme)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.restoreFocusOnClose = true;
    this.addEventListener("keydown", (e2) => {
      if (!e2.defaultPrevented && e2.composedPath()[0] === this.$.overlay && [38, 40].indexOf(e2.keyCode) > -1) {
        const child = this.getFirstChild();
        if (child && Array.isArray(child.items) && child.items.length) {
          e2.preventDefault();
          if (e2.keyCode === 38) {
            child.items[child.items.length - 1].focus();
          } else {
            child.focus();
          }
        }
      }
    });
  }
  /**
   * Returns the first element in the overlay content.
   *
   * @returns {HTMLElement}
   */
  getFirstChild() {
    return this.querySelector(":not(style):not(slot)");
  }
  /** @private */
  _themeChanged() {
    this.close();
  }
  /**
   * Returns the adjusted boundaries of the overlay.
   *
   * @returns {object}
   */
  getBoundaries() {
    const overlayRect = this.getBoundingClientRect();
    const contentRect = this.$.overlay.getBoundingClientRect();
    let yMax = overlayRect.bottom - contentRect.height;
    const parent = this.parentOverlay;
    if (parent && parent.hasAttribute("bottom-aligned")) {
      const parentStyle = getComputedStyle(parent);
      yMax = yMax - parseFloat(parentStyle.bottom) - parseFloat(parentStyle.height);
    }
    return {
      xMax: overlayRect.right - contentRect.width,
      xMin: overlayRect.left + contentRect.width,
      yMax
    };
  }
  /**
   * @protected
   * @override
   */
  _updatePosition() {
    super._updatePosition();
    if (this.positionTarget && this.parentOverlay) {
      const content = this.$.content;
      const style = getComputedStyle(content);
      const isLeftAligned = !!this.style.left;
      if (isLeftAligned) {
        this.style.left = `${parseFloat(this.style.left) + parseFloat(style.paddingLeft)}px`;
      } else {
        this.style.right = `${parseFloat(this.style.right) + parseFloat(style.paddingRight)}px`;
      }
      const isBottomAligned = !!this.style.bottom;
      if (isBottomAligned) {
        this.style.bottom = `${parseFloat(this.style.bottom) - parseFloat(style.paddingBottom)}px`;
      } else {
        this.style.top = `${parseFloat(this.style.top) - parseFloat(style.paddingTop)}px`;
      }
    }
  }
  /**
   * Override method inherited from `OverlayFocusMixin` to disable
   * focus restoration on sub-menu overlay close. Focus should
   * be only restored when the root menu closes.
   *
   * @protected
   * @override
   * @return {boolean}
   */
  _shouldRestoreFocus() {
    if (this.parentOverlay) {
      return false;
    }
    return super._shouldRestoreFocus();
  }
  /**
   * Override method inherited from `OverlayFocusMixin` to return
   * true if the overlay contains the given node, including
   * those within descendant menu overlays.
   *
   * @protected
   * @override
   * @param {Node} node
   * @return {boolean}
   */
  _deepContains(node) {
    let overlay2 = getClosestElement(this.localName, node);
    while (overlay2) {
      if (overlay2 === this) {
        return true;
      }
      overlay2 = overlay2.parentOverlay;
    }
    return false;
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const styles = css`
  :host {
    align-items: flex-start;
    justify-content: flex-start;
  }

  :host([right-aligned]),
  :host([end-aligned]) {
    align-items: flex-end;
  }

  :host([bottom-aligned]) {
    justify-content: flex-end;
  }

  [part='overlay'] {
    background-color: #fff;
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 3px solid !important;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-context-menu-overlay", [overlayStyles, styles], {
  moduleId: "vaadin-context-menu-overlay-styles"
});
class ContextMenuOverlay extends MenuOverlayMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-context-menu-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
}
defineCustomElement(ContextMenuOverlay);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MediaQueryController {
  constructor(query, callback) {
    this.query = query;
    this.callback = callback;
    this._boundQueryHandler = this._queryHandler.bind(this);
  }
  hostConnected() {
    this._removeListener();
    this._mediaQuery = window.matchMedia(this.query);
    this._addListener();
    this._queryHandler(this._mediaQuery);
  }
  hostDisconnected() {
    this._removeListener();
  }
  /** @private */
  _addListener() {
    if (this._mediaQuery) {
      this._mediaQuery.addListener(this._boundQueryHandler);
    }
  }
  /** @private */
  _removeListener() {
    if (this._mediaQuery) {
      this._mediaQuery.removeListener(this._boundQueryHandler);
    }
    this._mediaQuery = null;
  }
  /** @private */
  _queryHandler(mediaQuery) {
    if (typeof this.callback === "function") {
      this.callback(mediaQuery.matches);
    }
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ItemsMixin = (superClass) => class ItemsMixin extends superClass {
  static get properties() {
    return {
      /**
       * @typedef ContextMenuItem
       * @type {object}
       * @property {string} text - Text to be set as the menu item component's textContent
       * @property {union: string | object} component - The component to represent the item.
       * Either a tagName or an element instance. Defaults to "vaadin-context-menu-item".
       * @property {boolean} disabled - If true, the item is disabled and cannot be selected
       * @property {boolean} checked - If true, the item shows a checkmark next to it
       * @property {boolean} keepOpen - If true, the menu will not be closed on item selection
       * @property {string} className - A space-delimited list of CSS class names to be set on the menu item component.
       * @property {union: string | string[]} theme - If set, sets the given theme(s) as an attribute to the menu item component, overriding any theme set on the context menu.
       * @property {MenuItem[]} children - Array of child menu items
       */
      /**
       * Defines a (hierarchical) menu structure for the component.
       * If a menu item has a non-empty `children` set, a sub-menu with the child items is opened
       * next to the parent menu on mouseover, tap or a right arrow keypress.
       *
       * The items API can't be used together with a renderer!
       *
       * #### Example
       *
       * ```javascript
       * contextMenu.items = [
       *   { text: 'Menu Item 1', theme: 'primary', className: 'first', children:
       *     [
       *       { text: 'Menu Item 1-1', checked: true, keepOpen: true },
       *       { text: 'Menu Item 1-2' }
       *     ]
       *   },
       *   { component: 'hr' },
       *   { text: 'Menu Item 2', children:
       *     [
       *       { text: 'Menu Item 2-1' },
       *       { text: 'Menu Item 2-2', disabled: true }
       *     ]
       *   },
       *   { text: 'Menu Item 3', disabled: true, className: 'last' }
       * ];
       * ```
       *
       * @type {!Array<!ContextMenuItem> | undefined}
       */
      items: {
        type: Array,
        sync: true
      }
    };
  }
  constructor() {
    super();
    this.__itemsOutsideClickListener = (e2) => {
      if (this._shouldCloseOnOutsideClick(e2)) {
        this.dispatchEvent(new CustomEvent("items-outside-click"));
      }
    };
    this.addEventListener("items-outside-click", () => {
      this.items && this.close();
    });
  }
  /**
   * Tag name prefix used by overlay, list-box and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-context-menu";
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    document.documentElement.addEventListener("click", this.__itemsOutsideClickListener);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    document.documentElement.removeEventListener("click", this.__itemsOutsideClickListener);
  }
  /**
   * Whether to close the overlay on outside click or not.
   * Override this method to customize the closing logic.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(event) {
    return !event.composedPath().some((el) => el.localName === `${this._tagNamePrefix}-overlay`);
  }
  /** @protected */
  __forwardFocus() {
    const overlay2 = this._overlayElement;
    const child = overlay2.getFirstChild();
    if (overlay2.parentOverlay) {
      const parent = overlay2.parentOverlay.querySelector("[expanded]");
      if (parent && parent.hasAttribute("focused") && child) {
        child.focus();
      } else {
        overlay2.$.overlay.focus();
      }
    } else if (child) {
      child.focus();
    }
  }
  /** @private */
  __openSubMenu(subMenu, itemElement, overlayClass) {
    subMenu.items = itemElement._item.children;
    subMenu.listenOn = itemElement;
    subMenu.overlayClass = overlayClass;
    const parent = this._overlayElement;
    const subMenuOverlay = subMenu._overlayElement;
    subMenuOverlay.positionTarget = itemElement;
    subMenuOverlay.noHorizontalOverlap = true;
    subMenuOverlay._setParentOverlay(parent);
    if (parent.hasAttribute("theme")) {
      subMenu.setAttribute("theme", parent.getAttribute("theme"));
    } else {
      subMenu.removeAttribute("theme");
    }
    const content = subMenuOverlay.$.content;
    content.style.minWidth = "";
    itemElement.dispatchEvent(
      new CustomEvent("opensubmenu", {
        detail: {
          children: itemElement._item.children
        }
      })
    );
  }
  /**
   * @param {!ContextMenuItem} item
   * @return {HTMLElement}
   * @private
   */
  __createComponent(item2) {
    let component;
    if (item2.component instanceof HTMLElement) {
      component = item2.component;
    } else {
      component = document.createElement(item2.component || `${this._tagNamePrefix}-item`);
    }
    if (component._hasVaadinItemMixin) {
      component.setAttribute("role", "menuitem");
      component.tabIndex = -1;
    }
    if (component.localName === "hr") {
      component.setAttribute("role", "separator");
    } else {
      component.setAttribute("aria-haspopup", "false");
    }
    this._setMenuItemTheme(component, item2, this._theme);
    component._item = item2;
    if (item2.text) {
      component.textContent = item2.text;
    }
    if (item2.className) {
      component.setAttribute("class", item2.className);
    }
    this.__toggleMenuComponentAttribute(component, "menu-item-checked", item2.checked);
    this.__toggleMenuComponentAttribute(component, "disabled", item2.disabled);
    if (item2.children && item2.children.length) {
      this.__updateExpanded(component, false);
      component.setAttribute("aria-haspopup", "true");
    }
    return component;
  }
  /** @private */
  __initListBox() {
    const listBox2 = document.createElement(`${this._tagNamePrefix}-list-box`);
    if (this._theme) {
      listBox2.setAttribute("theme", this._theme);
    }
    listBox2.addEventListener("selected-changed", (event) => {
      const { value } = event.detail;
      if (typeof value === "number") {
        const item2 = listBox2.items[value]._item;
        listBox2.selected = null;
        if (!item2.children) {
          this.dispatchEvent(new CustomEvent("item-selected", { detail: { value: item2 } }));
        }
      }
    });
    return listBox2;
  }
  /** @private */
  __initOverlay() {
    const overlay2 = this._overlayElement;
    overlay2.$.backdrop.addEventListener("click", () => {
      this.close();
    });
    overlay2.addEventListener(isTouch ? "click" : "mouseover", (event) => {
      this.__showSubMenu(event);
    });
    overlay2.addEventListener("keydown", (event) => {
      const { key } = event;
      const isRTL = this.__isRTL;
      const isArrowRight = key === "ArrowRight";
      const isArrowLeft = key === "ArrowLeft";
      if (!isRTL && isArrowRight || isRTL && isArrowLeft || key === "Enter" || key === " ") {
        this.__showSubMenu(event);
      } else if (!isRTL && isArrowLeft || isRTL && isArrowRight || key === "Escape") {
        if (key === "Escape") {
          event.stopPropagation();
        }
        this.close();
        this.listenOn.focus();
      } else if (key === "Tab") {
        this.dispatchEvent(new CustomEvent("close-all-menus"));
      }
    });
  }
  /** @private */
  __initSubMenu() {
    const subMenu = document.createElement(this.constructor.is);
    subMenu._modeless = true;
    subMenu.openOn = "opensubmenu";
    subMenu.setAttribute("hidden", "");
    this.addEventListener("opened-changed", (event) => {
      if (!event.detail.value) {
        this._subMenu.close();
      }
    });
    subMenu.addEventListener("close-all-menus", () => {
      this.dispatchEvent(new CustomEvent("close-all-menus"));
    });
    subMenu.addEventListener("item-selected", (event) => {
      const { detail } = event;
      this.dispatchEvent(new CustomEvent("item-selected", { detail }));
    });
    this.addEventListener("close-all-menus", () => {
      this._overlayElement.close();
    });
    this.addEventListener("item-selected", (e2) => {
      const menu = e2.target;
      const selectedItem = e2.detail.value;
      const index = menu.items.indexOf(selectedItem);
      if (!!selectedItem.keepOpen && index > -1) {
        menu._overlayElement.requestContentUpdate();
        menu._listBox._observer.flush();
        const newItem = menu._listBox.children[index];
        newItem.focus();
      } else if (!selectedItem.keepOpen) {
        this.close();
      }
    });
    subMenu.addEventListener("opened-changed", (event) => {
      if (!event.detail.value) {
        const expandedItem = this._listBox.querySelector("[expanded]");
        if (expandedItem) {
          this.__updateExpanded(expandedItem, false);
        }
      }
    });
    return subMenu;
  }
  /** @private */
  __showSubMenu(event, item2 = event.composedPath().find((node) => node.localName === `${this._tagNamePrefix}-item`)) {
    if (!this.__openListenerActive) {
      return;
    }
    if (this._overlayElement.hasAttribute("opening")) {
      requestAnimationFrame(() => {
        this.__showSubMenu(event, item2);
      });
      return;
    }
    const subMenu = this._subMenu;
    if (item2) {
      const { children } = item2._item;
      const child = subMenu._overlayElement.getFirstChild();
      const isSubmenuFocused = child && child.focused;
      if (subMenu.items !== children) {
        subMenu.close();
      }
      if (!this.opened) {
        return;
      }
      if (children && children.length) {
        this.__updateExpanded(item2, true);
        const { overlayClass } = this;
        this.__openSubMenu(subMenu, item2, overlayClass);
      } else if (isSubmenuFocused) {
        subMenu.listenOn.focus();
      } else if (!this._listBox.focused) {
        this._overlayElement.$.overlay.focus();
      }
    }
  }
  /**
   * @param {!HTMLElement} root
   * @param {!ContextMenu} menu
   * @param {!ContextMenuRendererContext} context
   * @protected
   */
  __itemsRenderer(root2, menu, { detail }) {
    this.__initMenu(root2, menu);
    const subMenu = root2.querySelector(this.constructor.is);
    subMenu.closeOn = menu.closeOn;
    const listBox2 = root2.querySelector(`${this._tagNamePrefix}-list-box`);
    listBox2.innerHTML = "";
    [...detail.children || menu.items].forEach((item2) => {
      const component = this.__createComponent(item2);
      listBox2.appendChild(component);
    });
  }
  /** @protected */
  _setMenuItemTheme(component, item2, hostTheme) {
    let theme = component.getAttribute("theme") || hostTheme;
    if (item2.theme != null) {
      theme = Array.isArray(item2.theme) ? item2.theme.join(" ") : item2.theme;
    }
    this.__updateTheme(component, theme);
  }
  /** @private */
  __toggleMenuComponentAttribute(component, attribute, on) {
    if (on) {
      component.setAttribute(attribute, "");
      component[`__has-${attribute}`] = true;
    } else if (component[`__has-${attribute}`]) {
      component.removeAttribute(attribute);
      component[`__has-${attribute}`] = false;
    }
  }
  /** @private */
  __initMenu(root2, _menu) {
    if (!root2.firstElementChild) {
      this.__initOverlay();
      const listBox2 = this.__initListBox();
      this._listBox = listBox2;
      root2.appendChild(listBox2);
      const subMenu = this.__initSubMenu();
      this._subMenu = subMenu;
      root2.appendChild(subMenu);
      requestAnimationFrame(() => {
        this.__openListenerActive = true;
      });
    } else {
      this.__updateTheme(this._listBox, this._theme);
    }
  }
  /** @private */
  __updateExpanded(component, expanded) {
    component.setAttribute("aria-expanded", expanded.toString());
    component.toggleAttribute("expanded", expanded);
  }
  /** @private */
  __updateTheme(component, theme) {
    if (theme) {
      component.setAttribute("theme", theme);
    } else {
      component.removeAttribute("theme");
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ContextMenuMixin = (superClass) => class ContextMenuMixinClass extends ItemsMixin(superClass) {
  static get properties() {
    return {
      /**
       * CSS selector that can be used to target any child element
       * of the context menu to listen for `openOn` events.
       */
      selector: {
        type: String
      },
      /**
       * True if the overlay is currently displayed.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true
      },
      /**
       * Event name to listen for opening the context menu.
       * @attr {string} open-on
       * @type {string}
       */
      openOn: {
        type: String,
        value: "vaadin-contextmenu",
        sync: true
      },
      /**
       * The target element that's listened to for context menu opening events.
       * By default the vaadin-context-menu listens to the target's `vaadin-contextmenu`
       * events.
       * @type {!HTMLElement}
       * @default self
       */
      listenOn: {
        type: Object,
        sync: true,
        value() {
          return this;
        }
      },
      /**
       * Event name to listen for closing the context menu.
       * @attr {string} close-on
       * @type {string}
       */
      closeOn: {
        type: String,
        value: "click",
        observer: "_closeOnChanged",
        sync: true
      },
      /**
       * Custom function for rendering the content of the menu overlay.
       * Receives three arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `contextMenu` The reference to the `<vaadin-context-menu>` element.
       * - `context` The object with the menu context, contains:
       *   - `context.target`  the target of the menu opening event,
       *   - `context.detail` the menu opening event detail.
       * @type {ContextMenuRenderer | undefined}
       */
      renderer: {
        type: Function,
        sync: true
      },
      /**
       * When true, the menu overlay is modeless.
       * @protected
       */
      _modeless: {
        type: Boolean,
        sync: true
      },
      /** @private */
      _context: {
        type: Object,
        sync: true
      },
      /** @private */
      _phone: {
        type: Boolean
      },
      _fullscreen: {
        type: Boolean
      },
      _fullscreenMediaQuery: {
        type: String,
        value: "(max-width: 450px), (max-height: 450px)"
      }
    };
  }
  static get observers() {
    return [
      "_openedChanged(opened)",
      "_targetOrOpenOnChanged(listenOn, openOn)",
      "_rendererChanged(renderer, items)",
      "_fullscreenChanged(_fullscreen)",
      "_overlayContextChanged(_overlayElement, _context)",
      "_overlayModelessChanged(_overlayElement, _modeless)",
      "_overlayPhoneChanged(_overlayElement, _phone)",
      "_overlayThemeChanged(_overlayElement, _theme)"
    ];
  }
  constructor() {
    super();
    this._createOverlay();
    this._boundOpen = this.open.bind(this);
    this._boundClose = this.close.bind(this);
    this._boundPreventDefault = this._preventDefault.bind(this);
    this._boundOnGlobalContextMenu = this._onGlobalContextMenu.bind(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__boundOnScroll = this.__onScroll.bind(this);
    window.addEventListener("scroll", this.__boundOnScroll, true);
    if (this.__restoreOpened) {
      this._setOpened(true);
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("scroll", this.__boundOnScroll, true);
    this.__restoreOpened = this.opened;
    this.close();
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new MediaQueryController(this._fullscreenMediaQuery, (matches2) => {
        this._fullscreen = matches2;
      })
    );
  }
  /** @private */
  _createOverlay() {
    const overlay2 = document.createElement(`${this._tagNamePrefix}-overlay`);
    overlay2.owner = this;
    overlay2.addEventListener("opened-changed", (e2) => {
      this._onOverlayOpened(e2);
    });
    overlay2.addEventListener("vaadin-overlay-open", (e2) => {
      this._onVaadinOverlayOpen(e2);
    });
    this._overlayElement = overlay2;
  }
  /**
   * Runs before overlay is fully rendered
   * @private
   */
  _onOverlayOpened(e2) {
    const opened = e2.detail.value;
    this._setOpened(opened);
    if (opened) {
      this.__alignOverlayPosition();
    }
  }
  /**
   * Runs after overlay is fully rendered
   * @private
   */
  _onVaadinOverlayOpen() {
    this.__alignOverlayPosition();
    this._overlayElement.style.opacity = "";
    this.__forwardFocus();
  }
  /** @private */
  _overlayContextChanged(overlay2, context) {
    if (overlay2) {
      overlay2.model = context;
    }
  }
  /** @private */
  _overlayModelessChanged(overlay2, modeless) {
    if (overlay2) {
      overlay2.modeless = modeless;
    }
  }
  /** @private */
  _overlayPhoneChanged(overlay2, phone) {
    if (overlay2) {
      overlay2.toggleAttribute("phone", phone);
      overlay2.withBackdrop = phone;
    }
  }
  /** @private */
  _overlayThemeChanged(overlay2, theme) {
    if (overlay2) {
      if (theme) {
        overlay2.setAttribute("theme", theme);
      } else {
        overlay2.removeAttribute("theme");
      }
    }
  }
  /** @private */
  _targetOrOpenOnChanged(listenOn, openOn) {
    if (this._oldListenOn && this._oldOpenOn) {
      this._unlisten(this._oldListenOn, this._oldOpenOn, this._boundOpen);
      this._oldListenOn.style.webkitTouchCallout = "";
      this._oldListenOn.style.webkitUserSelect = "";
      this._oldListenOn.style.userSelect = "";
      this._oldListenOn = null;
      this._oldOpenOn = null;
    }
    if (listenOn && openOn) {
      this._listen(listenOn, openOn, this._boundOpen);
      this._oldListenOn = listenOn;
      this._oldOpenOn = openOn;
    }
  }
  /** @private */
  _fullscreenChanged(fullScreen) {
    this._phone = fullScreen;
  }
  /** @private */
  _setListenOnUserSelect(value) {
    this.listenOn.style.webkitTouchCallout = value;
    this.listenOn.style.webkitUserSelect = value;
    this.listenOn.style.userSelect = value;
    document.getSelection().removeAllRanges();
  }
  /** @private */
  _closeOnChanged(closeOn, oldCloseOn) {
    const evtOverlay = "vaadin-overlay-outside-click";
    const overlay2 = this._overlayElement;
    if (oldCloseOn) {
      this._unlisten(overlay2, oldCloseOn, this._boundClose);
    }
    if (closeOn) {
      this._listen(overlay2, closeOn, this._boundClose);
      overlay2.removeEventListener(evtOverlay, this._boundPreventDefault);
    } else {
      overlay2.addEventListener(evtOverlay, this._boundPreventDefault);
    }
  }
  /** @private */
  _preventDefault(e2) {
    e2.preventDefault();
  }
  /** @private */
  _openedChanged(opened) {
    if (opened) {
      document.documentElement.addEventListener("contextmenu", this._boundOnGlobalContextMenu, true);
      this._setListenOnUserSelect("none");
    } else {
      document.documentElement.removeEventListener("contextmenu", this._boundOnGlobalContextMenu, true);
      this._setListenOnUserSelect("");
    }
    this._overlayElement.opened = opened;
  }
  /**
   * Requests an update for the content of the menu overlay.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this._overlayElement || !this.renderer) {
      return;
    }
    this._overlayElement.requestContentUpdate();
  }
  /** @private */
  _rendererChanged(renderer, items) {
    if (items) {
      if (renderer) {
        throw new Error("The items API cannot be used together with a renderer");
      }
      if (this.closeOn === "click") {
        this.closeOn = "";
      }
      renderer = this.__itemsRenderer;
    }
    this._overlayElement.renderer = renderer;
  }
  /**
   * Closes the overlay.
   */
  close() {
    this._setOpened(false);
  }
  /** @private */
  _contextTarget(e2) {
    if (this.selector) {
      const targets = this.listenOn.querySelectorAll(this.selector);
      return Array.prototype.filter.call(targets, (el) => {
        return e2.composedPath().indexOf(el) > -1;
      })[0];
    }
    return e2.target;
  }
  /**
   * Opens the overlay.
   * @param {!Event | undefined} e used as the context for the menu. Overlay coordinates are taken from this event.
   */
  open(e2) {
    if (e2 && !this.opened) {
      this._context = {
        detail: e2.detail,
        target: this._contextTarget(e2)
      };
      if (this._context.target) {
        e2.preventDefault();
        e2.stopPropagation();
        this.__x = this._getEventCoordinate(e2, "x");
        this.__pageXOffset = window.pageXOffset;
        this.__y = this._getEventCoordinate(e2, "y");
        this.__pageYOffset = window.pageYOffset;
        this._overlayElement.style.opacity = "0";
        this._setOpened(true);
      }
    }
  }
  /** @private */
  __onScroll() {
    if (!this.opened) {
      return;
    }
    const yDiff = window.pageYOffset - this.__pageYOffset;
    const xDiff = window.pageXOffset - this.__pageXOffset;
    this.__adjustPosition("left", -xDiff);
    this.__adjustPosition("right", xDiff);
    this.__adjustPosition("top", -yDiff);
    this.__adjustPosition("bottom", yDiff);
    this.__pageYOffset += yDiff;
    this.__pageXOffset += xDiff;
  }
  /** @private */
  __adjustPosition(coord, diff) {
    const overlay2 = this._overlayElement;
    const style = overlay2.style;
    style[coord] = `${(parseInt(style[coord]) || 0) + diff}px`;
  }
  /** @private */
  __alignOverlayPosition() {
    const overlay2 = this._overlayElement;
    if (overlay2.positionTarget) {
      return;
    }
    const style = overlay2.style;
    ["top", "right", "bottom", "left"].forEach((prop) => style.removeProperty(prop));
    ["right-aligned", "end-aligned", "bottom-aligned"].forEach((attr) => overlay2.removeAttribute(attr));
    const { xMax, xMin, yMax } = overlay2.getBoundaries();
    const x2 = this.__x;
    const y3 = this.__y;
    const wdthVport = document.documentElement.clientWidth;
    const hghtVport = document.documentElement.clientHeight;
    if (!this.__isRTL) {
      if (x2 < wdthVport / 2 || x2 < xMax) {
        style.left = `${x2}px`;
      } else {
        style.right = `${Math.max(0, wdthVport - x2)}px`;
        this._setEndAligned(overlay2);
      }
    } else if (x2 > wdthVport / 2 || x2 > xMin) {
      style.right = `${Math.max(0, wdthVport - x2)}px`;
    } else {
      style.left = `${x2}px`;
      this._setEndAligned(overlay2);
    }
    if (y3 < hghtVport / 2 || y3 < yMax) {
      style.top = `${y3}px`;
    } else {
      style.bottom = `${Math.max(0, hghtVport - y3)}px`;
      overlay2.setAttribute("bottom-aligned", "");
    }
  }
  /** @private */
  _setEndAligned(element) {
    element.setAttribute("end-aligned", "");
    if (!this.__isRTL) {
      element.setAttribute("right-aligned", "");
    }
  }
  /** @private */
  _getEventCoordinate(event, coord) {
    if (event.detail instanceof Object) {
      if (event.detail[coord]) {
        return event.detail[coord];
      } else if (event.detail.sourceEvent) {
        return this._getEventCoordinate(event.detail.sourceEvent, coord);
      }
    } else {
      const prop = `client${coord.toUpperCase()}`;
      const position = event.changedTouches ? event.changedTouches[0][prop] : event[prop];
      if (position === 0) {
        const rect = event.target.getBoundingClientRect();
        return coord === "x" ? rect.left : rect.top + rect.height;
      }
      return position;
    }
  }
  /** @private */
  _listen(node, evType, handler) {
    if (gestures[evType]) {
      addListener(node, evType, handler);
    } else {
      node.addEventListener(evType, handler);
    }
  }
  /** @private */
  _unlisten(node, evType, handler) {
    if (gestures[evType]) {
      removeListener(node, evType, handler);
    } else {
      node.removeEventListener(evType, handler);
    }
  }
  /** @private */
  __createMouseEvent(name, clientX, clientY) {
    return new MouseEvent(name, {
      bubbles: true,
      composed: true,
      cancelable: true,
      clientX,
      clientY
    });
  }
  /** @private */
  __focusClosestFocusable(target) {
    let currentElement = target;
    while (currentElement) {
      if (currentElement instanceof HTMLElement && isElementFocusable(currentElement)) {
        currentElement.focus();
        return;
      }
      currentElement = currentElement.parentNode || currentElement.host;
    }
  }
  /**
   * Executes a synthetic contextmenu event on the target under the coordinates.
   * @private
   */
  __contextMenuAt(x2, y3) {
    const target = deepTargetFind(x2, y3);
    if (target) {
      queueMicrotask(() => {
        target.dispatchEvent(this.__createMouseEvent("mousedown", x2, y3));
        target.dispatchEvent(this.__createMouseEvent("mouseup", x2, y3));
        this.__focusClosestFocusable(target);
        target.dispatchEvent(this.__createMouseEvent("contextmenu", x2, y3));
      });
    }
  }
  /** @private */
  _onGlobalContextMenu(e2) {
    if (!e2.shiftKey) {
      const isTouchDevice = isAndroid || isIOS;
      if (!isTouchDevice) {
        e2.stopPropagation();
        this._overlayElement.__focusRestorationController.focusNode = null;
        this._overlayElement.addEventListener(
          "vaadin-overlay-closed",
          () => this.__contextMenuAt(e2.clientX, e2.clientY),
          {
            once: true
          }
        );
      }
      e2.preventDefault();
      this.close();
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ContextMenu extends ContextMenuMixin(
  OverlayClassMixin(ControllerMixin(ElementMixin(ThemePropertyMixin(PolymerElement))))
) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>

      <slot id="slot"></slot>
    `;
  }
  static get is() {
    return "vaadin-context-menu";
  }
  /** @protected */
  ready() {
    super.ready();
    processTemplates(this);
  }
  /**
   * @param {DocumentFragment} dom
   * @return {null}
   * @protected
   * @override
   */
  _attachDom(dom) {
    const root2 = this.attachShadow({ mode: "open" });
    root2.appendChild(dom);
    root2.appendChild(this._overlayElement);
    return root2;
  }
  /**
   * Fired when an item is selected when the context menu is populated using the `items` API.
   *
   * @event item-selected
   * @param {Object} detail
   * @param {Object} detail.value the selected menu item
   */
}
defineCustomElement(ContextMenu);
function getContainer(appId, nodeId) {
  try {
    return window.Vaadin.Flow.clients[appId].getByNodeId(nodeId);
  } catch (error) {
    console.error("Could not get node %s from app %s", nodeId, appId);
    console.error(error);
  }
}
function initLazy$1(contextMenu, appId) {
  if (contextMenu.$connector) {
    return;
  }
  contextMenu.$connector = {
    /**
     * Generates and assigns the items to the context menu.
     *
     * @param {number} nodeId
     */
    generateItems(nodeId) {
      const items = generateItemsTree(appId, nodeId);
      contextMenu.items = items;
    }
  };
}
function generateItemsTree(appId, nodeId) {
  const container = getContainer(appId, nodeId);
  if (!container) {
    return;
  }
  return Array.from(container.children).map((child) => {
    const item2 = {
      component: child,
      checked: child._checked,
      keepOpen: child._keepOpen,
      className: child.className,
      theme: child.__theme
    };
    if (child._hasVaadinItemMixin && child._containerNodeId) {
      item2.children = generateItemsTree(appId, child._containerNodeId);
    }
    child._item = item2;
    return item2;
  });
}
function setChecked(component, checked) {
  if (component._item) {
    component._item.checked = checked;
    if (component._item.keepOpen) {
      component.toggleAttribute("menu-item-checked", checked);
    }
  }
}
function setKeepOpen(component, keepOpen) {
  if (component._item) {
    component._item.keepOpen = keepOpen;
  }
}
function setTheme(component, theme) {
  if (component._item) {
    component._item.theme = theme;
  }
}
window.Vaadin.Flow.contextMenuConnector = {
  initLazy: initLazy$1,
  generateItemsTree,
  setChecked,
  setKeepOpen,
  setTheme
};
function init(target) {
  if (target.$contextMenuTargetConnector) {
    return;
  }
  target.$contextMenuTargetConnector = {
    openOnHandler(e2) {
      if (target.preventContextMenu && target.preventContextMenu(e2)) {
        return;
      }
      e2.preventDefault();
      e2.stopPropagation();
      this.$contextMenuTargetConnector.openEvent = e2;
      let detail = {};
      if (target.getContextMenuBeforeOpenDetail) {
        detail = target.getContextMenuBeforeOpenDetail(e2);
      }
      target.dispatchEvent(
        new CustomEvent("vaadin-context-menu-before-open", {
          detail
        })
      );
    },
    updateOpenOn(eventType) {
      this.removeListener();
      this.openOnEventType = eventType;
      customElements.whenDefined("vaadin-context-menu").then(() => {
        if (gestures[eventType]) {
          addListener(target, eventType, this.openOnHandler);
        } else {
          target.addEventListener(eventType, this.openOnHandler);
        }
      });
    },
    removeListener() {
      if (this.openOnEventType) {
        if (gestures[this.openOnEventType]) {
          removeListener(target, this.openOnEventType, this.openOnHandler);
        } else {
          target.removeEventListener(this.openOnEventType, this.openOnHandler);
        }
      }
    },
    openMenu(contextMenu) {
      contextMenu.open(this.openEvent);
    },
    removeConnector() {
      this.removeListener();
      target.$contextMenuTargetConnector = void 0;
    }
  };
}
window.Vaadin.Flow.contextMenuTargetConnector = { init };
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const customField = css`
  :host {
    --lumo-text-field-size: var(--lumo-size-m);
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-m);
    /* align with text-field height + vertical paddings */
    line-height: calc(var(--lumo-text-field-size) + 2 * var(--lumo-space-xs));
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: 0;
  }

  :host::before {
    margin-top: var(--lumo-space-xs);
    height: var(--lumo-text-field-size);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  /* align with text-field label */
  :host([has-label]) [part='label'] {
    padding-bottom: calc(0.5em - var(--lumo-space-xs));
  }

  :host(:not([has-label])) [part='label'],
  :host(:not([has-label]))::before {
    display: none;
  }

  /* align with text-field error message */
  :host([has-error-message]) [part='error-message']::before {
    height: calc(0.4em - var(--lumo-space-xs));
  }

  :host([focused]:not([readonly]):not([disabled])) [part='label'] {
    color: var(--lumo-primary-text-color);
  }

  :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='label'],
  :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='label'] {
      color: var(--lumo-secondary-text-color);
    }
  }

  /* Disabled */
  :host([disabled]) [part='label'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  /* Small theme */
  :host([theme~='small']) {
    font-size: var(--lumo-font-size-s);
    --lumo-text-field-size: var(--lumo-size-s);
  }

  :host([theme~='small'][has-label]) [part='label'] {
    font-size: var(--lumo-font-size-xs);
  }

  :host([theme~='small'][has-label]) [part='error-message'] {
    font-size: var(--lumo-font-size-xxs);
  }

  /* When custom-field is used with components without outer margin */
  :host([theme~='whitespace'][has-label]) [part='label'] {
    padding-bottom: 0.5em;
  }
`;
registerStyles$1("vaadin-custom-field", [requiredField, helper, customField], {
  moduleId: "lumo-custom-field"
});
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const defaultParseValue = (value) => {
  return value.split("	");
};
const defaultFormatValue = (inputValues) => {
  return inputValues.join("	");
};
const CustomFieldMixin = (superClass) => class CustomFieldMixin extends FieldMixin(FocusMixin(KeyboardMixin(superClass))) {
  static get properties() {
    return {
      /**
       * The name of the control, which is submitted with the form data.
       */
      name: String,
      /**
       * The value of the field. When wrapping several inputs, it will contain `\t`
       * (Tab character) as a delimiter indicating parts intended to be used as the
       * corresponding inputs values.
       * Use the [`formatValue`](#/elements/vaadin-custom-field#property-formatValue)
       * and [`parseValue`](#/elements/vaadin-custom-field#property-parseValue)
       * properties to customize this behavior.
       */
      value: {
        type: String,
        observer: "__valueChanged",
        notify: true
      },
      /**
       * Array of available input nodes
       * @type {!Array<!HTMLElement> | undefined}
       */
      inputs: {
        type: Array,
        readOnly: true,
        observer: "__inputsChanged"
      },
      /**
       * A function to format the values of the individual fields contained by
       * the custom field into a single component value. The function receives
       * an array of all values of the individual fields in the order of their
       * presence in the DOM, and must return a single component value.
       * This function is called each time a value of an internal field is
       * changed.
       *
       * Example:
       * ```js
       * customField.formatValue = (fieldValues) => {
       *   return fieldValues.join("-");
       * }
       * ```
       * @type {!CustomFieldFormatValueFn | undefined}
       */
      formatValue: {
        type: Function
      },
      /**
       * A function to parse the component value into values for the individual
       * fields contained by the custom field. The function receives the
       * component value, and must return an array of values for the individual
       * fields in the order of their presence in the DOM.
       * The function is called each time the value of the component changes.
       *
       * Example:
       * ```js
       * customField.parseValue = (componentValue) => {
       *   return componentValue.split("-");
       * }
       * ```
       * @type {!CustomFieldParseValueFn | undefined}
       */
      parseValue: {
        type: Function
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "group");
    this.ariaTarget = this;
    this.__childrenObserver = new MutationObserver(() => {
      this.__setInputsFromSlot();
    });
    this.__setInputsFromSlot();
    this.$.slot.addEventListener("slotchange", () => {
      this.__setInputsFromSlot();
      getFlattenedElements(this.$.slot).filter((el) => !this.__isInput(el)).forEach((el) => {
        this.__childrenObserver.observe(el, { childList: true });
      });
    });
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setShouldShow((target) => {
      const inputs = target.inputs || [];
      return !inputs.some((el) => el.opened);
    });
  }
  /** @protected */
  focus() {
    if (this.inputs && this.inputs[0]) {
      this.inputs[0].focus();
    }
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this._requestValidation();
    }
  }
  /**
   * Override method inherited from `FocusMixin` to not remove focused
   * state when focus moves to another input in the custom field.
   * @param {FocusEvent} event
   * @return {boolean}
   * @protected
   */
  _shouldRemoveFocus(event) {
    const { relatedTarget } = event;
    return !this.inputs || !this.inputs.some((el) => relatedTarget === (el.focusElement || el));
  }
  /**
   * Returns true if the current inputs values satisfy all constraints (if any).
   *
   * @return {boolean}
   */
  checkValidity() {
    const hasInvalidFields = this.inputs && this.inputs.some((input) => !(input.validate || input.checkValidity).call(input));
    if (hasInvalidFields || this.required && !(this.value && this.value.trim())) {
      return false;
    }
    return true;
  }
  /**
   * Override an observer from `FieldMixin`
   * to validate when required is removed.
   *
   * @protected
   * @override
   */
  _requiredChanged(required) {
    super._requiredChanged(required);
    if (required === false) {
      this._requestValidation();
    }
  }
  /**
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onKeyDown(e2) {
    if (e2.key === "Tab") {
      const inputs = this.inputs || [];
      if (inputs.indexOf(e2.target) < inputs.length - 1 && !e2.shiftKey || inputs.indexOf(e2.target) > 0 && e2.shiftKey) {
        this.dispatchEvent(new CustomEvent("internal-tab"));
      } else {
        this.__setValue();
      }
    }
  }
  /** @protected */
  _onInputChange(event) {
    event.stopPropagation();
    this.__setValue();
    this._requestValidation();
    this.dispatchEvent(
      new CustomEvent("change", {
        bubbles: true,
        cancelable: false,
        detail: {
          value: this.value
        }
      })
    );
  }
  /** @private */
  __setValue() {
    this.__settingValue = true;
    const formatFn = this.formatValue || defaultFormatValue;
    this.value = formatFn.apply(this, [this.inputs.map((input) => input.value)]);
    this.__settingValue = false;
  }
  /** @private */
  __isInput(node) {
    const isSlottedInput = node.getAttribute("slot") === "input" || node.getAttribute("slot") === "textarea";
    return !isSlottedInput && (node.validate || node.checkValidity);
  }
  /** @private */
  __getInputsFromSlot() {
    return getFlattenedElements(this.$.slot).filter((node) => this.__isInput(node));
  }
  /** @private */
  __setInputsFromSlot() {
    this._setInputs(this.__getInputsFromSlot());
  }
  /** @private */
  __inputsChanged(inputs, oldInputs) {
    if (inputs.length === 0) {
      if (oldInputs && oldInputs.length > 0) {
        this.__setValue();
      }
      return;
    }
    if (this.value && this.value !== "	" && (!oldInputs || oldInputs.length === 0)) {
      this.__applyInputsValue(this.value);
    } else {
      this.__setValue();
    }
  }
  /** @private */
  __toggleHasValue(value) {
    this.toggleAttribute("has-value", value !== null && value.trim() !== "");
  }
  /** @private */
  __valueChanged(value, oldValue) {
    this.__toggleHasValue(value);
    if (this.__settingValue || !this.inputs) {
      return;
    }
    this.__applyInputsValue(value || "	");
    if (oldValue !== void 0) {
      this._requestValidation();
    }
  }
  /** @private */
  __applyInputsValue(value) {
    const parseFn = this.parseValue || defaultParseValue;
    const valuesArray = parseFn.apply(this, [value]);
    if (!valuesArray || valuesArray.length === 0) {
      console.warn("Value parser has not provided values array");
      return;
    }
    this.inputs.forEach((input, idx) => {
      input.value = valuesArray[idx];
    });
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const customFieldStyles = css`
  :host {
    display: inline-flex;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
    /* Size and position this element on the same vertical position as the input-field element
           to make vertical align for the host element work as expected */
  }

  :host([hidden]) {
    display: none !important;
  }

  .vaadin-custom-field-container {
    width: 100%;
    display: flex;
    flex-direction: column;
  }

  .inputs-wrapper {
    flex: none;
  }
`;
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-custom-field", customFieldStyles, { moduleId: "vaadin-custom-field-styles" });
class CustomField extends CustomFieldMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-custom-field";
  }
  static get template() {
    return html`
      <div class="vaadin-custom-field-container">
        <div part="label" on-click="focus">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div class="inputs-wrapper" part="input-fields" on-change="_onInputChange">
          <slot id="slot"></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  /**
   * Fired when the user commits a value change for any of the internal inputs.
   *
   * @event change
   */
}
defineCustomElement(CustomField);
const datePickerOverlay = css`
  [part='overlay'] {
    /*
  Width:
      date cell widths
    + month calendar side padding
    + year scroller width
  */
    /* prettier-ignore */
    width:
    calc(
        var(--lumo-size-m) * 7
      + var(--lumo-space-xs) * 2
      + 57px
    );
    height: 100%;
    max-height: calc(var(--lumo-size-m) * 14);
    overflow: hidden;
    -webkit-tap-highlight-color: transparent;
    flex-direction: column;
  }

  [part='content'] {
    padding: 0;
    height: 100%;
    overflow: hidden;
    -webkit-mask-image: none;
    mask-image: none;
  }

  :host([top-aligned]) [part~='overlay'] {
    margin-top: var(--lumo-space-xs);
  }

  :host([bottom-aligned]) [part~='overlay'] {
    margin-bottom: var(--lumo-space-xs);
  }

  @media (max-width: 450px), (max-height: 450px) {
    [part='overlay'] {
      width: 100vw;
      height: 70vh;
      max-height: 70vh;
    }
  }
`;
registerStyles$1("vaadin-date-picker-overlay", [menuOverlay, datePickerOverlay], {
  moduleId: "lumo-date-picker-overlay"
});
registerStyles$1(
  "vaadin-date-picker-year",
  css`
    :host([current]) [part='year-number'] {
      color: var(--lumo-primary-text-color);
    }

    :host(:not([current])) [part='year-number'],
    [part='year-separator'] {
      opacity: var(--_lumo-date-picker-year-opacity, 0.7);
      transition: 0.2s opacity;
    }

    [part='year-number'],
    [part='year-separator'] {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 50%;
      transform: translateY(-50%);
    }

    [part='year-separator']::after {
      color: var(--lumo-disabled-text-color);
      content: '\\2022';
    }
  `,
  { moduleId: "lumo-date-picker-year" }
);
registerStyles$1(
  "vaadin-date-picker-overlay-content",
  css`
    :host {
      position: relative;
      /* Background for the year scroller, placed here as we are using a mask image on the actual years part */
      background-image: linear-gradient(var(--lumo-shade-5pct), var(--lumo-shade-5pct));
      background-size: 57px 100%;
      background-position: top right;
      background-repeat: no-repeat;
      cursor: default;
    }

    ::slotted([slot='months']) {
      /* Month calendar height:
              header height + margin-bottom
            + weekdays height + margin-bottom
            + date cell heights
            + small margin between month calendars
        */
      /* prettier-ignore */
      --vaadin-infinite-scroller-item-height:
          calc(
              var(--lumo-font-size-l) + var(--lumo-space-m)
            + var(--lumo-font-size-xs) + var(--lumo-space-s)
            + var(--lumo-size-m) * 6
            + var(--lumo-space-s)
          );
      --vaadin-infinite-scroller-buffer-offset: 10%;
      -webkit-mask-image: linear-gradient(transparent, #000 10%, #000 85%, transparent);
      mask-image: linear-gradient(transparent, #000 10%, #000 85%, transparent);
      position: relative;
      margin-right: 57px;
    }

    ::slotted([slot='years']) {
      /* TODO get rid of fixed magic number */
      --vaadin-infinite-scroller-buffer-width: 97px;
      width: 57px;
      height: auto;
      top: 0;
      bottom: 0;
      font-size: var(--lumo-font-size-s);
      box-shadow: inset 2px 0 4px 0 var(--lumo-shade-5pct);
      -webkit-mask-image: linear-gradient(transparent, #000 35%, #000 65%, transparent);
      mask-image: linear-gradient(transparent, #000 35%, #000 65%, transparent);
      cursor: var(--lumo-clickable-cursor);
    }

    ::slotted([slot='years']:hover) {
      --_lumo-date-picker-year-opacity: 1;
    }

    /* TODO unsupported selector */
    #scrollers {
      position: static;
      display: block;
    }

    /* TODO fix this in vaadin-date-picker that it adapts to the width of the year scroller */
    :host([desktop]) ::slotted([slot='months']) {
      right: auto;
    }

    /* Year scroller position indicator */
    ::slotted([slot='years'])::before {
      border: none;
      width: 1em;
      height: 1em;
      background-color: var(--lumo-base-color);
      background-image: linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
      transform: translate(-75%, -50%) rotate(45deg);
      border-top-right-radius: var(--lumo-border-radius-s);
      box-shadow: 2px -2px 6px 0 var(--lumo-shade-5pct);
      z-index: 1;
    }

    [part='toolbar'] {
      padding: var(--lumo-space-s);
      border-bottom-left-radius: var(--lumo-border-radius-l);
      margin-right: 57px;
    }

    [part='toolbar'] ::slotted(vaadin-button) {
      margin: 0;
    }

    /* Narrow viewport mode (fullscreen) */

    :host([fullscreen]) [part='toolbar'] {
      order: -1;
      background-color: var(--lumo-base-color);
    }

    :host([fullscreen]) [part='overlay-header'] {
      order: -2;
      height: var(--lumo-size-m);
      padding: var(--lumo-space-s);
      position: absolute;
      left: 0;
      right: 0;
      justify-content: center;
    }

    :host([fullscreen]) [part='toggle-button'],
    :host([fullscreen]) [part='clear-button'],
    [part='overlay-header'] [part='label'] {
      display: none;
    }

    /* Very narrow screen (year scroller initially hidden) */

    [part='years-toggle-button'] {
      display: flex;
      align-items: center;
      height: var(--lumo-size-s);
      padding: 0 0.5em;
      border-radius: var(--lumo-border-radius-m);
      z-index: 3;
      color: var(--lumo-primary-text-color);
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    :host([years-visible]) [part='years-toggle-button'] {
      background-color: var(--lumo-primary-color);
      color: var(--lumo-primary-contrast-color);
    }

    /* TODO magic number (same as used for media-query in vaadin-date-picker-overlay-content) */
    @media screen and (max-width: 374px) {
      :host {
        background-image: none;
      }

      [part='toolbar'],
      ::slotted([slot='months']) {
        margin-right: 0;
      }

      /* TODO make date-picker adapt to the width of the years part */
      ::slotted([slot='years']) {
        --vaadin-infinite-scroller-buffer-width: 90px;
        width: 50px;
        background-color: var(--lumo-shade-5pct);
      }

      :host([years-visible]) ::slotted([slot='months']) {
        padding-left: 50px;
      }
    }
  `,
  { moduleId: "lumo-date-picker-overlay-content" }
);
registerStyles$1(
  "vaadin-month-calendar",
  css`
    :host {
      -moz-user-select: none;
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      font-size: var(--lumo-font-size-m);
      color: var(--lumo-body-text-color);
      text-align: center;
      padding: 0 var(--lumo-space-xs);
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      --_selection-color: var(--vaadin-selection-color, var(--lumo-primary-color));
      --_selection-color-text: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
    }

    /* Month header */

    [part='month-header'] {
      color: var(--lumo-header-text-color);
      font-size: var(--lumo-font-size-l);
      line-height: 1;
      font-weight: 500;
      margin-bottom: var(--lumo-space-m);
    }

    /* Week days and numbers */

    [part='weekdays'],
    [part='weekday'],
    [part='week-number'] {
      font-size: var(--lumo-font-size-xxs);
      line-height: 1;
      color: var(--lumo-secondary-text-color);
    }

    [part='weekdays'] {
      margin-bottom: var(--lumo-space-s);
    }

    [part='weekday']:empty,
    [part='week-number'] {
      width: var(--lumo-size-xs);
    }

    /* Date and week number cells */

    [part~='date'],
    [part='week-number'] {
      box-sizing: border-box;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: var(--lumo-size-m);
      position: relative;
    }

    [part~='date'] {
      transition: color 0.1s;
    }

    [part~='date']:not(:empty) {
      cursor: var(--lumo-clickable-cursor);
    }

    :host([week-numbers]) [part='weekday']:not(:empty),
    :host([week-numbers]) [part~='date'] {
      width: calc((100% - var(--lumo-size-xs)) / 7);
    }

    /* Today date */

    [part~='date'][part~='today'] {
      color: var(--_selection-color-text);
    }

    /* Focused date */

    [part~='date']::before {
      content: '';
      position: absolute;
      z-index: -1;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      min-width: 2em;
      min-height: 2em;
      width: 80%;
      height: 80%;
      max-height: 100%;
      max-width: 100%;
      border-radius: var(--lumo-border-radius-m);
    }

    [part~='date'][part~='focused']::before {
      box-shadow:
        0 0 0 1px var(--lumo-base-color),
        0 0 0 calc(var(--_focus-ring-width) + 1px) var(--_focus-ring-color);
    }

    :host(:not([focused])) [part~='date'][part~='focused']::before {
      animation: vaadin-date-picker-month-calendar-focus-date 1.4s infinite;
    }

    @keyframes vaadin-date-picker-month-calendar-focus-date {
      50% {
        box-shadow:
          0 0 0 1px var(--lumo-base-color),
          0 0 0 calc(var(--_focus-ring-width) + 1px) transparent;
      }
    }

    [part~='date']:not(:empty):not([part~='disabled']):not([part~='selected']):hover::before {
      background-color: var(--lumo-primary-color-10pct);
    }

    [part~='date'][part~='selected'] {
      color: var(--lumo-primary-contrast-color);
    }

    [part~='date'][part~='selected']::before {
      background-color: var(--_selection-color);
    }

    [part~='date'][part~='disabled'] {
      color: var(--lumo-disabled-text-color);
    }

    @media (pointer: coarse) {
      [part~='date']:hover:not([part~='selected'])::before,
      :host(:not([focus-ring])) [part~='focused']:not([part~='selected'])::before {
        display: none;
      }

      [part~='date']:not(:empty):not([part~='disabled']):active::before {
        display: block;
      }

      :host(:not([focus-ring])) [part~='date'][part~='selected']::before {
        box-shadow: none;
      }
    }
    /* Disabled */

    :host([disabled]) * {
      color: var(--lumo-disabled-text-color) !important;
    }
  `,
  { moduleId: "lumo-month-calendar" }
);
const datePicker = css`
  [part='toggle-button']::before {
    content: var(--lumo-icons-calendar);
  }

  [part='clear-button']::before {
    content: var(--lumo-icons-cross);
  }

  @media (max-width: 450px), (max-height: 450px) {
    [part='overlay-content'] {
      height: 70vh;
    }
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input:placeholder-shown) {
    --_lumo-text-field-overflow-mask-image: none;
  }
`;
registerStyles$1("vaadin-date-picker", [inputFieldShared$1, datePicker], { moduleId: "lumo-date-picker" });
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DatePickerOverlayMixin = (superClass) => class DatePickerOverlayMixin extends PositionMixin(OverlayMixin(superClass)) {
  /**
   * Override method inherited from `OverlayMixin` to not close on input click.
   * Needed to ignore date-picker's own input in the mousedown listener below.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(event) {
    const eventPath = event.composedPath();
    return !eventPath.includes(this.positionTarget);
  }
  /**
   * @protected
   * @override
   */
  _mouseDownListener(event) {
    super._mouseDownListener(event);
    if (this._shouldCloseOnOutsideClick(event) && !isElementFocusable(event.composedPath()[0])) {
      event.preventDefault();
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const datePickerOverlayStyles = css`
  [part='overlay'] {
    display: flex;
    flex: auto;
  }

  [part~='content'] {
    flex: auto;
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 3px solid;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-date-picker-overlay", [overlayStyles, datePickerOverlayStyles], {
  moduleId: "vaadin-date-picker-overlay-styles"
});
class DatePickerOverlay extends DatePickerOverlayMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-date-picker-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
}
defineCustomElement(DatePickerOverlay);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function getISOWeekNumber(date) {
  let dayOfWeek = date.getDay();
  if (dayOfWeek === 0) {
    dayOfWeek = 7;
  }
  const nearestThursdayDiff = 4 - dayOfWeek;
  const nearestThursday = new Date(date.getTime() + nearestThursdayDiff * 24 * 3600 * 1e3);
  const firstOfJanuary = new Date(0, 0);
  firstOfJanuary.setFullYear(nearestThursday.getFullYear());
  const timeDiff = nearestThursday.getTime() - firstOfJanuary.getTime();
  const daysSinceFirstOfJanuary = Math.round(timeDiff / (24 * 3600 * 1e3));
  return Math.floor(daysSinceFirstOfJanuary / 7 + 1);
}
function normalizeDate(date) {
  const normalizedDate = new Date(date);
  normalizedDate.setHours(0, 0, 0, 0);
  return normalizedDate;
}
function normalizeUTCDate(date) {
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0, 0));
}
function dateEquals(date1, date2, normalizer = normalizeDate) {
  return date1 instanceof Date && date2 instanceof Date && normalizer(date1).getTime() === normalizer(date2).getTime();
}
function extractDateParts(date) {
  return {
    day: date.getDate(),
    month: date.getMonth(),
    year: date.getFullYear()
  };
}
function dateAllowed(date, min, max, isDateDisabled) {
  let dateIsDisabled = false;
  if (typeof isDateDisabled === "function" && !!date) {
    const dateToCheck = extractDateParts(date);
    dateIsDisabled = isDateDisabled(dateToCheck);
  }
  return (!min || date >= min) && (!max || date <= max) && !dateIsDisabled;
}
function getClosestDate(date, dates) {
  return dates.filter((date2) => date2 !== void 0).reduce((closestDate, candidate) => {
    if (!candidate) {
      return closestDate;
    }
    if (!closestDate) {
      return candidate;
    }
    const candidateDiff = Math.abs(date.getTime() - candidate.getTime());
    const closestDateDiff = Math.abs(closestDate.getTime() - date.getTime());
    return candidateDiff < closestDateDiff ? candidate : closestDate;
  });
}
function dateAfterXMonths(months) {
  const today = /* @__PURE__ */ new Date();
  const result = new Date(today);
  result.setDate(1);
  result.setMonth(parseInt(months) + today.getMonth());
  return result;
}
function getAdjustedYear(referenceDate, year, month = 0, day = 1) {
  if (year > 99) {
    throw new Error("The provided year cannot have more than 2 digits.");
  }
  if (year < 0) {
    throw new Error("The provided year cannot be negative.");
  }
  let adjustedYear = year + Math.floor(referenceDate.getFullYear() / 100) * 100;
  if (referenceDate < new Date(adjustedYear - 50, month, day)) {
    adjustedYear -= 100;
  } else if (referenceDate > new Date(adjustedYear + 50, month, day)) {
    adjustedYear += 100;
  }
  return adjustedYear;
}
function parseDate(str) {
  const parts = /^([-+]\d{1}|\d{2,4}|[-+]\d{6})-(\d{1,2})-(\d{1,2})$/u.exec(str);
  if (!parts) {
    return void 0;
  }
  const date = new Date(0, 0);
  date.setFullYear(parseInt(parts[1], 10));
  date.setMonth(parseInt(parts[2], 10) - 1);
  date.setDate(parseInt(parts[3], 10));
  return date;
}
function parseUTCDate(str) {
  const parts = /^([-+]\d{1}|\d{2,4}|[-+]\d{6})-(\d{1,2})-(\d{1,2})$/u.exec(str);
  if (!parts) {
    return void 0;
  }
  const date = new Date(Date.UTC(0, 0));
  date.setUTCFullYear(parseInt(parts[1], 10));
  date.setUTCMonth(parseInt(parts[2], 10) - 1);
  date.setUTCDate(parseInt(parts[3], 10));
  return date;
}
function formatISODateBase(dateParts) {
  const pad = (num, fmt = "00") => (fmt + num).substr((fmt + num).length - fmt.length);
  let yearSign = "";
  let yearFmt = "0000";
  let yearAbs = dateParts.year;
  if (yearAbs < 0) {
    yearAbs = -yearAbs;
    yearSign = "-";
    yearFmt = "000000";
  } else if (dateParts.year >= 1e4) {
    yearSign = "+";
    yearFmt = "000000";
  }
  const year = yearSign + pad(yearAbs, yearFmt);
  const month = pad(dateParts.month + 1);
  const day = pad(dateParts.day);
  return [year, month, day].join("-");
}
function formatISODate(date) {
  if (!(date instanceof Date)) {
    return "";
  }
  return formatISODateBase({
    year: date.getFullYear(),
    month: date.getMonth(),
    day: date.getDate()
  });
}
function formatUTCISODate(date) {
  if (!(date instanceof Date)) {
    return "";
  }
  return formatISODateBase({
    year: date.getUTCFullYear(),
    month: date.getUTCMonth(),
    day: date.getUTCDate()
  });
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const template$5 = document.createElement("template");
template$5.innerHTML = `
  <style>
    :host {
      display: block;
      overflow: hidden;
      height: 500px;
    }

    #scroller {
      position: relative;
      height: 100%;
      overflow: auto;
      outline: none;
      margin-right: -40px;
      -webkit-overflow-scrolling: touch;
      overflow-x: hidden;
    }

    #scroller.notouchscroll {
      -webkit-overflow-scrolling: auto;
    }

    #scroller::-webkit-scrollbar {
      display: none;
    }

    .buffer {
      position: absolute;
      width: var(--vaadin-infinite-scroller-buffer-width, 100%);
      box-sizing: border-box;
      padding-right: 40px;
      top: var(--vaadin-infinite-scroller-buffer-offset, 0);
      animation: fadein 0.2s;
    }

    @keyframes fadein {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }
  </style>

  <div id="scroller" tabindex="-1">
    <div class="buffer"></div>
    <div class="buffer"></div>
    <div id="fullHeight"></div>
  </div>
`;
class InfiniteScroller extends HTMLElement {
  constructor() {
    super();
    const root2 = this.attachShadow({ mode: "open" });
    root2.appendChild(template$5.content.cloneNode(true));
    this.bufferSize = 20;
    this._initialScroll = 5e5;
    this._initialIndex = 0;
    this._activated = false;
  }
  /**
   * @return {boolean}
   */
  get active() {
    return this._activated;
  }
  set active(active) {
    if (active && !this._activated) {
      this._createPool();
      this._activated = true;
    }
  }
  /**
   * @return {number}
   */
  get bufferOffset() {
    return this._buffers[0].offsetTop;
  }
  /**
   * @return {number}
   */
  get itemHeight() {
    if (!this._itemHeightVal) {
      const itemHeight = getComputedStyle(this).getPropertyValue("--vaadin-infinite-scroller-item-height");
      const tmpStyleProp = "background-position";
      this.$.fullHeight.style.setProperty(tmpStyleProp, itemHeight);
      const itemHeightPx = getComputedStyle(this.$.fullHeight).getPropertyValue(tmpStyleProp);
      this.$.fullHeight.style.removeProperty(tmpStyleProp);
      this._itemHeightVal = parseFloat(itemHeightPx);
    }
    return this._itemHeightVal;
  }
  /** @private */
  get _bufferHeight() {
    return this.itemHeight * this.bufferSize;
  }
  /**
   * @return {number}
   */
  get position() {
    return (this.$.scroller.scrollTop - this._buffers[0].translateY) / this.itemHeight + this._firstIndex;
  }
  /**
   * Current scroller position as index. Can be a fractional number.
   *
   * @type {number}
   */
  set position(index) {
    this._preventScrollEvent = true;
    if (index > this._firstIndex && index < this._firstIndex + this.bufferSize * 2) {
      this.$.scroller.scrollTop = this.itemHeight * (index - this._firstIndex) + this._buffers[0].translateY;
    } else {
      this._initialIndex = ~~index;
      this._reset();
      this._scrollDisabled = true;
      this.$.scroller.scrollTop += index % 1 * this.itemHeight;
      this._scrollDisabled = false;
    }
    if (this._mayHaveMomentum) {
      this.$.scroller.classList.add("notouchscroll");
      this._mayHaveMomentum = false;
      setTimeout(() => {
        this.$.scroller.classList.remove("notouchscroll");
      }, 10);
    }
  }
  /** @protected */
  connectedCallback() {
    if (!this._ready) {
      this._ready = true;
      this.$ = {};
      this.shadowRoot.querySelectorAll("[id]").forEach((node) => {
        this.$[node.id] = node;
      });
      this.$.scroller.addEventListener("scroll", () => this._scroll());
      this._buffers = [...this.shadowRoot.querySelectorAll(".buffer")];
      this.$.fullHeight.style.height = `${this._initialScroll * 2}px`;
    }
  }
  /** @protected */
  disconnectedCallback() {
    if (this._debouncerScrollFinish) {
      this._debouncerScrollFinish.cancel();
    }
    if (this._debouncerUpdateClones) {
      this._debouncerUpdateClones.cancel();
    }
    if (this.__pendingFinishInit) {
      cancelAnimationFrame(this.__pendingFinishInit);
    }
  }
  /**
   * Force the scroller to update clones after a reset, without
   * waiting for the debouncer to resolve.
   */
  forceUpdate() {
    if (this._debouncerScrollFinish) {
      this._debouncerScrollFinish.flush();
    }
    if (this._debouncerUpdateClones) {
      this._buffers[0].updated = this._buffers[1].updated = false;
      this._updateClones();
      this._debouncerUpdateClones.cancel();
    }
    flush();
  }
  /**
   * @protected
   * @override
   */
  _createElement() {
  }
  /**
   * @param {HTMLElement} _element
   * @param {number} _index
   * @protected
   * @override
   */
  _updateElement(_element, _index) {
  }
  /** @private */
  _finishInit() {
    if (!this._initDone) {
      this._buffers.forEach((buffer) => {
        [...buffer.children].forEach((slot) => {
          this._ensureStampedInstance(slot._itemWrapper);
        });
      });
      if (!this._buffers[0].translateY) {
        this._reset();
      }
      this._initDone = true;
      this.dispatchEvent(new CustomEvent("init-done"));
    }
  }
  /** @private */
  _translateBuffer(up) {
    const index = up ? 1 : 0;
    this._buffers[index].translateY = this._buffers[index ? 0 : 1].translateY + this._bufferHeight * (index ? -1 : 1);
    this._buffers[index].style.transform = `translate3d(0, ${this._buffers[index].translateY}px, 0)`;
    this._buffers[index].updated = false;
    this._buffers.reverse();
  }
  /** @private */
  _scroll() {
    if (this._scrollDisabled) {
      return;
    }
    const scrollTop = this.$.scroller.scrollTop;
    if (scrollTop < this._bufferHeight || scrollTop > this._initialScroll * 2 - this._bufferHeight) {
      this._initialIndex = ~~this.position;
      this._reset();
    }
    const offset = this.itemHeight + this.bufferOffset;
    const upperThresholdReached = scrollTop > this._buffers[1].translateY + offset;
    const lowerThresholdReached = scrollTop < this._buffers[0].translateY + offset;
    if (upperThresholdReached || lowerThresholdReached) {
      this._translateBuffer(lowerThresholdReached);
      this._updateClones();
    }
    if (!this._preventScrollEvent) {
      this.dispatchEvent(new CustomEvent("custom-scroll", { bubbles: false, composed: true }));
      this._mayHaveMomentum = true;
    }
    this._preventScrollEvent = false;
    this._debouncerScrollFinish = Debouncer$1.debounce(this._debouncerScrollFinish, timeOut.after(200), () => {
      const scrollerRect = this.$.scroller.getBoundingClientRect();
      if (!this._isVisible(this._buffers[0], scrollerRect) && !this._isVisible(this._buffers[1], scrollerRect)) {
        this.position = this.position;
      }
    });
  }
  /** @private */
  _reset() {
    this._scrollDisabled = true;
    this.$.scroller.scrollTop = this._initialScroll;
    this._buffers[0].translateY = this._initialScroll - this._bufferHeight;
    this._buffers[1].translateY = this._initialScroll;
    this._buffers.forEach((buffer) => {
      buffer.style.transform = `translate3d(0, ${buffer.translateY}px, 0)`;
    });
    this._buffers[0].updated = this._buffers[1].updated = false;
    this._updateClones(true);
    this._debouncerUpdateClones = Debouncer$1.debounce(this._debouncerUpdateClones, timeOut.after(200), () => {
      this._buffers[0].updated = this._buffers[1].updated = false;
      this._updateClones();
    });
    this._scrollDisabled = false;
  }
  /** @private */
  _createPool() {
    const container = this.getBoundingClientRect();
    this._buffers.forEach((buffer) => {
      for (let i2 = 0; i2 < this.bufferSize; i2++) {
        const itemWrapper = document.createElement("div");
        itemWrapper.style.height = `${this.itemHeight}px`;
        itemWrapper.instance = {};
        const slotName = `vaadin-infinite-scroller-item-content-${generateUniqueId()}`;
        const slot = document.createElement("slot");
        slot.setAttribute("name", slotName);
        slot._itemWrapper = itemWrapper;
        buffer.appendChild(slot);
        itemWrapper.setAttribute("slot", slotName);
        this.appendChild(itemWrapper);
        if (this._isVisible(itemWrapper, container)) {
          this._ensureStampedInstance(itemWrapper);
        }
      }
    });
    this.__pendingFinishInit = requestAnimationFrame(() => {
      this._finishInit();
      this.__pendingFinishInit = null;
    });
  }
  /** @private */
  _ensureStampedInstance(itemWrapper) {
    if (itemWrapper.firstElementChild) {
      return;
    }
    const tmpInstance = itemWrapper.instance;
    itemWrapper.instance = this._createElement();
    itemWrapper.appendChild(itemWrapper.instance);
    if (itemWrapper.instance.performUpdate) {
      itemWrapper.instance.performUpdate();
    }
    Object.keys(tmpInstance).forEach((prop) => {
      itemWrapper.instance[prop] = tmpInstance[prop];
    });
  }
  /** @private */
  _updateClones(viewPortOnly) {
    this._firstIndex = Math.round((this._buffers[0].translateY - this._initialScroll) / this.itemHeight) + this._initialIndex;
    const scrollerRect = viewPortOnly ? this.$.scroller.getBoundingClientRect() : void 0;
    this._buffers.forEach((buffer, bufferIndex) => {
      if (!buffer.updated) {
        const firstIndex = this._firstIndex + this.bufferSize * bufferIndex;
        [...buffer.children].forEach((slot, index) => {
          const itemWrapper = slot._itemWrapper;
          if (!viewPortOnly || this._isVisible(itemWrapper, scrollerRect)) {
            this._updateElement(itemWrapper.instance, firstIndex + index);
          }
        });
        buffer.updated = true;
      }
    });
  }
  /** @private */
  _isVisible(element, container) {
    const rect = element.getBoundingClientRect();
    return rect.bottom > container.top && rect.top < container.bottom;
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const stylesTemplate$1 = document.createElement("template");
stylesTemplate$1.innerHTML = `
  <style>
    :host {
      --vaadin-infinite-scroller-item-height: 270px;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      height: 100%;
    }
  </style>
`;
class DatePickerMonthScroller extends InfiniteScroller {
  static get is() {
    return "vaadin-date-picker-month-scroller";
  }
  constructor() {
    super();
    this.bufferSize = 3;
    this.shadowRoot.appendChild(stylesTemplate$1.content.cloneNode(true));
  }
  /**
   * @protected
   * @override
   */
  _createElement() {
    return document.createElement("vaadin-month-calendar");
  }
  /**
   * @param {HTMLElement} element
   * @param {number} index
   * @protected
   * @override
   */
  _updateElement(element, index) {
    element.month = dateAfterXMonths(index);
  }
}
defineCustomElement(DatePickerMonthScroller);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const stylesTemplate = document.createElement("template");
stylesTemplate.innerHTML = `
  <style>
    :host {
      --vaadin-infinite-scroller-item-height: 80px;
      width: 50px;
      display: block;
      height: 100%;
      position: absolute;
      right: 0;
      transform: translateX(100%);
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
      /* Center the year scroller position. */
      --vaadin-infinite-scroller-buffer-offset: 50%;
    }

    :host::before {
      content: '';
      display: block;
      background: transparent;
      width: 0;
      height: 0;
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      border-width: 6px;
      border-style: solid;
      border-color: transparent;
      border-left-color: #000;
    }
  </style>
`;
class DatePickerYearScroller extends InfiniteScroller {
  static get is() {
    return "vaadin-date-picker-year-scroller";
  }
  constructor() {
    super();
    this.bufferSize = 12;
    this.shadowRoot.appendChild(stylesTemplate.content.cloneNode(true));
  }
  /**
   * @protected
   * @override
   */
  _createElement() {
    return document.createElement("vaadin-date-picker-year");
  }
  /**
   * @param {HTMLElement} element
   * @param {number} index
   * @protected
   * @override
   */
  _updateElement(element, index) {
    element.year = this._yearAfterXYears(index);
  }
  /** @private */
  _yearAfterXYears(index) {
    const today = /* @__PURE__ */ new Date();
    const result = new Date(today);
    result.setFullYear(parseInt(index) + today.getFullYear());
    return result.getFullYear();
  }
}
defineCustomElement(DatePickerYearScroller);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DatePickerYearMixin = (superClass) => class DatePickerYearMixin extends superClass {
  static get properties() {
    return {
      year: {
        type: String,
        sync: true
      },
      selectedDate: {
        type: Object,
        sync: true
      }
    };
  }
  static get observers() {
    return ["__updateSelected(year, selectedDate)"];
  }
  /** @private */
  __updateSelected(year, selectedDate) {
    this.toggleAttribute("selected", selectedDate && selectedDate.getFullYear() === year);
    this.toggleAttribute("current", year === (/* @__PURE__ */ new Date()).getFullYear());
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class DatePickerYear extends ThemableMixin(DatePickerYearMixin(PolymerElement)) {
  static get is() {
    return "vaadin-date-picker-year";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          height: 100%;
        }
      </style>
      <div part="year-number">[[year]]</div>
      <div part="year-separator" aria-hidden="true"></div>
    `;
  }
}
defineCustomElement(DatePickerYear);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const domRepeatBase = OptionalMutableData(PolymerElement);
class DomRepeat extends domRepeatBase {
  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() {
    return "dom-repeat";
  }
  static get template() {
    return null;
  }
  static get properties() {
    return {
      /**
       * An array containing items determining how many instances of the template
       * to stamp and that that each template instance should bind to.
       */
      items: {
        type: Array
      },
      /**
       * The name of the variable to add to the binding scope for the array
       * element associated with a given template instance.
       */
      as: {
        type: String,
        value: "item"
      },
      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the sorted and filtered list of rendered items.
       * Note, for the index in the `this.items` array, use the value of the
       * `itemsIndexAs` property.
       */
      indexAs: {
        type: String,
        value: "index"
      },
      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the `this.items` array. Note, for the index of
       * this instance in the sorted and filtered list of rendered items,
       * use the value of the `indexAs` property.
       */
      itemsIndexAs: {
        type: String,
        value: "itemsIndex"
      },
      /**
       * A function that should determine the sort order of the items.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.sort`.
       * Using a sort function has no effect on the underlying `items` array.
       */
      sort: {
        type: Function,
        observer: "__sortChanged"
      },
      /**
       * A function that can be used to filter items out of the view.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.filter`.
       * Using a filter function has no effect on the underlying `items` array.
       */
      filter: {
        type: Function,
        observer: "__filterChanged"
      },
      /**
       * When using a `filter` or `sort` function, the `observe` property
       * should be set to a space-separated list of the names of item
       * sub-fields that should trigger a re-sort or re-filter when changed.
       * These should generally be fields of `item` that the sort or filter
       * function depends on.
       */
      observe: {
        type: String,
        observer: "__observeChanged"
      },
      /**
       * When using a `filter` or `sort` function, the `delay` property
       * determines a debounce time in ms after a change to observed item
       * properties that must pass before the filter or sort is re-run.
       * This is useful in rate-limiting shuffling of the view when
       * item changes may be frequent.
       */
      delay: Number,
      /**
       * Count of currently rendered items after `filter` (if any) has been applied.
       * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
       * set of template instances is rendered.
       *
       */
      renderedItemCount: {
        type: Number,
        notify: !suppressTemplateNotifications,
        readOnly: true
      },
      /**
       * When greater than zero, defines an initial count of template instances
       * to render after setting the `items` array, before the next paint, and
       * puts the `dom-repeat` into "chunking mode".  The remaining items (and
       * any future items as a result of pushing onto the array) will be created
       * and rendered incrementally at each animation frame thereof until all
       * instances have been rendered.
       */
      initialCount: {
        type: Number
      },
      /**
       * When `initialCount` is used, this property defines a frame rate (in
       * fps) to target by throttling the number of instances rendered each
       * frame to not exceed the budget for the target frame rate.  The
       * framerate is effectively the number of `requestAnimationFrame`s that
       * it tries to allow to actually fire in a given second. It does this
       * by measuring the time between `rAF`s and continuously adjusting the
       * number of items created each `rAF` to maintain the target framerate.
       * Setting this to a higher number allows lower latency and higher
       * throughput for event handlers and other tasks, but results in a
       * longer time for the remaining items to complete rendering.
       */
      targetFramerate: {
        type: Number,
        value: 20
      },
      _targetFrameTime: {
        type: Number,
        computed: "__computeFrameTime(targetFramerate)"
      },
      /**
       * When the global `suppressTemplateNotifications` setting is used, setting
       * `notifyDomChange: true` will enable firing `dom-change` events on this
       * element.
       */
      notifyDomChange: {
        type: Boolean
      },
      /**
       * When chunking is enabled via `initialCount` and the `items` array is
       * set to a new array, this flag controls whether the previously rendered
       * instances are reused or not.
       *
       * When `true`, any previously rendered template instances are updated in
       * place to their new item values synchronously in one shot, and then any
       * further items (if any) are chunked out.  When `false`, the list is
       * returned back to its `initialCount` (any instances over the initial
       * count are discarded) and the remainder of the list is chunked back in.
       * Set this to `true` to avoid re-creating the list and losing scroll
       * position, although note that when changing the list to completely
       * different data the render thread will be blocked until all existing
       * instances are updated to their new data.
       */
      reuseChunkedInstances: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return ["__itemsChanged(items.*)"];
  }
  constructor() {
    super();
    this.__instances = [];
    this.__renderDebouncer = null;
    this.__itemsIdxToInstIdx = {};
    this.__chunkCount = null;
    this.__renderStartTime = null;
    this.__itemsArrayChanged = false;
    this.__shouldMeasureChunk = false;
    this.__shouldContinueChunking = false;
    this.__chunkingId = 0;
    this.__sortFn = null;
    this.__filterFn = null;
    this.__observePaths = null;
    this.__ctor = null;
    this.__isDetached = true;
    this.template = null;
    this._templateInfo;
  }
  /**
   * @override
   * @return {void}
   */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__isDetached = true;
    for (let i2 = 0; i2 < this.__instances.length; i2++) {
      this.__detachInstance(i2);
    }
    if (this.__chunkingId) {
      cancelAnimationFrame(this.__chunkingId);
    }
  }
  /**
   * @override
   * @return {void}
   */
  connectedCallback() {
    super.connectedCallback();
    if (!hideElementsGlobally()) {
      this.style.display = "none";
    }
    if (this.__isDetached) {
      this.__isDetached = false;
      let wrappedParent = wrap$1(wrap$1(this).parentNode);
      for (let i2 = 0; i2 < this.__instances.length; i2++) {
        this.__attachInstance(i2, wrappedParent);
      }
      if (this.__chunkingId) {
        this.__render();
      }
    }
  }
  __ensureTemplatized() {
    if (!this.__ctor) {
      const thisAsTemplate = (
        /** @type {!HTMLTemplateElement} */
        /** @type {!HTMLElement} */
        this
      );
      let template2 = this.template = thisAsTemplate._templateInfo ? thisAsTemplate : (
        /** @type {!HTMLTemplateElement} */
        this.querySelector("template")
      );
      if (!template2) {
        let observer2 = new MutationObserver(() => {
          if (this.querySelector("template")) {
            observer2.disconnect();
            this.__render();
          } else {
            throw new Error("dom-repeat requires a <template> child");
          }
        });
        observer2.observe(this, { childList: true });
        return false;
      }
      let instanceProps = {};
      instanceProps[this.as] = true;
      instanceProps[this.indexAs] = true;
      instanceProps[this.itemsIndexAs] = true;
      this.__ctor = templatize(template2, this, {
        mutableData: this.mutableData,
        parentModel: true,
        instanceProps,
        /**
         * @this {DomRepeat}
         * @param {string} prop Property to set
         * @param {*} value Value to set property to
         */
        forwardHostProp: function(prop, value) {
          let i$ = this.__instances;
          for (let i2 = 0, inst; i2 < i$.length && (inst = i$[i2]); i2++) {
            inst.forwardHostProp(prop, value);
          }
        },
        /**
         * @this {DomRepeat}
         * @param {Object} inst Instance to notify
         * @param {string} prop Property to notify
         * @param {*} value Value to notify
         */
        notifyInstanceProp: function(inst, prop, value) {
          if (matches(this.as, prop)) {
            let idx = inst[this.itemsIndexAs];
            if (prop == this.as) {
              this.items[idx] = value;
            }
            let path = translate(this.as, `${JSCompiler_renameProperty("items", this)}.${idx}`, prop);
            this.notifyPath(path, value);
          }
        }
      });
    }
    return true;
  }
  __getMethodHost() {
    return this.__dataHost._methodHost || this.__dataHost;
  }
  __functionFromPropertyValue(functionOrMethodName) {
    if (typeof functionOrMethodName === "string") {
      let methodName = functionOrMethodName;
      let obj = this.__getMethodHost();
      return function() {
        return obj[methodName].apply(obj, arguments);
      };
    }
    return functionOrMethodName;
  }
  __sortChanged(sort) {
    this.__sortFn = this.__functionFromPropertyValue(sort);
    if (this.items) {
      this.__debounceRender(this.__render);
    }
  }
  __filterChanged(filter2) {
    this.__filterFn = this.__functionFromPropertyValue(filter2);
    if (this.items) {
      this.__debounceRender(this.__render);
    }
  }
  __computeFrameTime(rate) {
    return Math.ceil(1e3 / rate);
  }
  __observeChanged() {
    this.__observePaths = this.observe && this.observe.replace(".*", ".").split(" ");
  }
  __handleObservedPaths(path) {
    if (this.__sortFn || this.__filterFn) {
      if (!path) {
        this.__debounceRender(this.__render, this.delay);
      } else if (this.__observePaths) {
        let paths = this.__observePaths;
        for (let i2 = 0; i2 < paths.length; i2++) {
          if (path.indexOf(paths[i2]) === 0) {
            this.__debounceRender(this.__render, this.delay);
          }
        }
      }
    }
  }
  __itemsChanged(change) {
    if (this.items && !Array.isArray(this.items)) {
      console.warn("dom-repeat expected array for `items`, found", this.items);
    }
    if (!this.__handleItemPath(change.path, change.value)) {
      if (change.path === "items") {
        this.__itemsArrayChanged = true;
      }
      this.__debounceRender(this.__render);
    }
  }
  /**
   * @param {function(this:DomRepeat)} fn Function to debounce.
   * @param {number=} delay Delay in ms to debounce by.
   */
  __debounceRender(fn, delay = 0) {
    this.__renderDebouncer = Debouncer2.debounce(
      this.__renderDebouncer,
      delay > 0 ? timeOut$1.after(delay) : microTask$1,
      fn.bind(this)
    );
    enqueueDebouncer(this.__renderDebouncer);
  }
  /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   * @return {void}
   */
  render() {
    this.__debounceRender(this.__render);
    flush();
  }
  __render() {
    if (!this.__ensureTemplatized()) {
      return;
    }
    let items = this.items || [];
    const isntIdxToItemsIdx = this.__sortAndFilterItems(items);
    const limit = this.__calculateLimit(isntIdxToItemsIdx.length);
    this.__updateInstances(items, limit, isntIdxToItemsIdx);
    if (this.initialCount && (this.__shouldMeasureChunk || this.__shouldContinueChunking)) {
      cancelAnimationFrame(this.__chunkingId);
      this.__chunkingId = requestAnimationFrame(() => {
        this.__chunkingId = null;
        this.__continueChunking();
      });
    }
    this._setRenderedItemCount(this.__instances.length);
    if (!suppressTemplateNotifications || this.notifyDomChange) {
      this.dispatchEvent(new CustomEvent("dom-change", {
        bubbles: true,
        composed: true
      }));
    }
  }
  __sortAndFilterItems(items) {
    let isntIdxToItemsIdx = new Array(items.length);
    for (let i2 = 0; i2 < items.length; i2++) {
      isntIdxToItemsIdx[i2] = i2;
    }
    if (this.__filterFn) {
      isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i2, idx, array) => this.__filterFn(items[i2], idx, array));
    }
    if (this.__sortFn) {
      isntIdxToItemsIdx.sort((a3, b2) => this.__sortFn(items[a3], items[b2]));
    }
    return isntIdxToItemsIdx;
  }
  __calculateLimit(filteredItemCount) {
    let limit = filteredItemCount;
    const currentCount = this.__instances.length;
    if (this.initialCount) {
      let newCount;
      if (!this.__chunkCount || this.__itemsArrayChanged && !this.reuseChunkedInstances) {
        limit = Math.min(filteredItemCount, this.initialCount);
        newCount = Math.max(limit - currentCount, 0);
        this.__chunkCount = newCount || 1;
      } else {
        newCount = Math.min(
          Math.max(filteredItemCount - currentCount, 0),
          this.__chunkCount
        );
        limit = Math.min(currentCount + newCount, filteredItemCount);
      }
      this.__shouldMeasureChunk = newCount === this.__chunkCount;
      this.__shouldContinueChunking = limit < filteredItemCount;
      this.__renderStartTime = performance.now();
    }
    this.__itemsArrayChanged = false;
    return limit;
  }
  __continueChunking() {
    if (this.__shouldMeasureChunk) {
      const renderTime = performance.now() - this.__renderStartTime;
      const ratio = this._targetFrameTime / renderTime;
      this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
    }
    if (this.__shouldContinueChunking) {
      this.__debounceRender(this.__render);
    }
  }
  __updateInstances(items, limit, isntIdxToItemsIdx) {
    const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
    let instIdx;
    for (instIdx = 0; instIdx < limit; instIdx++) {
      let inst = this.__instances[instIdx];
      let itemIdx = isntIdxToItemsIdx[instIdx];
      let item2 = items[itemIdx];
      itemsIdxToInstIdx[itemIdx] = instIdx;
      if (inst) {
        inst._setPendingProperty(this.as, item2);
        inst._setPendingProperty(this.indexAs, instIdx);
        inst._setPendingProperty(this.itemsIndexAs, itemIdx);
        inst._flushProperties();
      } else {
        this.__insertInstance(item2, instIdx, itemIdx);
      }
    }
    for (let i2 = this.__instances.length - 1; i2 >= instIdx; i2--) {
      this.__detachAndRemoveInstance(i2);
    }
  }
  __detachInstance(idx) {
    let inst = this.__instances[idx];
    const wrappedRoot = wrap$1(inst.root);
    for (let i2 = 0; i2 < inst.children.length; i2++) {
      let el = inst.children[i2];
      wrappedRoot.appendChild(el);
    }
    return inst;
  }
  __attachInstance(idx, parent) {
    let inst = this.__instances[idx];
    parent.insertBefore(inst.root, this);
  }
  __detachAndRemoveInstance(idx) {
    this.__detachInstance(idx);
    this.__instances.splice(idx, 1);
  }
  __stampInstance(item2, instIdx, itemIdx) {
    let model = {};
    model[this.as] = item2;
    model[this.indexAs] = instIdx;
    model[this.itemsIndexAs] = itemIdx;
    return new this.__ctor(model);
  }
  __insertInstance(item2, instIdx, itemIdx) {
    const inst = this.__stampInstance(item2, instIdx, itemIdx);
    let beforeRow = this.__instances[instIdx + 1];
    let beforeNode = beforeRow ? beforeRow.children[0] : this;
    wrap$1(wrap$1(this).parentNode).insertBefore(inst.root, beforeNode);
    this.__instances[instIdx] = inst;
    return inst;
  }
  // Implements extension point from Templatize mixin
  /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @param {boolean} hidden Set to true to hide the children;
   * set to false to show them.
   * @return {void}
   * @protected
   */
  _showHideChildren(hidden) {
    for (let i2 = 0; i2 < this.__instances.length; i2++) {
      this.__instances[i2]._showHideChildren(hidden);
    }
  }
  // Called as a side effect of a host items.<key>.<path> path change,
  // responsible for notifying item.<path> changes to inst for key
  __handleItemPath(path, value) {
    let itemsPath = path.slice(6);
    let dot = itemsPath.indexOf(".");
    let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
    if (itemsIdx == parseInt(itemsIdx, 10)) {
      let itemSubPath = dot < 0 ? "" : itemsPath.substring(dot + 1);
      this.__handleObservedPaths(itemSubPath);
      let instIdx = this.__itemsIdxToInstIdx[itemsIdx];
      let inst = this.__instances[instIdx];
      if (inst) {
        let itemPath = this.as + (itemSubPath ? "." + itemSubPath : "");
        inst._setPendingPropertyOrPath(itemPath, value, false, true);
        inst._flushProperties();
      }
      return true;
    }
  }
  /**
   * Returns the item associated with a given element stamped by
   * this `dom-repeat`.
   *
   * Note, to modify sub-properties of the item,
   * `modelForElement(el).set('item.<sub-prop>', value)`
   * should be used.
   *
   * @param {!HTMLElement} el Element for which to return the item.
   * @return {*} Item associated with the element.
   */
  itemForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.as];
  }
  /**
   * Returns the inst index for a given element stamped by this `dom-repeat`.
   * If `sort` is provided, the index will reflect the sorted order (rather
   * than the original array order).
   *
   * @param {!HTMLElement} el Element for which to return the index.
   * @return {?number} Row index associated with the element (note this may
   *   not correspond to the array index if a user `sort` is applied).
   */
  indexForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.indexAs];
  }
  /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model
   * should be used to manipulate data associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @param {!HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   */
  modelForElement(el) {
    return modelForElement(this.template, el);
  }
}
customElements.define(DomRepeat.is, DomRepeat);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MonthCalendarMixin = (superClass) => class MonthCalendarMixinClass extends FocusMixin(superClass) {
  static get properties() {
    return {
      /**
       * A `Date` object defining the month to be displayed. Only year and
       * month properties are actually used.
       */
      month: {
        type: Object,
        value: /* @__PURE__ */ new Date(),
        sync: true
      },
      /**
       * A `Date` object for the currently selected date.
       */
      selectedDate: {
        type: Object,
        notify: true,
        sync: true
      },
      /**
       * A `Date` object for the currently focused date.
       */
      focusedDate: {
        type: Object
      },
      /**
       * Set true to display ISO-8601 week numbers in the calendar. Notice that
       * displaying week numbers is only supported when `i18n.firstDayOfWeek`
       * is 1 (Monday).
       */
      showWeekNumbers: {
        type: Boolean,
        value: false
      },
      i18n: {
        type: Object
      },
      /**
       * Flag stating whether taps on the component should be ignored.
       */
      ignoreTaps: {
        type: Boolean
      },
      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       */
      minDate: {
        type: Date,
        value: null,
        sync: true
      },
      /**
       * The latest date that can be selected. All later dates will be disabled.
       */
      maxDate: {
        type: Date,
        value: null,
        sync: true
      },
      /**
       * A function to be used to determine whether the user can select a given date.
       * Receives a `DatePickerDate` object of the date to be selected and should return a
       * boolean.
       * @type {Function | undefined}
       */
      isDateDisabled: {
        type: Function,
        value: () => false
      },
      enteredDate: {
        type: Date
      },
      disabled: {
        type: Boolean,
        reflectToAttribute: true
      },
      /** @protected */
      _days: {
        type: Array
      },
      /** @protected */
      _weeks: {
        type: Array
      },
      /** @private */
      _notTapping: {
        type: Boolean
      },
      /** @private */
      __hasFocus: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return ["__focusedDateChanged(focusedDate, _days)"];
  }
  get focusableDateElement() {
    return [...this.shadowRoot.querySelectorAll("[part~=date]")].find((datePart) => {
      return dateEquals(datePart.date, this.focusedDate);
    });
  }
  /** @protected */
  ready() {
    super.ready();
    addListener(this.$.monthGrid, "tap", this._handleTap.bind(this));
  }
  /** @override */
  _setFocused(focused) {
    super._setFocused(focused);
    this.__hasFocus = focused;
  }
  /**
   * Returns true if all the dates in the month are out of the allowed range
   * @protected
   */
  _isDisabled(month, minDate, maxDate) {
    const firstDate = new Date(0, 0);
    firstDate.setFullYear(month.getFullYear());
    firstDate.setMonth(month.getMonth());
    firstDate.setDate(1);
    const lastDate = new Date(0, 0);
    lastDate.setFullYear(month.getFullYear());
    lastDate.setMonth(month.getMonth() + 1);
    lastDate.setDate(0);
    if (minDate && maxDate && minDate.getMonth() === maxDate.getMonth() && minDate.getMonth() === month.getMonth() && maxDate.getDate() - minDate.getDate() >= 0) {
      return false;
    }
    return !dateAllowed(firstDate, minDate, maxDate) && !dateAllowed(lastDate, minDate, maxDate);
  }
  /** @protected */
  _getTitle(month, i18n) {
    if (month === void 0 || i18n === void 0) {
      return;
    }
    return i18n.formatTitle(i18n.monthNames[month.getMonth()], month.getFullYear());
  }
  /** @protected */
  _onMonthGridTouchStart() {
    this._notTapping = false;
    setTimeout(() => {
      this._notTapping = true;
    }, 300);
  }
  /** @private */
  _dateAdd(date, delta) {
    date.setDate(date.getDate() + delta);
  }
  /** @private */
  _applyFirstDayOfWeek(weekDayNames, firstDayOfWeek) {
    if (weekDayNames === void 0 || firstDayOfWeek === void 0) {
      return;
    }
    return weekDayNames.slice(firstDayOfWeek).concat(weekDayNames.slice(0, firstDayOfWeek));
  }
  /** @protected */
  _getWeekDayNames(i18n, showWeekNumbers) {
    if (i18n === void 0 || showWeekNumbers === void 0) {
      return [];
    }
    const { weekdays, weekdaysShort, firstDayOfWeek } = i18n;
    const weekDayNamesShort = this._applyFirstDayOfWeek(weekdaysShort, firstDayOfWeek);
    const weekDayNames = this._applyFirstDayOfWeek(weekdays, firstDayOfWeek);
    return weekDayNames.map((day, index) => {
      return {
        weekDay: day,
        weekDayShort: weekDayNamesShort[index]
      };
    }).slice(0, 7);
  }
  /** @private */
  __focusedDateChanged(focusedDate, days) {
    if (Array.isArray(days) && days.some((date) => dateEquals(date, focusedDate))) {
      this.removeAttribute("aria-hidden");
    } else {
      this.setAttribute("aria-hidden", "true");
    }
  }
  /** @protected */
  _getDate(date) {
    return date ? date.getDate() : "";
  }
  /** @protected */
  _showWeekSeparator(showWeekNumbers, i18n) {
    return showWeekNumbers && i18n && i18n.firstDayOfWeek === 1;
  }
  /** @protected */
  _isToday(date) {
    return dateEquals(/* @__PURE__ */ new Date(), date);
  }
  /** @protected */
  _getDays(month, i18n) {
    if (month === void 0 || i18n === void 0) {
      return [];
    }
    const date = new Date(0, 0);
    date.setFullYear(month.getFullYear());
    date.setMonth(month.getMonth());
    date.setDate(1);
    while (date.getDay() !== i18n.firstDayOfWeek) {
      this._dateAdd(date, -1);
    }
    const days = [];
    const startMonth = date.getMonth();
    const targetMonth = month.getMonth();
    while (date.getMonth() === targetMonth || date.getMonth() === startMonth) {
      days.push(date.getMonth() === targetMonth ? new Date(date.getTime()) : null);
      this._dateAdd(date, 1);
    }
    return days;
  }
  /** @protected */
  _getWeeks(days) {
    return days.reduce((acc, day, i2) => {
      if (i2 % 7 === 0) {
        acc.push([]);
      }
      acc[acc.length - 1].push(day);
      return acc;
    }, []);
  }
  /** @protected */
  _handleTap(e2) {
    if (!this.ignoreTaps && !this._notTapping && e2.target.date && !e2.target.hasAttribute("disabled")) {
      this.selectedDate = e2.target.date;
      this.dispatchEvent(
        new CustomEvent("date-tap", { detail: { date: e2.target.date }, bubbles: true, composed: true })
      );
    }
  }
  /** @protected */
  _preventDefault(e2) {
    e2.preventDefault();
  }
  /** @protected */
  __getWeekNumber(days) {
    const date = days.reduce((acc, d3) => {
      return !acc && d3 ? d3 : acc;
    });
    return getISOWeekNumber(date);
  }
  /** @protected */
  __getDayAriaLabel(date) {
    if (!date) {
      return "";
    }
    let ariaLabel = `${this._getDate(date)} ${this.i18n.monthNames[date.getMonth()]} ${date.getFullYear()}, ${this.i18n.weekdays[date.getDay()]}`;
    if (this._isToday(date)) {
      ariaLabel += `, ${this.i18n.today}`;
    }
    return ariaLabel;
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const monthCalendarStyles = css`
  :host {
    display: block;
  }

  #monthGrid {
    width: 100%;
    border-collapse: collapse;
  }

  #days-container tr,
  #weekdays-container tr {
    display: flex;
  }

  [part~='date'] {
    outline: none;
  }

  [part~='disabled'] {
    pointer-events: none;
  }

  [part='week-number'][hidden],
  [part='weekday'][hidden] {
    display: none;
  }

  [part='weekday'],
  [part~='date'] {
    width: calc(100% / 7);
    padding: 0;
    font-weight: normal;
  }

  [part='weekday']:empty,
  [part='week-number'] {
    width: 12.5%;
    flex-shrink: 0;
    padding: 0;
  }

  :host([week-numbers]) [part='weekday']:not(:empty),
  :host([week-numbers]) [part~='date'] {
    width: 12.5%;
  }

  @media (forced-colors: active) {
    [part~='date'][part~='focused'] {
      outline: 1px solid;
    }

    [part~='date'][part~='selected'] {
      outline: 3px solid;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-month-calendar", monthCalendarStyles, {
  moduleId: "vaadin-month-calendar-styles"
});
class MonthCalendar extends MonthCalendarMixin(ThemableMixin(PolymerElement)) {
  static get template() {
    return html`
      <div part="month-header" id="month-header" aria-hidden="true">[[_getTitle(month, i18n)]]</div>
      <table
        id="monthGrid"
        role="grid"
        aria-labelledby="month-header"
        on-touchend="_preventDefault"
        on-touchstart="_onMonthGridTouchStart"
      >
        <thead id="weekdays-container">
          <tr role="row" part="weekdays">
            <th part="weekday" aria-hidden="true" hidden$="[[!_showWeekSeparator(showWeekNumbers, i18n)]]"></th>
            <template is="dom-repeat" items="[[_getWeekDayNames(i18n, showWeekNumbers)]]">
              <th role="columnheader" part="weekday" scope="col" abbr$="[[item.weekDay]]" aria-hidden="true">
                [[item.weekDayShort]]
              </th>
            </template>
          </tr>
        </thead>
        <tbody id="days-container">
          <template is="dom-repeat" items="[[_weeks]]" as="week">
            <tr role="row">
              <td part="week-number" aria-hidden="true" hidden$="[[!_showWeekSeparator(showWeekNumbers, i18n)]]">
                [[__getWeekNumber(week)]]
              </td>
              <template is="dom-repeat" items="[[week]]">
                <td
                  role="gridcell"
                  part$="[[__getDatePart(item, focusedDate, selectedDate, minDate, maxDate, isDateDisabled, enteredDate, __hasFocus)]]"
                  date="[[item]]"
                  tabindex$="[[__getDayTabindex(item, focusedDate)]]"
                  disabled$="[[__isDayDisabled(item, minDate, maxDate, isDateDisabled)]]"
                  aria-selected$="[[__getDayAriaSelected(item, selectedDate)]]"
                  aria-disabled$="[[__getDayAriaDisabled(item, minDate, maxDate, isDateDisabled)]]"
                  aria-label$="[[__getDayAriaLabel(item)]]"
                  >[[_getDate(item)]]</td
                >
              </template>
            </tr>
          </template>
        </tbody>
      </table>
    `;
  }
  static get is() {
    return "vaadin-month-calendar";
  }
  static get properties() {
    return {
      /** @protected */
      _days: {
        type: Array,
        computed: "_getDays(month, i18n, minDate, maxDate, isDateDisabled)"
      },
      /** @protected */
      _weeks: {
        type: Array,
        computed: "_getWeeks(_days)"
      },
      disabled: {
        type: Boolean,
        reflectToAttribute: true,
        computed: "_isDisabled(month, minDate, maxDate)"
      }
    };
  }
  static get observers() {
    return ["_showWeekNumbersChanged(showWeekNumbers, i18n)"];
  }
  /** @private */
  _showWeekNumbersChanged(showWeekNumbers, i18n) {
    if (showWeekNumbers && i18n && i18n.firstDayOfWeek === 1) {
      this.setAttribute("week-numbers", "");
    } else {
      this.removeAttribute("week-numbers");
    }
  }
  /** @private */
  // eslint-disable-next-line @typescript-eslint/max-params
  __getDatePart(date, focusedDate, selectedDate, minDate, maxDate, isDateDisabled, enteredDate, hasFocus) {
    const result = ["date"];
    const greaterThanToday = date > normalizeDate(/* @__PURE__ */ new Date());
    const lessThanToday = date < normalizeDate(/* @__PURE__ */ new Date());
    if (this.__isDayDisabled(date, minDate, maxDate, isDateDisabled)) {
      result.push("disabled");
    }
    if (dateEquals(date, focusedDate) && (hasFocus || dateEquals(date, enteredDate))) {
      result.push("focused");
    }
    if (this.__isDaySelected(date, selectedDate)) {
      result.push("selected");
    }
    if (this._isToday(date)) {
      result.push("today");
    }
    if (lessThanToday) {
      result.push("past");
    }
    if (greaterThanToday) {
      result.push("future");
    }
    return result.join(" ");
  }
  /** @private */
  __isDaySelected(date, selectedDate) {
    return dateEquals(date, selectedDate);
  }
  /** @private */
  __getDayAriaSelected(date, selectedDate) {
    if (this.__isDaySelected(date, selectedDate)) {
      return "true";
    }
  }
  /** @private */
  __isDayDisabled(date, minDate, maxDate, isDateDisabled) {
    return !dateAllowed(date, minDate, maxDate, isDateDisabled);
  }
  /** @private */
  __getDayAriaDisabled(date, min, max, isDateDisabled) {
    if (date === void 0 || min === void 0 && max === void 0 && isDateDisabled === void 0) {
      return;
    }
    if (this.__isDayDisabled(date, min, max, isDateDisabled)) {
      return "true";
    }
  }
  /** @private */
  __getDayTabindex(date, focusedDate) {
    return dateEquals(date, focusedDate) ? "0" : "-1";
  }
}
defineCustomElement(MonthCalendar);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DatePickerOverlayContentMixin = (superClass) => class DatePickerOverlayContentMixin extends superClass {
  static get properties() {
    return {
      scrollDuration: {
        type: Number,
        value: 300
      },
      /**
       * The value for this element.
       */
      selectedDate: {
        type: Object,
        value: null,
        sync: true
      },
      /**
       * Date value which is focused using keyboard.
       */
      focusedDate: {
        type: Object,
        notify: true,
        observer: "_focusedDateChanged",
        sync: true
      },
      _focusedMonthDate: Number,
      /**
       * Date which should be visible when there is no value selected.
       */
      initialPosition: {
        type: Object,
        observer: "_initialPositionChanged",
        sync: true
      },
      _originDate: {
        type: Object,
        value: /* @__PURE__ */ new Date()
      },
      _visibleMonthIndex: Number,
      _desktopMode: {
        type: Boolean,
        observer: "_desktopModeChanged"
      },
      _desktopMediaQuery: {
        type: String,
        value: "(min-width: 375px)"
      },
      _translateX: {
        observer: "_translateXChanged"
      },
      _yearScrollerWidth: {
        value: 50
      },
      i18n: {
        type: Object
      },
      showWeekNumbers: {
        type: Boolean,
        value: false
      },
      _ignoreTaps: Boolean,
      _notTapping: Boolean,
      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       */
      minDate: {
        type: Object,
        sync: true
      },
      /**
       * The latest date that can be selected. All later dates will be disabled.
       */
      maxDate: {
        type: Object,
        sync: true
      },
      /**
       * A function to be used to determine whether the user can select a given date.
       * Receives a `DatePickerDate` object of the date to be selected and should return a
       * boolean.
       *
       * @type {function(DatePickerDate): boolean | undefined}
       */
      isDateDisabled: {
        type: Function
      },
      enteredDate: {
        type: Date,
        sync: true
      },
      /**
       * Input label
       */
      label: String,
      _cancelButton: {
        type: Object
      },
      _todayButton: {
        type: Object
      },
      calendars: {
        type: Array,
        value: () => []
      },
      years: {
        type: Array,
        value: () => []
      }
    };
  }
  static get observers() {
    return [
      "__updateCalendars(calendars, i18n, minDate, maxDate, selectedDate, focusedDate, showWeekNumbers, _ignoreTaps, _theme, isDateDisabled, enteredDate)",
      "__updateCancelButton(_cancelButton, i18n)",
      "__updateTodayButton(_todayButton, i18n, minDate, maxDate, isDateDisabled)",
      "__updateYears(years, selectedDate, _theme)"
    ];
  }
  /**
   * Whether to scroll to a sub-month position when scrolling to a date.
   * This is active if the month scroller is not large enough to fit a
   * full month. In that case we want to scroll to a position between
   * two months in order to have the focused date in the visible area.
   * @returns {boolean} whether to use sub-month scrolling
   * @private
   */
  get __useSubMonthScrolling() {
    return this._monthScroller.clientHeight < this._monthScroller.itemHeight + this._monthScroller.bufferOffset;
  }
  get focusableDateElement() {
    return this.calendars.map((calendar) => calendar.focusableDateElement).find(Boolean);
  }
  /** @protected */
  _addListeners() {
    setTouchAction(this.$.scrollers, "pan-y");
    addListener(this.$.scrollers, "track", this._track.bind(this));
    addListener(this.shadowRoot.querySelector('[part="clear-button"]'), "tap", this._clear.bind(this));
    addListener(this.shadowRoot.querySelector('[part="toggle-button"]'), "tap", this._cancel.bind(this));
    addListener(
      this.shadowRoot.querySelector('[part="years-toggle-button"]'),
      "tap",
      this._toggleYearScroller.bind(this)
    );
  }
  /** @protected */
  _initControllers() {
    this.addController(
      new MediaQueryController(this._desktopMediaQuery, (matches2) => {
        this._desktopMode = matches2;
      })
    );
    this.addController(
      new SlotController(this, "today-button", "vaadin-button", {
        observe: false,
        initializer: (btn) => {
          btn.setAttribute("theme", "tertiary");
          btn.addEventListener("keydown", (e2) => this.__onTodayButtonKeyDown(e2));
          addListener(btn, "tap", this._onTodayTap.bind(this));
          this._todayButton = btn;
        }
      })
    );
    this.addController(
      new SlotController(this, "cancel-button", "vaadin-button", {
        observe: false,
        initializer: (btn) => {
          btn.setAttribute("theme", "tertiary");
          btn.addEventListener("keydown", (e2) => this.__onCancelButtonKeyDown(e2));
          addListener(btn, "tap", this._cancel.bind(this));
          this._cancelButton = btn;
        }
      })
    );
    this.__initMonthScroller();
    this.__initYearScroller();
  }
  reset() {
    this._closeYearScroller();
    this._toggleAnimateClass(true);
  }
  /**
   * Focuses the cancel button
   */
  focusCancel() {
    this._cancelButton.focus();
  }
  /**
   * Scrolls the list to the given Date.
   */
  scrollToDate(date, animate) {
    const offset = this.__useSubMonthScrolling ? this._calculateWeekScrollOffset(date) : 0;
    this._scrollToPosition(this._differenceInMonths(date, this._originDate) + offset, animate);
    this._monthScroller.forceUpdate();
  }
  /** @private */
  __initMonthScroller() {
    this.addController(
      new SlotController(this, "months", "vaadin-date-picker-month-scroller", {
        observe: false,
        initializer: (scroller2) => {
          scroller2.addEventListener("custom-scroll", () => {
            this._onMonthScroll();
          });
          scroller2.addEventListener("touchstart", () => {
            this._onMonthScrollTouchStart();
          });
          scroller2.addEventListener("keydown", (e2) => {
            this.__onMonthCalendarKeyDown(e2);
          });
          scroller2.addEventListener("init-done", () => {
            const calendars = [...this.querySelectorAll("vaadin-month-calendar")];
            calendars.forEach((calendar) => {
              calendar.addEventListener("selected-date-changed", (e2) => {
                this.selectedDate = e2.detail.value;
              });
            });
            this.calendars = calendars;
          });
          this._monthScroller = scroller2;
        }
      })
    );
  }
  /** @private */
  __initYearScroller() {
    this.addController(
      new SlotController(this, "years", "vaadin-date-picker-year-scroller", {
        observe: false,
        initializer: (scroller2) => {
          scroller2.setAttribute("aria-hidden", "true");
          addListener(scroller2, "tap", (e2) => {
            this._onYearTap(e2);
          });
          scroller2.addEventListener("custom-scroll", () => {
            this._onYearScroll();
          });
          scroller2.addEventListener("touchstart", () => {
            this._onYearScrollTouchStart();
          });
          scroller2.addEventListener("init-done", () => {
            this.years = [...this.querySelectorAll("vaadin-date-picker-year")];
          });
          this._yearScroller = scroller2;
        }
      })
    );
  }
  /** @private */
  __updateCancelButton(cancelButton, i18n) {
    if (cancelButton) {
      cancelButton.textContent = i18n && i18n.cancel;
    }
  }
  /** @private */
  __updateTodayButton(todayButton, i18n, minDate, maxDate, isDateDisabled) {
    if (todayButton) {
      todayButton.textContent = i18n && i18n.today;
      todayButton.disabled = !this._isTodayAllowed(minDate, maxDate, isDateDisabled);
    }
  }
  // eslint-disable-next-line @typescript-eslint/max-params
  __updateCalendars(calendars, i18n, minDate, maxDate, selectedDate, focusedDate, showWeekNumbers, ignoreTaps, theme, isDateDisabled, enteredDate) {
    if (calendars && calendars.length) {
      calendars.forEach((calendar) => {
        calendar.i18n = i18n;
        calendar.minDate = minDate;
        calendar.maxDate = maxDate;
        calendar.isDateDisabled = isDateDisabled;
        calendar.focusedDate = focusedDate;
        calendar.selectedDate = selectedDate;
        calendar.showWeekNumbers = showWeekNumbers;
        calendar.ignoreTaps = ignoreTaps;
        calendar.enteredDate = enteredDate;
        if (theme) {
          calendar.setAttribute("theme", theme);
        } else {
          calendar.removeAttribute("theme");
        }
      });
    }
  }
  /** @private */
  __updateYears(years, selectedDate, theme) {
    if (years && years.length) {
      years.forEach((year) => {
        year.selectedDate = selectedDate;
        if (theme) {
          year.setAttribute("theme", theme);
        } else {
          year.removeAttribute("theme");
        }
      });
    }
  }
  /**
   * Select a date and fire event indicating user interaction.
   * @protected
   */
  _selectDate(dateToSelect) {
    if (!this._dateAllowed(dateToSelect)) {
      return false;
    }
    this.selectedDate = dateToSelect;
    this.dispatchEvent(
      new CustomEvent("date-selected", { detail: { date: dateToSelect }, bubbles: true, composed: true })
    );
    return true;
  }
  /** @private */
  _desktopModeChanged(desktopMode) {
    this.toggleAttribute("desktop", desktopMode);
  }
  /** @private */
  _focusedDateChanged(focusedDate) {
    this.revealDate(focusedDate);
  }
  /**
   * Scrolls the month and year scrollers enough to reveal the given date.
   */
  revealDate(date, animate = true) {
    if (!date) {
      return;
    }
    const diff = this._differenceInMonths(date, this._originDate);
    if (this.__useSubMonthScrolling) {
      const offset = this._calculateWeekScrollOffset(date);
      this._scrollToPosition(diff + offset, animate);
      return;
    }
    const scrolledAboveViewport = this._monthScroller.position > diff;
    const visibleArea = Math.max(
      this._monthScroller.itemHeight,
      this._monthScroller.clientHeight - this._monthScroller.bufferOffset * 2
    );
    const visibleItems = visibleArea / this._monthScroller.itemHeight;
    const scrolledBelowViewport = this._monthScroller.position + visibleItems - 1 < diff;
    if (scrolledAboveViewport) {
      this._scrollToPosition(diff, animate);
    } else if (scrolledBelowViewport) {
      this._scrollToPosition(diff - visibleItems + 1, animate);
    }
  }
  /**
   * Calculates an offset to be added to the month scroll position
   * when using sub-month scrolling, in order ensure that the week
   * that the date is in is visible even for small scroll areas.
   * As the month scroller uses a month as minimal scroll unit
   * (a value of `1` equals one month), we can not exactly identify
   * the position of a specific week. This is a best effort
   * implementation based on manual testing.
   * @param date the date for which to calculate the offset
   * @returns {number} the offset
   * @private
   */
  _calculateWeekScrollOffset(date) {
    const temp = new Date(0, 0);
    temp.setFullYear(date.getFullYear());
    temp.setMonth(date.getMonth());
    temp.setDate(1);
    let week = 0;
    while (temp.getDate() < date.getDate()) {
      temp.setDate(temp.getDate() + 1);
      if (temp.getDay() === this.i18n.firstDayOfWeek) {
        week += 1;
      }
    }
    return week / 6;
  }
  /** @private */
  _initialPositionChanged(initialPosition) {
    if (this._monthScroller && this._yearScroller) {
      this._monthScroller.active = true;
      this._yearScroller.active = true;
    }
    this.scrollToDate(initialPosition);
  }
  /** @private */
  _repositionYearScroller() {
    const monthPosition = this._monthScroller.position;
    this._visibleMonthIndex = Math.floor(monthPosition);
    this._yearScroller.position = (monthPosition + this._originDate.getMonth()) / 12;
  }
  /** @private */
  _repositionMonthScroller() {
    this._monthScroller.position = this._yearScroller.position * 12 - this._originDate.getMonth();
    this._visibleMonthIndex = Math.floor(this._monthScroller.position);
  }
  /** @private */
  _onMonthScroll() {
    this._repositionYearScroller();
    this._doIgnoreTaps();
  }
  /** @private */
  _onYearScroll() {
    this._repositionMonthScroller();
    this._doIgnoreTaps();
  }
  /** @private */
  _onYearScrollTouchStart() {
    this._notTapping = false;
    setTimeout(() => {
      this._notTapping = true;
    }, 300);
    this._repositionMonthScroller();
  }
  /** @private */
  _onMonthScrollTouchStart() {
    this._repositionYearScroller();
  }
  /** @private */
  _doIgnoreTaps() {
    this._ignoreTaps = true;
    this._debouncer = Debouncer$1.debounce(this._debouncer, timeOut.after(300), () => {
      this._ignoreTaps = false;
    });
  }
  /** @protected */
  _formatDisplayed(date, i18n, label) {
    if (date && i18n && typeof i18n.formatDate === "function") {
      return i18n.formatDate(extractDateParts(date));
    }
    return label;
  }
  /** @private */
  _onTodayTap() {
    const today = this._getTodayMidnight();
    if (Math.abs(this._monthScroller.position - this._differenceInMonths(today, this._originDate)) < 1e-3) {
      this._selectDate(today);
      this._close();
    } else {
      this._scrollToCurrentMonth();
    }
  }
  /** @private */
  _scrollToCurrentMonth() {
    if (this.focusedDate) {
      this.focusedDate = /* @__PURE__ */ new Date();
    }
    this.scrollToDate(/* @__PURE__ */ new Date(), true);
  }
  /** @private */
  _onYearTap(e2) {
    if (!this._ignoreTaps && !this._notTapping) {
      const scrollDelta = e2.detail.y - (this._yearScroller.getBoundingClientRect().top + this._yearScroller.clientHeight / 2);
      const yearDelta = scrollDelta / this._yearScroller.itemHeight;
      this._scrollToPosition(this._monthScroller.position + yearDelta * 12, true);
    }
  }
  /** @private */
  _scrollToPosition(targetPosition, animate) {
    if (this._targetPosition !== void 0) {
      this._targetPosition = targetPosition;
      return;
    }
    if (!animate) {
      this._monthScroller.position = targetPosition;
      this._monthScroller.forceUpdate();
      this._targetPosition = void 0;
      this._repositionYearScroller();
      this.__tryFocusDate();
      return;
    }
    this._targetPosition = targetPosition;
    let revealResolve;
    this._revealPromise = new Promise((resolve) => {
      revealResolve = resolve;
    });
    const easingFunction = (t2, b2, c2, d3) => {
      t2 /= d3 / 2;
      if (t2 < 1) {
        return c2 / 2 * t2 * t2 + b2;
      }
      t2 -= 1;
      return -c2 / 2 * (t2 * (t2 - 2) - 1) + b2;
    };
    let start = 0;
    const initialPosition = this._monthScroller.position;
    const smoothScroll = (timestamp) => {
      if (!start) {
        start = timestamp;
      }
      const currentTime = timestamp - start;
      if (currentTime < this.scrollDuration) {
        const currentPos = easingFunction(
          currentTime,
          initialPosition,
          this._targetPosition - initialPosition,
          this.scrollDuration
        );
        this._monthScroller.position = currentPos;
        window.requestAnimationFrame(smoothScroll);
      } else {
        this.dispatchEvent(
          new CustomEvent("scroll-animation-finished", {
            bubbles: true,
            composed: true,
            detail: {
              position: this._targetPosition,
              oldPosition: initialPosition
            }
          })
        );
        this._monthScroller.position = this._targetPosition;
        this._monthScroller.forceUpdate();
        this._targetPosition = void 0;
        revealResolve();
        this._revealPromise = void 0;
      }
      setTimeout(this._repositionYearScroller.bind(this), 1);
    };
    window.requestAnimationFrame(smoothScroll);
  }
  /** @private */
  _limit(value, range) {
    return Math.min(range.max, Math.max(range.min, value));
  }
  /** @private */
  _handleTrack(e2) {
    if (Math.abs(e2.detail.dx) < 10 || Math.abs(e2.detail.ddy) > 10) {
      return;
    }
    if (Math.abs(e2.detail.ddx) > this._yearScrollerWidth / 3) {
      this._toggleAnimateClass(true);
    }
    const newTranslateX = this._translateX + e2.detail.ddx;
    this._translateX = this._limit(newTranslateX, {
      min: 0,
      max: this._yearScrollerWidth
    });
  }
  /** @private */
  _track(e2) {
    if (this._desktopMode) {
      return;
    }
    switch (e2.detail.state) {
      case "start":
        this._toggleAnimateClass(false);
        break;
      case "track":
        this._handleTrack(e2);
        break;
      case "end":
        this._toggleAnimateClass(true);
        if (this._translateX >= this._yearScrollerWidth / 2) {
          this._closeYearScroller();
        } else {
          this._openYearScroller();
        }
        break;
    }
  }
  /** @private */
  _toggleAnimateClass(enable) {
    if (enable) {
      this.classList.add("animate");
    } else {
      this.classList.remove("animate");
    }
  }
  /** @private */
  _toggleYearScroller() {
    if (this._isYearScrollerVisible()) {
      this._closeYearScroller();
    } else {
      this._openYearScroller();
    }
  }
  /** @private */
  _openYearScroller() {
    this._translateX = 0;
    this.setAttribute("years-visible", "");
  }
  /** @private */
  _closeYearScroller() {
    this.removeAttribute("years-visible");
    this._translateX = this._yearScrollerWidth;
  }
  /** @private */
  _isYearScrollerVisible() {
    return this._translateX < this._yearScrollerWidth / 2;
  }
  /** @private */
  _translateXChanged(x2) {
    if (!this._desktopMode) {
      this._monthScroller.style.transform = `translateX(${x2 - this._yearScrollerWidth}px)`;
      this._yearScroller.style.transform = `translateX(${x2}px)`;
    }
  }
  /** @private */
  _yearAfterXMonths(months) {
    return dateAfterXMonths(months).getFullYear();
  }
  /** @private */
  _differenceInMonths(date1, date2) {
    const months = (date1.getFullYear() - date2.getFullYear()) * 12;
    return months - date2.getMonth() + date1.getMonth();
  }
  /** @private */
  _clear() {
    this._selectDate("");
  }
  /** @private */
  _close() {
    this.dispatchEvent(new CustomEvent("close", { bubbles: true, composed: true }));
  }
  /** @private */
  _cancel() {
    this.focusedDate = this.selectedDate;
    this._close();
  }
  /** @protected */
  _preventDefault(e2) {
    e2.preventDefault();
  }
  /** @private */
  __toggleDate(date) {
    if (dateEquals(date, this.selectedDate)) {
      this._clear();
      this.focusedDate = date;
    } else {
      this._selectDate(date);
    }
  }
  /** @private */
  __onMonthCalendarKeyDown(event) {
    let handled = false;
    switch (event.key) {
      case "ArrowDown":
        this._moveFocusByDays(7);
        handled = true;
        break;
      case "ArrowUp":
        this._moveFocusByDays(-7);
        handled = true;
        break;
      case "ArrowRight":
        this._moveFocusByDays(this.__isRTL ? -1 : 1);
        handled = true;
        break;
      case "ArrowLeft":
        this._moveFocusByDays(this.__isRTL ? 1 : -1);
        handled = true;
        break;
      case "Enter":
        if (this._selectDate(this.focusedDate)) {
          this._close();
          handled = true;
        }
        break;
      case " ":
        this.__toggleDate(this.focusedDate);
        handled = true;
        break;
      case "Home":
        this._moveFocusInsideMonth(this.focusedDate, "minDate");
        handled = true;
        break;
      case "End":
        this._moveFocusInsideMonth(this.focusedDate, "maxDate");
        handled = true;
        break;
      case "PageDown":
        this._moveFocusByMonths(event.shiftKey ? 12 : 1);
        handled = true;
        break;
      case "PageUp":
        this._moveFocusByMonths(event.shiftKey ? -12 : -1);
        handled = true;
        break;
      case "Tab":
        this._onTabKeyDown(event, "calendar");
        break;
    }
    if (handled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /** @private */
  _onTabKeyDown(event, section) {
    event.stopPropagation();
    switch (section) {
      case "calendar":
        if (event.shiftKey) {
          event.preventDefault();
          if (this.hasAttribute("fullscreen")) {
            this.focusCancel();
          } else {
            this.__focusInput();
          }
        }
        break;
      case "today":
        if (event.shiftKey) {
          event.preventDefault();
          this.focusDateElement();
        }
        break;
      case "cancel":
        if (!event.shiftKey) {
          event.preventDefault();
          if (this.hasAttribute("fullscreen")) {
            this.focusDateElement();
          } else {
            this.__focusInput();
          }
        }
        break;
    }
  }
  /** @private */
  __onTodayButtonKeyDown(event) {
    if (event.key === "Tab") {
      this._onTabKeyDown(event, "today");
    }
  }
  /** @private */
  __onCancelButtonKeyDown(event) {
    if (event.key === "Tab") {
      this._onTabKeyDown(event, "cancel");
    }
  }
  /** @private */
  __focusInput() {
    this.dispatchEvent(new CustomEvent("focus-input", { bubbles: true, composed: true }));
  }
  /** @private */
  __tryFocusDate() {
    const dateToFocus = this.__pendingDateFocus;
    if (dateToFocus) {
      const dateElement = this.focusableDateElement;
      if (dateElement && dateEquals(dateElement.date, this.__pendingDateFocus)) {
        delete this.__pendingDateFocus;
        dateElement.focus();
      }
    }
  }
  async focusDate(date, keepMonth) {
    const dateToFocus = date || this.selectedDate || this.initialPosition || /* @__PURE__ */ new Date();
    this.focusedDate = dateToFocus;
    if (!keepMonth) {
      this._focusedMonthDate = dateToFocus.getDate();
    }
    await this.focusDateElement(false);
  }
  async focusDateElement(reveal = true) {
    this.__pendingDateFocus = this.focusedDate;
    if (!this.calendars.length) {
      await new Promise((resolve) => {
        afterNextRender(this, () => {
          flush();
          resolve();
        });
      });
    }
    if (reveal) {
      this.revealDate(this.focusedDate);
    }
    if (this._revealPromise) {
      await this._revealPromise;
    }
    this.__tryFocusDate();
  }
  /** @private */
  _focusClosestDate(focus) {
    this.focusDate(getClosestDate(focus, [this.minDate, this.maxDate]));
  }
  /** @private */
  _focusAllowedDate(dateToFocus, diff, keepMonth) {
    if (this._dateAllowed(dateToFocus, void 0, void 0, () => false)) {
      this.focusDate(dateToFocus, keepMonth);
    } else if (this._dateAllowed(this.focusedDate)) {
      if (diff > 0) {
        this.focusDate(this.maxDate);
      } else {
        this.focusDate(this.minDate);
      }
    } else {
      this._focusClosestDate(this.focusedDate);
    }
  }
  /** @private */
  _getDateDiff(months, days) {
    const date = new Date(0, 0);
    date.setFullYear(this.focusedDate.getFullYear());
    date.setMonth(this.focusedDate.getMonth() + months);
    if (days) {
      date.setDate(this.focusedDate.getDate() + days);
    }
    return date;
  }
  /** @private */
  _moveFocusByDays(days) {
    const dateToFocus = this._getDateDiff(0, days);
    this._focusAllowedDate(dateToFocus, days, false);
  }
  /** @private */
  _moveFocusByMonths(months) {
    const dateToFocus = this._getDateDiff(months);
    const targetMonth = dateToFocus.getMonth();
    if (!this._focusedMonthDate) {
      this._focusedMonthDate = this.focusedDate.getDate();
    }
    dateToFocus.setDate(this._focusedMonthDate);
    if (dateToFocus.getMonth() !== targetMonth) {
      dateToFocus.setDate(0);
    }
    this._focusAllowedDate(dateToFocus, months, true);
  }
  /** @private */
  _moveFocusInsideMonth(focusedDate, property) {
    const dateToFocus = new Date(0, 0);
    dateToFocus.setFullYear(focusedDate.getFullYear());
    if (property === "minDate") {
      dateToFocus.setMonth(focusedDate.getMonth());
      dateToFocus.setDate(1);
    } else {
      dateToFocus.setMonth(focusedDate.getMonth() + 1);
      dateToFocus.setDate(0);
    }
    if (this._dateAllowed(dateToFocus)) {
      this.focusDate(dateToFocus);
    } else if (this._dateAllowed(focusedDate)) {
      this.focusDate(this[property]);
    } else {
      this._focusClosestDate(focusedDate);
    }
  }
  /** @private */
  _dateAllowed(date, min = this.minDate, max = this.maxDate, isDateDisabled = this.isDateDisabled) {
    return dateAllowed(date, min, max, isDateDisabled);
  }
  /** @private */
  _isTodayAllowed(min, max, isDateDisabled) {
    return this._dateAllowed(this._getTodayMidnight(), min, max, isDateDisabled);
  }
  /** @private */
  _getTodayMidnight() {
    const today = /* @__PURE__ */ new Date();
    const todayMidnight = new Date(0, 0);
    todayMidnight.setFullYear(today.getFullYear());
    todayMidnight.setMonth(today.getMonth());
    todayMidnight.setDate(today.getDate());
    return todayMidnight;
  }
  /**
   * Fired when the scroller reaches the target scrolling position.
   * @event scroll-animation-finished
   * @param {Number} detail.position new position
   * @param {Number} detail.oldPosition old position
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const overlayContentStyles = css`
  :host {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
    outline: none;
  }

  [part='overlay-header'] {
    display: flex;
    flex-shrink: 0;
    flex-wrap: nowrap;
    align-items: center;
  }

  :host(:not([fullscreen])) [part='overlay-header'] {
    display: none;
  }

  [part='label'] {
    flex-grow: 1;
  }

  [hidden] {
    display: none !important;
  }

  [part='years-toggle-button'] {
    display: flex;
  }

  #scrollers {
    display: flex;
    height: 100%;
    width: 100%;
    position: relative;
    overflow: hidden;
  }

  :host([desktop]) ::slotted([slot='months']) {
    right: 50px;
    transform: none !important;
  }

  :host([desktop]) ::slotted([slot='years']) {
    transform: none !important;
  }

  :host(.animate) ::slotted([slot='months']),
  :host(.animate) ::slotted([slot='years']) {
    transition: all 200ms;
  }

  [part='toolbar'] {
    display: flex;
    justify-content: space-between;
    z-index: 2;
    flex-shrink: 0;
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-date-picker-overlay-content", overlayContentStyles, {
  moduleId: "vaadin-date-picker-overlay-content-styles"
});
class DatePickerOverlayContent extends DatePickerOverlayContentMixin(
  ControllerMixin(ThemableMixin(DirMixin(PolymerElement)))
) {
  static get template() {
    return html`
      <div part="overlay-header" on-touchend="_preventDefault" aria-hidden="true">
        <div part="label">[[_formatDisplayed(selectedDate, i18n, label)]]</div>
        <div part="clear-button" hidden$="[[!selectedDate]]"></div>
        <div part="toggle-button"></div>

        <div part="years-toggle-button" hidden$="[[_desktopMode]]" aria-hidden="true">
          [[_yearAfterXMonths(_visibleMonthIndex)]]
        </div>
      </div>

      <div id="scrollers">
        <slot name="months"></slot>
        <slot name="years"></slot>
      </div>

      <div on-touchend="_preventDefault" role="toolbar" part="toolbar">
        <slot name="today-button"></slot>
        <slot name="cancel-button"></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-date-picker-overlay-content";
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "dialog");
    this._addListeners();
    this._initControllers();
  }
}
defineCustomElement(DatePickerOverlayContent);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const datePickerI18nDefaults = Object.freeze({
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  firstDayOfWeek: 0,
  today: "Today",
  cancel: "Cancel",
  referenceDate: "",
  formatDate(d3) {
    const yearStr = String(d3.year).replace(/\d+/u, (y3) => "0000".substr(y3.length) + y3);
    return [d3.month + 1, d3.day, yearStr].join("/");
  },
  parseDate(text) {
    const parts = text.split("/");
    const today = /* @__PURE__ */ new Date();
    let date, month = today.getMonth(), year = today.getFullYear();
    if (parts.length === 3) {
      month = parseInt(parts[0]) - 1;
      date = parseInt(parts[1]);
      year = parseInt(parts[2]);
      if (parts[2].length < 3 && year >= 0) {
        const usedReferenceDate = this.referenceDate ? parseDate(this.referenceDate) : /* @__PURE__ */ new Date();
        year = getAdjustedYear(usedReferenceDate, year, month, date);
      }
    } else if (parts.length === 2) {
      month = parseInt(parts[0]) - 1;
      date = parseInt(parts[1]);
    } else if (parts.length === 1) {
      date = parseInt(parts[0]);
    }
    if (date !== void 0) {
      return { day: date, month, year };
    }
  },
  formatTitle: (monthName, fullYear) => {
    return `${monthName} ${fullYear}`;
  }
});
const DatePickerMixin = (subclass) => class DatePickerMixinClass extends OverlayClassMixin(
  ControllerMixin(DelegateFocusMixin(InputConstraintsMixin(KeyboardMixin(subclass))))
) {
  static get properties() {
    return {
      /**
       * The current selected date.
       * @type {Date | undefined}
       * @protected
       */
      _selectedDate: {
        type: Object,
        sync: true
      },
      /**
       * @type {Date | undefined}
       * @protected
       */
      _focusedDate: {
        type: Object,
        sync: true
      },
      /**
       * Selected date.
       *
       * Supported date formats:
       * - ISO 8601 `"YYYY-MM-DD"` (default)
       * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
       *
       * @type {string}
       */
      value: {
        type: String,
        notify: true,
        value: "",
        sync: true
      },
      /**
       * Date which should be visible when there is no value selected.
       *
       * The same date formats as for the `value` property are supported.
       * @attr {string} initial-position
       */
      initialPosition: String,
      /**
       * Set true to open the date selector overlay.
       */
      opened: {
        type: Boolean,
        reflectToAttribute: true,
        notify: true,
        observer: "_openedChanged",
        sync: true
      },
      /**
       * Set true to prevent the overlay from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: {
        type: Boolean,
        sync: true
      },
      /**
       * Set true to display ISO-8601 week numbers in the calendar. Notice that
       * displaying week numbers is only supported when `i18n.firstDayOfWeek`
       * is 1 (Monday).
       * @attr {boolean} show-week-numbers
       */
      showWeekNumbers: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * @type {boolean}
       * @protected
       */
      _fullscreen: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * @type {string}
       * @protected
       */
      _fullscreenMediaQuery: {
        value: "(max-width: 450px), (max-height: 450px)"
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * `i18n` object with a custom one.
       *
       * To update individual properties, extend the existing i18n object like so:
       * ```
       * datePicker.i18n = { ...datePicker.i18n, {
       *   formatDate: date => { ... },
       *   parseDate: value => { ... },
       * }};
       * ```
       *
       * The object has the following JSON structure and default values:
       *
       * ```
       * {
       *   // An array with the full names of months starting
       *   // with January.
       *   monthNames: [
       *     'January', 'February', 'March', 'April', 'May',
       *     'June', 'July', 'August', 'September',
       *     'October', 'November', 'December'
       *   ],
       *
       *   // An array of weekday names starting with Sunday. Used
       *   // in screen reader announcements.
       *   weekdays: [
       *     'Sunday', 'Monday', 'Tuesday', 'Wednesday',
       *     'Thursday', 'Friday', 'Saturday'
       *   ],
       *
       *   // An array of short weekday names starting with Sunday.
       *   // Displayed in the calendar.
       *   weekdaysShort: [
       *     'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'
       *   ],
       *
       *   // An integer indicating the first day of the week
       *   // (0 = Sunday, 1 = Monday, etc.).
       *   firstDayOfWeek: 0,
       *
       *   // Translation of the Today shortcut button text.
       *   today: 'Today',
       *
       *   // Translation of the Cancel button text.
       *   cancel: 'Cancel',
       *
       *   // Used for adjusting the year value when parsing dates with short years.
       *   // The year values between 0 and 99 are evaluated and adjusted.
       *   // Example: for a referenceDate of 1970-10-30;
       *   //   dateToBeParsed: 40-10-30, result: 1940-10-30
       *   //   dateToBeParsed: 80-10-30, result: 1980-10-30
       *   //   dateToBeParsed: 10-10-30, result: 2010-10-30
       *   // Supported date format: ISO 8601 `"YYYY-MM-DD"` (default)
       *   // The default value is the current date.
       *   referenceDate: '',
       *
       *   // A function to format given `Object` as
       *   // date string. Object is in the format `{ day: ..., month: ..., year: ... }`
       *   // Note: The argument month is 0-based. This means that January = 0 and December = 11.
       *   formatDate: d => {
       *     // returns a string representation of the given
       *     // object in 'MM/DD/YYYY' -format
       *   },
       *
       *   // A function to parse the given text to an `Object` in the format `{ day: ..., month: ..., year: ... }`.
       *   // Must properly parse (at least) text formatted by `formatDate`.
       *   // Setting the property to null will disable keyboard input feature.
       *   // Note: The argument month is 0-based. This means that January = 0 and December = 11.
       *   parseDate: text => {
       *     // Parses a string in 'MM/DD/YY', 'MM/DD' or 'DD' -format to
       *     // an `Object` in the format `{ day: ..., month: ..., year: ... }`.
       *   }
       *
       *   // A function to format given `monthName` and
       *   // `fullYear` integer as calendar title string.
       *   formatTitle: (monthName, fullYear) => {
       *     return monthName + ' ' + fullYear;
       *   }
       * }
       * ```
       *
       * @type {!DatePickerI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        sync: true,
        value: () => ({ ...datePickerI18nDefaults })
      },
      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       *
       * Supported date formats:
       * - ISO 8601 `"YYYY-MM-DD"` (default)
       * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
       *
       * @type {string | undefined}
       */
      min: {
        type: String,
        sync: true
      },
      /**
       * The latest date that can be selected. All later dates will be disabled.
       *
       * Supported date formats:
       * - ISO 8601 `"YYYY-MM-DD"` (default)
       * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
       *
       * @type {string | undefined}
       */
      max: {
        type: String,
        sync: true
      },
      /**
       * A function to be used to determine whether the user can select a given date.
       * Receives a `DatePickerDate` object of the date to be selected and should return a
       * boolean.
       *
       * @type {function(DatePickerDate): boolean | undefined}
       */
      isDateDisabled: {
        type: Function
      },
      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       * @type {Date | undefined}
       * @protected
       */
      _minDate: {
        type: Date,
        computed: "__computeMinOrMaxDate(min)",
        sync: true
      },
      /**
       * The latest date that can be selected. All later dates will be disabled.
       * @type {Date | undefined}
       * @protected
       */
      _maxDate: {
        type: Date,
        computed: "__computeMinOrMaxDate(max)",
        sync: true
      },
      /** @private */
      _noInput: {
        type: Boolean,
        computed: "_isNoInput(inputElement, _fullscreen, _ios, i18n, opened, autoOpenDisabled)"
      },
      /** @private */
      _ios: {
        type: Boolean,
        value: isIOS
      },
      /** @private */
      _focusOverlayOnOpen: Boolean,
      /** @private */
      _overlayContent: {
        type: Object,
        sync: true
      },
      /** @private */
      __enteredDate: {
        type: Date,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "_selectedDateChanged(_selectedDate, i18n)",
      "_focusedDateChanged(_focusedDate, i18n)",
      "__updateOverlayContent(_overlayContent, i18n, label, _minDate, _maxDate, _focusedDate, _selectedDate, showWeekNumbers, isDateDisabled, __enteredDate)",
      "__updateOverlayContentTheme(_overlayContent, _theme)",
      "__updateOverlayContentFullScreen(_overlayContent, _fullscreen)"
    ];
  }
  static get constraints() {
    return [...super.constraints, "min", "max"];
  }
  constructor() {
    super();
    this._boundOnClick = this._onClick.bind(this);
    this._boundOnScroll = this._onScroll.bind(this);
    this._boundOverlayRenderer = this._overlayRenderer.bind(this);
  }
  /** @override */
  get _inputElementValue() {
    return super._inputElementValue;
  }
  /** @override */
  set _inputElementValue(value) {
    super._inputElementValue = value;
    const parsedDate = this.__parseDate(value);
    this.__setEnteredDate(parsedDate);
  }
  /**
   * Override a getter from `InputControlMixin` to make it optional
   * and to prevent warning when a clear button is missing,
   * for example when using <vaadin-date-picker-light>.
   * @protected
   * @return {Element | null | undefined}
   */
  get clearElement() {
    return null;
  }
  /** @private */
  get _nativeInput() {
    if (this.inputElement) {
      return this.inputElement.focusElement || this.inputElement;
    }
    return null;
  }
  /**
   * The input element's value when it cannot be parsed as a date, and an empty string otherwise.
   *
   * @return {string}
   * @private
   */
  get __unparsableValue() {
    if (!this._inputElementValue || this.__parseDate(this._inputElementValue)) {
      return "";
    }
    return this._inputElementValue;
  }
  /**
   * Override an event listener from `DelegateFocusMixin`
   * @protected
   */
  _onFocus(event) {
    super._onFocus(event);
    if (this._noInput && !isKeyboardActive()) {
      event.target.blur();
    }
  }
  /**
   * Override an event listener from `DelegateFocusMixin`
   * @protected
   */
  _onBlur(event) {
    super._onBlur(event);
    if (!this.opened) {
      this.__commitParsedOrFocusedDate();
      if (document.hasFocus()) {
        this._requestValidation();
      }
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("click", this._boundOnClick);
    this.addController(
      new MediaQueryController(this._fullscreenMediaQuery, (matches2) => {
        this._fullscreen = matches2;
      })
    );
    this.addController(new VirtualKeyboardController(this));
    const overlay2 = this.$.overlay;
    this._overlayElement = overlay2;
    overlay2.renderer = this._boundOverlayRenderer;
    this.addEventListener("mousedown", () => this.__bringToFront());
    this.addEventListener("touchstart", () => this.__bringToFront());
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.opened = false;
  }
  /**
   * Opens the dropdown.
   */
  open() {
    if (!this.disabled && !this.readonly) {
      this.opened = true;
    }
  }
  /**
   * Closes the dropdown.
   */
  close() {
    this.$.overlay.close();
  }
  /** @private */
  _overlayRenderer(root2) {
    if (root2.firstChild) {
      return;
    }
    const content = document.createElement("vaadin-date-picker-overlay-content");
    root2.appendChild(content);
    this._overlayContent = content;
    content.addEventListener("close", () => {
      this._close();
    });
    content.addEventListener("focus-input", this._focusAndSelect.bind(this));
    content.addEventListener("date-tap", (e2) => {
      this.__commitDate(e2.detail.date);
      this._close();
    });
    content.addEventListener("date-selected", (e2) => {
      this.__commitDate(e2.detail.date);
    });
    content.addEventListener("focusin", () => {
      if (this._keyboardActive) {
        this._setFocused(true);
      }
    });
    content.addEventListener("focusout", (event) => {
      if (this._shouldRemoveFocus(event)) {
        this._setFocused(false);
      }
    });
    content.addEventListener("focused-date-changed", (e2) => {
      this._focusedDate = e2.detail.value;
    });
    content.addEventListener("click", (e2) => e2.stopPropagation());
  }
  /**
   * @param {string} dateString
   * @private
   */
  __parseDate(dateString) {
    if (!this.i18n.parseDate) {
      return;
    }
    let dateObject = this.i18n.parseDate(dateString);
    if (dateObject) {
      dateObject = parseDate(`${dateObject.year}-${dateObject.month + 1}-${dateObject.day}`);
    }
    if (dateObject && !isNaN(dateObject.getTime())) {
      return dateObject;
    }
  }
  /**
   * @param {Date} dateObject
   * @private
   */
  __formatDate(dateObject) {
    if (this.i18n.formatDate) {
      return this.i18n.formatDate(extractDateParts(dateObject));
    }
  }
  /**
   * Returns true if the current input value satisfies all constraints (if any)
   *
   * Override the `checkValidity` method for custom validations.
   *
   * @return {boolean} True if the value is valid
   */
  checkValidity() {
    const inputValue = this._inputElementValue;
    const inputValid = !inputValue || !!this._selectedDate && inputValue === this.__formatDate(this._selectedDate);
    const isDateValid = !this._selectedDate || dateAllowed(this._selectedDate, this._minDate, this._maxDate, this.isDateDisabled);
    let inputValidity = true;
    if (this.inputElement && this.inputElement.checkValidity) {
      inputValidity = this.inputElement.checkValidity();
    }
    return inputValid && isDateValid && inputValidity;
  }
  /**
   * Override method inherited from `FocusMixin`
   * to not call `_setFocused(true)` when focus
   * is restored after closing overlay on click,
   * and to avoid removing `focus-ring` attribute.
   *
   * @param {!FocusEvent} _event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldSetFocus(_event) {
    return !this._shouldKeepFocusRing;
  }
  /**
   * Override method inherited from `FocusMixin`
   * to prevent removing the `focused` attribute:
   * - when moving focus to the overlay content,
   * - when closing on date click / outside click.
   *
   * @param {FocusEvent} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldRemoveFocus(event) {
    const { relatedTarget } = event;
    if (this.opened && relatedTarget !== null && relatedTarget !== document.body && !this.contains(relatedTarget) && !this._overlayContent.contains(relatedTarget)) {
      return true;
    }
    return !this.opened;
  }
  /**
   * Override method inherited from `FocusMixin`
   * to store the `focus-ring` state to restore
   * it later when closing on outside click.
   *
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    super._setFocused(focused);
    this._shouldKeepFocusRing = focused && this._keyboardActive;
  }
  /**
   * Depending on the nature of the value change that has occurred since
   * the last commit attempt, triggers validation and fires an event:
   *
   * Value change             | Event
   * :------------------------|:------------------
   * empty => parsable        | change
   * empty => unparsable      | unparsable-change
   * parsable => empty        | change
   * parsable => parsable     | change
   * parsable => unparsable   | change
   * unparsable => empty      | unparsable-change
   * unparsable => parsable   | change
   * unparsable => unparsable | unparsable-change
   *
   * @private
   */
  __commitValueChange() {
    const unparsableValue = this.__unparsableValue;
    if (this.__committedValue !== this.value) {
      this._requestValidation();
      this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
    } else if (this.__committedUnparsableValue !== unparsableValue) {
      this._requestValidation();
      this.dispatchEvent(new CustomEvent("unparsable-change"));
    }
    this.__committedValue = this.value;
    this.__committedUnparsableValue = unparsableValue;
  }
  /**
   * Sets the given date as the value and commits it.
   *
   * @param {Date} date
   * @private
   */
  __commitDate(date) {
    this.__keepCommittedValue = true;
    this._selectedDate = date;
    this.__keepCommittedValue = false;
    this.__commitValueChange();
  }
  /** @private */
  _close() {
    this._focus();
    this.close();
  }
  /** @private */
  __bringToFront() {
    requestAnimationFrame(() => {
      this.$.overlay.bringToFront();
    });
  }
  /** @private */
  // eslint-disable-next-line @typescript-eslint/max-params
  _isNoInput(inputElement, fullscreen, ios, i18n, opened, autoOpenDisabled) {
    const noInputOnFullscreenMode = fullscreen && (!autoOpenDisabled || opened);
    const noInputOnIos = ios && opened;
    return !inputElement || noInputOnFullscreenMode || noInputOnIos || !i18n.parseDate;
  }
  /** @private */
  _formatISO(date) {
    return formatISODate(date);
  }
  /** @protected */
  _inputElementChanged(input) {
    super._inputElementChanged(input);
    if (input) {
      input.autocomplete = "off";
      input.setAttribute("role", "combobox");
      input.setAttribute("aria-haspopup", "dialog");
      input.setAttribute("aria-expanded", !!this.opened);
      this._applyInputValue(this._selectedDate);
    }
  }
  /** @protected */
  _openedChanged(opened) {
    if (this.inputElement) {
      this.inputElement.setAttribute("aria-expanded", opened);
    }
  }
  /** @private */
  _selectedDateChanged(selectedDate, i18n) {
    if (selectedDate === void 0 || i18n === void 0) {
      return;
    }
    if (!this.__keepInputValue) {
      this._applyInputValue(selectedDate);
    }
    this.value = this._formatISO(selectedDate);
    this._ignoreFocusedDateChange = true;
    this._focusedDate = selectedDate;
    this._ignoreFocusedDateChange = false;
  }
  /** @private */
  _focusedDateChanged(focusedDate, i18n) {
    if (focusedDate === void 0 || i18n === void 0) {
      return;
    }
    if (!this._ignoreFocusedDateChange && !this._noInput) {
      this._applyInputValue(focusedDate);
    }
  }
  /**
   * Override the value observer from `InputMixin` to implement custom
   * handling of the `value` property. The date-picker doesn't forward
   * the value directly to the input like the default implementation of `InputMixin`.
   * Instead, it parses the value into a date, puts it in `_selectedDate` which
   * is then displayed in the input with respect to the specified date format.
   *
   * @param {string | undefined} value
   * @param {string | undefined} oldValue
   * @protected
   * @override
   */
  _valueChanged(value, oldValue) {
    const newDate = parseDate(value);
    if (value && !newDate) {
      this.value = oldValue;
      return;
    }
    if (value) {
      if (!dateEquals(this._selectedDate, newDate)) {
        this._selectedDate = newDate;
        if (oldValue !== void 0) {
          this._requestValidation();
        }
      }
    } else {
      this._selectedDate = null;
    }
    if (!this.__keepCommittedValue) {
      this.__committedValue = this.value;
      this.__committedUnparsableValue = "";
    }
    this._toggleHasValue(this._hasValue);
  }
  /** @private */
  // eslint-disable-next-line @typescript-eslint/max-params
  __updateOverlayContent(overlayContent, i18n, label, minDate, maxDate, focusedDate, selectedDate, showWeekNumbers, isDateDisabled, enteredDate) {
    if (overlayContent) {
      overlayContent.i18n = i18n;
      overlayContent.label = label;
      overlayContent.minDate = minDate;
      overlayContent.maxDate = maxDate;
      overlayContent.focusedDate = focusedDate;
      overlayContent.selectedDate = selectedDate;
      overlayContent.showWeekNumbers = showWeekNumbers;
      overlayContent.isDateDisabled = isDateDisabled;
      overlayContent.enteredDate = enteredDate;
    }
  }
  /** @private */
  __updateOverlayContentTheme(overlayContent, theme) {
    if (overlayContent) {
      if (theme) {
        overlayContent.setAttribute("theme", theme);
      } else {
        overlayContent.removeAttribute("theme");
      }
    }
  }
  /** @private */
  __updateOverlayContentFullScreen(overlayContent, fullscreen) {
    if (overlayContent) {
      overlayContent.toggleAttribute("fullscreen", fullscreen);
    }
  }
  /** @protected */
  _onOverlayEscapePress() {
    this._focusedDate = this._selectedDate;
    this._closedByEscape = true;
    this._close();
    this._closedByEscape = false;
  }
  /** @protected */
  _onOverlayOpened() {
    const content = this._overlayContent;
    content.reset();
    const initialPosition = this._getInitialPosition();
    content.initialPosition = initialPosition;
    const scrollFocusDate = content.focusedDate || initialPosition;
    content.scrollToDate(scrollFocusDate);
    this._ignoreFocusedDateChange = true;
    content.focusedDate = scrollFocusDate;
    this._ignoreFocusedDateChange = false;
    window.addEventListener("scroll", this._boundOnScroll, true);
    if (this._focusOverlayOnOpen) {
      content.focusDateElement();
      this._focusOverlayOnOpen = false;
    } else {
      this._focus();
    }
    const input = this._nativeInput;
    if (this._noInput && input) {
      input.blur();
      this._overlayContent.focusDateElement();
    }
    const focusables = this._noInput ? content : [input, content];
    this.__showOthers = hideOthers(focusables);
  }
  /** @private */
  _getInitialPosition() {
    const parsedInitialPosition = parseDate(this.initialPosition);
    const initialPosition = this._selectedDate || this._overlayContent.initialPosition || parsedInitialPosition || /* @__PURE__ */ new Date();
    return parsedInitialPosition || dateAllowed(initialPosition, this._minDate, this._maxDate, this.isDateDisabled) ? initialPosition : this._minDate || this._maxDate ? getClosestDate(initialPosition, [this._minDate, this._maxDate]) : /* @__PURE__ */ new Date();
  }
  /**
   * Tries to parse the input element's value as a date. If the input value
   * is parsable, commits the resulting date as the value. Otherwise, commits
   * an empty string as the value. If no i18n parser is provided, commits
   * the focused date as the value.
   *
   * @private
   */
  __commitParsedOrFocusedDate() {
    this._ignoreFocusedDateChange = true;
    if (this.i18n.parseDate) {
      const inputValue = this._inputElementValue || "";
      const parsedDate = this.__parseDate(inputValue);
      if (parsedDate) {
        this.__commitDate(parsedDate);
      } else {
        this.__keepInputValue = true;
        this.__commitDate(null);
        this.__keepInputValue = false;
      }
    } else if (this._focusedDate) {
      this.__commitDate(this._focusedDate);
    }
    this._ignoreFocusedDateChange = false;
  }
  /** @protected */
  _onOverlayClosed() {
    if (this.__showOthers) {
      this.__showOthers();
      this.__showOthers = null;
    }
    window.removeEventListener("scroll", this._boundOnScroll, true);
    if (this._closedByEscape) {
      this._applyInputValue(this._selectedDate);
    }
    this.__commitParsedOrFocusedDate();
    if (this._nativeInput && this._nativeInput.selectionStart) {
      this._nativeInput.selectionStart = this._nativeInput.selectionEnd;
    }
    if (!this.value && !this._keyboardActive) {
      this._requestValidation();
    }
  }
  /** @private */
  _onScroll(e2) {
    if (e2.target === window || !this._overlayContent.contains(e2.target)) {
      this._overlayContent._repositionYearScroller();
    }
  }
  /** @protected */
  _focus() {
    if (!this._noInput) {
      this.inputElement.focus();
    }
  }
  /** @private */
  _focusAndSelect() {
    this._focus();
    this._setSelectionRange(0, this._inputElementValue.length);
  }
  /** @private */
  _applyInputValue(date) {
    this._inputElementValue = date ? this.__formatDate(date) : "";
  }
  /** @private */
  _setSelectionRange(a3, b2) {
    if (this._nativeInput && this._nativeInput.setSelectionRange) {
      this._nativeInput.setSelectionRange(a3, b2);
    }
  }
  /**
   * Override an event listener from `InputConstraintsMixin`
   * to have date-picker fully control when to fire a change event
   * and trigger validation.
   *
   * @protected
   */
  _onChange(event) {
    event.stopPropagation();
  }
  /**
   * @param {Event} event
   * @private
   */
  _onClick(event) {
    if (!this._isClearButton(event)) {
      this._onHostClick(event);
    }
  }
  /**
   * @param {Event} event
   * @private
   */
  _onHostClick(event) {
    if (!this.autoOpenDisabled || this._noInput) {
      event.preventDefault();
      this.open();
    }
  }
  /**
   * Override an event listener from `InputControlMixin`
   * to validate and dispatch change on clear.
   * @protected
   */
  _onClearButtonClick(event) {
    event.preventDefault();
    this.__commitDate(null);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onKeyDown(e2) {
    super._onKeyDown(e2);
    if (this._noInput) {
      const allowedKeys = [
        9
        // Tab
      ];
      if (allowedKeys.indexOf(e2.keyCode) === -1) {
        e2.preventDefault();
      }
    }
    switch (e2.key) {
      case "ArrowDown":
      case "ArrowUp":
        e2.preventDefault();
        if (this.opened) {
          this._overlayContent.focusDateElement();
        } else {
          this._focusOverlayOnOpen = true;
          this.open();
        }
        break;
      case "Tab":
        if (this.opened) {
          e2.preventDefault();
          e2.stopPropagation();
          this._setSelectionRange(0, 0);
          if (e2.shiftKey) {
            this._overlayContent.focusCancel();
          } else {
            this._overlayContent.focusDateElement();
          }
        }
        break;
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {!KeyboardEvent} _event
   * @protected
   * @override
   */
  _onEnter(_event) {
    if (this.opened) {
      this.close();
    } else {
      this.__commitParsedOrFocusedDate();
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * Do not call `super` in order to override clear
   * button logic defined in `InputControlMixin`.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (this.opened) {
      return;
    }
    if (this.clearButtonVisible && !!this.value && !this.readonly) {
      event.stopPropagation();
      this._onClearButtonClick(event);
      return;
    }
    if (this.inputElement.value === "") {
      this.__commitDate(null);
    } else {
      this._applyInputValue(this._selectedDate);
    }
  }
  /** @protected */
  _isClearButton(event) {
    return event.composedPath()[0] === this.clearElement;
  }
  /**
   * Override an event listener from `InputMixin`
   * @protected
   */
  _onInput() {
    if (!this.opened && this._inputElementValue && !this.autoOpenDisabled) {
      this.open();
    }
    const parsedDate = this.__parseDate(this._inputElementValue || "");
    if (parsedDate) {
      this._ignoreFocusedDateChange = true;
      if (!dateEquals(parsedDate, this._focusedDate)) {
        this._focusedDate = parsedDate;
      }
      this._ignoreFocusedDateChange = false;
    }
    this.__setEnteredDate(parsedDate);
  }
  /**
   * @param {Date} date
   * @private
   */
  __setEnteredDate(date) {
    if (date) {
      if (!dateEquals(this.__enteredDate, date)) {
        this.__enteredDate = date;
      }
    } else if (this.__enteredDate != null) {
      this.__enteredDate = null;
    }
  }
  /** @private */
  __computeMinOrMaxDate(dateString) {
    return parseDate(dateString);
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
  /**
   * Fired when `value` property value changes.
   *
   * @event value-changed
   */
  /**
   * Fired when `opened` property value changes.
   *
   * @event opened-changed
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const datePickerStyles = css`
  :host([opened]) {
    pointer-events: auto;
  }

  :host([dir='rtl']) [part='input-field'] {
    direction: ltr;
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input)::placeholder {
    direction: rtl;
    text-align: left;
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-date-picker", [inputFieldShared, datePickerStyles], { moduleId: "vaadin-date-picker-styles" });
class DatePicker extends DatePickerMixin(InputControlMixin(ThemableMixin(ElementMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-date-picker";
  }
  static get template() {
    return html`
      <div class="vaadin-date-picker-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div part="toggle-button" slot="suffix" aria-hidden="true" on-click="_toggle"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-date-picker-overlay
        id="overlay"
        fullscreen$="[[_fullscreen]]"
        theme$="[[_theme]]"
        opened="{{opened}}"
        on-vaadin-overlay-escape-press="_onOverlayEscapePress"
        on-vaadin-overlay-open="_onOverlayOpened"
        on-vaadin-overlay-closing="_onOverlayClosed"
        restore-focus-on-close
        restore-focus-node="[[inputElement]]"
      ></vaadin-date-picker-overlay>

      <slot name="tooltip"></slot>
    `;
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(
        this,
        (input) => {
          this._setInputElement(input);
          this._setFocusElement(input);
          this.stateTarget = input;
          this.ariaTarget = input;
        },
        {
          // The "search" word is a trick to prevent Safari from enabling AutoFill,
          // which is causing click issues:
          // https://github.com/vaadin/web-components/issues/6817#issuecomment-2268229567
          uniqueIdPrefix: "search-input"
        }
      )
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this._tooltipController.setShouldShow((target) => !target.opened);
    const toggleButton = this.shadowRoot.querySelector('[part="toggle-button"]');
    toggleButton.addEventListener("mousedown", (e2) => e2.preventDefault());
    this.$.overlay.addEventListener("vaadin-overlay-close", this._onVaadinOverlayClose.bind(this));
  }
  /** @private */
  _onVaadinOverlayClose(e2) {
    if (e2.detail.sourceEvent && e2.detail.sourceEvent.composedPath().includes(this)) {
      e2.preventDefault();
    }
  }
  /** @private */
  _toggle(e2) {
    e2.stopPropagation();
    if (this.$.overlay.opened) {
      this.close();
    } else {
      this.open();
    }
  }
  // Workaround https://github.com/vaadin/web-components/issues/2855
  /** @protected */
  _openedChanged(opened) {
    super._openedChanged(opened);
    this.$.overlay.positionTarget = this.shadowRoot.querySelector('[part="input-field"]');
    this.$.overlay.noVerticalOverlap = true;
  }
}
defineCustomElement(DatePicker);
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function _typeof$y(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$y = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$y = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$y(obj);
}
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof$y(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function _typeof$x(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$x = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$x = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$x(obj);
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof$x(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return /* @__PURE__ */ new Date(NaN);
  }
}
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = /* @__PURE__ */ new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}
var formatters$1 = {
  // Year
  y: function y(date, token) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function d(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h: function h(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function H(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  // Minute
  m: function m(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function s(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function G(date, token, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      // A, B
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  // Year
  y: function y2(date, token, localize2) {
    if (token === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return formatters$1.y(date, token);
  },
  // Local week-numbering year
  Y: function Y(date, token, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function R(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function Q(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function q(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function M2(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return formatters$1.M(date, token);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone month
  L: function L(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Local week of year
  w: function w(date, token, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function I(date, token, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function d2(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return formatters$1.d(date, token);
  },
  // Day of year
  D: function D(date, token, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function E(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function e(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function c(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function i(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      // Tue
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function a2(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function h2(date, token, localize2) {
    if (token === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return formatters$1.h(date, token);
  },
  // Hour [0-23]
  H: function H2(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return formatters$1.H(date, token);
  },
  // Hour [0-11]
  K: function K(date, token, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function k(date, token, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function m2(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return formatters$1.m(date, token);
  },
  // Second
  s: function s2(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return formatters$1.s(date, token);
  },
  // Fraction of second
  S: function S2(date, token) {
    return formatters$1.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter = dirtyDelimiter;
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
var dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
};
var timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format2, input) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function formatDistance2(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function formatRelative2(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var locale = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$1 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$1 = /''/g;
var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions2 = getDefaultOptions();
  var locale$1 = (_ref = (_options$locale = void 0) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : locale;
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = void 0) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : void 0) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = void 0) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : void 0) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale$1.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale$1.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale$1,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp$1).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale$1.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp$1).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString$1(substring);
    }
    var formatter = formatters[firstCharacter];
    if (formatter) {
      if (isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale$1.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString$1(input) {
  var matched = input.match(escapedStringRegExp$1);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp$1, "'");
}
function assign(target, object) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      target[property] = object[property];
    }
  }
  return target;
}
function _typeof$w(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$w = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$w = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$w(obj);
}
function _inherits$v(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$v(subClass, superClass);
}
function _setPrototypeOf$v(o, p) {
  _setPrototypeOf$v = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$v(o, p);
}
function _createSuper$v(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$v();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$v(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$v(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$v(this, result);
  };
}
function _possibleConstructorReturn$v(self2, call) {
  if (call && (_typeof$w(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$v(self2);
}
function _assertThisInitialized$v(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$v() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$v(o) {
  _getPrototypeOf$v = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$v(o);
}
function _classCallCheck$w(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$w(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$w(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$w(Constructor.prototype, protoProps);
  return Constructor;
}
function _defineProperty$v(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = /* @__PURE__ */ function() {
  function Setter2() {
    _classCallCheck$w(this, Setter2);
    _defineProperty$v(this, "subPriority", 0);
  }
  _createClass$w(Setter2, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);
  return Setter2;
}();
var ValueSetter = /* @__PURE__ */ function(_Setter) {
  _inherits$v(ValueSetter2, _Setter);
  var _super = _createSuper$v(ValueSetter2);
  function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
    var _this;
    _classCallCheck$w(this, ValueSetter2);
    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;
    if (subPriority) {
      _this.subPriority = subPriority;
    }
    return _this;
  }
  _createClass$w(ValueSetter2, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set2(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);
  return ValueSetter2;
}(Setter);
var DateToSystemTimezoneSetter = /* @__PURE__ */ function(_Setter2) {
  _inherits$v(DateToSystemTimezoneSetter2, _Setter2);
  var _super2 = _createSuper$v(DateToSystemTimezoneSetter2);
  function DateToSystemTimezoneSetter2() {
    var _this2;
    _classCallCheck$w(this, DateToSystemTimezoneSetter2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _defineProperty$v(_assertThisInitialized$v(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
    _defineProperty$v(_assertThisInitialized$v(_this2), "subPriority", -1);
    return _this2;
  }
  _createClass$w(DateToSystemTimezoneSetter2, [{
    key: "set",
    value: function set2(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }
      var convertedDate = /* @__PURE__ */ new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);
  return DateToSystemTimezoneSetter2;
}(Setter);
function _classCallCheck$v(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$v(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$v(Constructor, protoProps, staticProps) {
  _defineProperties$v(Constructor.prototype, protoProps);
  return Constructor;
}
var Parser = /* @__PURE__ */ function() {
  function Parser2() {
    _classCallCheck$v(this, Parser2);
  }
  _createClass$v(Parser2, [{
    key: "run",
    value: function run(dateString, token, match2, options) {
      var result = this.parse(dateString, token, match2, options);
      if (!result) {
        return null;
      }
      return {
        setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);
  return Parser2;
}();
function _typeof$v(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$v = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$v = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$v(obj);
}
function _classCallCheck$u(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$u(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$u(Constructor, protoProps, staticProps) {
  _defineProperties$u(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$u(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$u(subClass, superClass);
}
function _setPrototypeOf$u(o, p) {
  _setPrototypeOf$u = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$u(o, p);
}
function _createSuper$u(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$u();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$u(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$u(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$u(this, result);
  };
}
function _possibleConstructorReturn$u(self2, call) {
  if (call && (_typeof$v(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$u(self2);
}
function _assertThisInitialized$u(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$u() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$u(o) {
  _getPrototypeOf$u = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$u(o);
}
function _defineProperty$u(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var EraParser = /* @__PURE__ */ function(_Parser) {
  _inherits$u(EraParser2, _Parser);
  var _super = _createSuper$u(EraParser2);
  function EraParser2() {
    var _this;
    _classCallCheck$u(this, EraParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$u(_assertThisInitialized$u(_this), "priority", 140);
    _defineProperty$u(_assertThisInitialized$u(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
    return _this;
  }
  _createClass$u(EraParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        // AD, BC
        case "G":
        case "GG":
        case "GGG":
          return match2.era(dateString, {
            width: "abbreviated"
          }) || match2.era(dateString, {
            width: "narrow"
          });
        // A, B
        case "GGGGG":
          return match2.era(dateString, {
            width: "narrow"
          });
        // Anno Domini, Before Christ
        case "GGGG":
        default:
          return match2.era(dateString, {
            width: "wide"
          }) || match2.era(dateString, {
            width: "abbreviated"
          }) || match2.era(dateString, {
            width: "narrow"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return EraParser2;
}(Parser);
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function _typeof$u(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$u = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$u = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$u(obj);
}
function _classCallCheck$t(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$t(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$t(Constructor, protoProps, staticProps) {
  _defineProperties$t(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$t(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$t(subClass, superClass);
}
function _setPrototypeOf$t(o, p) {
  _setPrototypeOf$t = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$t(o, p);
}
function _createSuper$t(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$t();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$t(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$t(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$t(this, result);
  };
}
function _possibleConstructorReturn$t(self2, call) {
  if (call && (_typeof$u(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$t(self2);
}
function _assertThisInitialized$t(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$t() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$t(o) {
  _getPrototypeOf$t = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$t(o);
}
function _defineProperty$t(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var YearParser = /* @__PURE__ */ function(_Parser) {
  _inherits$t(YearParser2, _Parser);
  var _super = _createSuper$t(YearParser2);
  function YearParser2() {
    var _this;
    _classCallCheck$t(this, YearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$t(_assertThisInitialized$t(_this), "priority", 130);
    _defineProperty$t(_assertThisInitialized$t(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$t(YearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(year) {
        return {
          year,
          isTwoDigitYear: token === "yy"
        };
      };
      switch (token) {
        case "y":
          return mapValue(parseNDigits(4, dateString), valueCallback3);
        case "yo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback3);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return YearParser2;
}(Parser);
function _typeof$t(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$t = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$t = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$t(obj);
}
function _classCallCheck$s(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$s(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$s(Constructor, protoProps, staticProps) {
  _defineProperties$s(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$s(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$s(subClass, superClass);
}
function _setPrototypeOf$s(o, p) {
  _setPrototypeOf$s = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$s(o, p);
}
function _createSuper$s(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$s(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$s(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$s(this, result);
  };
}
function _possibleConstructorReturn$s(self2, call) {
  if (call && (_typeof$t(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$s(self2);
}
function _assertThisInitialized$s(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$s() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$s(o) {
  _getPrototypeOf$s = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$s(o);
}
function _defineProperty$s(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalWeekYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits$s(LocalWeekYearParser2, _Parser);
  var _super = _createSuper$s(LocalWeekYearParser2);
  function LocalWeekYearParser2() {
    var _this;
    _classCallCheck$s(this, LocalWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$s(_assertThisInitialized$s(_this), "priority", 130);
    _defineProperty$s(_assertThisInitialized$s(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass$s(LocalWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(year) {
        return {
          year,
          isTwoDigitYear: token === "YY"
        };
      };
      switch (token) {
        case "Y":
          return mapValue(parseNDigits(4, dateString), valueCallback3);
        case "Yo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback3);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    }
  }]);
  return LocalWeekYearParser2;
}(Parser);
function _typeof$s(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$s = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$s = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$s(obj);
}
function _classCallCheck$r(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$r(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$r(Constructor, protoProps, staticProps) {
  _defineProperties$r(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$r(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$r(subClass, superClass);
}
function _setPrototypeOf$r(o, p) {
  _setPrototypeOf$r = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$r(o, p);
}
function _createSuper$r(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$r(this, result);
  };
}
function _possibleConstructorReturn$r(self2, call) {
  if (call && (_typeof$s(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$r(self2);
}
function _assertThisInitialized$r(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$r() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$r(o) {
  _getPrototypeOf$r = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$r(o);
}
function _defineProperty$r(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOWeekYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits$r(ISOWeekYearParser2, _Parser);
  var _super = _createSuper$r(ISOWeekYearParser2);
  function ISOWeekYearParser2() {
    var _this;
    _classCallCheck$r(this, ISOWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$r(_assertThisInitialized$r(_this), "priority", 130);
    _defineProperty$r(_assertThisInitialized$r(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$r(ISOWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      if (token === "R") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      var firstWeekOfYear = /* @__PURE__ */ new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  }]);
  return ISOWeekYearParser2;
}(Parser);
function _typeof$r(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$r = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$r = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$r(obj);
}
function _classCallCheck$q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$q(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$q(Constructor, protoProps, staticProps) {
  _defineProperties$q(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$q(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$q(subClass, superClass);
}
function _setPrototypeOf$q(o, p) {
  _setPrototypeOf$q = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$q(o, p);
}
function _createSuper$q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$q(this, result);
  };
}
function _possibleConstructorReturn$q(self2, call) {
  if (call && (_typeof$r(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$q(self2);
}
function _assertThisInitialized$q(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$q() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$q(o) {
  _getPrototypeOf$q = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$q(o);
}
function _defineProperty$q(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ExtendedYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits$q(ExtendedYearParser2, _Parser);
  var _super = _createSuper$q(ExtendedYearParser2);
  function ExtendedYearParser2() {
    var _this;
    _classCallCheck$q(this, ExtendedYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$q(_assertThisInitialized$q(_this), "priority", 130);
    _defineProperty$q(_assertThisInitialized$q(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$q(ExtendedYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      if (token === "u") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ExtendedYearParser2;
}(Parser);
function _typeof$q(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$q = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$q = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$q(obj);
}
function _classCallCheck$p(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$p(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$p(Constructor, protoProps, staticProps) {
  _defineProperties$p(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$p(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$p(subClass, superClass);
}
function _setPrototypeOf$p(o, p) {
  _setPrototypeOf$p = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$p(o, p);
}
function _createSuper$p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$p(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$p(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$p(this, result);
  };
}
function _possibleConstructorReturn$p(self2, call) {
  if (call && (_typeof$q(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$p(self2);
}
function _assertThisInitialized$p(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$p() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$p(o) {
  _getPrototypeOf$p = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$p(o);
}
function _defineProperty$p(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var QuarterParser = /* @__PURE__ */ function(_Parser) {
  _inherits$p(QuarterParser2, _Parser);
  var _super = _createSuper$p(QuarterParser2);
  function QuarterParser2() {
    var _this;
    _classCallCheck$p(this, QuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$p(_assertThisInitialized$p(_this), "priority", 120);
    _defineProperty$p(_assertThisInitialized$p(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$p(QuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        // 1, 2, 3, 4
        case "Q":
        case "QQ":
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th
        case "Qo":
          return match2.ordinalNumber(dateString, {
            unit: "quarter"
          });
        // Q1, Q2, Q3, Q4
        case "QQQ":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "QQQQQ":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // 1st quarter, 2nd quarter, ...
        case "QQQQ":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return QuarterParser2;
}(Parser);
function _typeof$p(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$p = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$p = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$p(obj);
}
function _classCallCheck$o(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$o(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$o(Constructor, protoProps, staticProps) {
  _defineProperties$o(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$o(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$o(subClass, superClass);
}
function _setPrototypeOf$o(o, p) {
  _setPrototypeOf$o = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$o(o, p);
}
function _createSuper$o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$o(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$o(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$o(this, result);
  };
}
function _possibleConstructorReturn$o(self2, call) {
  if (call && (_typeof$p(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$o(self2);
}
function _assertThisInitialized$o(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$o() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$o(o) {
  _getPrototypeOf$o = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$o(o);
}
function _defineProperty$o(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneQuarterParser = /* @__PURE__ */ function(_Parser) {
  _inherits$o(StandAloneQuarterParser2, _Parser);
  var _super = _createSuper$o(StandAloneQuarterParser2);
  function StandAloneQuarterParser2() {
    var _this;
    _classCallCheck$o(this, StandAloneQuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$o(_assertThisInitialized$o(_this), "priority", 120);
    _defineProperty$o(_assertThisInitialized$o(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$o(StandAloneQuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        // 1, 2, 3, 4
        case "q":
        case "qq":
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th
        case "qo":
          return match2.ordinalNumber(dateString, {
            unit: "quarter"
          });
        // Q1, Q2, Q3, Q4
        case "qqq":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "qqqqq":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        // 1st quarter, 2nd quarter, ...
        case "qqqq":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneQuarterParser2;
}(Parser);
function _typeof$o(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$o = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$o = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$o(obj);
}
function _classCallCheck$n(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$n(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$n(Constructor, protoProps, staticProps) {
  _defineProperties$n(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$n(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$n(subClass, superClass);
}
function _setPrototypeOf$n(o, p) {
  _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$n(o, p);
}
function _createSuper$n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$n(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$n(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$n(this, result);
  };
}
function _possibleConstructorReturn$n(self2, call) {
  if (call && (_typeof$o(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$n(self2);
}
function _assertThisInitialized$n(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$n() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$n(o) {
  _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$n(o);
}
function _defineProperty$n(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MonthParser = /* @__PURE__ */ function(_Parser) {
  _inherits$n(MonthParser2, _Parser);
  var _super = _createSuper$n(MonthParser2);
  function MonthParser2() {
    var _this;
    _classCallCheck$n(this, MonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$n(_assertThisInitialized$n(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
    _defineProperty$n(_assertThisInitialized$n(_this), "priority", 110);
    return _this;
  }
  _createClass$n(MonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(value) {
        return value - 1;
      };
      switch (token) {
        // 1, 2, ..., 12
        case "M":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
        // 01, 02, ..., 12
        case "MM":
          return mapValue(parseNDigits(2, dateString), valueCallback3);
        // 1st, 2nd, ..., 12th
        case "Mo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback3);
        // Jan, Feb, ..., Dec
        case "MMM":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // J, F, ..., D
        case "MMMMM":
          return match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // January, February, ..., December
        case "MMMM":
        default:
          return match2.month(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return MonthParser2;
}(Parser);
function _typeof$n(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$n = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$n = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$n(obj);
}
function _classCallCheck$m(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$m(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$m(Constructor, protoProps, staticProps) {
  _defineProperties$m(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$m(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$m(subClass, superClass);
}
function _setPrototypeOf$m(o, p) {
  _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$m(o, p);
}
function _createSuper$m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$m(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$m(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$m(this, result);
  };
}
function _possibleConstructorReturn$m(self2, call) {
  if (call && (_typeof$n(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$m(self2);
}
function _assertThisInitialized$m(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$m() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$m(o) {
  _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$m(o);
}
function _defineProperty$m(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneMonthParser = /* @__PURE__ */ function(_Parser) {
  _inherits$m(StandAloneMonthParser2, _Parser);
  var _super = _createSuper$m(StandAloneMonthParser2);
  function StandAloneMonthParser2() {
    var _this;
    _classCallCheck$m(this, StandAloneMonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$m(_assertThisInitialized$m(_this), "priority", 110);
    _defineProperty$m(_assertThisInitialized$m(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$m(StandAloneMonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(value) {
        return value - 1;
      };
      switch (token) {
        // 1, 2, ..., 12
        case "L":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
        // 01, 02, ..., 12
        case "LL":
          return mapValue(parseNDigits(2, dateString), valueCallback3);
        // 1st, 2nd, ..., 12th
        case "Lo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback3);
        // Jan, Feb, ..., Dec
        case "LLL":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        // J, F, ..., D
        case "LLLLL":
          return match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        // January, February, ..., December
        case "LLLL":
        default:
          return match2.month(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneMonthParser2;
}(Parser);
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
function _typeof$m(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$m = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$m = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$m(obj);
}
function _classCallCheck$l(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$l(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$l(Constructor, protoProps, staticProps) {
  _defineProperties$l(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$l(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$l(subClass, superClass);
}
function _setPrototypeOf$l(o, p) {
  _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$l(o, p);
}
function _createSuper$l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$l(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$l(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$l(this, result);
  };
}
function _possibleConstructorReturn$l(self2, call) {
  if (call && (_typeof$m(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$l(self2);
}
function _assertThisInitialized$l(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$l() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$l(o) {
  _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$l(o);
}
function _defineProperty$l(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalWeekParser = /* @__PURE__ */ function(_Parser) {
  _inherits$l(LocalWeekParser2, _Parser);
  var _super = _createSuper$l(LocalWeekParser2);
  function LocalWeekParser2() {
    var _this;
    _classCallCheck$l(this, LocalWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$l(_assertThisInitialized$l(_this), "priority", 100);
    _defineProperty$l(_assertThisInitialized$l(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass$l(LocalWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "w":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "wo":
          return match2.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    }
  }]);
  return LocalWeekParser2;
}(Parser);
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
function _typeof$l(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$l = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$l = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$l(obj);
}
function _classCallCheck$k(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$k(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$k(Constructor, protoProps, staticProps) {
  _defineProperties$k(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$k(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$k(subClass, superClass);
}
function _setPrototypeOf$k(o, p) {
  _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$k(o, p);
}
function _createSuper$k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$k(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$k(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$k(this, result);
  };
}
function _possibleConstructorReturn$k(self2, call) {
  if (call && (_typeof$l(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$k(self2);
}
function _assertThisInitialized$k(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$k() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$k(o) {
  _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$k(o);
}
function _defineProperty$k(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOWeekParser = /* @__PURE__ */ function(_Parser) {
  _inherits$k(ISOWeekParser2, _Parser);
  var _super = _createSuper$k(ISOWeekParser2);
  function ISOWeekParser2() {
    var _this;
    _classCallCheck$k(this, ISOWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$k(_assertThisInitialized$k(_this), "priority", 100);
    _defineProperty$k(_assertThisInitialized$k(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$k(ISOWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "I":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "Io":
          return match2.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value));
    }
  }]);
  return ISOWeekParser2;
}(Parser);
function _typeof$k(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$k = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$k = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$k(obj);
}
function _classCallCheck$j(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$j(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$j(Constructor, protoProps, staticProps) {
  _defineProperties$j(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$j(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$j(subClass, superClass);
}
function _setPrototypeOf$j(o, p) {
  _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$j(o, p);
}
function _createSuper$j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$j(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$j(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$j(this, result);
  };
}
function _possibleConstructorReturn$j(self2, call) {
  if (call && (_typeof$k(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$j(self2);
}
function _assertThisInitialized$j(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$j() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$j(o) {
  _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$j(o);
}
function _defineProperty$j(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DateParser = /* @__PURE__ */ function(_Parser) {
  _inherits$j(DateParser2, _Parser);
  var _super = _createSuper$j(DateParser2);
  function DateParser2() {
    var _this;
    _classCallCheck$j(this, DateParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$j(_assertThisInitialized$j(_this), "priority", 90);
    _defineProperty$j(_assertThisInitialized$j(_this), "subPriority", 1);
    _defineProperty$j(_assertThisInitialized$j(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$j(DateParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "d":
          return parseNumericPattern(numericPatterns.date, dateString);
        case "do":
          return match2.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      var month = date.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DateParser2;
}(Parser);
function _typeof$j(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$j = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$j = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$j(obj);
}
function _classCallCheck$i(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$i(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$i(Constructor, protoProps, staticProps) {
  _defineProperties$i(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$i(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$i(subClass, superClass);
}
function _setPrototypeOf$i(o, p) {
  _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$i(o, p);
}
function _createSuper$i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$i(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$i(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$i(this, result);
  };
}
function _possibleConstructorReturn$i(self2, call) {
  if (call && (_typeof$j(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$i(self2);
}
function _assertThisInitialized$i(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$i() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$i(o) {
  _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$i(o);
}
function _defineProperty$i(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayOfYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits$i(DayOfYearParser2, _Parser);
  var _super = _createSuper$i(DayOfYearParser2);
  function DayOfYearParser2() {
    var _this;
    _classCallCheck$i(this, DayOfYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$i(_assertThisInitialized$i(_this), "priority", 90);
    _defineProperty$i(_assertThisInitialized$i(_this), "subpriority", 1);
    _defineProperty$i(_assertThisInitialized$i(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$i(DayOfYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case "Do":
          return match2.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayOfYearParser2;
}(Parser);
function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
function _typeof$i(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$i = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$i = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$i(obj);
}
function _classCallCheck$h(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$h(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$h(Constructor, protoProps, staticProps) {
  _defineProperties$h(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$h(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$h(subClass, superClass);
}
function _setPrototypeOf$h(o, p) {
  _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$h(o, p);
}
function _createSuper$h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$h(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$h(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$h(this, result);
  };
}
function _possibleConstructorReturn$h(self2, call) {
  if (call && (_typeof$i(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$h(self2);
}
function _assertThisInitialized$h(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$h() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$h(o) {
  _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$h(o);
}
function _defineProperty$h(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayParser = /* @__PURE__ */ function(_Parser) {
  _inherits$h(DayParser2, _Parser);
  var _super = _createSuper$h(DayParser2);
  function DayParser2() {
    var _this;
    _classCallCheck$h(this, DayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$h(_assertThisInitialized$h(_this), "priority", 90);
    _defineProperty$h(_assertThisInitialized$h(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$h(DayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        // Tue
        case "E":
        case "EE":
        case "EEE":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // T
        case "EEEEE":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "EEEEEE":
          return match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // Tuesday
        case "EEEE":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayParser2;
}(Parser);
function _typeof$h(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$h = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$h = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$h(obj);
}
function _classCallCheck$g(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$g(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$g(Constructor, protoProps, staticProps) {
  _defineProperties$g(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$g(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$g(subClass, superClass);
}
function _setPrototypeOf$g(o, p) {
  _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$g(o, p);
}
function _createSuper$g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$g(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$g(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$g(this, result);
  };
}
function _possibleConstructorReturn$g(self2, call) {
  if (call && (_typeof$h(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$g(self2);
}
function _assertThisInitialized$g(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$g() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$g(o) {
  _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$g(o);
}
function _defineProperty$g(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalDayParser = /* @__PURE__ */ function(_Parser) {
  _inherits$g(LocalDayParser2, _Parser);
  var _super = _createSuper$g(LocalDayParser2);
  function LocalDayParser2() {
    var _this;
    _classCallCheck$g(this, LocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$g(_assertThisInitialized$g(_this), "priority", 90);
    _defineProperty$g(_assertThisInitialized$g(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
    return _this;
  }
  _createClass$g(LocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2, options) {
      var valueCallback3 = function valueCallback4(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        // 3
        case "e":
        case "ee":
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
        // 3rd
        case "eo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback3);
        // Tue
        case "eee":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // T
        case "eeeee":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "eeeeee":
          return match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // Tuesday
        case "eeee":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return LocalDayParser2;
}(Parser);
function _typeof$g(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$g = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$g = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$g(obj);
}
function _classCallCheck$f(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$f(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$f(Constructor, protoProps, staticProps) {
  _defineProperties$f(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$f(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$f(subClass, superClass);
}
function _setPrototypeOf$f(o, p) {
  _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$f(o, p);
}
function _createSuper$f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$f(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$f(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$f(this, result);
  };
}
function _possibleConstructorReturn$f(self2, call) {
  if (call && (_typeof$g(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$f(self2);
}
function _assertThisInitialized$f(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$f() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$f(o) {
  _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$f(o);
}
function _defineProperty$f(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneLocalDayParser = /* @__PURE__ */ function(_Parser) {
  _inherits$f(StandAloneLocalDayParser2, _Parser);
  var _super = _createSuper$f(StandAloneLocalDayParser2);
  function StandAloneLocalDayParser2() {
    var _this;
    _classCallCheck$f(this, StandAloneLocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$f(_assertThisInitialized$f(_this), "priority", 90);
    _defineProperty$f(_assertThisInitialized$f(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
    return _this;
  }
  _createClass$f(StandAloneLocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2, options) {
      var valueCallback3 = function valueCallback4(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        // 3
        case "c":
        case "cc":
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
        // 3rd
        case "co":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback3);
        // Tue
        case "ccc":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        // T
        case "ccccc":
          return match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        // Tu
        case "cccccc":
          return match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        // Tuesday
        case "cccc":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneLocalDayParser2;
}(Parser);
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
function _typeof$f(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$f = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$f = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$f(obj);
}
function _classCallCheck$e(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$e(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$e(Constructor, protoProps, staticProps) {
  _defineProperties$e(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$e(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$e(subClass, superClass);
}
function _setPrototypeOf$e(o, p) {
  _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$e(o, p);
}
function _createSuper$e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$e(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$e(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$e(this, result);
  };
}
function _possibleConstructorReturn$e(self2, call) {
  if (call && (_typeof$f(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$e(self2);
}
function _assertThisInitialized$e(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$e(o) {
  _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$e(o);
}
function _defineProperty$e(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISODayParser = /* @__PURE__ */ function(_Parser) {
  _inherits$e(ISODayParser2, _Parser);
  var _super = _createSuper$e(ISODayParser2);
  function ISODayParser2() {
    var _this;
    _classCallCheck$e(this, ISODayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$e(_assertThisInitialized$e(_this), "priority", 90);
    _defineProperty$e(_assertThisInitialized$e(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$e(ISODayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        // 2
        case "i":
        case "ii":
          return parseNDigits(token.length, dateString);
        // 2nd
        case "io":
          return match2.ordinalNumber(dateString, {
            unit: "day"
          });
        // Tue
        case "iii":
          return mapValue(match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        // T
        case "iiiii":
          return mapValue(match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        // Tu
        case "iiiiii":
          return mapValue(match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        // Tuesday
        case "iiii":
        default:
          return mapValue(match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date = setUTCISODay(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ISODayParser2;
}(Parser);
function _typeof$e(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$e = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$e = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$e(obj);
}
function _classCallCheck$d(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$d(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$d(Constructor, protoProps, staticProps) {
  _defineProperties$d(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$d(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$d(subClass, superClass);
}
function _setPrototypeOf$d(o, p) {
  _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$d(o, p);
}
function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$d(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$d(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$d(this, result);
  };
}
function _possibleConstructorReturn$d(self2, call) {
  if (call && (_typeof$e(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$d(self2);
}
function _assertThisInitialized$d(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$d(o) {
  _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$d(o);
}
function _defineProperty$d(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AMPMParser = /* @__PURE__ */ function(_Parser) {
  _inherits$d(AMPMParser2, _Parser);
  var _super = _createSuper$d(AMPMParser2);
  function AMPMParser2() {
    var _this;
    _classCallCheck$d(this, AMPMParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$d(_assertThisInitialized$d(_this), "priority", 80);
    _defineProperty$d(_assertThisInitialized$d(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass$d(AMPMParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "a":
        case "aa":
        case "aaa":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMParser2;
}(Parser);
function _typeof$d(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$d = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$d = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$d(obj);
}
function _classCallCheck$c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$c(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$c(Constructor, protoProps, staticProps) {
  _defineProperties$c(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$c(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$c(subClass, superClass);
}
function _setPrototypeOf$c(o, p) {
  _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$c(o, p);
}
function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$c(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$c(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$c(this, result);
  };
}
function _possibleConstructorReturn$c(self2, call) {
  if (call && (_typeof$d(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$c(self2);
}
function _assertThisInitialized$c(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$c(o) {
  _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$c(o);
}
function _defineProperty$c(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AMPMMidnightParser = /* @__PURE__ */ function(_Parser) {
  _inherits$c(AMPMMidnightParser2, _Parser);
  var _super = _createSuper$c(AMPMMidnightParser2);
  function AMPMMidnightParser2() {
    var _this;
    _classCallCheck$c(this, AMPMMidnightParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$c(_assertThisInitialized$c(_this), "priority", 80);
    _defineProperty$c(_assertThisInitialized$c(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass$c(AMPMMidnightParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "b":
        case "bb":
        case "bbb":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMMidnightParser2;
}(Parser);
function _typeof$c(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$c = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$c = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$c(obj);
}
function _classCallCheck$b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$b(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$b(Constructor, protoProps, staticProps) {
  _defineProperties$b(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$b(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$b(subClass, superClass);
}
function _setPrototypeOf$b(o, p) {
  _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$b(o, p);
}
function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$b(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$b(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _possibleConstructorReturn$b(self2, call) {
  if (call && (_typeof$c(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$b(self2);
}
function _assertThisInitialized$b(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$b(o) {
  _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$b(o);
}
function _defineProperty$b(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayPeriodParser = /* @__PURE__ */ function(_Parser) {
  _inherits$b(DayPeriodParser2, _Parser);
  var _super = _createSuper$b(DayPeriodParser2);
  function DayPeriodParser2() {
    var _this;
    _classCallCheck$b(this, DayPeriodParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$b(_assertThisInitialized$b(_this), "priority", 80);
    _defineProperty$b(_assertThisInitialized$b(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
    return _this;
  }
  _createClass$b(DayPeriodParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return DayPeriodParser2;
}(Parser);
function _typeof$b(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$b = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$b = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$b(obj);
}
function _classCallCheck$a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$a(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$a(Constructor, protoProps, staticProps) {
  _defineProperties$a(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$a(subClass, superClass);
}
function _setPrototypeOf$a(o, p) {
  _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$a(o, p);
}
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$a(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$a(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$a(this, result);
  };
}
function _possibleConstructorReturn$a(self2, call) {
  if (call && (_typeof$b(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$a(self2);
}
function _assertThisInitialized$a(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$a(o) {
  _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$a(o);
}
function _defineProperty$a(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour1to12Parser = /* @__PURE__ */ function(_Parser) {
  _inherits$a(Hour1to12Parser2, _Parser);
  var _super = _createSuper$a(Hour1to12Parser2);
  function Hour1to12Parser2() {
    var _this;
    _classCallCheck$a(this, Hour1to12Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$a(_assertThisInitialized$a(_this), "priority", 70);
    _defineProperty$a(_assertThisInitialized$a(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass$a(Hour1to12Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case "ho":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour1to12Parser2;
}(Parser);
function _typeof$a(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$a = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$a = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$a(obj);
}
function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$9(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$9(Constructor, protoProps, staticProps) {
  _defineProperties$9(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$9(subClass, superClass);
}
function _setPrototypeOf$9(o, p) {
  _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$9(o, p);
}
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$9(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$9(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$9(this, result);
  };
}
function _possibleConstructorReturn$9(self2, call) {
  if (call && (_typeof$a(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$9(self2);
}
function _assertThisInitialized$9(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$9(o) {
  _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$9(o);
}
function _defineProperty$9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour0to23Parser = /* @__PURE__ */ function(_Parser) {
  _inherits$9(Hour0to23Parser2, _Parser);
  var _super = _createSuper$9(Hour0to23Parser2);
  function Hour0to23Parser2() {
    var _this;
    _classCallCheck$9(this, Hour0to23Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$9(_assertThisInitialized$9(_this), "priority", 70);
    _defineProperty$9(_assertThisInitialized$9(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass$9(Hour0to23Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case "Ho":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);
  return Hour0to23Parser2;
}(Parser);
function _typeof$9(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$9 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$9 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$9(obj);
}
function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$8(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$8(Constructor, protoProps, staticProps) {
  _defineProperties$8(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$8(subClass, superClass);
}
function _setPrototypeOf$8(o, p) {
  _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$8(o, p);
}
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$8(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$8(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$8(this, result);
  };
}
function _possibleConstructorReturn$8(self2, call) {
  if (call && (_typeof$9(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$8(self2);
}
function _assertThisInitialized$8(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$8(o) {
  _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$8(o);
}
function _defineProperty$8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour0To11Parser = /* @__PURE__ */ function(_Parser) {
  _inherits$8(Hour0To11Parser2, _Parser);
  var _super = _createSuper$8(Hour0To11Parser2);
  function Hour0To11Parser2() {
    var _this;
    _classCallCheck$8(this, Hour0To11Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$8(_assertThisInitialized$8(_this), "priority", 70);
    _defineProperty$8(_assertThisInitialized$8(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass$8(Hour0To11Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case "Ko":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour0To11Parser2;
}(Parser);
function _typeof$8(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$8 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$8 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$8(obj);
}
function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$7(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$7(Constructor, protoProps, staticProps) {
  _defineProperties$7(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$7(subClass, superClass);
}
function _setPrototypeOf$7(o, p) {
  _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$7(o, p);
}
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$7(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$7(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$7(this, result);
  };
}
function _possibleConstructorReturn$7(self2, call) {
  if (call && (_typeof$8(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$7(self2);
}
function _assertThisInitialized$7(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$7(o) {
  _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$7(o);
}
function _defineProperty$7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour1To24Parser = /* @__PURE__ */ function(_Parser) {
  _inherits$7(Hour1To24Parser2, _Parser);
  var _super = _createSuper$7(Hour1To24Parser2);
  function Hour1To24Parser2() {
    var _this;
    _classCallCheck$7(this, Hour1To24Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$7(_assertThisInitialized$7(_this), "priority", 70);
    _defineProperty$7(_assertThisInitialized$7(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
    return _this;
  }
  _createClass$7(Hour1To24Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case "ko":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);
  return Hour1To24Parser2;
}(Parser);
function _typeof$7(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$7 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$7 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$7(obj);
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$6(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$6(Constructor, protoProps, staticProps) {
  _defineProperties$6(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$6(subClass, superClass);
}
function _setPrototypeOf$6(o, p) {
  _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$6(o, p);
}
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$6(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$6(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$6(this, result);
  };
}
function _possibleConstructorReturn$6(self2, call) {
  if (call && (_typeof$7(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$6(self2);
}
function _assertThisInitialized$6(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$6(o) {
  _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$6(o);
}
function _defineProperty$6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MinuteParser = /* @__PURE__ */ function(_Parser) {
  _inherits$6(MinuteParser2, _Parser);
  var _super = _createSuper$6(MinuteParser2);
  function MinuteParser2() {
    var _this;
    _classCallCheck$6(this, MinuteParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$6(_assertThisInitialized$6(_this), "priority", 60);
    _defineProperty$6(_assertThisInitialized$6(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass$6(MinuteParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, dateString);
        case "mo":
          return match2.ordinalNumber(dateString, {
            unit: "minute"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);
  return MinuteParser2;
}(Parser);
function _typeof$6(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$6 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$6 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$6(obj);
}
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  _defineProperties$5(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o, p) {
  _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$5(o, p);
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$5(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$5(this, result);
  };
}
function _possibleConstructorReturn$5(self2, call) {
  if (call && (_typeof$6(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$5(self2);
}
function _assertThisInitialized$5(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$5(o) {
  _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$5(o);
}
function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var SecondParser = /* @__PURE__ */ function(_Parser) {
  _inherits$5(SecondParser2, _Parser);
  var _super = _createSuper$5(SecondParser2);
  function SecondParser2() {
    var _this;
    _classCallCheck$5(this, SecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$5(_assertThisInitialized$5(_this), "priority", 50);
    _defineProperty$5(_assertThisInitialized$5(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass$5(SecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "s":
          return parseNumericPattern(numericPatterns.second, dateString);
        case "so":
          return match2.ordinalNumber(dateString, {
            unit: "second"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);
  return SecondParser2;
}(Parser);
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$5 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$5 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$5(obj);
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  _defineProperties$4(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o, p) {
  _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$4(o, p);
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$4(this, result);
  };
}
function _possibleConstructorReturn$4(self2, call) {
  if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$4(self2);
}
function _assertThisInitialized$4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$4(o) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$4(o);
}
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var FractionOfSecondParser = /* @__PURE__ */ function(_Parser) {
  _inherits$4(FractionOfSecondParser2, _Parser);
  var _super = _createSuper$4(FractionOfSecondParser2);
  function FractionOfSecondParser2() {
    var _this;
    _classCallCheck$4(this, FractionOfSecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$4(_assertThisInitialized$4(_this), "priority", 30);
    _defineProperty$4(_assertThisInitialized$4(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass$4(FractionOfSecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      var valueCallback3 = function valueCallback4(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };
      return mapValue(parseNDigits(token.length, dateString), valueCallback3);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);
  return FractionOfSecondParser2;
}(Parser);
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$4 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$4 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$4(obj);
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  _defineProperties$3(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o, p) {
  _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$3(o, p);
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result);
  };
}
function _possibleConstructorReturn$3(self2, call) {
  if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$3(self2);
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$3(o) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$3(o);
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOTimezoneWithZParser = /* @__PURE__ */ function(_Parser) {
  _inherits$3(ISOTimezoneWithZParser2, _Parser);
  var _super = _createSuper$3(ISOTimezoneWithZParser2);
  function ISOTimezoneWithZParser2() {
    var _this;
    _classCallCheck$3(this, ISOTimezoneWithZParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$3(_assertThisInitialized$3(_this), "priority", 10);
    _defineProperty$3(_assertThisInitialized$3(_this), "incompatibleTokens", ["t", "T", "x"]);
    return _this;
  }
  _createClass$3(ISOTimezoneWithZParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      switch (token) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneWithZParser2;
}(Parser);
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  _defineProperties$2(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o, p) {
  _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$2(o, p);
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _possibleConstructorReturn$2(self2, call) {
  if (call && (_typeof$3(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$2(self2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$2(o);
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOTimezoneParser = /* @__PURE__ */ function(_Parser) {
  _inherits$2(ISOTimezoneParser2, _Parser);
  var _super = _createSuper$2(ISOTimezoneParser2);
  function ISOTimezoneParser2() {
    var _this;
    _classCallCheck$2(this, ISOTimezoneParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$2(_assertThisInitialized$2(_this), "priority", 10);
    _defineProperty$2(_assertThisInitialized$2(_this), "incompatibleTokens", ["t", "T", "X"]);
    return _this;
  }
  _createClass$2(ISOTimezoneParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      switch (token) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneParser2;
}(Parser);
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$2 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$2(obj);
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  _defineProperties$1(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1(o, p);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1(o);
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TimestampSecondsParser = /* @__PURE__ */ function(_Parser) {
  _inherits$1(TimestampSecondsParser2, _Parser);
  var _super = _createSuper$1(TimestampSecondsParser2);
  function TimestampSecondsParser2() {
    var _this;
    _classCallCheck$1(this, TimestampSecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$1(_assertThisInitialized$1(_this), "priority", 40);
    _defineProperty$1(_assertThisInitialized$1(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass$1(TimestampSecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value * 1e3), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampSecondsParser2;
}(Parser);
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  _defineProperties(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TimestampMillisecondsParser = /* @__PURE__ */ function(_Parser) {
  _inherits(TimestampMillisecondsParser2, _Parser);
  var _super = _createSuper(TimestampMillisecondsParser2);
  function TimestampMillisecondsParser2() {
    var _this;
    _classCallCheck(this, TimestampMillisecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 20);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass(TimestampMillisecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampMillisecondsParser2;
}(Parser);
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e2) {
        throw _e2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s3() {
    it = o[Symbol.iterator]();
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null) it.return();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions2 = getDefaultOptions();
  var locale$1 = (_ref = (_options$locale = void 0) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : locale;
  if (!locale$1.match) {
    throw new RangeError("locale must contain match property");
  }
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = void 0) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : void 0) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = void 0) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : void 0) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate(dirtyReferenceDate);
    } else {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale$1
  };
  var setters = [new DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter in longFormatters) {
      var longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale$1.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp);
  var usedTokens = [];
  var _iterator = _createForOfIteratorHelper(tokens), _step;
  try {
    var _loop = function _loop2() {
      var token = _step.value;
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      var firstCharacter = token[0];
      var parser = parsers[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function(usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });
          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }
        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.run(dateString, token, locale$1.match, subFnOptions);
        if (!parseResult) {
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
        }
        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        }
        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString(token);
        }
        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _ret = _loop();
      if (_typeof(_ret) === "object") return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a3, b2) {
    return b2 - a3;
  }).filter(function(priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a3, b2) {
      return b2.subPriority - a3.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var setter = _step2.value;
      if (!setter.validate(utcDate, subFnOptions)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      var result = setter.set(utcDate, flags, subFnOptions);
      if (Array.isArray(result)) {
        utcDate = result[0];
        assign(flags, result[1]);
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return utcDate;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
window.Vaadin.Flow.datepickerConnector = {};
window.Vaadin.Flow.datepickerConnector.initLazy = (datepicker) => {
  if (datepicker.$connector) {
    return;
  }
  datepicker.$connector = {};
  const createLocaleBasedDateFormat = function(locale2) {
    try {
      (/* @__PURE__ */ new Date()).toLocaleDateString(locale2);
    } catch (e2) {
      console.warn("The locale is not supported, using default format setting (ISO 8601).");
      return "yyyy-MM-dd";
    }
    const testDate = new Date(Date.UTC(1234, 4, 6));
    let pattern = testDate.toLocaleDateString(locale2, { timeZone: "UTC" });
    pattern = pattern.replace(/([a-zA-Z]+)/g, "'$1'").replace("06", "dd").replace("6", "d").replace("05", "MM").replace("5", "M").replace("1234", "yyyy");
    const isValidPattern = pattern.includes("d") && pattern.includes("M") && pattern.includes("y");
    if (!isValidPattern) {
      console.warn("The locale is not supported, using default format setting (ISO 8601).");
      return "yyyy-MM-dd";
    }
    return pattern;
  };
  function createFormatterAndParser(formats) {
    if (!formats || formats.length === 0) {
      throw new Error("Array of custom date formats is null or empty");
    }
    function getShortYearFormat(format2) {
      if (format2.includes("yyyy") && !format2.includes("yyyyy")) {
        return format2.replace("yyyy", "yy");
      }
      if (format2.includes("YYYY") && !format2.includes("YYYYY")) {
        return format2.replace("YYYY", "YY");
      }
      return void 0;
    }
    function isFormatWithYear(format2) {
      return format2.includes("y") || format2.includes("Y");
    }
    function isShortYearFormat(format2) {
      return !format2.includes("yyyy") && !format2.includes("YYYY");
    }
    function getExtendedFormats(formats2) {
      return formats2.reduce((acc, format2) => {
        if (isFormatWithYear(format2) && !isShortYearFormat(format2)) {
          acc.push(getShortYearFormat(format2));
        }
        acc.push(format2);
        return acc;
      }, []);
    }
    function correctFullYear(date) {
      if (datepicker.$connector._lastParseStatus === "error") {
        return;
      }
      if (datepicker.$connector._lastParseStatus === "successful") {
        if (datepicker.$connector._lastParsedDate.day === date.getDate() && datepicker.$connector._lastParsedDate.month === date.getMonth() && datepicker.$connector._lastParsedDate.year % 100 === date.getFullYear() % 100) {
          date.setFullYear(datepicker.$connector._lastParsedDate.year);
        }
        return;
      }
      const currentValue = parseDate(datepicker.value);
      if (isValid(currentValue) && currentValue.getDate() === date.getDate() && currentValue.getMonth() === date.getMonth() && currentValue.getFullYear() % 100 === date.getFullYear() % 100) {
        date.setFullYear(currentValue.getFullYear());
      }
    }
    function formatDate(dateParts) {
      const format$1 = formats[0];
      const date = parseDate(`${dateParts.year}-${dateParts.month + 1}-${dateParts.day}`);
      return format(date, format$1);
    }
    function doParseDate(dateString, format2, referenceDate) {
      const refDate = isFormatWithYear(format2) ? referenceDate : /* @__PURE__ */ new Date();
      const date = parse(dateString, format2, refDate);
      if (isValid(date)) {
        if (isFormatWithYear(format2) && isShortYearFormat(format2)) {
          correctFullYear(date);
        }
        return {
          day: date.getDate(),
          month: date.getMonth(),
          year: date.getFullYear()
        };
      }
    }
    function parseDate$1(dateString) {
      const referenceDate = _getReferenceDate();
      for (let format2 of getExtendedFormats(formats)) {
        const parsedDate = doParseDate(dateString, format2, referenceDate);
        if (parsedDate) {
          datepicker.$connector._lastParseStatus = "successful";
          datepicker.$connector._lastParsedDate = parsedDate;
          return parsedDate;
        }
      }
      datepicker.$connector._lastParseStatus = "error";
      return false;
    }
    return {
      formatDate,
      parseDate: parseDate$1
    };
  }
  function _getReferenceDate() {
    const { referenceDate } = datepicker.i18n;
    return referenceDate ? new Date(referenceDate.year, referenceDate.month, referenceDate.day) : /* @__PURE__ */ new Date();
  }
  datepicker.$connector.updateI18n = (locale2, i18n) => {
    const hasCustomFormats = i18n && i18n.dateFormats && i18n.dateFormats.length > 0;
    if (i18n && i18n.referenceDate) {
      i18n.referenceDate = extractDateParts(new Date(i18n.referenceDate));
    }
    const usedFormats = hasCustomFormats ? i18n.dateFormats : [createLocaleBasedDateFormat(locale2)];
    const formatterAndParser = createFormatterAndParser(usedFormats);
    datepicker.i18n = Object.assign({}, datepicker.i18n, i18n, formatterAndParser);
  };
  datepicker.addEventListener("opened-changed", () => datepicker.$connector._lastParseStatus = void 0);
};
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-time-picker-item", [item, comboBoxItem], {
  moduleId: "lumo-time-picker-item"
});
registerStyles$1(
  "vaadin-time-picker-overlay",
  [
    overlay,
    menuOverlayCore,
    comboBoxOverlay,
    css`
      :host {
        --_vaadin-time-picker-items-container-border-width: var(--lumo-space-xs);
        --_vaadin-time-picker-items-container-border-style: solid;
      }
    `
  ],
  {
    moduleId: "lumo-time-picker-overlay"
  }
);
const timePicker = css`
  [part~='toggle-button']::before {
    content: var(--lumo-icons-clock);
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input:placeholder-shown) {
    --_lumo-text-field-overflow-mask-image: none;
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }
`;
registerStyles$1("vaadin-time-picker", [inputFieldShared$1, timePicker], { moduleId: "lumo-time-picker" });
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TimePickerItem extends ComboBoxItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-time-picker-item";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
}
defineCustomElement(TimePickerItem);
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const timePickerOverlayStyles = css`
  #overlay {
    width: var(--vaadin-time-picker-overlay-width, var(--_vaadin-time-picker-overlay-default-width, auto));
  }

  [part='content'] {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
`;
registerStyles$1("vaadin-time-picker-overlay", [overlayStyles, timePickerOverlayStyles], {
  moduleId: "vaadin-time-picker-overlay-styles"
});
class TimePickerOverlay extends ComboBoxOverlayMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-time-picker-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden></div>
      <div part="overlay" id="overlay">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
}
defineCustomElement(TimePickerOverlay);
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TimePickerScroller extends ComboBoxScrollerMixin(PolymerElement) {
  static get is() {
    return "vaadin-time-picker-scroller";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          min-height: 1px;
          overflow: auto;

          /* Fixes item background from getting on top of scrollbars on Safari */
          transform: translate3d(0, 0, 0);

          /* Enable momentum scrolling on iOS */
          -webkit-overflow-scrolling: touch;

          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */
          box-shadow: 0 0 0 white;
        }

        #selector {
          border-width: var(--_vaadin-time-picker-items-container-border-width);
          border-style: var(--_vaadin-time-picker-items-container-border-style);
          border-color: var(--_vaadin-time-picker-items-container-border-color, transparent);
          position: relative;
        }
      </style>
      <div id="selector">
        <slot></slot>
      </div>
    `;
  }
}
defineCustomElement(TimePickerScroller);
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TimePickerComboBox extends ComboBoxMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-time-picker-combo-box";
  }
  static get template() {
    return html`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <slot></slot>

      <vaadin-time-picker-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[positionTarget]]"
        no-vertical-overlap
        restore-focus-node="[[inputElement]]"
      ></vaadin-time-picker-overlay>
    `;
  }
  static get properties() {
    return {
      positionTarget: {
        type: Object
      }
    };
  }
  /**
   * Tag name prefix used by scroller and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-time-picker";
  }
  /**
   * Reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.querySelector('[part="clear-button"]');
  }
  /** @protected */
  ready() {
    super.ready();
    this.allowCustomValue = true;
    this._toggleElement = this.querySelector(".toggle-button");
    this.setAttribute("dir", "ltr");
  }
}
defineCustomElement(TimePickerComboBox);
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function formatISOTime(time) {
  if (!time) {
    return "";
  }
  const pad = (num = 0, fmt = "00") => (fmt + num).substr((fmt + num).length - fmt.length);
  let timeString = `${pad(time.hours)}:${pad(time.minutes)}`;
  if (time.seconds !== void 0) {
    timeString += `:${pad(time.seconds)}`;
  }
  if (time.milliseconds !== void 0) {
    timeString += `.${pad(time.milliseconds, "000")}`;
  }
  return timeString;
}
const MATCH_HOURS = "(\\d|[0-1]\\d|2[0-3])";
const MATCH_MINUTES = "(\\d|[0-5]\\d)";
const MATCH_SECONDS = MATCH_MINUTES;
const MATCH_MILLISECONDS = "(\\d{1,3})";
const re = new RegExp(`^${MATCH_HOURS}(?::${MATCH_MINUTES}(?::${MATCH_SECONDS}(?:\\.${MATCH_MILLISECONDS})?)?)?$`, "u");
function parseISOTime(timeString) {
  const parts = re.exec(timeString);
  if (parts) {
    if (parts[4]) {
      while (parts[4].length < 3) {
        parts[4] += "0";
      }
    }
    return { hours: parts[1], minutes: parts[2], seconds: parts[3], milliseconds: parts[4] };
  }
}
function getStepSegment(stepValue) {
  const step = stepValue == null ? 60 : parseFloat(stepValue);
  if (step % 3600 === 0) {
    return 1;
  } else if (step % 60 === 0 || !step) {
    return 2;
  } else if (step % 1 === 0) {
    return 3;
  } else if (step < 1) {
    return 4;
  }
}
function validateTime(timeObject, step) {
  if (timeObject) {
    const stepSegment = getStepSegment(step);
    timeObject.hours = parseInt(timeObject.hours);
    timeObject.minutes = parseInt(timeObject.minutes || 0);
    timeObject.seconds = stepSegment < 3 ? void 0 : parseInt(timeObject.seconds || 0);
    timeObject.milliseconds = stepSegment < 4 ? void 0 : parseInt(timeObject.milliseconds || 0);
  }
  return timeObject;
}
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const timePickerI18nDefaults = Object.freeze({
  formatTime: formatISOTime,
  parseTime: parseISOTime
});
const MIN_ALLOWED_TIME = "00:00:00.000";
const MAX_ALLOWED_TIME = "23:59:59.999";
const TimePickerMixin = (superClass) => class TimePickerMixinClass extends PatternMixin(InputControlMixin(superClass)) {
  static get properties() {
    return {
      /**
       * The time value for this element.
       *
       * Supported time formats are in ISO 8601:
       * - `hh:mm` (default)
       * - `hh:mm:ss`
       * - `hh:mm:ss.fff`
       * @type {string}
       */
      value: {
        type: String,
        notify: true,
        value: "",
        sync: true
      },
      /**
       * True if the dropdown is open, false otherwise.
       */
      opened: {
        type: Boolean,
        notify: true,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Minimum time allowed.
       *
       * Supported time formats are in ISO 8601:
       * - `hh:mm`
       * - `hh:mm:ss`
       * - `hh:mm:ss.fff`
       * @type {string}
       */
      min: {
        type: String,
        value: "",
        sync: true
      },
      /**
       * Maximum time allowed.
       *
       * Supported time formats are in ISO 8601:
       * - `hh:mm`
       * - `hh:mm:ss`
       * - `hh:mm:ss.fff`
       * @type {string}
       */
      max: {
        type: String,
        value: "",
        sync: true
      },
      /**
       * Defines the time interval (in seconds) between the items displayed
       * in the time selection box. The default is 1 hour (i.e. `3600`).
       *
       * It also configures the precision of the value string. By default
       * the component formats values as `hh:mm` but setting a step value
       * lower than one minute or one second, format resolution changes to
       * `hh:mm:ss` and `hh:mm:ss.fff` respectively.
       *
       * Unit must be set in seconds, and for correctly configuring intervals
       * in the dropdown, it need to evenly divide a day.
       *
       * Note: it is possible to define step that is dividing an hour in inexact
       * fragments (i.e. 5760 seconds which equals 1 hour 36 minutes), but it is
       * not recommended to use it for better UX experience.
       */
      step: {
        type: Number,
        sync: true
      },
      /**
       * Set true to prevent the overlay from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: {
        type: Boolean,
        sync: true
      },
      /**
       * A space-delimited list of CSS class names to set on the overlay element.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure:
       *
       * ```
       * {
       *   // A function to format given `Object` as
       *   // time string. Object is in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
       *   formatTime: (time) => {
       *     // returns a string representation of the given
       *     // object in `hh` / 'hh:mm' / 'hh:mm:ss' / 'hh:mm:ss.fff' - formats
       *   },
       *
       *   // A function to parse the given text to an `Object` in the format
       *   // `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`.
       *   // Must properly parse (at least) text
       *   // formatted by `formatTime`.
       *   parseTime: text => {
       *     // Parses a string in object/string that can be formatted by`formatTime`.
       *   }
       * }
       * ```
       *
       * Both `formatTime` and `parseTime` need to be implemented
       * to ensure the component works properly.
       *
       * @type {!TimePickerI18n}
       */
      i18n: {
        type: Object,
        sync: true,
        value: () => ({ ...timePickerI18nDefaults })
      },
      /** @private */
      _comboBoxValue: {
        type: String,
        sync: true,
        observer: "__comboBoxValueChanged"
      },
      /** @private */
      __dropdownItems: {
        type: Array,
        sync: true
      },
      /** @private */
      _inputContainer: {
        type: Object
      }
    };
  }
  static get observers() {
    return [
      "__updateAriaAttributes(__dropdownItems, opened, inputElement)",
      "__updateDropdownItems(i18n, min, max, step)"
    ];
  }
  static get constraints() {
    return [...super.constraints, "min", "max"];
  }
  /**
   * Used by `ClearButtonMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /**
   * The input element's value when it cannot be parsed as a time, and an empty string otherwise.
   *
   * @private
   * @return {string}
   */
  get __unparsableValue() {
    if (this._inputElementValue && !this.i18n.parseTime(this._inputElementValue)) {
      return this._inputElementValue;
    }
    return "";
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(
        this,
        (input) => {
          this._setInputElement(input);
          this._setFocusElement(input);
          this.stateTarget = input;
          this.ariaTarget = input;
        },
        {
          // The "search" word is a trick to prevent Safari from enabling AutoFill,
          // which is causing click issues:
          // https://github.com/vaadin/web-components/issues/6817#issuecomment-2268229567
          uniqueIdPrefix: "search-input"
        }
      )
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._inputContainer = this.shadowRoot.querySelector('[part~="input-field"]');
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setShouldShow((timePicker2) => !timePicker2.opened);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this.addController(this._tooltipController);
  }
  /**
   * Override method inherited from `InputMixin` to forward the input to combo-box.
   * @protected
   * @override
   */
  _inputElementChanged(input) {
    super._inputElementChanged(input);
    if (input) {
      this.$.comboBox._setInputElement(input);
    }
  }
  /**
   * Opens the dropdown list.
   */
  open() {
    if (!this.disabled && !this.readonly) {
      this.opened = true;
    }
  }
  /**
   * Closes the dropdown list.
   */
  close() {
    this.opened = false;
  }
  /**
   * Returns true if the current input value satisfies all constraints (if any).
   * You can override this method for custom validations.
   *
   * @return {boolean} True if the value is valid
   */
  checkValidity() {
    return !!(this.inputElement.checkValidity() && (!this.value || this._timeAllowed(this.i18n.parseTime(this.value))) && (!this._comboBoxValue || this.i18n.parseTime(this._comboBoxValue)));
  }
  /**
   * @param {boolean} focused
   * @override
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      if (document.hasFocus()) {
        this._requestValidation();
      }
    }
  }
  /** @private */
  __validDayDivisor(step) {
    return !step || 24 * 3600 % step === 0 || step < 1 && step % 1 * 1e3 % 1 === 0;
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * @param {!KeyboardEvent} e
   * @protected
   */
  _onKeyDown(e2) {
    super._onKeyDown(e2);
    if (this.readonly || this.disabled || this.__dropdownItems.length) {
      return;
    }
    const stepResolution = this.__validDayDivisor(this.step) && this.step || 60;
    if (e2.keyCode === 40) {
      this.__onArrowPressWithStep(-stepResolution);
    } else if (e2.keyCode === 38) {
      this.__onArrowPressWithStep(stepResolution);
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * Do not call `super` in order to override clear
   * button logic defined in `InputControlMixin`.
   * @param {Event} event
   * @protected
   */
  _onEscape() {
  }
  /** @private */
  __onArrowPressWithStep(step) {
    const objWithStep = this.__addStep(this.__getMsec(this.__memoValue), step, true);
    this.__memoValue = objWithStep;
    this.__useMemo = true;
    this._comboBoxValue = this.i18n.formatTime(objWithStep);
    this.__useMemo = false;
    this.__commitValueChange();
  }
  /**
   * Depending on the nature of the value change that has occurred since
   * the last commit attempt, triggers validation and fires an event:
   *
   * Value change             | Event
   * -------------------------|-------------------
   * empty => parsable        | change
   * empty => unparsable      | unparsable-change
   * parsable => empty        | change
   * parsable => parsable     | change
   * parsable => unparsable   | change
   * unparsable => empty      | unparsable-change
   * unparsable => parsable   | change
   * unparsable => unparsable | unparsable-change
   *
   * @private
   */
  __commitValueChange() {
    const unparsableValue = this.__unparsableValue;
    if (this.__committedValue !== this.value) {
      this._requestValidation();
      this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
    } else if (this.__committedUnparsableValue !== unparsableValue) {
      this._requestValidation();
      this.dispatchEvent(new CustomEvent("unparsable-change"));
    }
    this.__committedValue = this.value;
    this.__committedUnparsableValue = unparsableValue;
  }
  /**
   * Returning milliseconds from Object in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
   * @private
   */
  __getMsec(obj) {
    let result = (obj && obj.hours || 0) * 60 * 60 * 1e3;
    result += (obj && obj.minutes || 0) * 60 * 1e3;
    result += (obj && obj.seconds || 0) * 1e3;
    result += obj && parseInt(obj.milliseconds) || 0;
    return result;
  }
  /**
   * Returning seconds from Object in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
   * @private
   */
  __getSec(obj) {
    let result = (obj && obj.hours || 0) * 60 * 60;
    result += (obj && obj.minutes || 0) * 60;
    result += obj && obj.seconds || 0;
    result += obj && obj.milliseconds / 1e3 || 0;
    return result;
  }
  /**
   * Returning Object in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
   * from the result of adding step value in milliseconds to the milliseconds amount.
   * With `precision` parameter rounding the value to the closest step valid interval.
   * @private
   */
  __addStep(msec, step, precision) {
    if (msec === 0 && step < 0) {
      msec = 24 * 60 * 60 * 1e3;
    }
    const stepMsec = step * 1e3;
    const diffToNext = msec % stepMsec;
    if (stepMsec < 0 && diffToNext && precision) {
      msec -= diffToNext;
    } else if (stepMsec > 0 && diffToNext && precision) {
      msec -= diffToNext - stepMsec;
    } else {
      msec += stepMsec;
    }
    const hh = Math.floor(msec / 1e3 / 60 / 60);
    msec -= hh * 1e3 * 60 * 60;
    const mm = Math.floor(msec / 1e3 / 60);
    msec -= mm * 1e3 * 60;
    const ss = Math.floor(msec / 1e3);
    msec -= ss * 1e3;
    return { hours: hh < 24 ? hh : 0, minutes: mm, seconds: ss, milliseconds: msec };
  }
  /** @private */
  __updateDropdownItems(i18n, min, max, step) {
    const minTimeObj = validateTime(parseISOTime(min || MIN_ALLOWED_TIME), step);
    const minSec = this.__getSec(minTimeObj);
    const maxTimeObj = validateTime(parseISOTime(max || MAX_ALLOWED_TIME), step);
    const maxSec = this.__getSec(maxTimeObj);
    this.__dropdownItems = this.__generateDropdownList(minSec, maxSec, step);
    if (step !== this.__oldStep) {
      this.__oldStep = step;
      const parsedObj = validateTime(parseISOTime(this.value), step);
      this.__updateValue(parsedObj);
    }
    if (this.value) {
      this._comboBoxValue = i18n.formatTime(i18n.parseTime(this.value));
    }
  }
  /** @private */
  __updateAriaAttributes(items, opened, input) {
    if (items === void 0 || input === void 0) {
      return;
    }
    if (items.length === 0) {
      input.removeAttribute("role");
      input.removeAttribute("aria-expanded");
    } else {
      input.setAttribute("role", "combobox");
      input.setAttribute("aria-expanded", !!opened);
    }
  }
  /** @private */
  __generateDropdownList(minSec, maxSec, step) {
    if (step < 15 * 60 || !this.__validDayDivisor(step)) {
      return [];
    }
    const generatedList = [];
    if (!step) {
      step = 3600;
    }
    let time = -step + minSec;
    while (time + step >= minSec && time + step <= maxSec) {
      const timeObj = validateTime(this.__addStep(time * 1e3, step), step);
      time += step;
      const formatted = this.i18n.formatTime(timeObj);
      generatedList.push({ label: formatted, value: formatted });
    }
    return generatedList;
  }
  /**
   * Override an observer from `InputMixin`.
   * @protected
   * @override
   */
  _valueChanged(value, oldValue) {
    const parsedObj = this.__memoValue = parseISOTime(value);
    const newValue = formatISOTime(parsedObj) || "";
    if (!this.__keepCommittedValue) {
      this.__committedValue = value;
      this.__committedUnparsableValue = "";
    }
    if (value !== "" && value !== null && !parsedObj) {
      this.value = oldValue === void 0 ? "" : oldValue;
    } else if (value !== newValue) {
      this.value = newValue;
    } else if (this.__keepInvalidInput) {
      delete this.__keepInvalidInput;
    } else {
      this.__updateInputValue(parsedObj);
    }
    this._toggleHasValue(this._hasValue);
  }
  /** @private */
  __comboBoxValueChanged(value, oldValue) {
    if (value === "" && oldValue === void 0) {
      return;
    }
    const parsedObj = this.__useMemo ? this.__memoValue : this.i18n.parseTime(value);
    const newValue = this.i18n.formatTime(parsedObj) || "";
    if (parsedObj) {
      if (value !== newValue) {
        this._comboBoxValue = newValue;
      } else {
        this.__keepCommittedValue = true;
        this.__updateValue(parsedObj);
        this.__keepCommittedValue = false;
      }
    } else {
      if (this.value !== "" && value !== "") {
        this.__keepInvalidInput = true;
      }
      this.__keepCommittedValue = true;
      this.value = "";
      this.__keepCommittedValue = false;
    }
  }
  /** @private */
  __onComboBoxChange(event) {
    event.stopPropagation();
    this.__commitValueChange();
  }
  /**
   * Synchronizes the `_hasInputValue` property with the internal combo-box's one.
   *
   * @private
   */
  __onComboBoxHasInputValueChanged() {
    this._hasInputValue = this.$.comboBox._hasInputValue;
  }
  /** @private */
  __updateValue(obj) {
    const timeString = formatISOTime(validateTime(obj, this.step)) || "";
    this.value = timeString;
    this.__updateInputValue(obj);
  }
  /** @private */
  __updateInputValue(obj) {
    const timeString = this.i18n.formatTime(validateTime(obj, this.step)) || "";
    this._comboBoxValue = timeString;
  }
  /**
   * Returns true if `time` satisfies the `min` and `max` constraints (if any).
   *
   * @param {!TimePickerTime} time Value to check against constraints
   * @return {boolean} True if `time` satisfies the constraints
   * @protected
   */
  _timeAllowed(time) {
    const parsedMin = this.i18n.parseTime(this.min || MIN_ALLOWED_TIME);
    const parsedMax = this.i18n.parseTime(this.max || MAX_ALLOWED_TIME);
    return (!this.__getMsec(parsedMin) || this.__getMsec(time) >= this.__getMsec(parsedMin)) && (!this.__getMsec(parsedMax) || this.__getMsec(time) <= this.__getMsec(parsedMax));
  }
  /**
   * Override method inherited from `InputControlMixin`.
   * @protected
   */
  _onClearButtonClick() {
  }
  /**
   * Override method inherited from `InputConstraintsMixin`.
   * @protected
   */
  _onChange() {
  }
  /**
   * Override method inherited from `InputMixin`.
   * @protected
   */
  _onInput() {
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
};
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-time-picker", inputFieldShared, { moduleId: "vaadin-time-picker-styles" });
class TimePicker extends TimePickerMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-time-picker";
  }
  static get template() {
    return html`
      <style>
        /* See https://github.com/vaadin/vaadin-time-picker/issues/145 */
        :host([dir='rtl']) [part='input-field'] {
          direction: ltr;
        }

        :host([dir='rtl']) [part='input-field'] ::slotted(input)::placeholder {
          direction: rtl;
          text-align: left;
        }

        [part~='toggle-button'] {
          cursor: pointer;
        }
      </style>

      <div class="vaadin-time-picker-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-time-picker-combo-box
          id="comboBox"
          filtered-items="[[__dropdownItems]]"
          value="{{_comboBoxValue}}"
          opened="{{opened}}"
          disabled="[[disabled]]"
          readonly="[[readonly]]"
          clear-button-visible="[[clearButtonVisible]]"
          auto-open-disabled="[[autoOpenDisabled]]"
          overlay-class="[[overlayClass]]"
          position-target="[[_inputContainer]]"
          theme$="[[_theme]]"
          on-change="__onComboBoxChange"
          on-has-input-value-changed="__onComboBoxHasInputValueChanged"
        >
          <vaadin-input-container
            part="input-field"
            readonly="[[readonly]]"
            disabled="[[disabled]]"
            invalid="[[invalid]]"
            theme$="[[_theme]]"
          >
            <slot name="prefix" slot="prefix"></slot>
            <slot name="input"></slot>
            <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
            <div id="toggleButton" class="toggle-button" part="toggle-button" slot="suffix" aria-hidden="true"></div>
          </vaadin-input-container>
        </vaadin-time-picker-combo-box>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
      <slot name="tooltip"></slot>
    `;
  }
}
defineCustomElement(TimePicker);
const dateTimePicker = css`
  ::slotted([slot='date-picker']) {
    margin-inline-end: 2px;
    --vaadin-input-field-top-end-radius: 0;
    --vaadin-input-field-bottom-end-radius: 0;
  }

  ::slotted([slot='time-picker']) {
    --vaadin-input-field-top-start-radius: 0;
    --vaadin-input-field-bottom-start-radius: 0;
  }
`;
registerStyles$1("vaadin-date-time-picker", [dateTimePicker, requiredField, helper, customField], {
  moduleId: "lumo-date-time-picker"
});
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const datePickerI18nProps = Object.keys(datePickerI18nDefaults);
const timePickerI18nProps = Object.keys(timePickerI18nDefaults);
class PickerSlotController extends SlotController {
  constructor(host, type) {
    super(host, `${type}-picker`, `vaadin-${type}-picker`, {
      initializer: (picker, host2) => {
        if (picker.performUpdate) {
          picker.performUpdate();
        }
        const prop = `__${type}Picker`;
        host2[prop] = picker;
      }
    });
  }
}
const DateTimePickerMixin = (superClass) => class DateTimePickerMixinClass extends FieldMixin(FocusMixin(DisabledMixin(superClass))) {
  static get properties() {
    return {
      /**
       * The name of the control, which is submitted with the form data.
       */
      name: {
        type: String
      },
      /**
       * The value for this element.
       *
       * Supported date time format is based on ISO 8601 (without a time zone designator):
       * - Minute precision `"YYYY-MM-DDThh:mm"` (default)
       * - Second precision `"YYYY-MM-DDThh:mm:ss"`
       * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
       * @type {string}
       */
      value: {
        type: String,
        notify: true,
        value: "",
        observer: "__valueChanged",
        sync: true
      },
      /**
       * The earliest allowed value (date and time) that can be selected. All earlier values will be disabled.
       *
       * Supported date time format is based on ISO 8601 (without a time zone designator):
       * - Minute precision `"YYYY-MM-DDThh:mm"`
       * - Second precision `"YYYY-MM-DDThh:mm:ss"`
       * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
       *
       * @type {string | undefined}
       */
      min: {
        type: String,
        observer: "__minChanged",
        sync: true
      },
      /**
       * The latest value (date and time) that can be selected. All later values will be disabled.
       *
       * Supported date time format is based on ISO 8601 (without a time zone designator):
       * - Minute precision `"YYYY-MM-DDThh:mm"`
       * - Second precision `"YYYY-MM-DDThh:mm:ss"`
       * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
       *
       * @type {string | undefined}
       */
      max: {
        type: String,
        observer: "__maxChanged",
        sync: true
      },
      /**
       * The earliest value that can be selected. All earlier values will be disabled.
       * @private
       */
      __minDateTime: {
        type: Date,
        value: "",
        sync: true
      },
      /**
       * The latest value that can be selected. All later values will be disabled.
       * @private
       */
      __maxDateTime: {
        type: Date,
        value: "",
        sync: true
      },
      /**
       * A placeholder string for the date field.
       * @attr {string} date-placeholder
       */
      datePlaceholder: {
        type: String,
        sync: true
      },
      /**
       * A placeholder string for the time field.
       * @attr {string} time-placeholder
       */
      timePlaceholder: {
        type: String,
        sync: true
      },
      /**
       * Defines the time interval (in seconds) between the items displayed
       * in the time selection box. The default is 1 hour (i.e. `3600`).
       *
       * It also configures the precision of the time part of the value string. By default
       * the component formats time values as `hh:mm` but setting a step value
       * lower than one minute or one second, format resolution changes to
       * `hh:mm:ss` and `hh:mm:ss.fff` respectively.
       *
       * Unit must be set in seconds, and for correctly configuring intervals
       * in the dropdown, it need to evenly divide a day.
       *
       * Note: it is possible to define step that is dividing an hour in inexact
       * fragments (i.e. 5760 seconds which equals 1 hour 36 minutes), but it is
       * not recommended to use it for better UX.
       */
      step: {
        type: Number,
        sync: true
      },
      /**
       * Date which should be visible in the date picker overlay when there is no value selected.
       *
       * The same date formats as for the `value` property are supported but without the time part.
       * @attr {string} initial-position
       */
      initialPosition: {
        type: String,
        sync: true
      },
      /**
       * Set true to display ISO-8601 week numbers in the calendar. Notice that
       * displaying week numbers is only supported when `i18n.firstDayOfWeek`
       * is 1 (Monday).
       * @attr {boolean} show-week-numbers
       */
      showWeekNumbers: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * Set to true to prevent the overlays from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: {
        type: Boolean,
        sync: true
      },
      /**
       * Set to true to make this element read-only.
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Specify that this control should have input focus when the page loads.
       * @type {boolean}
       */
      autofocus: {
        type: Boolean
      },
      /**
       * The current selected date time.
       * @private
       */
      __selectedDateTime: {
        type: Date,
        sync: true
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * `i18n` object or just the properties you want to modify.
       *
       * The object is a combination of the i18n properties supported by
       * [`<vaadin-date-picker>`](#/elements/vaadin-date-picker) and
       * [`<vaadin-time-picker>`](#/elements/vaadin-time-picker).
       * @type {!DateTimePickerI18n}
       */
      i18n: {
        type: Object,
        sync: true,
        value: () => ({ ...datePickerI18nDefaults, ...timePickerI18nDefaults })
      },
      /**
       * A space-delimited list of CSS class names to set on the overlay elements
       * of the internal components controlled by the `<vaadin-date-time-picker>`:
       *
       * - [`<vaadin-date-picker>`](#/elements/vaadin-date-picker#property-overlayClass)
       * - [`<vaadin-time-picker>`](#/elements/vaadin-time-picker#property-overlayClass)
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * The current slotted date picker.
       * @private
       */
      __datePicker: {
        type: Object,
        sync: true,
        observer: "__datePickerChanged"
      },
      /**
       * The current slotted time picker.
       * @private
       */
      __timePicker: {
        type: Object,
        sync: true,
        observer: "__timePickerChanged"
      }
    };
  }
  static get observers() {
    return [
      "__selectedDateTimeChanged(__selectedDateTime)",
      "__datePlaceholderChanged(datePlaceholder, __datePicker)",
      "__timePlaceholderChanged(timePlaceholder, __timePicker)",
      "__stepChanged(step, __timePicker)",
      "__initialPositionChanged(initialPosition, __datePicker)",
      "__showWeekNumbersChanged(showWeekNumbers, __datePicker)",
      "__requiredChanged(required, __datePicker, __timePicker)",
      "__invalidChanged(invalid, __datePicker, __timePicker)",
      "__disabledChanged(disabled, __datePicker, __timePicker)",
      "__readonlyChanged(readonly, __datePicker, __timePicker)",
      "__i18nChanged(i18n, __datePicker, __timePicker)",
      "__autoOpenDisabledChanged(autoOpenDisabled, __datePicker, __timePicker)",
      "__themeChanged(_theme, __datePicker, __timePicker)",
      "__overlayClassChanged(overlayClass, __datePicker, __timePicker)",
      "__pickersChanged(__datePicker, __timePicker)",
      "__labelOrAccessibleNameChanged(label, accessibleName, i18n, __datePicker, __timePicker)"
    ];
  }
  constructor() {
    super();
    this.__defaultDateMinMaxValue = void 0;
    this.__defaultTimeMinValue = "00:00:00.000";
    this.__defaultTimeMaxValue = "23:59:59.999";
    this.__changeEventHandler = this.__changeEventHandler.bind(this);
    this.__valueChangedEventHandler = this.__valueChangedEventHandler.bind(this);
    this.__openedChangedEventHandler = this.__openedChangedEventHandler.bind(this);
  }
  /** @private */
  get __pickers() {
    return [this.__datePicker, this.__timePicker];
  }
  /** @private */
  get __formattedValue() {
    const values = this.__pickers.map((picker) => picker.value);
    return values.every(Boolean) ? values.join("T") : "";
  }
  /** @protected */
  ready() {
    super.ready();
    this._datePickerController = new PickerSlotController(this, "date");
    this.addController(this._datePickerController);
    this._timePickerController = new PickerSlotController(this, "time");
    this.addController(this._timePickerController);
    if (this.autofocus && !this.disabled) {
      window.requestAnimationFrame(() => this.focus());
    }
    this.setAttribute("role", "group");
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setPosition("top");
    this._tooltipController.setShouldShow((target) => {
      return target.__datePicker && !target.__datePicker.opened && target.__timePicker && !target.__timePicker.opened;
    });
    this.ariaTarget = this;
  }
  focus() {
    if (this.__datePicker) {
      this.__datePicker.focus();
    }
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
  /**
   * Override method inherited from `FocusMixin` to not remove focused
   * state when focus moves between pickers or to the overlay.
   * @param {FocusEvent} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldRemoveFocus(event) {
    const target = event.relatedTarget;
    const overlayContent = this.__datePicker._overlayContent;
    if (this.__datePicker.contains(target) || this.__timePicker.contains(target) || overlayContent && overlayContent.contains(target)) {
      return false;
    }
    return true;
  }
  /** @private */
  __syncI18n(target, source, props = Object.keys(source.i18n)) {
    const i18n = { ...target.i18n };
    props.forEach((prop) => {
      if (source.i18n && source.i18n.hasOwnProperty(prop)) {
        i18n[prop] = source.i18n[prop];
      }
    });
    target.i18n = i18n;
  }
  /** @private */
  __changeEventHandler(event) {
    event.stopPropagation();
    if (this.__dispatchChangeForValue === this.value) {
      this._requestValidation();
      this.__dispatchChange();
    }
    this.__dispatchChangeForValue = void 0;
  }
  /** @private */
  __openedChangedEventHandler() {
    const opened = this.__datePicker.opened || this.__timePicker.opened;
    this.style.pointerEvents = opened ? "auto" : "";
  }
  /** @private */
  __addInputListeners(node) {
    node.addEventListener("change", this.__changeEventHandler);
    node.addEventListener("value-changed", this.__valueChangedEventHandler);
    node.addEventListener("opened-changed", this.__openedChangedEventHandler);
  }
  /** @private */
  __removeInputListeners(node) {
    node.removeEventListener("change", this.__changeEventHandler);
    node.removeEventListener("value-changed", this.__valueChangedEventHandler);
    node.removeEventListener("opened-changed", this.__openedChangedEventHandler);
  }
  /** @private */
  __isDefaultPicker(picker, type) {
    const controller = this[`_${type}PickerController`];
    return controller && picker === controller.defaultNode;
  }
  /** @private */
  __datePickerChanged(newDatePicker, existingDatePicker) {
    if (!newDatePicker) {
      return;
    }
    if (existingDatePicker) {
      this.__removeInputListeners(existingDatePicker);
      existingDatePicker.remove();
    }
    this.__addInputListeners(newDatePicker);
    if (!this.__isDefaultPicker(newDatePicker, "date")) {
      this.datePlaceholder = newDatePicker.placeholder;
      this.initialPosition = newDatePicker.initialPosition;
      this.showWeekNumbers = newDatePicker.showWeekNumbers;
      this.__syncI18n(this, newDatePicker, datePickerI18nProps);
    }
    newDatePicker.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue);
    newDatePicker.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue);
    newDatePicker.manualValidation = true;
  }
  /** @private */
  __timePickerChanged(newTimePicker, existingTimePicker) {
    if (!newTimePicker) {
      return;
    }
    if (existingTimePicker) {
      this.__removeInputListeners(existingTimePicker);
      existingTimePicker.remove();
    }
    this.__addInputListeners(newTimePicker);
    if (!this.__isDefaultPicker(newTimePicker, "time")) {
      this.timePlaceholder = newTimePicker.placeholder;
      this.step = newTimePicker.step;
      this.__syncI18n(this, newTimePicker, timePickerI18nProps);
    }
    this.__updateTimePickerMinMax();
    newTimePicker.manualValidation = true;
  }
  /** @private */
  __updateTimePickerMinMax() {
    if (this.__timePicker && this.__datePicker) {
      const selectedDate = this.__parseDate(this.__datePicker.value);
      const isMinMaxSameDay = dateEquals(this.__minDateTime, this.__maxDateTime, normalizeUTCDate);
      if (this.__minDateTime && dateEquals(selectedDate, this.__minDateTime, normalizeUTCDate) || isMinMaxSameDay) {
        this.__timePicker.min = this.__dateToIsoTimeString(this.__minDateTime);
      } else {
        this.__timePicker.min = this.__defaultTimeMinValue;
      }
      if (this.__maxDateTime && dateEquals(selectedDate, this.__maxDateTime, normalizeUTCDate) || isMinMaxSameDay) {
        this.__timePicker.max = this.__dateToIsoTimeString(this.__maxDateTime);
      } else {
        this.__timePicker.max = this.__defaultTimeMaxValue;
      }
    }
  }
  /** @private */
  __i18nChanged(_i18n, datePicker2, timePicker2) {
    if (datePicker2) {
      this.__syncI18n(datePicker2, this, datePickerI18nProps);
    }
    if (timePicker2) {
      this.__syncI18n(timePicker2, this, timePickerI18nProps);
    }
  }
  /** @private */
  __labelOrAccessibleNameChanged(label, accessibleName, i18n, datePicker2, timePicker2) {
    const name = accessibleName || label || "";
    if (datePicker2) {
      datePicker2.accessibleName = `${name} ${i18n.dateLabel || ""}`.trim();
    }
    if (timePicker2) {
      timePicker2.accessibleName = `${name} ${i18n.timeLabel || ""}`.trim();
    }
  }
  /** @private */
  __datePlaceholderChanged(datePlaceholder, datePicker2) {
    if (datePicker2) {
      datePicker2.placeholder = datePlaceholder;
    }
  }
  /** @private */
  __timePlaceholderChanged(timePlaceholder, timePicker2) {
    if (timePicker2) {
      timePicker2.placeholder = timePlaceholder;
    }
  }
  /** @private */
  __stepChanged(step, timePicker2) {
    if (timePicker2 && timePicker2.step !== step) {
      timePicker2.step = step;
    }
  }
  /** @private */
  __initialPositionChanged(initialPosition, datePicker2) {
    if (datePicker2) {
      datePicker2.initialPosition = initialPosition;
    }
  }
  /** @private */
  __showWeekNumbersChanged(showWeekNumbers, datePicker2) {
    if (datePicker2) {
      datePicker2.showWeekNumbers = showWeekNumbers;
    }
  }
  /** @private */
  __invalidChanged(invalid, datePicker2, timePicker2) {
    if (datePicker2) {
      datePicker2.invalid = invalid;
    }
    if (timePicker2) {
      timePicker2.invalid = invalid;
    }
  }
  /** @private */
  __requiredChanged(required, datePicker2, timePicker2) {
    if (datePicker2) {
      datePicker2.required = required;
    }
    if (timePicker2) {
      timePicker2.required = required;
    }
    if (this.__oldRequired && !required) {
      this._requestValidation();
    }
    this.__oldRequired = required;
  }
  /** @private */
  __disabledChanged(disabled, datePicker2, timePicker2) {
    if (datePicker2) {
      datePicker2.disabled = disabled;
    }
    if (timePicker2) {
      timePicker2.disabled = disabled;
    }
  }
  /** @private */
  __readonlyChanged(readonly, datePicker2, timePicker2) {
    if (datePicker2) {
      datePicker2.readonly = readonly;
    }
    if (timePicker2) {
      timePicker2.readonly = readonly;
    }
  }
  /**
   * String (ISO date) to Date object
   * @param {string} str e.g. 'yyyy-mm-dd'
   * @return {Date | undefined}
   * @private
   */
  __parseDate(str) {
    return parseUTCDate(str);
  }
  /**
   * Date object to string (ISO date)
   * @param {Date} date
   * @param {string} defaultValue
   * @return {string} e.g. 'yyyy-mm-dd' (or defaultValue when date is falsy)
   * @private
   */
  __formatDateISO(date, defaultValue) {
    if (!date) {
      return defaultValue;
    }
    return formatUTCISODate(date);
  }
  /**
   * String (ISO date time) to Date object
   * @param {string} str e.g. 'yyyy-mm-ddThh:mm', 'yyyy-mm-ddThh:mm:ss', 'yyyy-mm-ddThh:mm:ss.fff'
   * @return {Date | undefined}
   * @private
   */
  __parseDateTime(str) {
    const [dateValue, timeValue] = str.split("T");
    if (!(dateValue && timeValue)) {
      return;
    }
    const date = this.__parseDate(dateValue);
    if (!date) {
      return;
    }
    const time = parseISOTime(timeValue);
    if (!time) {
      return;
    }
    date.setUTCHours(parseInt(time.hours));
    date.setUTCMinutes(parseInt(time.minutes || 0));
    date.setUTCSeconds(parseInt(time.seconds || 0));
    date.setUTCMilliseconds(parseInt(time.milliseconds || 0));
    return date;
  }
  /**
   * Date object to string (ISO date time)
   * @param {Date} date
   * @return {string} e.g. 'yyyy-mm-ddThh:mm', 'yyyy-mm-ddThh:mm:ss', 'yyyy-mm-ddThh:mm:ss.fff'
   *                  (depending on precision defined by "step" property)
   * @private
   */
  __formatDateTime(date) {
    if (!date) {
      return "";
    }
    const dateValue = this.__formatDateISO(date, "");
    const timeValue = this.__dateToIsoTimeString(date);
    return `${dateValue}T${timeValue}`;
  }
  /**
   * Date object to string (ISO time)
   * @param {Date} date
   * @return {string} e.g. 'hh:mm', 'hh:mm:ss', 'hh:mm:ss.fff' (depending on precision defined by "step" property)
   * @private
   */
  __dateToIsoTimeString(date) {
    return formatISOTime(
      validateTime(
        {
          hours: date.getUTCHours(),
          minutes: date.getUTCMinutes(),
          seconds: date.getUTCSeconds(),
          milliseconds: date.getUTCMilliseconds()
        },
        this.step
      )
    );
  }
  /**
   * Returns true if the current input value satisfies all constraints (if any)
   *
   * You can override the `checkValidity` method for custom validations.
   * @return {boolean}
   */
  checkValidity() {
    const hasInvalidPickers = this.__pickers.some((picker) => !picker.checkValidity());
    const hasEmptyRequiredPickers = this.required && this.__pickers.some((picker) => !picker.value);
    return !hasInvalidPickers && !hasEmptyRequiredPickers;
  }
  /**
   * @param {Date} date1
   * @param {Date} date2
   * @return {boolean}
   * @private
   */
  __dateTimeEquals(date1, date2) {
    if (!dateEquals(date1, date2, normalizeUTCDate)) {
      return false;
    }
    return date1.getUTCHours() === date2.getUTCHours() && date1.getUTCMinutes() === date2.getUTCMinutes() && date1.getUTCSeconds() === date2.getUTCSeconds() && date1.getUTCMilliseconds() === date2.getUTCMilliseconds();
  }
  /** @private */
  __handleDateTimeChange(property, parsedProperty, value, oldValue) {
    if (!value) {
      this[property] = "";
      this[parsedProperty] = "";
      return;
    }
    const dateTime = this.__parseDateTime(value);
    if (!dateTime) {
      this[property] = oldValue;
      return;
    }
    if (!this.__dateTimeEquals(this[parsedProperty], dateTime)) {
      this[parsedProperty] = dateTime;
    }
  }
  /** @private */
  __valueChanged(value, oldValue) {
    this.__handleDateTimeChange("value", "__selectedDateTime", value, oldValue);
    if (oldValue !== void 0) {
      this.__dispatchChangeForValue = value;
    }
    this.toggleAttribute("has-value", !!value);
    this.__updateTimePickerMinMax();
  }
  /** @private */
  __dispatchChange() {
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
  }
  /** @private */
  __minChanged(value, oldValue) {
    this.__handleDateTimeChange("min", "__minDateTime", value, oldValue);
    if (this.__datePicker) {
      this.__datePicker.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue);
    }
    this.__updateTimePickerMinMax();
    if (this.__datePicker && this.__timePicker && this.value) {
      this._requestValidation();
    }
  }
  /** @private */
  __maxChanged(value, oldValue) {
    this.__handleDateTimeChange("max", "__maxDateTime", value, oldValue);
    if (this.__datePicker) {
      this.__datePicker.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue);
    }
    this.__updateTimePickerMinMax();
    if (this.__datePicker && this.__timePicker && this.value) {
      this._requestValidation();
    }
  }
  /** @private */
  __selectedDateTimeChanged(selectedDateTime) {
    const formattedValue = this.__formatDateTime(selectedDateTime);
    if (this.value !== formattedValue) {
      this.value = formattedValue;
    }
    const isDatePickerReady = Boolean(this.__datePicker && this.__datePicker.$);
    if (isDatePickerReady && !this.__ignoreInputValueChange) {
      this.__ignoreInputValueChange = true;
      const [dateValue, timeValue] = this.value.split("T");
      this.__datePicker.value = dateValue || "";
      this.__timePicker.value = timeValue || "";
      this.__ignoreInputValueChange = false;
    }
  }
  /** @private */
  __valueChangedEventHandler() {
    if (this.__ignoreInputValueChange) {
      return;
    }
    this.__ignoreInputValueChange = true;
    this.__updateTimePickerMinMax();
    this.value = this.__formattedValue;
    this.__ignoreInputValueChange = false;
  }
  /** @private */
  __autoOpenDisabledChanged(autoOpenDisabled, datePicker2, timePicker2) {
    if (datePicker2) {
      datePicker2.autoOpenDisabled = autoOpenDisabled;
    }
    if (timePicker2) {
      timePicker2.autoOpenDisabled = autoOpenDisabled;
    }
  }
  /** @private */
  __themeChanged(theme, datePicker2, timePicker2) {
    if (!datePicker2 || !timePicker2) {
      return;
    }
    [datePicker2, timePicker2].forEach((picker) => {
      if (theme) {
        picker.setAttribute("theme", theme);
      } else {
        picker.removeAttribute("theme");
      }
    });
  }
  /** @private */
  __overlayClassChanged(overlayClass, datePicker2, timePicker2) {
    if (!datePicker2 || !timePicker2) {
      return;
    }
    datePicker2.overlayClass = overlayClass;
    timePicker2.overlayClass = overlayClass;
  }
  /** @private */
  __pickersChanged(datePicker2, timePicker2) {
    if (!datePicker2 || !timePicker2) {
      return;
    }
    if (this.__isDefaultPicker(datePicker2, "date") !== this.__isDefaultPicker(timePicker2, "time")) {
      return;
    }
    if (datePicker2.value) {
      this.__valueChangedEventHandler();
    } else if (this.value) {
      this.__selectedDateTimeChanged(this.__selectedDateTime);
      if (this.min && this.__minDateTime || this.max && this.__maxDateTime) {
        this._requestValidation();
      }
    }
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
};
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-date-time-picker", inputFieldShared, { moduleId: "vaadin-date-time-picker" });
class DateTimePicker extends DateTimePickerMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        .vaadin-date-time-picker-container {
          --vaadin-field-default-width: auto;
        }

        .slots {
          display: flex;
          --vaadin-field-default-width: 12em;
        }

        .slots ::slotted([slot='date-picker']) {
          min-width: 0;
          flex: 1 1 auto;
        }

        .slots ::slotted([slot='time-picker']) {
          min-width: 0;
          flex: 1 1.65 auto;
        }
      </style>

      <div class="vaadin-date-time-picker-container">
        <div part="label" on-click="focus">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div class="slots">
          <slot name="date-picker" id="dateSlot"></slot>
          <slot name="time-picker" id="timeSlot"></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-date-time-picker";
  }
}
defineCustomElement(DateTimePicker);
const EASTERN_ARABIC_DIGIT_MAP = {
  "\\u0660": "0",
  "\\u0661": "1",
  "\\u0662": "2",
  "\\u0663": "3",
  "\\u0664": "4",
  "\\u0665": "5",
  "\\u0666": "6",
  "\\u0667": "7",
  "\\u0668": "8",
  "\\u0669": "9"
};
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function parseEasternArabicDigits(digits) {
  return digits.replace(/[\u0660-\u0669]/g, function(char) {
    const unicode = "\\u0" + char.charCodeAt(0).toString(16);
    return EASTERN_ARABIC_DIGIT_MAP[unicode];
  });
}
function getAmOrPmString(locale2, testTime) {
  const testTimeString = testTime.toLocaleTimeString(locale2);
  const amOrPmRegExp = /[^\d\u0660-\u0669]/;
  const matches2 = (
    // In most locales, the time ends with AM/PM:
    testTimeString.match(new RegExp(`${amOrPmRegExp.source}+$`, "g")) || // In some locales, the time starts with AM/PM e.g in Chinese:
    testTimeString.match(new RegExp(`^${amOrPmRegExp.source}+`, "g"))
  );
  return matches2 && matches2[0].trim();
}
function getSeparator(locale2) {
  let timeString = TEST_PM_TIME.toLocaleTimeString(locale2);
  const pmString = getPmString(locale2);
  if (pmString && timeString.startsWith(pmString)) {
    timeString = timeString.replace(pmString, "");
  }
  const matches2 = timeString.match(/[^\u0660-\u0669\s\d]/);
  return matches2 && matches2[0];
}
function searchAmOrPmToken(timeString, amOrPmString) {
  if (!amOrPmString) return null;
  const tokenRegExpString = amOrPmString.split(/\s*/).map(escapeRegExp).join("\\s*");
  const tokenRegExp = new RegExp(tokenRegExpString, "i");
  const tokenMatches = timeString.match(tokenRegExp);
  if (tokenMatches) {
    return tokenMatches[0];
  }
}
const TEST_PM_TIME = /* @__PURE__ */ new Date("August 19, 1975 23:15:30");
const TEST_AM_TIME = /* @__PURE__ */ new Date("August 19, 1975 05:15:30");
function getPmString(locale2) {
  return getAmOrPmString(locale2, TEST_PM_TIME);
}
function getAmString(locale2) {
  return getAmOrPmString(locale2, TEST_AM_TIME);
}
function parseDigitsIntoInteger(digits) {
  return parseInt(parseEasternArabicDigits(digits));
}
function parseMillisecondsIntoInteger(milliseconds) {
  milliseconds = parseEasternArabicDigits(milliseconds);
  if (milliseconds.length === 1) {
    milliseconds += "00";
  } else if (milliseconds.length === 2) {
    milliseconds += "0";
  }
  return parseInt(milliseconds);
}
function formatMilliseconds(timeString, milliseconds, amString, pmString) {
  let cleanedTimeString = timeString;
  if (timeString.endsWith(amString)) {
    cleanedTimeString = timeString.replace(" " + amString, "");
  } else if (timeString.endsWith(pmString)) {
    cleanedTimeString = timeString.replace(" " + pmString, "");
  }
  if (milliseconds) {
    let millisecondsString = milliseconds < 10 ? "0" : "";
    millisecondsString += milliseconds < 100 ? "0" : "";
    millisecondsString += milliseconds;
    cleanedTimeString += "." + millisecondsString;
  } else {
    cleanedTimeString += ".000";
  }
  if (timeString.endsWith(amString)) {
    cleanedTimeString = cleanedTimeString + " " + amString;
  } else if (timeString.endsWith(pmString)) {
    cleanedTimeString = cleanedTimeString + " " + pmString;
  }
  return cleanedTimeString;
}
function when(predicate, callback, timeout = 0) {
  if (predicate()) {
    callback();
  } else {
    setTimeout(() => when(predicate, callback, 200), timeout);
  }
}
function parseISO(text) {
  const timeObject = parseISOTime(text);
  return {
    hours: parseInt(timeObject.hours || 0),
    minutes: parseInt(timeObject.minutes || 0),
    seconds: parseInt(timeObject.seconds || 0),
    milliseconds: parseInt(timeObject.milliseconds || 0)
  };
}
window.Vaadin.Flow.timepickerConnector = {};
window.Vaadin.Flow.timepickerConnector.initLazy = (timepicker) => {
  if (timepicker.$connector) {
    return;
  }
  timepicker.$connector = {};
  timepicker.$connector.setLocale = (locale2) => {
    let previousValueObject;
    if (timepicker.value && timepicker.value !== "") {
      previousValueObject = parseISO(timepicker.value);
    }
    try {
      TEST_PM_TIME.toLocaleTimeString(locale2);
    } catch (e2) {
      locale2 = "en-US";
      throw new Error(
        "vaadin-time-picker: The locale " + locale2 + " is not supported, falling back to default locale setting(en-US)."
      );
    }
    const pmString = getPmString(locale2);
    const amString = getAmString(locale2);
    const separator = getSeparator(locale2);
    const includeSeconds = function() {
      return timepicker.step && timepicker.step < 60;
    };
    const includeMilliSeconds = function() {
      return timepicker.step && timepicker.step < 1;
    };
    let cachedTimeString;
    let cachedTimeObject;
    timepicker.i18n = {
      formatTime(timeObject) {
        if (!timeObject) return;
        const timeToBeFormatted = /* @__PURE__ */ new Date();
        timeToBeFormatted.setHours(timeObject.hours);
        timeToBeFormatted.setMinutes(timeObject.minutes);
        timeToBeFormatted.setSeconds(timeObject.seconds !== void 0 ? timeObject.seconds : 0);
        let localeTimeString = timeToBeFormatted.toLocaleTimeString(locale2, {
          hour: "numeric",
          minute: "numeric",
          second: includeSeconds() ? "numeric" : void 0
        });
        if (includeMilliSeconds()) {
          localeTimeString = formatMilliseconds(localeTimeString, timeObject.milliseconds, amString, pmString);
        }
        return localeTimeString;
      },
      parseTime(timeString) {
        if (timeString && timeString === cachedTimeString && cachedTimeObject) {
          return cachedTimeObject;
        }
        if (!timeString) {
          return;
        }
        const amToken = searchAmOrPmToken(timeString, amString);
        const pmToken = searchAmOrPmToken(timeString, pmString);
        const numbersOnlyTimeString = timeString.replace(amToken || "", "").replace(pmToken || "", "").trim();
        const numbersRegExp = new RegExp("([\\d\\u0660-\\u0669]){1,2}(?:" + separator + ")?", "g");
        let hours = numbersRegExp.exec(numbersOnlyTimeString);
        if (hours) {
          hours = parseDigitsIntoInteger(hours[0].replace(separator, ""));
          if (amToken !== pmToken) {
            if (hours === 12 && amToken) {
              hours = 0;
            }
            if (hours !== 12 && pmToken) {
              hours += 12;
            }
          }
          const minutes = numbersRegExp.exec(numbersOnlyTimeString);
          const seconds = minutes && numbersRegExp.exec(numbersOnlyTimeString);
          const millisecondRegExp = /[[\.][\d\u0660-\u0669]{1,3}$/;
          let milliseconds = seconds && includeMilliSeconds() && millisecondRegExp.exec(numbersOnlyTimeString);
          if (milliseconds && milliseconds["index"] <= seconds["index"]) {
            milliseconds = void 0;
          }
          cachedTimeObject = hours !== void 0 && {
            hours,
            minutes: minutes ? parseDigitsIntoInteger(minutes[0].replace(separator, "")) : 0,
            seconds: seconds ? parseDigitsIntoInteger(seconds[0].replace(separator, "")) : 0,
            milliseconds: minutes && seconds && milliseconds ? parseMillisecondsIntoInteger(milliseconds[0].replace(".", "")) : 0
          };
          cachedTimeString = timeString;
          return cachedTimeObject;
        }
      }
    };
    if (previousValueObject) {
      when(
        () => timepicker.$,
        () => {
          const newValue = timepicker.i18n.formatTime(previousValueObject);
          if (timepicker.inputElement.value !== newValue) {
            timepicker.inputElement.value = newValue;
            timepicker.$.comboBox.value = newValue;
          }
        }
      );
    }
  };
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DialogOverlayMixin = (superClass) => class DialogOverlayMixin extends OverlayMixin(superClass) {
  static get properties() {
    return {
      /**
       * String used for rendering a dialog title.
       */
      headerTitle: {
        type: String
      },
      /**
       * Custom function for rendering the dialog header.
       */
      headerRenderer: {
        type: Object
      },
      /**
       * Custom function for rendering the dialog footer.
       */
      footerRenderer: {
        type: Object
      }
    };
  }
  static get observers() {
    return [
      "_headerFooterRendererChange(headerRenderer, footerRenderer, opened)",
      "_headerTitleChanged(headerTitle, opened)"
    ];
  }
  /** @protected */
  ready() {
    super.ready();
    this.__resizeObserver = new ResizeObserver(() => {
      this.__updateOverflow();
    });
    this.__resizeObserver.observe(this.$.resizerContainer);
    this.$.content.addEventListener("scroll", () => {
      this.__updateOverflow();
    });
  }
  /** @private */
  __createContainer(slot) {
    const container = document.createElement("div");
    container.setAttribute("slot", slot);
    return container;
  }
  /** @private */
  __clearContainer(container) {
    container.innerHTML = "";
    delete container._$litPart$;
  }
  /** @private */
  __initContainer(container, slot) {
    if (container) {
      this.__clearContainer(container);
    } else {
      container = this.__createContainer(slot);
    }
    return container;
  }
  /** @private */
  _headerFooterRendererChange(headerRenderer, footerRenderer, opened) {
    const headerRendererChanged = this.__oldHeaderRenderer !== headerRenderer;
    this.__oldHeaderRenderer = headerRenderer;
    const footerRendererChanged = this.__oldFooterRenderer !== footerRenderer;
    this.__oldFooterRenderer = footerRenderer;
    const openedChanged = this._oldOpenedFooterHeader !== opened;
    this._oldOpenedFooterHeader = opened;
    this.toggleAttribute("has-header", !!headerRenderer);
    this.toggleAttribute("has-footer", !!footerRenderer);
    if (headerRendererChanged) {
      if (headerRenderer) {
        this.headerContainer = this.__initContainer(this.headerContainer, "header-content");
      } else if (this.headerContainer) {
        this.headerContainer.remove();
        this.headerContainer = null;
        this.__updateOverflow();
      }
    }
    if (footerRendererChanged) {
      if (footerRenderer) {
        this.footerContainer = this.__initContainer(this.footerContainer, "footer");
      } else if (this.footerContainer) {
        this.footerContainer.remove();
        this.footerContainer = null;
        this.__updateOverflow();
      }
    }
    if (headerRenderer && (headerRendererChanged || openedChanged) || footerRenderer && (footerRendererChanged || openedChanged)) {
      if (opened) {
        this.requestContentUpdate();
      }
    }
  }
  /** @private */
  _headerTitleChanged(headerTitle, opened) {
    this.toggleAttribute("has-title", !!headerTitle);
    if (opened && (headerTitle || this._oldHeaderTitle)) {
      this.requestContentUpdate();
    }
    this._oldHeaderTitle = headerTitle;
  }
  /** @private */
  _headerTitleRenderer() {
    if (this.headerTitle) {
      if (!this.headerTitleElement) {
        this.headerTitleElement = document.createElement("h2");
        this.headerTitleElement.setAttribute("slot", "title");
        this.headerTitleElement.classList.add("draggable");
      }
      this.appendChild(this.headerTitleElement);
      this.headerTitleElement.textContent = this.headerTitle;
    } else if (this.headerTitleElement) {
      this.headerTitleElement.remove();
      this.headerTitleElement = null;
    }
  }
  /**
   * @override
   */
  requestContentUpdate() {
    super.requestContentUpdate();
    if (this.headerContainer) {
      if (!this.headerContainer.parentElement) {
        this.appendChild(this.headerContainer);
      }
      if (this.headerRenderer) {
        this.headerRenderer.call(this.owner, this.headerContainer, this.owner);
      }
    }
    if (this.footerContainer) {
      if (!this.footerContainer.parentElement) {
        this.appendChild(this.footerContainer);
      }
      if (this.footerRenderer) {
        this.footerRenderer.call(this.owner, this.footerContainer, this.owner);
      }
    }
    this._headerTitleRenderer();
    this.__updateOverflow();
  }
  /**
   * Updates the coordinates of the overlay.
   * @param {!DialogOverlayBoundsParam} bounds
   */
  setBounds(bounds) {
    const overlay2 = this.$.overlay;
    const parsedBounds = { ...bounds };
    if (overlay2.style.position !== "absolute") {
      overlay2.style.position = "absolute";
      this.setAttribute("has-bounds-set", "");
    }
    Object.keys(parsedBounds).forEach((arg) => {
      if (!isNaN(parsedBounds[arg])) {
        parsedBounds[arg] = `${parsedBounds[arg]}px`;
      }
    });
    Object.assign(overlay2.style, parsedBounds);
  }
  /**
   * Retrieves the coordinates of the overlay.
   * @return {!DialogOverlayBounds}
   */
  getBounds() {
    const overlayBounds = this.$.overlay.getBoundingClientRect();
    const containerBounds = this.getBoundingClientRect();
    const top = overlayBounds.top - containerBounds.top;
    const left = overlayBounds.left - containerBounds.left;
    const width = overlayBounds.width;
    const height = overlayBounds.height;
    return { top, left, width, height };
  }
  /** @private */
  __updateOverflow() {
    let overflow = "";
    if (this.hasAttribute("has-header") || this.hasAttribute("has-footer") || this.headerTitle) {
      const content = this.$.content;
      if (content.scrollTop > 0) {
        overflow += " top";
      }
      if (content.scrollTop < content.scrollHeight - content.clientHeight) {
        overflow += " bottom";
      }
    }
    const value = overflow.trim();
    if (value.length > 0 && this.getAttribute("overflow") !== value) {
      this.setAttribute("overflow", value);
    } else if (value.length === 0 && this.hasAttribute("overflow")) {
      this.removeAttribute("overflow");
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-dialog-overlay", [overlayStyles, dialogOverlay, resizableOverlay], {
  moduleId: "vaadin-dialog-overlay-styles"
});
class DialogOverlay extends DialogOverlayMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-dialog-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <section id="resizerContainer" class="resizer-container">
          <header part="header">
            <div part="title"><slot name="title"></slot></div>
            <div part="header-content"><slot name="header-content"></slot></div>
          </header>
          <div part="content" id="content"><slot></slot></div>
          <footer part="footer"><slot name="footer"></slot></footer>
        </section>
      </div>
    `;
  }
}
defineCustomElement(DialogOverlay);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function getMouseOrFirstTouchEvent(e2) {
  return e2.touches ? e2.touches[0] : e2;
}
function eventInWindow(e2) {
  return e2.clientX >= 0 && e2.clientX <= window.innerWidth && e2.clientY >= 0 && e2.clientY <= window.innerHeight;
}
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DialogDraggableMixin = (superClass) => class VaadinDialogDraggableMixin extends superClass {
  static get properties() {
    return {
      /**
       * Set to true to enable repositioning the dialog by clicking and dragging.
       *
       * By default, only the overlay area can be used to drag the element. But,
       * a child element can be marked as a draggable area by adding a
       * "`draggable`" class to it, this will by default make all of its children draggable also.
       * If you want a child element to be draggable
       * but still have its children non-draggable (by default), mark it with
       * "`draggable-leaf-only`" class name.
       *
       * @type {boolean}
       */
      draggable: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /** @private */
      _touchDevice: {
        type: Boolean,
        value: isTouch
      },
      /* TODO: Expose as a public property (check naming) */
      __dragHandleClassName: {
        type: String
      }
    };
  }
  /** @protected */
  async ready() {
    super.ready();
    this._originalBounds = {};
    this._originalMouseCoords = {};
    this._startDrag = this._startDrag.bind(this);
    this._drag = this._drag.bind(this);
    this._stopDrag = this._stopDrag.bind(this);
    await new Promise(requestAnimationFrame);
    this.$.overlay.$.overlay.addEventListener("mousedown", this._startDrag);
    this.$.overlay.$.overlay.addEventListener("touchstart", this._startDrag);
  }
  /** @private */
  _startDrag(e2) {
    if (e2.type === "touchstart" && e2.touches.length > 1) {
      return;
    }
    if (this.draggable && (e2.button === 0 || e2.touches)) {
      const resizerContainer = this.$.overlay.$.resizerContainer;
      const isResizerContainer = e2.target === resizerContainer;
      const isResizerContainerScrollbar = e2.offsetX > resizerContainer.clientWidth || e2.offsetY > resizerContainer.clientHeight;
      const isContentPart = e2.target === this.$.overlay.$.content;
      const isDraggable = e2.composedPath().some((node, index) => {
        if (!node.classList) {
          return false;
        }
        const isDraggableNode = node.classList.contains(this.__dragHandleClassName || "draggable");
        const isDraggableLeafOnly = node.classList.contains("draggable-leaf-only");
        const isLeafNode = index === 0;
        return isDraggableLeafOnly && isLeafNode || isDraggableNode && (!isDraggableLeafOnly || isLeafNode);
      });
      if (isResizerContainer && !isResizerContainerScrollbar || isContentPart || isDraggable) {
        if (!isDraggable) {
          e2.preventDefault();
        }
        this._originalBounds = this.$.overlay.getBounds();
        const event = getMouseOrFirstTouchEvent(e2);
        this._originalMouseCoords = { top: event.pageY, left: event.pageX };
        window.addEventListener("mouseup", this._stopDrag);
        window.addEventListener("touchend", this._stopDrag);
        window.addEventListener("mousemove", this._drag);
        window.addEventListener("touchmove", this._drag);
        if (this.$.overlay.$.overlay.style.position !== "absolute") {
          const { top, left } = this._originalBounds;
          this.$.overlay.setBounds({ top, left });
        }
      }
    }
  }
  /** @private */
  _drag(e2) {
    const event = getMouseOrFirstTouchEvent(e2);
    if (eventInWindow(event)) {
      const top = this._originalBounds.top + (event.pageY - this._originalMouseCoords.top);
      const left = this._originalBounds.left + (event.pageX - this._originalMouseCoords.left);
      this.top = top;
      this.left = left;
    }
  }
  /** @private */
  _stopDrag() {
    this.dispatchEvent(
      new CustomEvent("dragged", { bubbles: true, composed: true, detail: { top: this.top, left: this.left } })
    );
    window.removeEventListener("mouseup", this._stopDrag);
    window.removeEventListener("touchend", this._stopDrag);
    window.removeEventListener("mousemove", this._drag);
    window.removeEventListener("touchmove", this._drag);
  }
  /**
   * Fired when the dialog drag is finished.
   *
   * @event dragged
   */
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DialogRendererMixin = (superClass) => class DialogRendererMixin extends superClass {
  static get properties() {
    return {
      /**
       * Custom function for rendering the content of the dialog.
       * Receives two arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `dialog` The reference to the `<vaadin-dialog>` element.
       * @type {DialogRenderer | undefined}
       */
      renderer: {
        type: Object
      },
      /**
       * String used for rendering a dialog title.
       *
       * If both `headerTitle` and `headerRenderer` are defined, the title
       * and the elements created by the renderer will be placed next to
       * each other, with the title coming first.
       *
       * When `headerTitle` is set, the attribute `has-title` is added to the overlay element.
       * @attr {string} header-title
       */
      headerTitle: String,
      /**
       * Custom function for rendering the dialog header.
       * Receives two arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `dialog` The reference to the `<vaadin-dialog>` element.
       *
       * If both `headerTitle` and `headerRenderer` are defined, the title
       * and the elements created by the renderer will be placed next to
       * each other, with the title coming first.
       *
       * When `headerRenderer` is set, the attribute `has-header` is added to the overlay element.
       * @type {DialogRenderer | undefined}
       */
      headerRenderer: {
        type: Object
      },
      /**
       * Custom function for rendering the dialog footer.
       * Receives two arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `dialog` The reference to the `<vaadin-dialog>` element.
       *
       * When `footerRenderer` is set, the attribute `has-footer` is added to the overlay element.
       * @type {DialogRenderer | undefined}
       */
      footerRenderer: {
        type: Object
      }
    };
  }
  /**
   * Requests an update for the content of the dialog.
   * While performing the update, it invokes the renderer passed in the `renderer` property,
   * as well as `headerRender` and `footerRenderer` properties, if these are defined.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (this._overlayElement) {
      this._overlayElement.requestContentUpdate();
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DialogResizableMixin = (superClass) => class VaadinDialogResizableMixin extends superClass {
  static get properties() {
    return {
      /**
       * Set to true to enable resizing the dialog by dragging the corners and edges.
       * @type {boolean}
       */
      resizable: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    };
  }
  /** @protected */
  async ready() {
    super.ready();
    this._originalBounds = {};
    this._originalMouseCoords = {};
    this._resizeListeners = { start: {}, resize: {}, stop: {} };
    await new Promise(requestAnimationFrame);
    this._addResizeListeners();
  }
  /** @private */
  _addResizeListeners() {
    ["n", "e", "s", "w", "nw", "ne", "se", "sw"].forEach((direction) => {
      const resizer = document.createElement("div");
      this._resizeListeners.start[direction] = (e2) => this._startResize(e2, direction);
      this._resizeListeners.resize[direction] = (e2) => this._resize(e2, direction);
      this._resizeListeners.stop[direction] = () => this._stopResize(direction);
      if (direction.length === 1) {
        resizer.classList.add("edge");
      }
      resizer.classList.add("resizer");
      resizer.classList.add(direction);
      resizer.addEventListener("mousedown", this._resizeListeners.start[direction]);
      resizer.addEventListener("touchstart", this._resizeListeners.start[direction]);
      this.$.overlay.$.resizerContainer.appendChild(resizer);
    });
  }
  /**
   * @param {!MouseEvent | !TouchEvent} e
   * @param {!DialogResizableDirection} direction
   * @protected
   */
  _startResize(e2, direction) {
    if (e2.type === "touchstart" && e2.touches.length > 1) {
      return;
    }
    if (e2.button === 0 || e2.touches) {
      e2.preventDefault();
      this._originalBounds = this.$.overlay.getBounds();
      const event = getMouseOrFirstTouchEvent(e2);
      this._originalMouseCoords = { top: event.pageY, left: event.pageX };
      window.addEventListener("mousemove", this._resizeListeners.resize[direction]);
      window.addEventListener("touchmove", this._resizeListeners.resize[direction]);
      window.addEventListener("mouseup", this._resizeListeners.stop[direction]);
      window.addEventListener("touchend", this._resizeListeners.stop[direction]);
      if (this.$.overlay.$.overlay.style.position !== "absolute" || this.width || this.height) {
        this.$.overlay.setBounds(this._originalBounds);
      }
    }
  }
  /**
   * @param {!MouseEvent | !TouchEvent} e
   * @param {!DialogResizableDirection} resizer
   * @protected
   */
  _resize(e2, resizer) {
    const event = getMouseOrFirstTouchEvent(e2);
    if (eventInWindow(event)) {
      const minimumSize = 40;
      resizer.split("").forEach((direction) => {
        switch (direction) {
          case "n": {
            const height = this._originalBounds.height - (event.pageY - this._originalMouseCoords.top);
            const top = this._originalBounds.top + (event.pageY - this._originalMouseCoords.top);
            if (height > minimumSize) {
              this.top = top;
              this.height = height;
            }
            break;
          }
          case "e": {
            const width = this._originalBounds.width + (event.pageX - this._originalMouseCoords.left);
            if (width > minimumSize) {
              this.width = width;
            }
            break;
          }
          case "s": {
            const height = this._originalBounds.height + (event.pageY - this._originalMouseCoords.top);
            if (height > minimumSize) {
              this.height = height;
            }
            break;
          }
          case "w": {
            const width = this._originalBounds.width - (event.pageX - this._originalMouseCoords.left);
            const left = this._originalBounds.left + (event.pageX - this._originalMouseCoords.left);
            if (width > minimumSize) {
              this.left = left;
              this.width = width;
            }
            break;
          }
        }
      });
    }
  }
  /**
   * @param {!DialogResizableDirection} direction
   * @protected
   */
  _stopResize(direction) {
    window.removeEventListener("mousemove", this._resizeListeners.resize[direction]);
    window.removeEventListener("touchmove", this._resizeListeners.resize[direction]);
    window.removeEventListener("mouseup", this._resizeListeners.stop[direction]);
    window.removeEventListener("touchend", this._resizeListeners.stop[direction]);
    this.dispatchEvent(new CustomEvent("resize", { detail: this._getResizeDimensions() }));
  }
  /**
   * @return {!DialogResizeDimensions}
   * @protected
   */
  _getResizeDimensions() {
    const scrollPosition = this.$.overlay.$.resizerContainer.scrollTop;
    const { width, height, top, left } = getComputedStyle(this.$.overlay.$.overlay);
    const content = this.$.overlay.$.content;
    content.setAttribute(
      "style",
      "position: absolute; top: 0; right: 0; bottom: 0; left: 0; box-sizing: content-box; height: auto;"
    );
    const { width: contentWidth, height: contentHeight } = getComputedStyle(content);
    content.removeAttribute("style");
    this.$.overlay.$.resizerContainer.scrollTop = scrollPosition;
    return { width, height, contentWidth, contentHeight, top, left };
  }
  /**
   * Fired when the dialog resize is finished.
   *
   * @event resize
   */
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Dialog extends DialogDraggableMixin(
  DialogResizableMixin(
    DialogRendererMixin(DialogBaseMixin(OverlayClassMixin(ThemePropertyMixin(ElementMixin(PolymerElement)))))
  )
) {
  static get template() {
    return html`
      <style>
        :host {
          display: none !important;
        }
      </style>

      <vaadin-dialog-overlay
        id="overlay"
        role$="[[overlayRole]]"
        header-title="[[headerTitle]]"
        on-opened-changed="_onOverlayOpened"
        on-mousedown="_bringOverlayToFront"
        on-touchstart="_bringOverlayToFront"
        theme$="[[_theme]]"
        modeless="[[modeless]]"
        with-backdrop="[[!modeless]]"
        resizable$="[[resizable]]"
        restore-focus-on-close
        focus-trap
      ></vaadin-dialog-overlay>
    `;
  }
  static get is() {
    return "vaadin-dialog";
  }
  static get properties() {
    return {
      /**
       * Set the `aria-label` attribute for assistive technologies like
       * screen readers. An empty string value for this property (the
       * default) means that the `aria-label` attribute is not present.
       */
      ariaLabel: {
        type: String,
        value: ""
      }
    };
  }
  static get observers() {
    return [
      "_openedChanged(opened)",
      "_ariaLabelChanged(ariaLabel, headerTitle)",
      "_rendererChanged(renderer, headerRenderer, footerRenderer)"
    ];
  }
  /** @protected */
  ready() {
    super.ready();
    processTemplates(this);
  }
  /** @private */
  _rendererChanged(renderer, headerRenderer, footerRenderer) {
    this.$.overlay.setProperties({ owner: this, renderer, headerRenderer, footerRenderer });
  }
  /** @private */
  _openedChanged(opened) {
    this.$.overlay.opened = opened;
  }
  /** @private */
  _ariaLabelChanged(ariaLabel, headerTitle) {
    if (ariaLabel || headerTitle) {
      this.$.overlay.setAttribute("aria-label", ariaLabel || headerTitle);
    } else {
      this.$.overlay.removeAttribute("aria-label");
    }
  }
}
defineCustomElement(Dialog);
window.Vaadin = window.Vaadin || {};
window.Vaadin.Flow = window.Vaadin.Flow || {};
window.Vaadin.Flow.dndConnector = {
  __ondragenterListener: function(event) {
    const effect = event.currentTarget["__dropEffect"];
    if (!event.currentTarget.hasAttribute("disabled")) {
      if (effect) {
        event.dataTransfer.dropEffect = effect;
      }
      if (effect !== "none") {
        if (event.currentTarget.classList.contains("v-drag-over-target")) {
          event.currentTarget["__skip-leave"] = true;
        } else {
          event.currentTarget.classList.add("v-drag-over-target");
        }
        event.preventDefault();
        event.stopPropagation();
      }
    }
  },
  __ondragoverListener: function(event) {
    if (!event.currentTarget.hasAttribute("disabled")) {
      const effect = event.currentTarget["__dropEffect"];
      if (effect) {
        event.dataTransfer.dropEffect = effect;
      }
      event.preventDefault();
      event.stopPropagation();
    }
  },
  __ondragleaveListener: function(event) {
    if (event.currentTarget["__skip-leave"]) {
      event.currentTarget["__skip-leave"] = false;
    } else {
      event.currentTarget.classList.remove("v-drag-over-target");
    }
    event.stopPropagation();
  },
  __ondropListener: function(event) {
    const effect = event.currentTarget["__dropEffect"];
    if (effect) {
      event.dataTransfer.dropEffect = effect;
    }
    event.currentTarget.classList.remove("v-drag-over-target");
    event.preventDefault();
    event.stopPropagation();
  },
  updateDropTarget: function(element) {
    if (element["__active"]) {
      element.addEventListener("dragenter", this.__ondragenterListener, false);
      element.addEventListener("dragover", this.__ondragoverListener, false);
      element.addEventListener("dragleave", this.__ondragleaveListener, false);
      element.addEventListener("drop", this.__ondropListener, false);
    } else {
      element.removeEventListener("dragenter", this.__ondragenterListener, false);
      element.removeEventListener("dragover", this.__ondragoverListener, false);
      element.removeEventListener("dragleave", this.__ondragleaveListener, false);
      element.removeEventListener("drop", this.__ondropListener, false);
      element.classList.remove("v-drag-over-target");
    }
  },
  /** DRAG SOURCE METHODS: */
  __dragstartListener: function(event) {
    event.stopPropagation();
    event.dataTransfer.setData("text/plain", "");
    if (event.currentTarget.hasAttribute("disabled")) {
      event.preventDefault();
    } else {
      if (event.currentTarget["__effectAllowed"]) {
        event.dataTransfer.effectAllowed = event.currentTarget["__effectAllowed"];
      }
      event.currentTarget.classList.add("v-dragged");
    }
    if (event.currentTarget.__dragImage) {
      if (event.currentTarget.__dragImage.style.display === "none") {
        event.currentTarget.__dragImage.style.display = "block";
        event.currentTarget.classList.add("shown");
      }
      event.dataTransfer.setDragImage(
        event.currentTarget.__dragImage,
        event.currentTarget.__dragImageOffsetX,
        event.currentTarget.__dragImageOffsetY
      );
    }
  },
  __dragendListener: function(event) {
    event.currentTarget.classList.remove("v-dragged");
    if (event.currentTarget.classList.contains("shown")) {
      event.currentTarget.classList.remove("shown");
      event.currentTarget.__dragImage.style.display = "none";
    }
  },
  updateDragSource: function(element) {
    if (element["draggable"]) {
      element.addEventListener("dragstart", this.__dragstartListener, false);
      element.addEventListener("dragend", this.__dragendListener, false);
    } else {
      element.removeEventListener("dragstart", this.__dragstartListener, false);
      element.removeEventListener("dragend", this.__dragendListener, false);
    }
  },
  setDragImage: function(dragImage, offsetX, offsetY, dragSource) {
    dragSource.__dragImage = dragImage;
    dragSource.__dragImageOffsetX = offsetX;
    dragSource.__dragImageOffsetY = offsetY;
  }
};
registerStyles$1(
  "vaadin-form-layout",
  css`
    :host {
      --vaadin-form-layout-column-spacing: var(--lumo-space-l);
    }
  `,
  { moduleId: "lumo-form-layout" }
);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class FormLayout extends ResizeMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          max-width: 100%;
          animation: 1ms vaadin-form-layout-appear;
          /* CSS API for host */
          --vaadin-form-item-label-width: 8em;
          --vaadin-form-item-label-spacing: 1em;
          --vaadin-form-item-row-spacing: 1em;
          --vaadin-form-layout-column-spacing: 2em; /* (default) */
          align-self: stretch;
        }

        @keyframes vaadin-form-layout-appear {
          to {
            opacity: 1 !important; /* stylelint-disable-line keyframe-declaration-no-important */
          }
        }

        :host([hidden]) {
          display: none !important;
        }

        #layout {
          display: flex;

          align-items: baseline; /* default \`stretch\` is not appropriate */

          flex-wrap: wrap; /* the items should wrap */
        }

        #layout ::slotted(*) {
          /* Items should neither grow nor shrink. */
          flex-grow: 0;
          flex-shrink: 0;

          /* Margins make spacing between the columns */
          margin-left: calc(0.5 * var(--vaadin-form-layout-column-spacing));
          margin-right: calc(0.5 * var(--vaadin-form-layout-column-spacing));
        }

        #layout ::slotted(br) {
          display: none;
        }
      </style>
      <div id="layout">
        <slot id="slot"></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-form-layout";
  }
  static get properties() {
    return {
      /**
       * @typedef FormLayoutResponsiveStep
       * @type {object}
       * @property {string} minWidth - The threshold value for this step in CSS length units.
       * @property {number} columns - Number of columns. Only natural numbers are valid.
       * @property {string} labelsPosition - Labels position option, valid values: `"aside"` (default), `"top"`.
       */
      /**
       * Allows specifying a responsive behavior with the number of columns
       * and the label position depending on the layout width.
       *
       * Format: array of objects, each object defines one responsive step
       * with `minWidth` CSS length, `columns` number, and optional
       * `labelsPosition` string of `"aside"` or `"top"`. At least one item is required.
       *
       * #### Examples
       *
       * ```javascript
       * formLayout.responsiveSteps = [{columns: 1}];
       * // The layout is always a single column, labels aside.
       * ```
       *
       * ```javascript
       * formLayout.responsiveSteps = [
       *   {minWidth: 0, columns: 1},
       *   {minWidth: '40em', columns: 2}
       * ];
       * // Sets two responsive steps:
       * // 1. When the layout width is < 40em, one column, labels aside.
       * // 2. Width >= 40em, two columns, labels aside.
       * ```
       *
       * ```javascript
       * formLayout.responsiveSteps = [
       *   {minWidth: 0, columns: 1, labelsPosition: 'top'},
       *   {minWidth: '20em', columns: 1},
       *   {minWidth: '40em', columns: 2}
       * ];
       * // Default value. Three responsive steps:
       * // 1. Width < 20em, one column, labels on top.
       * // 2. 20em <= width < 40em, one column, labels aside.
       * // 3. Width >= 40em, two columns, labels aside.
       * ```
       *
       * @type {!Array<!FormLayoutResponsiveStep>}
       */
      responsiveSteps: {
        type: Array,
        value() {
          return [
            { minWidth: 0, columns: 1, labelsPosition: "top" },
            { minWidth: "20em", columns: 1 },
            { minWidth: "40em", columns: 2 }
          ];
        },
        observer: "_responsiveStepsChanged"
      },
      /**
       * Current number of columns in the layout
       * @private
       */
      _columnCount: {
        type: Number
      },
      /**
       * Indicates that labels are on top
       * @private
       */
      _labelsOnTop: {
        type: Boolean
      },
      /** @private */
      __isVisible: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return ["_invokeUpdateLayout(_columnCount, _labelsOnTop)"];
  }
  /** @protected */
  ready() {
    this._styleElement = document.createElement("style");
    this.appendChild(this._styleElement);
    this._styleElement.textContent = " ";
    super.ready();
    this.addEventListener("animationend", this.__onAnimationEnd);
  }
  constructor() {
    super();
    this.__intersectionObserver = new IntersectionObserver(([entry]) => {
      if (!entry.isIntersecting) {
        this.$.layout.style.opacity = 0;
      }
      if (!this.__isVisible && entry.isIntersecting) {
        this._updateLayout();
        this.$.layout.style.opacity = "";
      }
      this.__isVisible = entry.isIntersecting;
    });
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    requestAnimationFrame(() => this._selectResponsiveStep());
    requestAnimationFrame(() => this._updateLayout());
    this._observeChildrenColspanChange();
    this.__intersectionObserver.observe(this.$.layout);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__mutationObserver.disconnect();
    this.__childObserver.disconnect();
    this.__intersectionObserver.disconnect();
  }
  /** @private */
  _observeChildrenColspanChange() {
    const mutationObserverConfig = { attributes: true };
    this.__mutationObserver = new MutationObserver((mutationRecord) => {
      mutationRecord.forEach((mutation) => {
        if (mutation.type === "attributes" && (mutation.attributeName === "colspan" || mutation.attributeName === "data-colspan" || mutation.attributeName === "hidden")) {
          this._updateLayout();
        }
      });
    });
    [...this.children].forEach((child) => {
      this.__mutationObserver.observe(child, mutationObserverConfig);
    });
    this.__childObserver = new MutationObserver((mutations) => {
      const addedNodes = [];
      const removedNodes = [];
      mutations.forEach((mutation) => {
        addedNodes.push(...this._getObservableNodes(mutation.addedNodes));
        removedNodes.push(...this._getObservableNodes(mutation.removedNodes));
      });
      addedNodes.forEach((child) => {
        this.__mutationObserver.observe(child, mutationObserverConfig);
      });
      if (addedNodes.length > 0 || removedNodes.length > 0) {
        this._updateLayout();
      }
    });
    this.__childObserver.observe(this, { childList: true });
  }
  /** @private */
  _getObservableNodes(nodeList) {
    const ignore = ["template", "style", "dom-repeat", "dom-if"];
    return Array.from(nodeList).filter(
      (node) => node.nodeType === Node.ELEMENT_NODE && ignore.indexOf(node.localName.toLowerCase()) === -1
    );
  }
  /** @private */
  _naturalNumberOrOne(n) {
    if (typeof n === "number" && n >= 1 && n < Infinity) {
      return Math.floor(n);
    }
    return 1;
  }
  /** @private */
  _isValidCSSLength(value) {
    if (value === "inherit" || value === "normal") {
      return false;
    }
    this._styleElement.firstChild.nodeValue = `#styleElement { word-spacing: ${value}; }`;
    if (!this._styleElement.sheet) {
      return true;
    }
    return ["", null].indexOf(this._styleElement.sheet.cssRules[0].style.getPropertyValue("word-spacing")) < 0;
  }
  /** @private */
  _responsiveStepsChanged(responsiveSteps, oldResponsiveSteps) {
    try {
      if (!Array.isArray(responsiveSteps)) {
        throw new Error('Invalid "responsiveSteps" type, an Array is required.');
      }
      if (responsiveSteps.length < 1) {
        throw new Error('Invalid empty "responsiveSteps" array, at least one item is required.');
      }
      responsiveSteps.forEach((step) => {
        if (this._naturalNumberOrOne(step.columns) !== step.columns) {
          throw new Error(`Invalid 'columns' value of ${step.columns}, a natural number is required.`);
        }
        if (step.minWidth !== void 0 && !this._isValidCSSLength(step.minWidth)) {
          throw new Error(`Invalid 'minWidth' value of ${step.minWidth}, a valid CSS length required.`);
        }
        if (step.labelsPosition !== void 0 && ["aside", "top"].indexOf(step.labelsPosition) === -1) {
          throw new Error(
            `Invalid 'labelsPosition' value of ${step.labelsPosition}, 'aside' or 'top' string is required.`
          );
        }
      });
    } catch (e2) {
      if (oldResponsiveSteps && oldResponsiveSteps !== responsiveSteps) {
        console.warn(`${e2.message} Using previously set 'responsiveSteps' instead.`);
        this.responsiveSteps = oldResponsiveSteps;
      } else {
        console.warn(`${e2.message} Using default 'responsiveSteps' instead.`);
        this.responsiveSteps = [
          { minWidth: 0, columns: 1, labelsPosition: "top" },
          { minWidth: "20em", columns: 1 },
          { minWidth: "40em", columns: 2 }
        ];
      }
    }
    this._selectResponsiveStep();
  }
  /** @private */
  __onAnimationEnd(e2) {
    if (e2.animationName.indexOf("vaadin-form-layout-appear") === 0) {
      this._selectResponsiveStep();
    }
  }
  /** @private */
  _selectResponsiveStep() {
    let selectedStep;
    const tmpStyleProp = "background-position";
    this.responsiveSteps.forEach((step) => {
      this.$.layout.style.setProperty(tmpStyleProp, step.minWidth);
      const stepMinWidthPx = parseFloat(getComputedStyle(this.$.layout).getPropertyValue(tmpStyleProp));
      if (stepMinWidthPx <= this.offsetWidth) {
        selectedStep = step;
      }
    });
    this.$.layout.style.removeProperty(tmpStyleProp);
    if (selectedStep) {
      this._columnCount = selectedStep.columns;
      this._labelsOnTop = selectedStep.labelsPosition === "top";
    }
  }
  /** @private */
  _invokeUpdateLayout() {
    this._updateLayout();
  }
  /**
   * Update the layout.
   * @protected
   */
  _updateLayout() {
    if (isElementHidden(this)) {
      return;
    }
    const style = getComputedStyle(this);
    const columnSpacing = style.getPropertyValue("--vaadin-form-layout-column-spacing");
    const direction = style.direction;
    const marginStartProp = `margin-${direction === "ltr" ? "left" : "right"}`;
    const marginEndProp = `margin-${direction === "ltr" ? "right" : "left"}`;
    const containerWidth = this.offsetWidth;
    let col = 0;
    Array.from(this.children).filter((child) => child.localName === "br" || getComputedStyle(child).display !== "none").forEach((child, index, children) => {
      if (child.localName === "br") {
        col = 0;
        return;
      }
      const attrColspan = child.getAttribute("colspan") || child.getAttribute("data-colspan");
      let colspan;
      colspan = this._naturalNumberOrOne(parseFloat(attrColspan));
      colspan = Math.min(colspan, this._columnCount);
      const childRatio = colspan / this._columnCount;
      child.style.width = `calc(${childRatio * 99.9}% - ${1 - childRatio} * ${columnSpacing})`;
      if (col + colspan > this._columnCount) {
        col = 0;
      }
      if (col === 0) {
        child.style.setProperty(marginStartProp, "0px");
      } else {
        child.style.removeProperty(marginStartProp);
      }
      const nextIndex = index + 1;
      const nextLineBreak = nextIndex < children.length && children[nextIndex].localName === "br";
      if (col + colspan === this._columnCount) {
        child.style.setProperty(marginEndProp, "0px");
      } else if (nextLineBreak) {
        const colspanRatio = (this._columnCount - col - colspan) / this._columnCount;
        child.style.setProperty(
          marginEndProp,
          `calc(${colspanRatio * containerWidth}px + ${colspanRatio} * ${columnSpacing})`
        );
      } else {
        child.style.removeProperty(marginEndProp);
      }
      col = (col + colspan) % this._columnCount;
      if (child.localName === "vaadin-form-item") {
        if (this._labelsOnTop) {
          if (child.getAttribute("label-position") !== "top") {
            child.__useLayoutLabelPosition = true;
            child.setAttribute("label-position", "top");
          }
        } else if (child.__useLayoutLabelPosition) {
          delete child.__useLayoutLabelPosition;
          child.removeAttribute("label-position");
        }
      }
    });
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this._selectResponsiveStep();
  }
}
defineCustomElement(FormLayout);
registerStyles$1(
  "vaadin-form-item",
  css`
    :host {
      --vaadin-form-item-row-spacing: 0;
    }

    /* font-weight, margin-bottom, transition and line-height same as for part label in text-field */
    [part='label'] {
      color: var(--lumo-secondary-text-color);
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-s);
      font-weight: 500;
      margin-top: var(--lumo-space-m);
      margin-left: calc(var(--lumo-border-radius-m) / 4);
      margin-bottom: var(--lumo-space-xs);
      transition: color 0.4s;
      line-height: 1.333;
    }

    [part='required-indicator']::after {
      content: var(--lumo-required-field-indicator, '\\2022');
      transition: opacity 0.2s;
      opacity: 0;
      color: var(--lumo-required-field-indicator-color, var(--lumo-primary-text-color));
      position: relative;
      width: 1em;
      text-align: center;
    }

    :host([required]) [part='required-indicator']::after {
      opacity: 1;
    }

    :host([invalid]) [part='required-indicator']::after {
      color: var(--lumo-required-field-indicator-color, var(--lumo-error-text-color));
    }
  `,
  { moduleId: "lumo-form-item" }
);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class FormItem extends ThemableMixin(PolymerElement) {
  static get template() {
    return html`
      <style>
        :host {
          display: inline-flex;
          flex-direction: row;
          align-items: baseline;
          margin: calc(0.5 * var(--vaadin-form-item-row-spacing, 1em)) 0;
        }

        :host([label-position='top']) {
          flex-direction: column;
          align-items: stretch;
        }

        :host([hidden]) {
          display: none !important;
        }

        #label {
          width: var(--vaadin-form-item-label-width, 8em);
          flex: 0 0 auto;
        }

        :host([label-position='top']) #label {
          width: auto;
        }

        #spacing {
          width: var(--vaadin-form-item-label-spacing, 1em);
          flex: 0 0 auto;
        }

        #content {
          flex: 1 1 auto;
        }

        #content ::slotted(.full-width) {
          box-sizing: border-box;
          width: 100%;
          min-width: 0;
        }
      </style>
      <div id="label" part="label" on-click="__onLabelClick">
        <slot name="label" id="labelSlot" on-slotchange="__onLabelSlotChange"></slot>
        <span part="required-indicator" aria-hidden="true"></span>
      </div>
      <div id="spacing"></div>
      <div id="content">
        <slot id="contentSlot" on-slotchange="__onContentSlotChange"></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-form-item";
  }
  constructor() {
    super();
    this.__updateInvalidState = this.__updateInvalidState.bind(this);
    this.__fieldNodeObserver = new MutationObserver(() => this.__updateRequiredState(this.__fieldNode.required));
    this.__labelNode = null;
    this.__fieldNode = null;
  }
  /**
   * Returns a target element to add ARIA attributes to for a field.
   *
   * - For Vaadin field components, the method returns an element
   * obtained through the `ariaTarget` property defined in `FieldMixin`.
   * - In other cases, the method returns the field element itself.
   *
   * @param {HTMLElement} field
   * @protected
   */
  _getFieldAriaTarget(field) {
    return field.ariaTarget || field;
  }
  /**
   * Links the label to a field by adding the label id to
   * the `aria-labelledby` attribute of the field's ARIA target element.
   *
   * @param {HTMLElement} field
   * @private
   */
  __linkLabelToField(field) {
    addValueToAttribute(this._getFieldAriaTarget(field), "aria-labelledby", this.__labelId);
  }
  /**
   * Unlinks the label from a field by removing the label id from
   * the `aria-labelledby` attribute of the field's ARIA target element.
   *
   * @param {HTMLElement} field
   * @private
   */
  __unlinkLabelFromField(field) {
    removeValueFromAttribute(this._getFieldAriaTarget(field), "aria-labelledby", this.__labelId);
  }
  /** @private */
  __onLabelClick() {
    const fieldNode = this.__fieldNode;
    if (fieldNode) {
      fieldNode.focus();
      fieldNode.click();
    }
  }
  /** @private */
  __getValidateFunction(field) {
    return field.validate || field.checkValidity;
  }
  /**
   * A `slotchange` event handler for the label slot.
   *
   * - Ensures the label id is only assigned to the first label node.
   * - Ensures the label node is linked to the first field node via the `aria-labelledby` attribute
   * if both nodes are provided, and unlinked otherwise.
   *
   * @private
   */
  __onLabelSlotChange() {
    if (this.__labelNode) {
      this.__labelNode = null;
      if (this.__fieldNode) {
        this.__unlinkLabelFromField(this.__fieldNode);
      }
    }
    const newLabelNode = this.$.labelSlot.assignedElements()[0];
    if (newLabelNode) {
      this.__labelNode = newLabelNode;
      if (this.__labelNode.id) {
        this.__labelId = this.__labelNode.id;
      } else {
        this.__labelId = `label-${this.localName}-${generateUniqueId()}`;
        this.__labelNode.id = this.__labelId;
      }
      if (this.__fieldNode) {
        this.__linkLabelToField(this.__fieldNode);
      }
    }
  }
  /**
   * A `slotchange` event handler for the content slot.
   *
   * - Ensures the label node is only linked to the first field node via the `aria-labelledby` attribute.
   * - Sets up an observer for the `required` attribute changes on the first field
   * to reflect the attribute on the component. Ensures the observer is disconnected from the field
   * as soon as it is removed or replaced by another one.
   *
   * @private
   */
  __onContentSlotChange() {
    if (this.__fieldNode) {
      this.__unlinkLabelFromField(this.__fieldNode);
      this.__updateRequiredState(false);
      this.__fieldNodeObserver.disconnect();
      this.__fieldNode = null;
    }
    const fieldNodes = this.$.contentSlot.assignedElements();
    if (fieldNodes.length > 1) {
      console.warn(
        `WARNING: Since Vaadin 23, placing multiple fields directly to a <vaadin-form-item> is deprecated.
Please wrap fields with a <vaadin-custom-field> instead.`
      );
    }
    const newFieldNode = fieldNodes.find((field) => {
      return !!this.__getValidateFunction(field);
    });
    if (newFieldNode) {
      this.__fieldNode = newFieldNode;
      this.__updateRequiredState(this.__fieldNode.required);
      this.__fieldNodeObserver.observe(this.__fieldNode, { attributes: true, attributeFilter: ["required"] });
      if (this.__labelNode) {
        this.__linkLabelToField(this.__fieldNode);
      }
    }
  }
  /** @private */
  __updateRequiredState(required) {
    if (required) {
      this.setAttribute("required", "");
      this.__fieldNode.addEventListener("blur", this.__updateInvalidState);
      this.__fieldNode.addEventListener("change", this.__updateInvalidState);
    } else {
      this.removeAttribute("invalid");
      this.removeAttribute("required");
      this.__fieldNode.removeEventListener("blur", this.__updateInvalidState);
      this.__fieldNode.removeEventListener("change", this.__updateInvalidState);
    }
  }
  /** @private */
  __updateInvalidState() {
    const isValid2 = this.__getValidateFunction(this.__fieldNode).call(this.__fieldNode);
    this.toggleAttribute("invalid", isValid2 === false);
  }
}
defineCustomElement(FormItem);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function getBodyRowCells(row) {
  return row.__cells || Array.from(row.querySelectorAll('[part~="cell"]:not([part~="details-cell"])'));
}
function iterateChildren(container, callback) {
  [...container.children].forEach(callback);
}
function iterateRowCells(row, callback) {
  getBodyRowCells(row).forEach(callback);
  if (row.__detailsCell) {
    callback(row.__detailsCell);
  }
}
function updateColumnOrders(columns, scope, baseOrder) {
  let c2 = 1;
  columns.forEach((column) => {
    if (c2 % 10 === 0) {
      c2 += 1;
    }
    column._order = baseOrder + c2 * scope;
    c2 += 1;
  });
}
function updateState(element, attribute, value) {
  switch (typeof value) {
    case "boolean":
      element.toggleAttribute(attribute, value);
      break;
    case "string":
      element.setAttribute(attribute, value);
      break;
    default:
      element.removeAttribute(attribute);
      break;
  }
}
function updatePart(element, value, part) {
  if (value || value === "") {
    addValueToAttribute(element, "part", part);
  } else {
    removeValueFromAttribute(element, "part", part);
  }
}
function updateCellsPart(cells, part, value) {
  cells.forEach((cell) => {
    updatePart(cell, value, part);
  });
}
function updateBooleanRowStates(row, states) {
  const cells = getBodyRowCells(row);
  Object.entries(states).forEach(([state, value]) => {
    updateState(row, state, value);
    const rowPart = `${state}-row`;
    updatePart(row, value, rowPart);
    updateCellsPart(cells, `${rowPart}-cell`, value);
  });
}
function updateStringRowStates(row, states) {
  const cells = getBodyRowCells(row);
  Object.entries(states).forEach(([state, value]) => {
    const prevValue = row.getAttribute(state);
    updateState(row, state, value);
    if (prevValue) {
      const prevRowPart = `${state}-${prevValue}-row`;
      updatePart(row, false, prevRowPart);
      updateCellsPart(cells, `${prevRowPart}-cell`, false);
    }
    if (value) {
      const rowPart = `${state}-${value}-row`;
      updatePart(row, value, rowPart);
      updateCellsPart(cells, `${rowPart}-cell`, value);
    }
  });
}
function updateCellState(cell, attribute, value, part, oldPart) {
  updateState(cell, attribute, value);
  if (oldPart) {
    updatePart(cell, false, oldPart);
  }
  updatePart(cell, value, part || `${attribute}-cell`);
}
class ColumnObserver {
  constructor(host, callback) {
    this.__host = host;
    this.__callback = callback;
    this.__currentSlots = [];
    this.__onMutation = this.__onMutation.bind(this);
    this.__observer = new MutationObserver(this.__onMutation);
    this.__observer.observe(host, {
      childList: true
    });
    this.__initialCallDebouncer = Debouncer$1.debounce(this.__initialCallDebouncer, microTask, () => this.__onMutation());
  }
  disconnect() {
    this.__observer.disconnect();
    this.__initialCallDebouncer.cancel();
    this.__toggleSlotChangeListeners(false);
  }
  flush() {
    this.__onMutation();
  }
  __toggleSlotChangeListeners(add) {
    this.__currentSlots.forEach((slot) => {
      if (add) {
        slot.addEventListener("slotchange", this.__onMutation);
      } else {
        slot.removeEventListener("slotchange", this.__onMutation);
      }
    });
  }
  __onMutation() {
    const initialCall = !this.__currentColumns;
    this.__currentColumns || (this.__currentColumns = []);
    const columns = ColumnObserver.getColumns(this.__host);
    const addedColumns = columns.filter((column) => !this.__currentColumns.includes(column));
    const removedColumns = this.__currentColumns.filter((column) => !columns.includes(column));
    const orderChanged = this.__currentColumns.some((column, index) => column !== columns[index]);
    this.__currentColumns = columns;
    this.__toggleSlotChangeListeners(false);
    this.__currentSlots = [...this.__host.children].filter((child) => child instanceof HTMLSlotElement);
    this.__toggleSlotChangeListeners(true);
    const invokeCallback = initialCall || addedColumns.length || removedColumns.length || orderChanged;
    if (invokeCallback) {
      this.__callback(addedColumns, removedColumns);
    }
  }
  /**
   * Default filter for column elements.
   */
  static __isColumnElement(node) {
    return node.nodeType === Node.ELEMENT_NODE && /\bcolumn\b/u.test(node.localName);
  }
  static getColumns(host) {
    const columns = [];
    const isColumnElement = host._isColumnElement || ColumnObserver.__isColumnElement;
    [...host.children].forEach((child) => {
      if (isColumnElement(child)) {
        columns.push(child);
      } else if (child instanceof HTMLSlotElement) {
        [...child.assignedElements({ flatten: true })].filter((assignedElement) => isColumnElement(assignedElement)).forEach((assignedElement) => columns.push(assignedElement));
      }
    });
    return columns;
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ColumnBaseMixin = (superClass) => class ColumnBaseMixin extends superClass {
  static get properties() {
    return {
      /**
       * When set to true, the column is user-resizable.
       * @default false
       */
      resizable: {
        type: Boolean,
        sync: true,
        value() {
          if (this.localName === "vaadin-grid-column-group") {
            return;
          }
          const parent = this.parentNode;
          if (parent && parent.localName === "vaadin-grid-column-group") {
            return parent.resizable || false;
          }
          return false;
        }
      },
      /**
       * When true, the column is frozen. When a column inside of a column group is frozen,
       * all of the sibling columns inside the group will get frozen also.
       * @type {boolean}
       */
      frozen: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * When true, the column is frozen to end of grid.
       *
       * When a column inside of a column group is frozen to end, all of the sibling columns
       * inside the group will get frozen to end also.
       *
       * Column can not be set as `frozen` and `frozenToEnd` at the same time.
       * @attr {boolean} frozen-to-end
       * @type {boolean}
       */
      frozenToEnd: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * When true, the cells for this column will be rendered with the `role` attribute
       * set as `rowheader`, instead of the `gridcell` role value used by default.
       *
       * When a column is set as row header, its cells will be announced by screen readers
       * while navigating to help user identify the current row as uniquely as possible.
       *
       * @attr {boolean} row-header
       * @type {boolean}
       */
      rowHeader: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * When set to true, the cells for this column are hidden.
       */
      hidden: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * Text content to display in the header cell of the column.
       */
      header: {
        type: String,
        sync: true
      },
      /**
       * Aligns the columns cell content horizontally.
       * Supported values: "start", "center" and "end".
       * @attr {start|center|end} text-align
       * @type {GridColumnTextAlign | null | undefined}
       */
      textAlign: {
        type: String,
        sync: true
      },
      /**
       * Custom part name for the header cell.
       *
       * @attr {string} header-part-name
       */
      headerPartName: {
        type: String,
        sync: true
      },
      /**
       * Custom part name for the footer cell.
       *
       * @attr {string} footer-part-name
       */
      footerPartName: {
        type: String,
        sync: true
      },
      /**
       * @type {boolean}
       * @protected
       */
      _lastFrozen: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * @type {boolean}
       * @protected
       */
      _bodyContentHidden: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * @type {boolean}
       * @protected
       */
      _firstFrozenToEnd: {
        type: Boolean,
        value: false,
        sync: true
      },
      /** @protected */
      _order: {
        type: Number,
        sync: true
      },
      /** @private */
      _reorderStatus: {
        type: Boolean,
        sync: true
      },
      /**
       * @type {Array<!HTMLElement>}
       * @protected
       */
      _emptyCells: Array,
      /** @private */
      _headerCell: Object,
      /** @private */
      _footerCell: Object,
      /** @protected */
      _grid: Object,
      /**
       * By default, the Polymer doesn't invoke the observer
       * during initialization if all of its dependencies are `undefined`.
       * This internal property can be used to force initial invocation of an observer
       * even the other dependencies of the observer are `undefined`.
       *
       * @private
       */
      __initialized: {
        type: Boolean,
        value: true
      },
      /**
       * Custom function for rendering the header content.
       * Receives two arguments:
       *
       * - `root` The header cell content DOM element. Append your content to it.
       * - `column` The `<vaadin-grid-column>` element.
       *
       * @type {GridHeaderFooterRenderer | null | undefined}
       */
      headerRenderer: {
        type: Function,
        sync: true
      },
      /**
       * Represents the final header renderer computed on the set of observable arguments.
       * It is supposed to be used internally when rendering the header cell content.
       *
       * @protected
       * @type {GridHeaderFooterRenderer | undefined}
       */
      _headerRenderer: {
        type: Function,
        computed: "_computeHeaderRenderer(headerRenderer, header, __initialized)",
        sync: true
      },
      /**
       * Custom function for rendering the footer content.
       * Receives two arguments:
       *
       * - `root` The footer cell content DOM element. Append your content to it.
       * - `column` The `<vaadin-grid-column>` element.
       *
       * @type {GridHeaderFooterRenderer | null | undefined}
       */
      footerRenderer: {
        type: Function,
        sync: true
      },
      /**
       * Represents the final footer renderer computed on the set of observable arguments.
       * It is supposed to be used internally when rendering the footer cell content.
       *
       * @protected
       * @type {GridHeaderFooterRenderer | undefined}
       */
      _footerRenderer: {
        type: Function,
        computed: "_computeFooterRenderer(footerRenderer, __initialized)",
        sync: true
      },
      /**
       * An internal property that is mainly used by `vaadin-template-renderer`
       * to identify grid column elements.
       *
       * @private
       */
      __gridColumnElement: {
        type: Boolean,
        value: true
      }
    };
  }
  static get observers() {
    return [
      "_widthChanged(width, _headerCell, _footerCell, _cells)",
      "_frozenChanged(frozen, _headerCell, _footerCell, _cells)",
      "_frozenToEndChanged(frozenToEnd, _headerCell, _footerCell, _cells)",
      "_flexGrowChanged(flexGrow, _headerCell, _footerCell, _cells)",
      "_textAlignChanged(textAlign, _cells, _headerCell, _footerCell)",
      "_orderChanged(_order, _headerCell, _footerCell, _cells)",
      "_lastFrozenChanged(_lastFrozen)",
      "_firstFrozenToEndChanged(_firstFrozenToEnd)",
      "_onRendererOrBindingChanged(_renderer, _cells, _bodyContentHidden, path)",
      "_onHeaderRendererOrBindingChanged(_headerRenderer, _headerCell, path, header)",
      "_onFooterRendererOrBindingChanged(_footerRenderer, _footerCell)",
      "_resizableChanged(resizable, _headerCell)",
      "_reorderStatusChanged(_reorderStatus, _headerCell, _footerCell, _cells)",
      "_hiddenChanged(hidden, _headerCell, _footerCell, _cells)",
      "_rowHeaderChanged(rowHeader, _cells)",
      "__headerFooterPartNameChanged(_headerCell, _footerCell, headerPartName, footerPartName)"
    ];
  }
  /**
   * @return {!Grid | undefined}
   * @protected
   */
  get _grid() {
    if (!this._gridValue) {
      this._gridValue = this._findHostGrid();
    }
    return this._gridValue;
  }
  /**
   * @return {!Array<!HTMLElement>}
   * @protected
   */
  get _allCells() {
    return [].concat(this._cells || []).concat(this._emptyCells || []).concat(this._headerCell).concat(this._footerCell).filter((cell) => cell);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    requestAnimationFrame(() => {
      if (!this._grid) {
        return;
      }
      this._allCells.forEach((cell) => {
        if (!cell._content.parentNode) {
          this._grid.appendChild(cell._content);
        }
      });
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    requestAnimationFrame(() => {
      if (this._grid) {
        return;
      }
      this._allCells.forEach((cell) => {
        if (cell._content.parentNode) {
          cell._content.parentNode.removeChild(cell._content);
        }
      });
    });
    this._gridValue = void 0;
  }
  /** @protected */
  ready() {
    super.ready();
    processTemplates(this);
  }
  /**
   * @return {!Grid | undefined}
   * @protected
   */
  _findHostGrid() {
    let el = this;
    while (el && !/^vaadin.*grid(-pro)?$/u.test(el.localName)) {
      el = el.assignedSlot ? el.assignedSlot.parentNode : el.parentNode;
    }
    return el || void 0;
  }
  /** @protected */
  _renderHeaderAndFooter() {
    this._renderHeaderCellContent(this._headerRenderer, this._headerCell);
    this._renderFooterCellContent(this._footerRenderer, this._footerCell);
  }
  /** @private */
  _flexGrowChanged(flexGrow) {
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._columnPropChanged("flexGrow");
    }
    this._allCells.forEach((cell) => {
      cell.style.flexGrow = flexGrow;
    });
  }
  /** @private */
  _orderChanged(order) {
    this._allCells.forEach((cell) => {
      cell.style.order = order;
    });
  }
  /** @private */
  _widthChanged(width) {
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._columnPropChanged("width");
    }
    this._allCells.forEach((cell) => {
      cell.style.width = width;
    });
  }
  /** @private */
  _frozenChanged(frozen) {
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._columnPropChanged("frozen", frozen);
    }
    this._allCells.forEach((cell) => {
      updateCellState(cell, "frozen", frozen);
    });
    if (this._grid && this._grid._frozenCellsChanged) {
      this._grid._frozenCellsChanged();
    }
  }
  /** @private */
  _frozenToEndChanged(frozenToEnd) {
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._columnPropChanged("frozenToEnd", frozenToEnd);
    }
    this._allCells.forEach((cell) => {
      if (this._grid && cell.parentElement === this._grid.$.sizer) {
        return;
      }
      updateCellState(cell, "frozen-to-end", frozenToEnd);
    });
    if (this._grid && this._grid._frozenCellsChanged) {
      this._grid._frozenCellsChanged();
    }
  }
  /** @private */
  _lastFrozenChanged(lastFrozen) {
    this._allCells.forEach((cell) => {
      updateCellState(cell, "last-frozen", lastFrozen);
    });
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._lastFrozen = lastFrozen;
    }
  }
  /** @private */
  _firstFrozenToEndChanged(firstFrozenToEnd) {
    this._allCells.forEach((cell) => {
      if (this._grid && cell.parentElement === this._grid.$.sizer) {
        return;
      }
      updateCellState(cell, "first-frozen-to-end", firstFrozenToEnd);
    });
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._firstFrozenToEnd = firstFrozenToEnd;
    }
  }
  /** @private */
  _rowHeaderChanged(rowHeader, cells) {
    if (!cells) {
      return;
    }
    cells.forEach((cell) => {
      cell.setAttribute("role", rowHeader ? "rowheader" : "gridcell");
    });
  }
  /**
   * @param {string} path
   * @return {string}
   * @protected
   */
  _generateHeader(path) {
    return path.substr(path.lastIndexOf(".") + 1).replace(/([A-Z])/gu, "-$1").toLowerCase().replace(/-/gu, " ").replace(/^./u, (match2) => match2.toUpperCase());
  }
  /** @private */
  _reorderStatusChanged(reorderStatus) {
    const prevStatus = this.__previousReorderStatus;
    const oldPart = prevStatus ? `reorder-${prevStatus}-cell` : "";
    const newPart = `reorder-${reorderStatus}-cell`;
    this._allCells.forEach((cell) => {
      updateCellState(cell, "reorder-status", reorderStatus, newPart, oldPart);
    });
    this.__previousReorderStatus = reorderStatus;
  }
  /** @private */
  _resizableChanged(resizable, headerCell) {
    if (resizable === void 0 || headerCell === void 0) {
      return;
    }
    if (headerCell) {
      [headerCell].concat(this._emptyCells).forEach((cell) => {
        if (cell) {
          const existingHandle = cell.querySelector('[part~="resize-handle"]');
          if (existingHandle) {
            cell.removeChild(existingHandle);
          }
          if (resizable) {
            const handle = document.createElement("div");
            handle.setAttribute("part", "resize-handle");
            cell.appendChild(handle);
          }
        }
      });
    }
  }
  /** @private */
  _textAlignChanged(textAlign) {
    if (textAlign === void 0 || this._grid === void 0) {
      return;
    }
    if (["start", "end", "center"].indexOf(textAlign) === -1) {
      console.warn('textAlign can only be set as "start", "end" or "center"');
      return;
    }
    let textAlignFallback;
    if (getComputedStyle(this._grid).direction === "ltr") {
      if (textAlign === "start") {
        textAlignFallback = "left";
      } else if (textAlign === "end") {
        textAlignFallback = "right";
      }
    } else if (textAlign === "start") {
      textAlignFallback = "right";
    } else if (textAlign === "end") {
      textAlignFallback = "left";
    }
    this._allCells.forEach((cell) => {
      cell._content.style.textAlign = textAlign;
      if (getComputedStyle(cell._content).textAlign !== textAlign) {
        cell._content.style.textAlign = textAlignFallback;
      }
    });
  }
  /** @private */
  _hiddenChanged(hidden) {
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._columnPropChanged("hidden", hidden);
    }
    if (!!hidden !== !!this._previousHidden && this._grid) {
      if (hidden === true) {
        this._allCells.forEach((cell) => {
          if (cell._content.parentNode) {
            cell._content.parentNode.removeChild(cell._content);
          }
        });
      }
      this._grid._debouncerHiddenChanged = Debouncer$1.debounce(
        this._grid._debouncerHiddenChanged,
        animationFrame,
        () => {
          if (this._grid && this._grid._renderColumnTree) {
            this._grid._renderColumnTree(this._grid._columnTree);
          }
        }
      );
      if (this._grid._debounceUpdateFrozenColumn) {
        this._grid._debounceUpdateFrozenColumn();
      }
      if (this._grid._resetKeyboardNavigation) {
        this._grid._resetKeyboardNavigation();
      }
    }
    this._previousHidden = hidden;
  }
  /** @protected */
  _runRenderer(renderer, cell, model) {
    const isVisibleBodyCell = model && model.item && !cell.parentElement.hidden;
    const shouldRender = isVisibleBodyCell || renderer === this._headerRenderer || renderer === this._footerRenderer;
    if (!shouldRender) {
      return;
    }
    const args = [cell._content, this];
    if (isVisibleBodyCell) {
      args.push(model);
    }
    renderer.apply(this, args);
  }
  /**
   * Renders the content to the given cells using a renderer.
   *
   * @private
   */
  __renderCellsContent(renderer, cells) {
    if (this.hidden || !this._grid) {
      return;
    }
    cells.forEach((cell) => {
      if (!cell.parentElement) {
        return;
      }
      const model = this._grid.__getRowModel(cell.parentElement);
      if (!renderer) {
        return;
      }
      if (cell._renderer !== renderer) {
        this._clearCellContent(cell);
      }
      cell._renderer = renderer;
      this._runRenderer(renderer, cell, model);
    });
  }
  /**
   * Clears the content of a cell.
   *
   * @protected
   */
  _clearCellContent(cell) {
    cell._content.innerHTML = "";
    delete cell._content._$litPart$;
  }
  /**
   * Renders the header cell content using a renderer,
   * and then updates the visibility of the parent row depending on
   * whether all its children cells are empty or not.
   *
   * @protected
   */
  _renderHeaderCellContent(headerRenderer, headerCell) {
    if (!headerCell || !headerRenderer) {
      return;
    }
    this.__renderCellsContent(headerRenderer, [headerCell]);
    if (this._grid && headerCell.parentElement) {
      this._grid.__debounceUpdateHeaderFooterRowVisibility(headerCell.parentElement);
    }
  }
  /** @protected */
  _onHeaderRendererOrBindingChanged(headerRenderer, headerCell, ..._bindings) {
    this._renderHeaderCellContent(headerRenderer, headerCell);
  }
  /** @private */
  __headerFooterPartNameChanged(headerCell, footerCell, headerPartName, footerPartName) {
    [
      { cell: headerCell, partName: headerPartName },
      { cell: footerCell, partName: footerPartName }
    ].forEach(({ cell, partName }) => {
      if (cell) {
        const customParts = cell.__customParts || [];
        cell.part.remove(...customParts);
        cell.__customParts = partName ? partName.trim().split(" ") : [];
        cell.part.add(...cell.__customParts);
      }
    });
  }
  /**
   * Renders the content of body cells using a renderer.
   *
   * @protected
   */
  _renderBodyCellsContent(renderer, cells) {
    if (!cells || !renderer) {
      return;
    }
    this.__renderCellsContent(renderer, cells);
  }
  /** @protected */
  _onRendererOrBindingChanged(renderer, cells, ..._bindings) {
    this._renderBodyCellsContent(renderer, cells);
  }
  /**
   * Renders the footer cell content using a renderer
   * and then updates the visibility of the parent row depending on
   * whether all its children cells are empty or not.
   *
   * @protected
   */
  _renderFooterCellContent(footerRenderer, footerCell) {
    if (!footerCell || !footerRenderer) {
      return;
    }
    this.__renderCellsContent(footerRenderer, [footerCell]);
    if (this._grid && footerCell.parentElement) {
      this._grid.__debounceUpdateHeaderFooterRowVisibility(footerCell.parentElement);
    }
  }
  /** @protected */
  _onFooterRendererOrBindingChanged(footerRenderer, footerCell) {
    this._renderFooterCellContent(footerRenderer, footerCell);
  }
  /** @private */
  __setTextContent(node, textContent) {
    if (node.textContent !== textContent) {
      node.textContent = textContent;
    }
  }
  /**
   * Renders the text header to the header cell.
   *
   * @private
   */
  __textHeaderRenderer() {
    this.__setTextContent(this._headerCell._content, this.header);
  }
  /**
   * Computes the property name based on the path and renders it to the header cell.
   * If the path is not defined, then nothing is rendered.
   *
   * @protected
   */
  _defaultHeaderRenderer() {
    if (!this.path) {
      return;
    }
    this.__setTextContent(this._headerCell._content, this._generateHeader(this.path));
  }
  /**
   * Computes the item property value based on the path and renders it to the body cell.
   * If the path is not defined, then nothing is rendered.
   *
   * @protected
   */
  _defaultRenderer(root2, _owner, { item: item2 }) {
    if (!this.path) {
      return;
    }
    this.__setTextContent(root2, get$1(this.path, item2));
  }
  /**
   * By default, nothing is rendered to the footer cell.
   *
   * @protected
   */
  _defaultFooterRenderer() {
  }
  /**
   * Computes the final header renderer for the `_headerRenderer` computed property.
   * All the arguments are observable by the Polymer, it re-calls the method
   * once an argument is changed to update the property value.
   *
   * @protected
   * @return {GridHeaderFooterRenderer | undefined}
   */
  _computeHeaderRenderer(headerRenderer, header) {
    if (headerRenderer) {
      return headerRenderer;
    }
    if (header !== void 0 && header !== null) {
      return this.__textHeaderRenderer;
    }
    return this._defaultHeaderRenderer;
  }
  /**
   * Computes the final renderer for the `_renderer` property.
   * All the arguments are observable by the Polymer, it re-calls the method
   * once an argument is changed to update the property value.
   *
   * @protected
   * @return {GridBodyRenderer | undefined}
   */
  _computeRenderer(renderer) {
    if (renderer) {
      return renderer;
    }
    return this._defaultRenderer;
  }
  /**
   * Computes the final footer renderer for the `_footerRenderer` property.
   * All the arguments are observable by the Polymer, it re-calls the method
   * once an argument is changed to update the property value.
   *
   * @protected
   * @return {GridHeaderFooterRenderer | undefined}
   */
  _computeFooterRenderer(footerRenderer) {
    if (footerRenderer) {
      return footerRenderer;
    }
    return this._defaultFooterRenderer;
  }
};
const GridColumnMixin = (superClass) => class extends ColumnBaseMixin(DirMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Width of the cells for this column.
       *
       * Please note that using the `em` length unit is discouraged as
       * it might lead to misalignment issues if the header, body, and footer
       * cells have different font sizes. Instead, use `rem` if you need
       * a length unit relative to the font size.
       */
      width: {
        type: String,
        value: "100px",
        sync: true
      },
      /**
       * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.
       * @attr {number} flex-grow
       * @type {number}
       */
      flexGrow: {
        type: Number,
        value: 1,
        sync: true
      },
      /**
       * Custom function for rendering the cell content.
       * Receives three arguments:
       *
       * - `root` The cell content DOM element. Append your content to it.
       * - `column` The `<vaadin-grid-column>` element.
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *   - `model.detailsOpened` Details opened state.
       *
       * @type {GridBodyRenderer | null | undefined}
       */
      renderer: {
        type: Function,
        sync: true
      },
      /**
       * Represents the final renderer computed on the set of observable arguments.
       * It is supposed to be used internally when rendering the content of a body cell.
       *
       * @protected
       * @type {GridBodyRenderer | undefined}
       */
      _renderer: {
        type: Function,
        computed: "_computeRenderer(renderer, __initialized)",
        sync: true
      },
      /**
       * Path to an item sub-property whose value gets displayed in the column body cells.
       * The property name is also shown in the column header if an explicit header or renderer isn't defined.
       */
      path: {
        type: String,
        sync: true
      },
      /**
       * Automatically sets the width of the column based on the column contents when this is set to `true`.
       *
       * For performance reasons the column width is calculated automatically only once when the grid items
       * are rendered for the first time and the calculation only considers the rows which are currently
       * rendered in DOM (a bit more than what is currently visible). If the grid is scrolled, or the cell
       * content changes, the column width might not match the contents anymore.
       *
       * Hidden columns are ignored in the calculation and their widths are not automatically updated when
       * you show a column that was initially hidden.
       *
       * You can manually trigger the auto sizing behavior again by calling `grid.recalculateColumnWidths()`.
       *
       * The column width may still grow larger when `flexGrow` is not 0.
       * @attr {boolean} auto-width
       * @type {boolean}
       */
      autoWidth: {
        type: Boolean,
        value: false
      },
      /**
       * When true, wraps the cell's slot into an element with role="button", and sets
       * the tabindex attribute on the button element, instead of the cell itself.
       * This is needed to keep focus in sync with VoiceOver cursor when navigating
       * with Control + Option + arrow keys: focusing the `<td>` element does not fire
       * a focus event, but focusing an element with role="button" inside a cell fires it.
       * @protected
       */
      _focusButtonMode: {
        type: Boolean,
        value: false
      },
      /**
       * @type {Array<!HTMLElement>}
       * @protected
       */
      _cells: {
        type: Array,
        sync: true
      }
    };
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const GridColumnGroupMixin = (superClass) => class extends ColumnBaseMixin(superClass) {
  static get properties() {
    return {
      /** @private */
      _childColumns: {
        value() {
          return this._getChildColumns(this);
        }
      },
      /**
       * Flex grow ratio for the column group as the sum of the ratios of its child columns.
       * @attr {number} flex-grow
       */
      flexGrow: {
        type: Number,
        readOnly: true,
        sync: true
      },
      /**
       * Width of the column group as the sum of the widths of its child columns.
       */
      width: {
        type: String,
        readOnly: true
      },
      /** @private */
      _visibleChildColumns: Array,
      /** @private */
      _colSpan: Number,
      /** @private */
      _rootColumns: Array
    };
  }
  static get observers() {
    return [
      "_groupFrozenChanged(frozen, _rootColumns)",
      "_groupFrozenToEndChanged(frozenToEnd, _rootColumns)",
      "_groupHiddenChanged(hidden)",
      "_colSpanChanged(_colSpan, _headerCell, _footerCell)",
      "_groupOrderChanged(_order, _rootColumns)",
      "_groupReorderStatusChanged(_reorderStatus, _rootColumns)",
      "_groupResizableChanged(resizable, _rootColumns)"
    ];
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this._addNodeObserver();
    this._updateFlexAndWidth();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this._observer) {
      this._observer.disconnect();
    }
  }
  /**
   * @param {string} path
   * @param {unknown=} value
   * @protected
   */
  _columnPropChanged(path, value) {
    if (path === "hidden") {
      this._preventHiddenSynchronization = true;
      this._updateVisibleChildColumns(this._childColumns);
      this._preventHiddenSynchronization = false;
    }
    if (/flexGrow|width|hidden|_childColumns/u.test(path)) {
      this._updateFlexAndWidth();
    }
    if (path === "frozen" && !this.frozen) {
      this.frozen = value;
    }
    if (path === "lastFrozen" && !this._lastFrozen) {
      this._lastFrozen = value;
    }
    if (path === "frozenToEnd" && !this.frozenToEnd) {
      this.frozenToEnd = value;
    }
    if (path === "firstFrozenToEnd" && !this._firstFrozenToEnd) {
      this._firstFrozenToEnd = value;
    }
  }
  /** @private */
  _groupOrderChanged(order, rootColumns) {
    if (rootColumns) {
      const _rootColumns = rootColumns.slice(0);
      if (!order) {
        _rootColumns.forEach((column) => {
          column._order = 0;
        });
        return;
      }
      const trailingZeros = /(0+)$/u.exec(order).pop().length;
      const childCountDigits = ~~(Math.log(rootColumns.length) / Math.LN10) + 1;
      const scope = 10 ** (trailingZeros - childCountDigits);
      if (_rootColumns[0] && _rootColumns[0]._order) {
        _rootColumns.sort((a3, b2) => a3._order - b2._order);
      }
      updateColumnOrders(_rootColumns, scope, order);
    }
  }
  /** @private */
  _groupReorderStatusChanged(reorderStatus, rootColumns) {
    if (reorderStatus === void 0 || rootColumns === void 0) {
      return;
    }
    rootColumns.forEach((column) => {
      column._reorderStatus = reorderStatus;
    });
  }
  /** @private */
  _groupResizableChanged(resizable, rootColumns) {
    if (resizable === void 0 || rootColumns === void 0) {
      return;
    }
    rootColumns.forEach((column) => {
      column.resizable = resizable;
    });
  }
  /** @private */
  _updateVisibleChildColumns(childColumns) {
    this._visibleChildColumns = Array.prototype.filter.call(childColumns, (col) => !col.hidden);
    this._colSpan = this._visibleChildColumns.length;
    this._updateAutoHidden();
  }
  /** @protected */
  _updateFlexAndWidth() {
    if (!this._visibleChildColumns) {
      return;
    }
    if (this._visibleChildColumns.length > 0) {
      const width = this._visibleChildColumns.reduce((prev, curr) => {
        prev += ` + ${(curr.width || "0px").replace("calc", "")}`;
        return prev;
      }, "").substring(3);
      this._setWidth(`calc(${width})`);
    } else {
      this._setWidth("0px");
    }
    this._setFlexGrow(
      Array.prototype.reduce.call(this._visibleChildColumns, (prev, curr) => prev + curr.flexGrow, 0)
    );
  }
  /**
   * This method is called before the group's frozen value is being propagated to the child columns.
   * In case some of the child columns are frozen, while others are not, the non-frozen ones
   * will get automatically frozen as well. As this may sometimes be unintended, this method
   * shows a warning in the console in such cases.
   * @private
   */
  __scheduleAutoFreezeWarning(columns, frozenProp) {
    if (this._grid) {
      const frozenAttr = frozenProp.replace(/([A-Z])/gu, "-$1").toLowerCase();
      const firstColumnFrozen = columns[0][frozenProp] || columns[0].hasAttribute(frozenAttr);
      const allSameFrozen = columns.every((column) => {
        return (column[frozenProp] || column.hasAttribute(frozenAttr)) === firstColumnFrozen;
      });
      if (!allSameFrozen) {
        this._grid.__autoFreezeWarningDebouncer = Debouncer$1.debounce(
          this._grid.__autoFreezeWarningDebouncer,
          animationFrame,
          () => {
            console.warn(
              `WARNING: Joining ${frozenProp} and non-${frozenProp} Grid columns inside the same column group! This will automatically freeze all the joined columns to avoid rendering issues. If this was intentional, consider marking each joined column explicitly as ${frozenProp}. Otherwise, exclude the ${frozenProp} columns from the joined group.`
            );
          }
        );
      }
    }
  }
  /** @private */
  _groupFrozenChanged(frozen, rootColumns) {
    if (rootColumns === void 0 || frozen === void 0) {
      return;
    }
    if (frozen !== false) {
      this.__scheduleAutoFreezeWarning(rootColumns, "frozen");
      Array.from(rootColumns).forEach((col) => {
        col.frozen = frozen;
      });
    }
  }
  /** @private */
  _groupFrozenToEndChanged(frozenToEnd, rootColumns) {
    if (rootColumns === void 0 || frozenToEnd === void 0) {
      return;
    }
    if (frozenToEnd !== false) {
      this.__scheduleAutoFreezeWarning(rootColumns, "frozenToEnd");
      Array.from(rootColumns).forEach((col) => {
        col.frozenToEnd = frozenToEnd;
      });
    }
  }
  /** @private */
  _groupHiddenChanged(hidden) {
    if (hidden || this.__groupHiddenInitialized) {
      this._synchronizeHidden();
    }
    this.__groupHiddenInitialized = true;
  }
  /** @private */
  _updateAutoHidden() {
    const wasAutoHidden = this._autoHidden;
    this._autoHidden = (this._visibleChildColumns || []).length === 0;
    if (wasAutoHidden || this._autoHidden) {
      this.hidden = this._autoHidden;
    }
  }
  /** @private */
  _synchronizeHidden() {
    if (this._childColumns && !this._preventHiddenSynchronization) {
      this._childColumns.forEach((column) => {
        column.hidden = this.hidden;
      });
    }
  }
  /** @private */
  _colSpanChanged(colSpan, headerCell, footerCell) {
    if (headerCell) {
      headerCell.setAttribute("colspan", colSpan);
      if (this._grid) {
        this._grid._a11yUpdateCellColspan(headerCell, colSpan);
      }
    }
    if (footerCell) {
      footerCell.setAttribute("colspan", colSpan);
      if (this._grid) {
        this._grid._a11yUpdateCellColspan(footerCell, colSpan);
      }
    }
  }
  /**
   * @param {!GridColumnGroup} el
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getChildColumns(el) {
    return ColumnObserver.getColumns(el);
  }
  /** @private */
  _addNodeObserver() {
    this._observer = new ColumnObserver(this, () => {
      this._preventHiddenSynchronization = true;
      this._rootColumns = this._getChildColumns(this);
      this._childColumns = this._rootColumns;
      this._updateVisibleChildColumns(this._childColumns);
      this._preventHiddenSynchronization = false;
      if (this._grid && this._grid._debounceUpdateColumnTree) {
        this._grid._debounceUpdateColumnTree();
      }
    });
    this._observer.flush();
  }
  /**
   * @param {!Node} node
   * @return {boolean}
   * @protected
   */
  _isColumnElement(node) {
    return node.nodeType === Node.ELEMENT_NODE && /\bcolumn\b/u.test(node.localName);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class GridColumnGroup extends GridColumnGroupMixin(PolymerElement) {
  static get is() {
    return "vaadin-grid-column-group";
  }
}
defineCustomElement(GridColumnGroup);
registerStyles$1(
  "vaadin-grid",
  css`
    :host {
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      line-height: var(--lumo-line-height-s);
      color: var(--lumo-body-text-color);
      background-color: var(--lumo-base-color);
      box-sizing: border-box;
      -webkit-text-size-adjust: 100%;
      -webkit-tap-highlight-color: transparent;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      /* For internal use only */
      --_lumo-grid-border-color: var(--lumo-contrast-20pct);
      --_lumo-grid-secondary-border-color: var(--lumo-contrast-10pct);
      --_lumo-grid-border-width: 1px;
      --_lumo-grid-selected-row-color: var(--lumo-primary-color-10pct);
    }

    /* No (outer) border */

    :host(:not([theme~='no-border'])) {
      border: var(--_lumo-grid-border-width) solid var(--_lumo-grid-border-color);
    }

    :host([disabled]) {
      opacity: 0.7;
    }

    /* Cell styles */

    [part~='cell'] {
      min-height: var(--lumo-size-m);
      background-color: var(--vaadin-grid-cell-background, var(--lumo-base-color));
      cursor: default;
      --_cell-padding: var(--vaadin-grid-cell-padding, var(--_cell-default-padding));
      --_cell-default-padding: var(--lumo-space-xs) var(--lumo-space-m);
    }

    [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      cursor: inherit;
      padding: var(--_cell-padding);
    }

    /* Apply row borders by default and introduce the "no-row-borders" variant */
    :host(:not([theme~='no-row-borders'])) [part~='cell']:not([part~='details-cell']) {
      border-top: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);
    }

    /* Hide first body row top border */
    :host(:not([theme~='no-row-borders'])) [part~='first-row'] [part~='cell']:not([part~='details-cell']) {
      border-top: 0;
      min-height: calc(var(--lumo-size-m) - var(--_lumo-grid-border-width));
    }

    /* Focus-ring */

    [part~='row'] {
      position: relative;
    }

    [part~='row']:focus,
    [part~='focused-cell']:focus {
      outline: none;
    }

    :host([navigating]) [part~='row']:focus::before,
    :host([navigating]) [part~='focused-cell']:focus::before {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }

    :host([navigating]) [part~='row']:focus::before {
      transform: translateX(calc(-1 * var(--_grid-horizontal-scroll-position)));
      z-index: 3;
    }

    /* Empty state */
    [part~='empty-state'] {
      padding: var(--lumo-space-m);
      color: var(--lumo-secondary-text-color);
    }

    /* Drag and Drop styles */
    :host([dragover])::after {
      content: '';
      position: absolute;
      z-index: 100;
      inset: 0;
      pointer-events: none;
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }

    [part~='row'][dragover] {
      z-index: 100 !important;
    }

    [part~='row'][dragover] [part~='cell'] {
      overflow: visible;
    }

    [part~='row'][dragover] [part~='cell']::after {
      content: '';
      position: absolute;
      inset: 0;
      height: calc(var(--_lumo-grid-border-width) + 2px);
      pointer-events: none;
      background: var(--lumo-primary-color-50pct);
    }

    [part~='row'][dragover] [part~='cell'][last-frozen]::after {
      right: -1px;
    }

    :host([theme~='no-row-borders']) [dragover] [part~='cell']::after {
      height: 2px;
    }

    [part~='row'][dragover='below'] [part~='cell']::after {
      top: 100%;
      bottom: auto;
      margin-top: -1px;
    }

    :host([all-rows-visible]) [part~='last-row'][dragover='below'] [part~='cell']::after {
      height: 1px;
    }

    [part~='row'][dragover='above'] [part~='cell']::after {
      top: auto;
      bottom: 100%;
      margin-bottom: -1px;
    }

    [part~='row'][details-opened][dragover='below'] [part~='cell']:not([part~='details-cell'])::after,
    [part~='row'][details-opened][dragover='above'] [part~='details-cell']::after {
      display: none;
    }

    [part~='row'][dragover][dragover='on-top'] [part~='cell']::after {
      height: 100%;
      opacity: 0.5;
    }

    [part~='row'][dragstart] [part~='cell'] {
      border: none !important;
      box-shadow: none !important;
    }

    [part~='row'][dragstart] [part~='cell'][last-column] {
      border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;
    }

    [part~='row'][dragstart] [part~='cell'][first-column] {
      border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);
    }

    #scroller [part~='row'][dragstart]:not([dragstart=''])::after {
      display: block;
      position: absolute;
      left: var(--_grid-drag-start-x);
      top: var(--_grid-drag-start-y);
      z-index: 100;
      content: attr(dragstart);
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      padding: calc(var(--lumo-space-xs) * 0.8);
      color: var(--lumo-error-contrast-color);
      background-color: var(--lumo-error-color);
      border-radius: var(--lumo-border-radius-m);
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-xxs);
      line-height: 1;
      font-weight: 500;
      text-transform: initial;
      letter-spacing: initial;
      min-width: calc(var(--lumo-size-s) * 0.7);
      text-align: center;
    }

    /* Headers and footers */

    [part~='header-cell'],
    [part~='footer-cell'],
    [part~='reorder-ghost'] {
      font-size: var(--lumo-font-size-s);
      font-weight: 500;
    }

    [part~='footer-cell'] {
      font-weight: 400;
    }

    [part~='row']:only-child [part~='header-cell'] {
      min-height: var(--lumo-size-xl);
    }

    /* Header borders */

    /* Hide first header row top border */
    :host(:not([theme~='no-row-borders'])) [part~='row']:first-child [part~='header-cell'] {
      border-top: 0;
    }

    /* Hide header row top border if previous row is hidden */
    [part~='row'][hidden] + [part~='row'] [part~='header-cell'] {
      border-top: 0;
    }

    [part~='row']:last-child [part~='header-cell'] {
      border-bottom: var(--_lumo-grid-border-width) solid transparent;
    }

    :host(:not([theme~='no-row-borders'])) [part~='row']:last-child [part~='header-cell'] {
      border-bottom-color: var(--_lumo-grid-secondary-border-color);
    }

    /* Overflow uses a stronger border color */
    :host([overflow~='top']) [part~='row']:last-child [part~='header-cell'] {
      border-bottom-color: var(--_lumo-grid-border-color);
    }

    /* Footer borders */

    [part~='row']:first-child [part~='footer-cell'] {
      border-top: var(--_lumo-grid-border-width) solid transparent;
    }

    :host(:not([theme~='no-row-borders'])) [part~='row']:first-child [part~='footer-cell'] {
      border-top-color: var(--_lumo-grid-secondary-border-color);
    }

    /* Overflow uses a stronger border color */
    :host([overflow~='bottom']) [part~='row']:first-child [part~='footer-cell'] {
      border-top-color: var(--_lumo-grid-border-color);
    }

    /* Column reordering */

    :host([reordering]) [part~='cell'] {
      background: linear-gradient(var(--lumo-shade-20pct), var(--lumo-shade-20pct)) var(--lumo-base-color);
    }

    :host([reordering]) [part~='cell'][reorder-status='allowed'] {
      background: var(--lumo-base-color);
    }

    :host([reordering]) [part~='cell'][reorder-status='dragging'] {
      background: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct)) var(--lumo-base-color);
    }

    [part~='reorder-ghost'] {
      opacity: 0.85;
      box-shadow: var(--lumo-box-shadow-s);
      /* TODO Use the same styles as for the cell element (reorder-ghost copies styles from the cell element) */
      padding: var(--lumo-space-s) var(--lumo-space-m) !important;
    }

    /* Column resizing */

    [part='resize-handle'] {
      --_resize-handle-width: 3px;
      width: var(--_resize-handle-width);
      background-color: var(--lumo-primary-color-50pct);
      opacity: 0;
      transition: opacity 0.2s;
    }

    [part='resize-handle']::before {
      transform: translateX(calc(-50% + var(--_resize-handle-width) / 2));
      width: var(--lumo-size-s);
    }

    :host(:not([reordering])) *:not([column-resizing]) [part~='cell']:hover [part='resize-handle'],
    [part='resize-handle']:active {
      opacity: 1;
      transition-delay: 0.15s;
    }

    /* Column borders */

    :host([theme~='column-borders']) [part~='cell']:not([last-column]):not([part~='details-cell']) {
      border-right: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);
    }

    /* Frozen columns */

    [last-frozen] {
      border-right: var(--_lumo-grid-border-width) solid transparent;
      overflow: hidden;
    }

    :host([overflow~='start']) [part~='cell'][last-frozen]:not([part~='details-cell']) {
      border-right-color: var(--_lumo-grid-border-color);
    }

    [first-frozen-to-end] {
      border-left: var(--_lumo-grid-border-width) solid transparent;
    }

    :host([overflow~='end']) [part~='cell'][first-frozen-to-end]:not([part~='details-cell']) {
      border-left-color: var(--_lumo-grid-border-color);
    }

    /* Row stripes */

    :host([theme~='row-stripes']) [part~='even-row'] [part~='body-cell'],
    :host([theme~='row-stripes']) [part~='even-row'] [part~='details-cell'] {
      background-image: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
      background-repeat: repeat-x;
    }

    /* Selected row */

    /* Raise the selected rows above unselected rows (so that box-shadow can cover unselected rows) */
    :host(:not([reordering])) [part~='row'][selected] {
      z-index: 1;
    }

    :host(:not([reordering])) [part~='row'][selected] [part~='body-cell']:not([part~='details-cell']) {
      background-image: linear-gradient(var(--_lumo-grid-selected-row-color), var(--_lumo-grid-selected-row-color));
      background-repeat: repeat;
    }

    /* Cover the border of an unselected row */
    :host(:not([theme~='no-row-borders'])) [part~='row'][selected] [part~='cell']:not([part~='details-cell']) {
      box-shadow: 0 var(--_lumo-grid-border-width) 0 0 var(--_lumo-grid-selected-row-color);
    }

    /* Compact */

    :host([theme~='compact']) [part~='row']:only-child [part~='header-cell'] {
      min-height: var(--lumo-size-m);
    }

    :host([theme~='compact']) [part~='cell'] {
      min-height: var(--lumo-size-s);
      --_cell-default-padding: var(--lumo-space-xs) var(--lumo-space-s);
    }

    :host([theme~='compact']) [part~='first-row'] [part~='cell']:not([part~='details-cell']) {
      min-height: calc(var(--lumo-size-s) - var(--_lumo-grid-border-width));
    }

    :host([theme~='compact']) [part~='empty-state'] {
      padding: var(--lumo-space-s);
    }

    /* Wrap cell contents */

    :host([theme~='wrap-cell-content']) [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      white-space: normal;
    }

    /* RTL specific styles */

    :host([dir='rtl']) [part~='row'][dragstart] [part~='cell'][last-column] {
      border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);
    }

    :host([dir='rtl']) [part~='row'][dragstart] [part~='cell'][first-column] {
      border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;
    }

    :host([dir='rtl'][theme~='column-borders']) [part~='cell']:not([last-column]):not([part~='details-cell']) {
      border-right: none;
      border-left: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);
    }

    :host([dir='rtl']) [last-frozen] {
      border-right: none;
      border-left: var(--_lumo-grid-border-width) solid transparent;
    }

    :host([dir='rtl']) [first-frozen-to-end] {
      border-left: none;
      border-right: var(--_lumo-grid-border-width) solid transparent;
    }

    :host([dir='rtl'][overflow~='start']) [part~='cell'][last-frozen]:not([part~='details-cell']) {
      border-left-color: var(--_lumo-grid-border-color);
    }

    :host([dir='rtl'][overflow~='end']) [part~='cell'][first-frozen-to-end]:not([part~='details-cell']) {
      border-right-color: var(--_lumo-grid-border-color);
    }
  `,
  { moduleId: "lumo-grid" }
);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class GridColumn extends GridColumnMixin(PolymerElement) {
  static get is() {
    return "vaadin-grid-column";
  }
}
defineCustomElement(GridColumn);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const A11yMixin = (superClass) => class A11yMixin extends superClass {
  static get properties() {
    return {
      /**
       * String used to label the grid to screen reader users.
       * @attr {string} accessible-name
       */
      accessibleName: {
        type: String
      }
    };
  }
  static get observers() {
    return ["_a11yUpdateGridSize(size, _columnTree)"];
  }
  /** @private */
  _a11yGetHeaderRowCount(_columnTree) {
    return _columnTree.filter(
      (level) => level.some((col) => col.headerRenderer || col.path && col.header !== null || col.header)
    ).length;
  }
  /** @private */
  _a11yGetFooterRowCount(_columnTree) {
    return _columnTree.filter((level) => level.some((col) => col.headerRenderer)).length;
  }
  /** @private */
  _a11yUpdateGridSize(size, _columnTree) {
    if (size === void 0 || _columnTree === void 0) {
      return;
    }
    const bodyColumns = _columnTree[_columnTree.length - 1];
    this.$.table.setAttribute(
      "aria-rowcount",
      size + this._a11yGetHeaderRowCount(_columnTree) + this._a11yGetFooterRowCount(_columnTree)
    );
    this.$.table.setAttribute("aria-colcount", bodyColumns && bodyColumns.length || 0);
    this._a11yUpdateHeaderRows();
    this._a11yUpdateFooterRows();
  }
  /** @protected */
  _a11yUpdateHeaderRows() {
    iterateChildren(this.$.header, (headerRow, index) => {
      headerRow.setAttribute("aria-rowindex", index + 1);
    });
  }
  /** @protected */
  _a11yUpdateFooterRows() {
    iterateChildren(this.$.footer, (footerRow, index) => {
      footerRow.setAttribute("aria-rowindex", this._a11yGetHeaderRowCount(this._columnTree) + this.size + index + 1);
    });
  }
  /**
   * @param {!HTMLElement} row
   * @param {number} index
   * @protected
   */
  _a11yUpdateRowRowindex(row, index) {
    row.setAttribute("aria-rowindex", index + this._a11yGetHeaderRowCount(this._columnTree) + 1);
  }
  /**
   * @param {!HTMLElement} row
   * @param {boolean} selected
   * @protected
   */
  _a11yUpdateRowSelected(row, selected) {
    row.setAttribute("aria-selected", Boolean(selected));
    iterateRowCells(row, (cell) => {
      cell.setAttribute("aria-selected", Boolean(selected));
    });
  }
  /**
   * @param {!HTMLElement} row
   * @protected
   */
  _a11yUpdateRowExpanded(row) {
    if (this.__isRowExpandable(row)) {
      row.setAttribute("aria-expanded", "false");
    } else if (this.__isRowCollapsible(row)) {
      row.setAttribute("aria-expanded", "true");
    } else {
      row.removeAttribute("aria-expanded");
    }
  }
  /**
   * @param {!HTMLElement} row
   * @param {number} level
   * @protected
   */
  _a11yUpdateRowLevel(row, level) {
    if (level > 0 || this.__isRowCollapsible(row) || this.__isRowExpandable(row)) {
      row.setAttribute("aria-level", level + 1);
    } else {
      row.removeAttribute("aria-level");
    }
  }
  /**
   * @param {!HTMLElement} row
   * @param {!HTMLElement} detailsCell
   * @protected
   */
  _a11ySetRowDetailsCell(row, detailsCell) {
    iterateRowCells(row, (cell) => {
      if (cell !== detailsCell) {
        cell.setAttribute("aria-controls", detailsCell.id);
      }
    });
  }
  /**
   * @param {!HTMLElement} row
   * @param {number} colspan
   * @protected
   */
  _a11yUpdateCellColspan(cell, colspan) {
    cell.setAttribute("aria-colspan", Number(colspan));
  }
  /** @protected */
  _a11yUpdateSorters() {
    Array.from(this.querySelectorAll("vaadin-grid-sorter")).forEach((sorter) => {
      let cellContent = sorter.parentNode;
      while (cellContent && cellContent.localName !== "vaadin-grid-cell-content") {
        cellContent = cellContent.parentNode;
      }
      if (cellContent && cellContent.assignedSlot) {
        const cell = cellContent.assignedSlot.parentNode;
        cell.setAttribute(
          "aria-sort",
          {
            asc: "ascending",
            desc: "descending"
          }[String(sorter.direction)] || "none"
        );
      }
    });
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const isFocusable = (target) => {
  return target.offsetParent && !target.part.contains("body-cell") && isElementFocusable(target) && getComputedStyle(target).visibility !== "hidden";
};
const ActiveItemMixin = (superClass) => class ActiveItemMixin extends superClass {
  static get properties() {
    return {
      /**
       * The item user has last interacted with. Turns to `null` after user deactivates
       * the item by re-interacting with the currently active item.
       * @type {GridItem}
       */
      activeItem: {
        type: Object,
        notify: true,
        value: null,
        sync: true
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this.$.scroller.addEventListener("click", this._onClick.bind(this));
    this.addEventListener("cell-activate", this._activateItem.bind(this));
    this.addEventListener("row-activate", this._activateItem.bind(this));
  }
  /** @private */
  _activateItem(e2) {
    const model = e2.detail.model;
    const clickedItem = model ? model.item : null;
    if (clickedItem) {
      this.activeItem = !this._itemsEqual(this.activeItem, clickedItem) ? clickedItem : null;
    }
  }
  /**
   * Checks whether the click event should not activate the cell on which it occurred.
   *
   * @protected
   */
  _shouldPreventCellActivationOnClick(e2) {
    const { cell } = this._getGridEventLocation(e2);
    return (
      // Something has handled this click already, e. g., <vaadin-grid-sorter>
      e2.defaultPrevented || // No clicked cell available
      !cell || // Cell is a details cell
      cell.getAttribute("part").includes("details-cell") || // Cell is the empty state cell
      cell === this.$.emptystatecell || // Cell content is focused
      cell._content.contains(this.getRootNode().activeElement) || // Clicked on a focusable element
      this._isFocusable(e2.target) || // Clicked on a label element
      e2.target instanceof HTMLLabelElement
    );
  }
  /**
   * @param {!MouseEvent} e
   * @protected
   */
  _onClick(e2) {
    if (this._shouldPreventCellActivationOnClick(e2)) {
      return;
    }
    const { cell } = this._getGridEventLocation(e2);
    if (cell) {
      this.dispatchEvent(
        new CustomEvent("cell-activate", {
          detail: {
            model: this.__getRowModel(cell.parentElement)
          }
        })
      );
    }
  }
  /**
   * @param {!Element} target
   * @return {boolean}
   * @protected
   */
  _isFocusable(target) {
    return isFocusable(target);
  }
  /**
   * Fired when the `activeItem` property changes.
   *
   * @event active-item-changed
   */
  /**
   * Fired when the cell is activated with click or keyboard.
   *
   * @event cell-activate
   */
};
function get(path, object) {
  return path.split(".").reduce((obj, property) => obj[property], object);
}
function checkPaths(arrayToCheck, action, items) {
  if (items.length === 0) {
    return false;
  }
  let result = true;
  arrayToCheck.forEach(({ path }) => {
    if (!path || path.indexOf(".") === -1) {
      return;
    }
    const parentProperty = path.replace(/\.[^.]*$/u, "");
    if (get(parentProperty, items[0]) === void 0) {
      console.warn(`Path "${path}" used for ${action} does not exist in all of the items, ${action} is disabled.`);
      result = false;
    }
  });
  return result;
}
function normalizeEmptyValue(value) {
  if ([void 0, null].indexOf(value) >= 0) {
    return "";
  } else if (isNaN(value)) {
    return value.toString();
  }
  return value;
}
function compare(a3, b2) {
  a3 = normalizeEmptyValue(a3);
  b2 = normalizeEmptyValue(b2);
  if (a3 < b2) {
    return -1;
  }
  if (a3 > b2) {
    return 1;
  }
  return 0;
}
function multiSort(items, sortOrders) {
  return items.sort((a3, b2) => {
    return sortOrders.map((sortOrder) => {
      if (sortOrder.direction === "asc") {
        return compare(get(sortOrder.path, a3), get(sortOrder.path, b2));
      } else if (sortOrder.direction === "desc") {
        return compare(get(sortOrder.path, b2), get(sortOrder.path, a3));
      }
      return 0;
    }).reduce((p, n) => {
      return p !== 0 ? p : n;
    }, 0);
  });
}
function filter(items, filters) {
  return items.filter((item2) => {
    return filters.every((filter2) => {
      const value = normalizeEmptyValue(get(filter2.path, item2));
      const filterValueLowercase = normalizeEmptyValue(filter2.value).toString().toLowerCase();
      return value.toString().toLowerCase().includes(filterValueLowercase);
    });
  });
}
const createArrayDataProvider = (allItems) => {
  return (params, callback) => {
    let items = allItems ? [...allItems] : [];
    if (params.filters && checkPaths(params.filters, "filtering", items)) {
      items = filter(items, params.filters);
    }
    if (Array.isArray(params.sortOrders) && params.sortOrders.length && checkPaths(params.sortOrders, "sorting", items)) {
      items = multiSort(items, params.sortOrders);
    }
    const count = Math.min(items.length, params.pageSize);
    const start = params.page * count;
    const end = start + count;
    const slice = items.slice(start, end);
    callback(slice, items.length);
  };
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ArrayDataProviderMixin = (superClass) => class ArrayDataProviderMixin extends superClass {
  static get properties() {
    return {
      /**
       * An array containing the items which will be passed to renderer functions.
       *
       * @type {Array<!GridItem> | undefined}
       */
      items: {
        type: Array,
        sync: true
      }
    };
  }
  static get observers() {
    return ["__dataProviderOrItemsChanged(dataProvider, items, isAttached, items.*)"];
  }
  /** @private */
  __setArrayDataProvider(items) {
    const arrayDataProvider = createArrayDataProvider(this.items);
    arrayDataProvider.__items = items;
    this._arrayDataProvider = arrayDataProvider;
    this.size = items.length;
    this.dataProvider = arrayDataProvider;
  }
  /**
   * @override
   * @protected
   */
  _onDataProviderPageReceived() {
    super._onDataProviderPageReceived();
    if (this._arrayDataProvider) {
      this.size = this._flatSize;
    }
  }
  /** @private */
  __dataProviderOrItemsChanged(dataProvider, items, isAttached) {
    if (!isAttached) {
      return;
    }
    if (this._arrayDataProvider) {
      if (dataProvider !== this._arrayDataProvider) {
        this._arrayDataProvider = void 0;
        this.items = void 0;
      } else if (!items) {
        this._arrayDataProvider = void 0;
        this.dataProvider = void 0;
        this.size = 0;
        this.clearCache();
      } else if (this._arrayDataProvider.__items === items) {
        this.clearCache();
      } else {
        this.__setArrayDataProvider(items);
      }
    } else if (items) {
      this.__setArrayDataProvider(items);
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ColumnReorderingMixin = (superClass) => class ColumnReorderingMixin extends superClass {
  static get properties() {
    return {
      /**
       * Set to true to allow column reordering.
       * @attr {boolean} column-reordering-allowed
       * @type {boolean}
       */
      columnReorderingAllowed: {
        type: Boolean,
        value: false
      },
      /** @private */
      _orderBaseScope: {
        type: Number,
        value: 1e7
      }
    };
  }
  static get observers() {
    return ["_updateOrders(_columnTree)"];
  }
  /** @protected */
  ready() {
    super.ready();
    addListener(this, "track", this._onTrackEvent);
    this._reorderGhost = this.shadowRoot.querySelector('[part="reorder-ghost"]');
    this.addEventListener("touchstart", this._onTouchStart.bind(this));
    this.addEventListener("touchmove", this._onTouchMove.bind(this));
    this.addEventListener("touchend", this._onTouchEnd.bind(this));
    this.addEventListener("contextmenu", this._onContextMenu.bind(this));
  }
  /** @private */
  _onContextMenu(e2) {
    if (this.hasAttribute("reordering")) {
      e2.preventDefault();
      if (!isTouch) {
        this._onTrackEnd();
      }
    }
  }
  /** @private */
  _onTouchStart(e2) {
    this._startTouchReorderTimeout = setTimeout(() => {
      this._onTrackStart({
        detail: {
          x: e2.touches[0].clientX,
          y: e2.touches[0].clientY
        }
      });
    }, 100);
  }
  /** @private */
  _onTouchMove(e2) {
    if (this._draggedColumn) {
      e2.preventDefault();
    }
    clearTimeout(this._startTouchReorderTimeout);
  }
  /** @private */
  _onTouchEnd() {
    clearTimeout(this._startTouchReorderTimeout);
    this._onTrackEnd();
  }
  /** @private */
  _onTrackEvent(e2) {
    if (e2.detail.state === "start") {
      const path = e2.composedPath();
      const headerCell = path[path.indexOf(this.$.header) - 2];
      if (!headerCell || !headerCell._content) {
        return;
      }
      if (headerCell._content.contains(this.getRootNode().activeElement)) {
        return;
      }
      if (this.$.scroller.hasAttribute("column-resizing")) {
        return;
      }
      if (!this._touchDevice) {
        this._onTrackStart(e2);
      }
    } else if (e2.detail.state === "track") {
      this._onTrack(e2);
    } else if (e2.detail.state === "end") {
      this._onTrackEnd(e2);
    }
  }
  /** @private */
  _onTrackStart(e2) {
    if (!this.columnReorderingAllowed) {
      return;
    }
    const path = e2.composedPath && e2.composedPath();
    if (path && path.some((node) => node.hasAttribute && node.hasAttribute("draggable"))) {
      return;
    }
    const headerCell = this._cellFromPoint(e2.detail.x, e2.detail.y);
    if (!headerCell || !headerCell.getAttribute("part").includes("header-cell")) {
      return;
    }
    this.toggleAttribute("reordering", true);
    this._draggedColumn = headerCell._column;
    while (this._draggedColumn.parentElement.childElementCount === 1) {
      this._draggedColumn = this._draggedColumn.parentElement;
    }
    this._setSiblingsReorderStatus(this._draggedColumn, "allowed");
    this._draggedColumn._reorderStatus = "dragging";
    this._updateGhost(headerCell);
    this._reorderGhost.style.visibility = "visible";
    this._updateGhostPosition(e2.detail.x, this._touchDevice ? e2.detail.y - 50 : e2.detail.y);
    this._autoScroller();
  }
  /** @private */
  _onTrack(e2) {
    if (!this._draggedColumn) {
      return;
    }
    const targetCell = this._cellFromPoint(e2.detail.x, e2.detail.y);
    if (!targetCell) {
      return;
    }
    const targetColumn = this._getTargetColumn(targetCell, this._draggedColumn);
    if (this._isSwapAllowed(this._draggedColumn, targetColumn) && this._isSwappableByPosition(targetColumn, e2.detail.x)) {
      const columnTreeLevel = this._columnTree.findIndex((level) => level.includes(targetColumn));
      const levelColumnsInOrder = this._getColumnsInOrder(columnTreeLevel);
      const startIndex = levelColumnsInOrder.indexOf(this._draggedColumn);
      const endIndex = levelColumnsInOrder.indexOf(targetColumn);
      const direction = startIndex < endIndex ? 1 : -1;
      for (let i2 = startIndex; i2 !== endIndex; i2 += direction) {
        this._swapColumnOrders(this._draggedColumn, levelColumnsInOrder[i2 + direction]);
      }
    }
    this._updateGhostPosition(e2.detail.x, this._touchDevice ? e2.detail.y - 50 : e2.detail.y);
    this._lastDragClientX = e2.detail.x;
  }
  /** @private */
  _onTrackEnd() {
    if (!this._draggedColumn) {
      return;
    }
    this.toggleAttribute("reordering", false);
    this._draggedColumn._reorderStatus = "";
    this._setSiblingsReorderStatus(this._draggedColumn, "");
    this._draggedColumn = null;
    this._lastDragClientX = null;
    this._reorderGhost.style.visibility = "hidden";
    this.dispatchEvent(
      new CustomEvent("column-reorder", {
        detail: {
          columns: this._getColumnsInOrder()
        }
      })
    );
  }
  /**
   * Returns the columns (or column groups) on the specified header level in visual order.
   * By default, the bottom level is used.
   *
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getColumnsInOrder(headerLevel = this._columnTree.length - 1) {
    return this._columnTree[headerLevel].filter((c2) => !c2.hidden).sort((b2, a3) => b2._order - a3._order);
  }
  /**
   * @param {number} x
   * @param {number} y
   * @return {HTMLElement | undefined}
   * @protected
   */
  _cellFromPoint(x2 = 0, y3 = 0) {
    if (!this._draggedColumn) {
      this.$.scroller.toggleAttribute("no-content-pointer-events", true);
    }
    const elementFromPoint = this.shadowRoot.elementFromPoint(x2, y3);
    this.$.scroller.toggleAttribute("no-content-pointer-events", false);
    return this._getCellFromElement(elementFromPoint);
  }
  /** @private */
  _getCellFromElement(element) {
    if (element) {
      if (element._column) {
        return element;
      }
      const { parentElement } = element;
      if (parentElement && parentElement._focusButton === element) {
        return parentElement;
      }
    }
    return null;
  }
  /**
   * @param {number} eventClientX
   * @param {number} eventClientY
   * @protected
   */
  _updateGhostPosition(eventClientX, eventClientY) {
    const ghostRect = this._reorderGhost.getBoundingClientRect();
    const targetLeft = eventClientX - ghostRect.width / 2;
    const targetTop = eventClientY - ghostRect.height / 2;
    const _left = parseInt(this._reorderGhost._left || 0);
    const _top = parseInt(this._reorderGhost._top || 0);
    this._reorderGhost._left = _left - (ghostRect.left - targetLeft);
    this._reorderGhost._top = _top - (ghostRect.top - targetTop);
    this._reorderGhost.style.transform = `translate(${this._reorderGhost._left}px, ${this._reorderGhost._top}px)`;
  }
  /**
   * @param {!HTMLElement} cell
   * @return {!HTMLElement}
   * @protected
   */
  _updateGhost(cell) {
    const ghost = this._reorderGhost;
    ghost.textContent = cell._content.innerText;
    const style = window.getComputedStyle(cell);
    [
      "boxSizing",
      "display",
      "width",
      "height",
      "background",
      "alignItems",
      "padding",
      "border",
      "flex-direction",
      "overflow"
    ].forEach((propertyName) => {
      ghost.style[propertyName] = style[propertyName];
    });
    return ghost;
  }
  /** @private */
  _updateOrders(columnTree) {
    if (columnTree === void 0) {
      return;
    }
    columnTree[0].forEach((column) => {
      column._order = 0;
    });
    updateColumnOrders(columnTree[0], this._orderBaseScope, 0);
  }
  /**
   * @param {!GridColumn} column
   * @param {string} status
   * @protected
   */
  _setSiblingsReorderStatus(column, status) {
    iterateChildren(column.parentNode, (sibling) => {
      if (/column/u.test(sibling.localName) && this._isSwapAllowed(sibling, column)) {
        sibling._reorderStatus = status;
      }
    });
  }
  /** @protected */
  _autoScroller() {
    if (this._lastDragClientX) {
      const rightDiff = this._lastDragClientX - this.getBoundingClientRect().right + 50;
      const leftDiff = this.getBoundingClientRect().left - this._lastDragClientX + 50;
      if (rightDiff > 0) {
        this.$.table.scrollLeft += rightDiff / 10;
      } else if (leftDiff > 0) {
        this.$.table.scrollLeft -= leftDiff / 10;
      }
    }
    if (this._draggedColumn) {
      setTimeout(() => this._autoScroller(), 10);
    }
  }
  /**
   * @param {GridColumn | undefined} column1
   * @param {GridColumn | undefined} column2
   * @return {boolean | undefined}
   * @protected
   */
  _isSwapAllowed(column1, column2) {
    if (column1 && column2) {
      const differentColumns = column1 !== column2;
      const sameParent = column1.parentElement === column2.parentElement;
      const sameFrozen = column1.frozen && column2.frozen || // Both columns are frozen
      column1.frozenToEnd && column2.frozenToEnd || // Both columns are frozen to end
      !column1.frozen && !column1.frozenToEnd && !column2.frozen && !column2.frozenToEnd;
      return differentColumns && sameParent && sameFrozen;
    }
  }
  /**
   * @param {!GridColumn} targetColumn
   * @param {number} clientX
   * @return {boolean}
   * @protected
   */
  _isSwappableByPosition(targetColumn, clientX) {
    const targetCell = Array.from(this.$.header.querySelectorAll('tr:not([hidden]) [part~="cell"]')).find(
      (cell) => targetColumn.contains(cell._column)
    );
    const sourceCellRect = this.$.header.querySelector("tr:not([hidden]) [reorder-status=dragging]").getBoundingClientRect();
    const targetRect = targetCell.getBoundingClientRect();
    if (targetRect.left > sourceCellRect.left) {
      return clientX > targetRect.right - sourceCellRect.width;
    }
    return clientX < targetRect.left + sourceCellRect.width;
  }
  /**
   * @param {!GridColumn} column1
   * @param {!GridColumn} column2
   * @protected
   */
  _swapColumnOrders(column1, column2) {
    [column1._order, column2._order] = [column2._order, column1._order];
    this._debounceUpdateFrozenColumn();
    this._updateFirstAndLastColumn();
  }
  /**
   * @param {HTMLElement | undefined} targetCell
   * @param {GridColumn} draggedColumn
   * @return {GridColumn | undefined}
   * @protected
   */
  _getTargetColumn(targetCell, draggedColumn) {
    if (targetCell && draggedColumn) {
      let candidate = targetCell._column;
      while (candidate.parentElement !== draggedColumn.parentElement && candidate !== this) {
        candidate = candidate.parentElement;
      }
      if (candidate.parentElement === draggedColumn.parentElement) {
        return candidate;
      }
      return targetCell._column;
    }
  }
  /**
   * Fired when the columns in the grid are reordered.
   *
   * @event column-reorder
   * @param {Object} detail
   * @param {Object} detail.columns the columns in the new order
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ColumnResizingMixin = (superClass) => class ColumnResizingMixin extends superClass {
  /** @protected */
  ready() {
    super.ready();
    const scroller2 = this.$.scroller;
    addListener(scroller2, "track", this._onHeaderTrack.bind(this));
    scroller2.addEventListener("touchmove", (e2) => scroller2.hasAttribute("column-resizing") && e2.preventDefault());
    scroller2.addEventListener(
      "contextmenu",
      (e2) => e2.target.getAttribute("part") === "resize-handle" && e2.preventDefault()
    );
    scroller2.addEventListener(
      "mousedown",
      (e2) => e2.target.getAttribute("part") === "resize-handle" && e2.preventDefault()
    );
  }
  /** @private */
  _onHeaderTrack(e2) {
    const handle = e2.target;
    if (handle.getAttribute("part") === "resize-handle") {
      const cell = handle.parentElement;
      let column = cell._column;
      this.$.scroller.toggleAttribute("column-resizing", true);
      while (column.localName === "vaadin-grid-column-group") {
        column = column._childColumns.slice(0).sort((a3, b2) => a3._order - b2._order).filter((column2) => !column2.hidden).pop();
      }
      const isRTL = this.__isRTL;
      const eventX = e2.detail.x;
      const columnRowCells = Array.from(this.$.header.querySelectorAll('[part~="row"]:last-child [part~="cell"]'));
      const targetCell = columnRowCells.find((cell2) => cell2._column === column);
      if (targetCell.offsetWidth) {
        const style = getComputedStyle(targetCell._content);
        const minWidth = 10 + parseInt(style.paddingLeft) + parseInt(style.paddingRight) + parseInt(style.borderLeftWidth) + parseInt(style.borderRightWidth) + parseInt(style.marginLeft) + parseInt(style.marginRight);
        let maxWidth;
        const cellWidth = targetCell.offsetWidth;
        const cellRect = targetCell.getBoundingClientRect();
        if (targetCell.hasAttribute("frozen-to-end")) {
          maxWidth = cellWidth + (isRTL ? eventX - cellRect.right : cellRect.left - eventX);
        } else {
          maxWidth = cellWidth + (isRTL ? cellRect.left - eventX : eventX - cellRect.right);
        }
        column.width = `${Math.max(minWidth, maxWidth)}px`;
        column.flexGrow = 0;
      }
      columnRowCells.sort((a3, b2) => a3._column._order - b2._column._order).forEach((cell2, index, array) => {
        if (index < array.indexOf(targetCell)) {
          cell2._column.width = `${cell2.offsetWidth}px`;
          cell2._column.flexGrow = 0;
        }
      });
      const cellFrozenToEnd = this._frozenToEndCells[0];
      if (cellFrozenToEnd && this.$.table.scrollWidth > this.$.table.offsetWidth) {
        const frozenRect = cellFrozenToEnd.getBoundingClientRect();
        const offset = eventX - (isRTL ? frozenRect.right : frozenRect.left);
        if (isRTL && offset <= 0 || !isRTL && offset >= 0) {
          this.$.table.scrollLeft += offset;
        }
      }
      if (e2.detail.state === "end") {
        this.$.scroller.toggleAttribute("column-resizing", false);
        this.dispatchEvent(
          new CustomEvent("column-resize", {
            detail: { resizedColumn: column }
          })
        );
      }
      this._resizeHandler();
    }
  }
  /**
   * Fired when a column in the grid is resized by the user.
   *
   * @event column-resize
   * @param {Object} detail
   * @param {Object} detail.resizedColumn the column that was resized
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DataProviderMixin = (superClass) => class DataProviderMixin extends superClass {
  static get properties() {
    return {
      /**
       * The number of root-level items in the grid.
       * @attr {number} size
       * @type {number}
       */
      size: {
        type: Number,
        notify: true,
        sync: true
      },
      /**
       * @type {number}
       * @protected
       */
      _flatSize: {
        type: Number,
        sync: true
      },
      /**
       * Number of items fetched at a time from the dataprovider.
       * @attr {number} page-size
       * @type {number}
       */
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged",
        sync: true
      },
      /**
       * Function that provides items lazily. Receives arguments `params`, `callback`
       *
       * `params.page` Requested page index
       *
       * `params.pageSize` Current page size
       *
       * `params.filters` Currently applied filters
       *
       * `params.sortOrders` Currently applied sorting orders
       *
       * `params.parentItem` When tree is used, and sublevel items
       * are requested, reference to parent item of the requested sublevel.
       * Otherwise `undefined`.
       *
       * `callback(items, size)` Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items. When tree sublevel items
       *     are requested, total number of items in the requested sublevel.
       *     Optional when tree is not used, required for tree.
       *
       * @type {GridDataProvider | null | undefined}
       */
      dataProvider: {
        type: Object,
        notify: true,
        observer: "_dataProviderChanged",
        sync: true
      },
      /**
       * `true` while data is being requested from the data provider.
       */
      loading: {
        type: Boolean,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },
      /**
       * @protected
       */
      _hasData: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * Path to an item sub-property that indicates whether the item has child items.
       * @attr {string} item-has-children-path
       */
      itemHasChildrenPath: {
        type: String,
        value: "children",
        observer: "__itemHasChildrenPathChanged",
        sync: true
      },
      /**
       * Path to an item sub-property that identifies the item.
       * @attr {string} item-id-path
       */
      itemIdPath: {
        type: String,
        value: null,
        sync: true
      },
      /**
       * An array that contains the expanded items.
       * @type {!Array<!GridItem>}
       */
      expandedItems: {
        type: Object,
        notify: true,
        value: () => [],
        sync: true
      },
      /**
       * @private
       */
      __expandedKeys: {
        type: Object,
        computed: "__computeExpandedKeys(itemIdPath, expandedItems)"
      }
    };
  }
  static get observers() {
    return ["_sizeChanged(size)", "_expandedItemsChanged(expandedItems)"];
  }
  constructor() {
    super();
    this._dataProviderController = new DataProviderController(this, {
      size: this.size || 0,
      pageSize: this.pageSize,
      getItemId: this.getItemId.bind(this),
      isExpanded: this._isExpanded.bind(this),
      dataProvider: this.dataProvider ? this.dataProvider.bind(this) : null,
      dataProviderParams: () => {
        return {
          sortOrders: this._mapSorters(),
          filters: this._mapFilters()
        };
      }
    });
    this._dataProviderController.addEventListener("page-requested", this._onDataProviderPageRequested.bind(this));
    this._dataProviderController.addEventListener("page-received", this._onDataProviderPageReceived.bind(this));
    this._dataProviderController.addEventListener("page-loaded", this._onDataProviderPageLoaded.bind(this));
  }
  /**
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get _cache() {
    console.warn("<vaadin-grid> The `_cache` property is deprecated and will be removed in Vaadin 25.");
    return this._dataProviderController.rootCache;
  }
  /**
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get _effectiveSize() {
    console.warn("<vaadin-grid> The `_effectiveSize` property is deprecated and will be removed in Vaadin 25.");
    return this._flatSize;
  }
  /** @private */
  _sizeChanged(size) {
    this._dataProviderController.rootCache.size = size;
    this._dataProviderController.recalculateFlatSize();
    this._flatSize = this._dataProviderController.flatSize;
  }
  /** @private */
  __itemHasChildrenPathChanged(value, oldValue) {
    if (!oldValue && value === "children") {
      return;
    }
    this.requestContentUpdate();
  }
  /**
   * @param {number} index
   * @param {HTMLElement} el
   * @protected
   */
  _getItem(index, el) {
    el.index = index;
    const { item: item2 } = this._dataProviderController.getFlatIndexContext(index);
    if (item2) {
      this.__updateLoading(el, false);
      this._updateItem(el, item2);
      if (this._isExpanded(item2)) {
        this._dataProviderController.ensureFlatIndexHierarchy(index);
      }
    } else {
      this.__updateLoading(el, true);
      this._dataProviderController.ensureFlatIndexLoaded(index);
    }
  }
  /**
   * @param {!HTMLElement} row
   * @param {boolean} loading
   * @private
   */
  __updateLoading(row, loading) {
    const cells = getBodyRowCells(row);
    updateState(row, "loading", loading);
    updateCellsPart(cells, "loading-row-cell", loading);
    if (loading) {
      this._generateCellClassNames(row);
      this._generateCellPartNames(row);
    }
  }
  /**
   * Returns a value that identifies the item. Uses `itemIdPath` if available.
   * Can be customized by overriding.
   * @param {!GridItem} item
   * @return {!GridItem | !unknown}
   */
  getItemId(item2) {
    return this.itemIdPath ? get$1(this.itemIdPath, item2) : item2;
  }
  /**
   * @param {!GridItem} item
   * @return {boolean}
   * @protected
   */
  _isExpanded(item2) {
    return this.__expandedKeys && this.__expandedKeys.has(this.getItemId(item2));
  }
  /** @private */
  _expandedItemsChanged() {
    this._dataProviderController.recalculateFlatSize();
    this._flatSize = this._dataProviderController.flatSize;
    this.__updateVisibleRows();
  }
  /** @private */
  __computeExpandedKeys(_itemIdPath, expandedItems) {
    const expanded = expandedItems || [];
    const expandedKeys = /* @__PURE__ */ new Set();
    expanded.forEach((item2) => {
      expandedKeys.add(this.getItemId(item2));
    });
    return expandedKeys;
  }
  /**
   * Expands the given item tree.
   * @param {!GridItem} item
   */
  expandItem(item2) {
    if (!this._isExpanded(item2)) {
      this.expandedItems = [...this.expandedItems, item2];
    }
  }
  /**
   * Collapses the given item tree.
   * @param {!GridItem} item
   */
  collapseItem(item2) {
    if (this._isExpanded(item2)) {
      this.expandedItems = this.expandedItems.filter((i2) => !this._itemsEqual(i2, item2));
    }
  }
  /**
   * @param {number} index
   * @return {number}
   * @protected
   */
  _getIndexLevel(index = 0) {
    const { level } = this._dataProviderController.getFlatIndexContext(index);
    return level;
  }
  /**
   * @param {number} page
   * @param {ItemCache} cache
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  _loadPage(page, cache) {
    console.warn("<vaadin-grid> The `_loadPage` method is deprecated and will be removed in Vaadin 25.");
    this._dataProviderController.__loadCachePage(cache, page);
  }
  /** @protected */
  _onDataProviderPageRequested() {
    this._setLoading(true);
  }
  /** @protected */
  _onDataProviderPageReceived() {
    if (this._flatSize !== this._dataProviderController.flatSize) {
      this._shouldUpdateAllRenderedRowsAfterPageLoad = true;
      this._flatSize = this._dataProviderController.flatSize;
    }
    this._getRenderedRows().forEach((row) => {
      this._dataProviderController.ensureFlatIndexHierarchy(row.index);
    });
    this._hasData = true;
  }
  /** @protected */
  _onDataProviderPageLoaded() {
    this._debouncerApplyCachedData = Debouncer$1.debounce(this._debouncerApplyCachedData, timeOut.after(0), () => {
      this._setLoading(false);
      const shouldUpdateAllRenderedRowsAfterPageLoad = this._shouldUpdateAllRenderedRowsAfterPageLoad;
      this._shouldUpdateAllRenderedRowsAfterPageLoad = false;
      this._getRenderedRows().forEach((row) => {
        const { item: item2 } = this._dataProviderController.getFlatIndexContext(row.index);
        if (item2 || shouldUpdateAllRenderedRowsAfterPageLoad) {
          this._getItem(row.index, row);
        }
      });
      this.__scrollToPendingIndexes();
      this.__dispatchPendingBodyCellFocus();
    });
    if (!this._dataProviderController.isLoading()) {
      this._debouncerApplyCachedData.flush();
    }
  }
  /** @private */
  __debounceClearCache() {
    this.__clearCacheDebouncer = Debouncer$1.debounce(this.__clearCacheDebouncer, microTask, () => this.clearCache());
  }
  /**
   * Clears the cached pages and reloads data from dataprovider when needed.
   */
  clearCache() {
    this._dataProviderController.clearCache();
    this._dataProviderController.rootCache.size = this.size || 0;
    this._dataProviderController.recalculateFlatSize();
    this._hasData = false;
    this.__updateVisibleRows();
    if (!this.__virtualizer || !this.__virtualizer.size) {
      this._dataProviderController.loadFirstPage();
    }
  }
  /** @private */
  _pageSizeChanged(pageSize, oldPageSize) {
    this._dataProviderController.setPageSize(pageSize);
    if (oldPageSize !== void 0 && pageSize !== oldPageSize) {
      this.clearCache();
    }
  }
  /** @protected */
  _checkSize() {
    if (this.size === void 0 && this._flatSize === 0) {
      console.warn(
        "The <vaadin-grid> needs the total number of items in order to display rows, which you can specify either by setting the `size` property, or by providing it to the second argument of the `dataProvider` function `callback` call."
      );
    }
  }
  /** @private */
  _dataProviderChanged(dataProvider, oldDataProvider) {
    this._dataProviderController.setDataProvider(dataProvider ? dataProvider.bind(this) : null);
    if (oldDataProvider !== void 0) {
      this.clearCache();
    }
    this._ensureFirstPageLoaded();
    this._debouncerCheckSize = Debouncer$1.debounce(
      this._debouncerCheckSize,
      timeOut.after(2e3),
      this._checkSize.bind(this)
    );
  }
  /** @protected */
  _ensureFirstPageLoaded() {
    if (!this._hasData) {
      this._dataProviderController.loadFirstPage();
    }
  }
  /**
   * @param {!GridItem} item1
   * @param {!GridItem} item2
   * @return {boolean}
   * @protected
   */
  _itemsEqual(item1, item2) {
    return this.getItemId(item1) === this.getItemId(item2);
  }
  /**
   * @param {!GridItem} item
   * @param {!Array<!GridItem>} array
   * @return {number}
   * @protected
   */
  _getItemIndexInArray(item2, array) {
    let result = -1;
    array.forEach((i2, idx) => {
      if (this._itemsEqual(i2, item2)) {
        result = idx;
      }
    });
    return result;
  }
  /**
   * Scroll to a specific row index in the virtual list. Note that the row index is
   * not always the same for any particular item. For example, sorting or filtering
   * items can affect the row index related to an item.
   *
   * The `indexes` parameter can be either a single number or multiple numbers.
   * The grid will first try to scroll to the item at the first index on the top level.
   * In case the item at the first index is expanded, the grid will then try scroll to the
   * item at the second index within the children of the expanded first item, and so on.
   * Each given index points to a child of the item at the previous index.
   *
   * Using `Infinity` as an index will point to the last item on the level.
   *
   * @param indexes {...number} Row indexes to scroll to
   */
  scrollToIndex(...indexes) {
    let targetIndex;
    while (targetIndex !== (targetIndex = this._dataProviderController.getFlatIndexByPath(indexes))) {
      this._scrollToFlatIndex(targetIndex);
    }
    if (this._dataProviderController.isLoading() || !this.clientHeight) {
      this.__pendingScrollToIndexes = indexes;
    }
  }
  /** @private */
  __scrollToPendingIndexes() {
    if (this.__pendingScrollToIndexes && this.$.items.children.length) {
      const indexes = this.__pendingScrollToIndexes;
      delete this.__pendingScrollToIndexes;
      this.scrollToIndex(...indexes);
    }
  }
  /**
   * Fired when the `expandedItems` property changes.
   *
   * @event expanded-items-changed
   */
  /**
   * Fired when the `loading` property changes.
   *
   * @event loading-changed
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DropMode = {
  BETWEEN: "between",
  ON_TOP: "on-top",
  ON_TOP_OR_BETWEEN: "on-top-or-between",
  ON_GRID: "on-grid"
};
const DropLocation = {
  ON_TOP: "on-top",
  ABOVE: "above",
  BELOW: "below",
  EMPTY: "empty"
};
const usesDnDPolyfill = !("draggable" in document.createElement("div"));
const DragAndDropMixin = (superClass) => class DragAndDropMixin extends superClass {
  static get properties() {
    return {
      /**
       * Defines the locations within the Grid row where an element can be dropped.
       *
       * Possible values are:
       * - `between`: The drop event can happen between Grid rows.
       * - `on-top`: The drop event can happen on top of Grid rows.
       * - `on-top-or-between`: The drop event can happen either on top of or between Grid rows.
       * - `on-grid`: The drop event will not happen on any specific row, it will show the drop target outline around the whole grid.
       * @attr {between|on-top|on-top-or-between|on-grid} drop-mode
       * @type {GridDropMode | null | undefined}
       */
      dropMode: {
        type: String,
        sync: true
      },
      /**
       * Marks the grid's rows to be available for dragging.
       * @attr {boolean} rows-draggable
       */
      rowsDraggable: {
        type: Boolean,
        sync: true
      },
      /**
       * A function that filters dragging of specific grid rows. The return value should be false
       * if dragging of the row should be disabled.
       *
       * Receives one argument:
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridDragAndDropFilter | null | undefined}
       */
      dragFilter: {
        type: Function,
        sync: true
      },
      /**
       * A function that filters dropping on specific grid rows. The return value should be false
       * if dropping on the row should be disabled.
       *
       * Receives one argument:
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridDragAndDropFilter | null | undefined}
       */
      dropFilter: {
        type: Function,
        sync: true
      },
      /** @private */
      __dndAutoScrollThreshold: {
        value: 50
      },
      /** @private  */
      __draggedItems: {
        value: () => []
      }
    };
  }
  static get observers() {
    return ["_dragDropAccessChanged(rowsDraggable, dropMode, dragFilter, dropFilter, loading)"];
  }
  constructor() {
    super();
    this.__onDocumentDragStart = this.__onDocumentDragStart.bind(this);
  }
  /** @protected */
  ready() {
    super.ready();
    this.$.table.addEventListener("dragstart", this._onDragStart.bind(this));
    this.$.table.addEventListener("dragend", this._onDragEnd.bind(this));
    this.$.table.addEventListener("dragover", this._onDragOver.bind(this));
    this.$.table.addEventListener("dragleave", this._onDragLeave.bind(this));
    this.$.table.addEventListener("drop", this._onDrop.bind(this));
    this.$.table.addEventListener("dragenter", (e2) => {
      if (this.dropMode) {
        e2.preventDefault();
        e2.stopPropagation();
      }
    });
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    document.addEventListener("dragstart", this.__onDocumentDragStart, { capture: true });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("dragstart", this.__onDocumentDragStart, { capture: true });
  }
  /** @private */
  _onDragStart(e2) {
    if (this.rowsDraggable) {
      let row = e2.target;
      if (row.localName === "vaadin-grid-cell-content") {
        row = row.assignedSlot.parentNode.parentNode;
      }
      if (row.parentNode !== this.$.items) {
        return;
      }
      e2.stopPropagation();
      this.toggleAttribute("dragging-rows", true);
      if (this._safari) {
        const transform = row.style.transform;
        row.style.top = /translateY\((.*)\)/u.exec(transform)[1];
        row.style.transform = "none";
        requestAnimationFrame(() => {
          row.style.top = "";
          row.style.transform = transform;
        });
      }
      const rowRect = row.getBoundingClientRect();
      if (usesDnDPolyfill) {
        e2.dataTransfer.setDragImage(row);
      } else {
        e2.dataTransfer.setDragImage(row, e2.clientX - rowRect.left, e2.clientY - rowRect.top);
      }
      let rows = [row];
      if (this._isSelected(row._item)) {
        rows = this.__getViewportRows().filter((row2) => this._isSelected(row2._item)).filter((row2) => !this.dragFilter || this.dragFilter(this.__getRowModel(row2)));
      }
      this.__draggedItems = rows.map((row2) => row2._item);
      e2.dataTransfer.setData("text", this.__formatDefaultTransferData(rows));
      updateBooleanRowStates(row, { dragstart: rows.length > 1 ? `${rows.length}` : "" });
      this.style.setProperty("--_grid-drag-start-x", `${e2.clientX - rowRect.left + 20}px`);
      this.style.setProperty("--_grid-drag-start-y", `${e2.clientY - rowRect.top + 10}px`);
      requestAnimationFrame(() => {
        updateBooleanRowStates(row, { dragstart: false });
        this.style.setProperty("--_grid-drag-start-x", "");
        this.style.setProperty("--_grid-drag-start-y", "");
        this.requestContentUpdate();
      });
      const event = new CustomEvent("grid-dragstart", {
        detail: {
          draggedItems: [...this.__draggedItems],
          setDragData: (type, data) => e2.dataTransfer.setData(type, data),
          setDraggedItemsCount: (count) => row.setAttribute("dragstart", count)
        }
      });
      event.originalEvent = e2;
      this.dispatchEvent(event);
    }
  }
  /** @private */
  _onDragEnd(e2) {
    this.toggleAttribute("dragging-rows", false);
    e2.stopPropagation();
    const event = new CustomEvent("grid-dragend");
    event.originalEvent = e2;
    this.dispatchEvent(event);
    this.__draggedItems = [];
    this.requestContentUpdate();
  }
  /** @private */
  _onDragLeave(e2) {
    if (!this.dropMode) {
      return;
    }
    e2.stopPropagation();
    this._clearDragStyles();
  }
  /** @private */
  _onDragOver(e2) {
    if (this.dropMode) {
      this._dropLocation = void 0;
      this._dragOverItem = void 0;
      if (this.__dndAutoScroll(e2.clientY)) {
        this._clearDragStyles();
        return;
      }
      let row = e2.composedPath().find((node) => node.localName === "tr");
      if (!this._flatSize || this.dropMode === DropMode.ON_GRID) {
        this._dropLocation = DropLocation.EMPTY;
      } else if (!row || row.parentNode !== this.$.items) {
        if (row) {
          return;
        } else if (this.dropMode === DropMode.BETWEEN || this.dropMode === DropMode.ON_TOP_OR_BETWEEN) {
          row = Array.from(this.$.items.children).filter((row2) => !row2.hidden).pop();
          this._dropLocation = DropLocation.BELOW;
        } else {
          return;
        }
      } else {
        const rowRect = row.getBoundingClientRect();
        this._dropLocation = DropLocation.ON_TOP;
        if (this.dropMode === DropMode.BETWEEN) {
          const dropAbove = e2.clientY - rowRect.top < rowRect.bottom - e2.clientY;
          this._dropLocation = dropAbove ? DropLocation.ABOVE : DropLocation.BELOW;
        } else if (this.dropMode === DropMode.ON_TOP_OR_BETWEEN) {
          if (e2.clientY - rowRect.top < rowRect.height / 3) {
            this._dropLocation = DropLocation.ABOVE;
          } else if (e2.clientY - rowRect.top > rowRect.height / 3 * 2) {
            this._dropLocation = DropLocation.BELOW;
          }
        }
      }
      if (row && row.hasAttribute("drop-disabled")) {
        this._dropLocation = void 0;
        return;
      }
      e2.stopPropagation();
      e2.preventDefault();
      if (this._dropLocation === DropLocation.EMPTY) {
        this.toggleAttribute("dragover", true);
      } else if (row) {
        this._dragOverItem = row._item;
        if (row.getAttribute("dragover") !== this._dropLocation) {
          updateStringRowStates(row, { dragover: this._dropLocation });
        }
      } else {
        this._clearDragStyles();
      }
    }
  }
  /**
   * Webkit-based browsers have issues with generating drag images
   * for elements that have children with massive heights. Chromium
   * browsers crash, while Safari experiences significant performance
   * issues. To mitigate these issues, we hide the scroller element
   * when drag starts to remove it from the drag image.
   *
   * Grids with fewer rows also have issues on Chromium and Safari
   * where the drag image is not properly clipped and may include
   * content outside the grid. Temporary inline styles are applied
   * to mitigate this issue.
   *
   * Related issues:
   * - https://github.com/vaadin/web-components/issues/7985
   * - https://issues.chromium.org/issues/383356871
   * - https://github.com/vaadin/web-components/issues/8386
   *
   * @private
   */
  __onDocumentDragStart(e2) {
    if (e2.target.contains(this)) {
      const elements = [e2.target, this.$.items, this.$.scroller];
      const originalInlineStyles = elements.map((element) => element.style.cssText);
      if (this.$.table.scrollHeight > 2e4) {
        this.$.scroller.style.display = "none";
      }
      if (isChrome) {
        e2.target.style.willChange = "transform";
      }
      if (isSafari) {
        this.$.items.style.flexShrink = 1;
      }
      requestAnimationFrame(() => {
        elements.forEach((element, index) => {
          element.style.cssText = originalInlineStyles[index];
        });
      });
    }
  }
  /** @private */
  __dndAutoScroll(clientY) {
    if (this.__dndAutoScrolling) {
      return true;
    }
    const headerBottom = this.$.header.getBoundingClientRect().bottom;
    const footerTop = this.$.footer.getBoundingClientRect().top;
    const topDiff = headerBottom - clientY + this.__dndAutoScrollThreshold;
    const bottomDiff = clientY - footerTop + this.__dndAutoScrollThreshold;
    let scrollTopDelta = 0;
    if (bottomDiff > 0) {
      scrollTopDelta = bottomDiff * 2;
    } else if (topDiff > 0) {
      scrollTopDelta = -topDiff * 2;
    }
    if (scrollTopDelta) {
      const scrollTop = this.$.table.scrollTop;
      this.$.table.scrollTop += scrollTopDelta;
      const scrollTopChanged = scrollTop !== this.$.table.scrollTop;
      if (scrollTopChanged) {
        this.__dndAutoScrolling = true;
        setTimeout(() => {
          this.__dndAutoScrolling = false;
        }, 20);
        return true;
      }
    }
  }
  /** @private */
  __getViewportRows() {
    const headerBottom = this.$.header.getBoundingClientRect().bottom;
    const footerTop = this.$.footer.getBoundingClientRect().top;
    return Array.from(this.$.items.children).filter((row) => {
      const rowRect = row.getBoundingClientRect();
      return rowRect.bottom > headerBottom && rowRect.top < footerTop;
    });
  }
  /** @protected */
  _clearDragStyles() {
    this.removeAttribute("dragover");
    iterateChildren(this.$.items, (row) => {
      updateStringRowStates(row, { dragover: null });
    });
  }
  /** @private */
  __updateDragSourceParts(row, model) {
    updateBooleanRowStates(row, { "drag-source": this.__draggedItems.includes(model.item) });
  }
  /** @private */
  _onDrop(e2) {
    if (this.dropMode) {
      e2.stopPropagation();
      e2.preventDefault();
      const dragData = e2.dataTransfer.types && Array.from(e2.dataTransfer.types).map((type) => {
        return {
          type,
          data: e2.dataTransfer.getData(type)
        };
      });
      this._clearDragStyles();
      const event = new CustomEvent("grid-drop", {
        bubbles: e2.bubbles,
        cancelable: e2.cancelable,
        detail: {
          dropTargetItem: this._dragOverItem,
          dropLocation: this._dropLocation,
          dragData
        }
      });
      event.originalEvent = e2;
      this.dispatchEvent(event);
    }
  }
  /** @private */
  __formatDefaultTransferData(rows) {
    return rows.map((row) => {
      return Array.from(row.children).filter((cell) => !cell.hidden && cell.getAttribute("part").indexOf("details-cell") === -1).sort((a3, b2) => {
        return a3._column._order > b2._column._order ? 1 : -1;
      }).map((cell) => cell._content.textContent.trim()).filter((content) => content).join("	");
    }).join("\n");
  }
  /** @private */
  _dragDropAccessChanged() {
    this.filterDragAndDrop();
  }
  /**
   * Runs the `dragFilter` and `dropFilter` hooks for the visible cells.
   * If the filter depends on varying conditions, you may need to
   * call this function manually in order to update the draggability when
   * the conditions change.
   */
  filterDragAndDrop() {
    iterateChildren(this.$.items, (row) => {
      if (!row.hidden) {
        this._filterDragAndDrop(row, this.__getRowModel(row));
      }
    });
  }
  /**
   * @param {!HTMLElement} row
   * @param {!GridItemModel} model
   * @protected
   */
  _filterDragAndDrop(row, model) {
    const loading = this.loading || row.hasAttribute("loading");
    const dragDisabled = !this.rowsDraggable || loading || this.dragFilter && !this.dragFilter(model);
    const dropDisabled = !this.dropMode || loading || this.dropFilter && !this.dropFilter(model);
    iterateRowCells(row, (cell) => {
      if (dragDisabled) {
        cell._content.removeAttribute("draggable");
      } else {
        cell._content.setAttribute("draggable", true);
      }
    });
    updateBooleanRowStates(row, {
      "drag-disabled": !!dragDisabled,
      "drop-disabled": !!dropDisabled
    });
  }
  /**
   * Fired when starting to drag grid rows.
   *
   * @event grid-dragstart
   * @param {Object} originalEvent The native dragstart event
   * @param {Object} detail
   * @param {Object} detail.draggedItems the items in the visible viewport that are dragged
   * @param {Function} detail.setDraggedItemsCount Overrides the default number shown in the drag image on multi row drag.
   * Parameter is of type number.
   * @param {Function} detail.setDragData Sets dataTransfer data for the drag operation.
   * Note that "text" is the only data type supported by all the browsers the grid currently supports (including IE11).
   * The function takes two parameters:
   * - type:string The type of the data
   * - data:string The data
   */
  /**
   * Fired when the dragging of the rows ends.
   *
   * @event grid-dragend
   * @param {Object} originalEvent The native dragend event
   */
  /**
   * Fired when a drop occurs on top of the grid.
   *
   * @event grid-drop
   * @param {Object} originalEvent The native drop event
   * @param {Object} detail
   * @param {Object} detail.dropTargetItem The item of the grid row on which the drop occurred.
   * @param {string} detail.dropLocation The position at which the drop event took place relative to a row.
   * Depending on the dropMode value, the drop location can be one of the following
   * - `on-top`: when the drop occurred on top of the row
   * - `above`: when the drop occurred above the row
   * - `below`: when the drop occurred below the row
   * - `empty`: when the drop occurred over the grid, not relative to any specific row
   * @param {string} detail.dragData An array of items with the payload as a string representation as the
   * `data` property and the type of the data as `type` property.
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function arrayEquals(arr1, arr2) {
  if (!arr1 || !arr2 || arr1.length !== arr2.length) {
    return false;
  }
  for (let i2 = 0, l = arr1.length; i2 < l; i2++) {
    if (arr1[i2] instanceof Array && arr2[i2] instanceof Array) {
      if (!arrayEquals(arr1[i2], arr2[i2])) {
        return false;
      }
    } else if (arr1[i2] !== arr2[i2]) {
      return false;
    }
  }
  return true;
}
const DynamicColumnsMixin = (superClass) => class DynamicColumnsMixin extends superClass {
  static get properties() {
    return {
      /**
       * @protected
       */
      _columnTree: Object
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this._addNodeObserver();
  }
  /** @private */
  _hasColumnGroups(columns) {
    return columns.some((column) => column.localName === "vaadin-grid-column-group");
  }
  /**
   * @param {!GridColumnGroup} el
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getChildColumns(el) {
    return ColumnObserver.getColumns(el);
  }
  /** @private */
  _flattenColumnGroups(columns) {
    return columns.map((col) => {
      if (col.localName === "vaadin-grid-column-group") {
        return this._getChildColumns(col);
      }
      return [col];
    }).reduce((prev, curr) => {
      return prev.concat(curr);
    }, []);
  }
  /** @private */
  _getColumnTree() {
    const rootColumns = ColumnObserver.getColumns(this);
    const columnTree = [rootColumns];
    let c2 = rootColumns;
    while (this._hasColumnGroups(c2)) {
      c2 = this._flattenColumnGroups(c2);
      columnTree.push(c2);
    }
    return columnTree;
  }
  /** @protected */
  _debounceUpdateColumnTree() {
    this.__updateColumnTreeDebouncer = Debouncer$1.debounce(
      this.__updateColumnTreeDebouncer,
      microTask,
      () => this._updateColumnTree()
    );
  }
  /** @protected */
  _updateColumnTree() {
    const columnTree = this._getColumnTree();
    if (!arrayEquals(columnTree, this._columnTree)) {
      columnTree.forEach((columnArray) => {
        columnArray.forEach((column) => {
          if (column.performUpdate) {
            column.performUpdate();
          }
        });
      });
      this._columnTree = columnTree;
    }
  }
  /** @private */
  _addNodeObserver() {
    this._observer = new ColumnObserver(this, (_addedColumns, removedColumns) => {
      const allRemovedCells = removedColumns.flatMap((c2) => c2._allCells);
      const filterNotConnected = (element) => allRemovedCells.filter((cell) => cell && cell._content.contains(element)).length;
      this.__removeSorters(this._sorters.filter(filterNotConnected));
      this.__removeFilters(this._filters.filter(filterNotConnected));
      this._debounceUpdateColumnTree();
      this._debouncerCheckImports = Debouncer$1.debounce(
        this._debouncerCheckImports,
        timeOut.after(2e3),
        this._checkImports.bind(this)
      );
      this._ensureFirstPageLoaded();
    });
  }
  /** @protected */
  _checkImports() {
    [
      "vaadin-grid-column-group",
      "vaadin-grid-filter",
      "vaadin-grid-filter-column",
      "vaadin-grid-tree-toggle",
      "vaadin-grid-selection-column",
      "vaadin-grid-sort-column",
      "vaadin-grid-sorter"
    ].forEach((elementName) => {
      const element = this.querySelector(elementName);
      if (element && !customElements.get(elementName)) {
        console.warn(`Make sure you have imported the required module for <${elementName}> element.`);
      }
    });
  }
  /** @protected */
  _updateFirstAndLastColumn() {
    Array.from(this.shadowRoot.querySelectorAll("tr")).forEach((row) => this._updateFirstAndLastColumnForRow(row));
  }
  /**
   * @param {!HTMLElement} row
   * @protected
   */
  _updateFirstAndLastColumnForRow(row) {
    Array.from(row.querySelectorAll('[part~="cell"]:not([part~="details-cell"])')).sort((a3, b2) => {
      return a3._column._order - b2._column._order;
    }).forEach((cell, cellIndex, children) => {
      updateCellState(cell, "first-column", cellIndex === 0);
      updateCellState(cell, "last-column", cellIndex === children.length - 1);
    });
  }
  /**
   * @param {!Node} node
   * @return {boolean}
   * @protected
   */
  _isColumnElement(node) {
    return node.nodeType === Node.ELEMENT_NODE && /\bcolumn\b/u.test(node.localName);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const EventContextMixin = (superClass) => class EventContextMixin extends superClass {
  /**
   * Returns an object with context information about the event target:
   * - `item`: the data object corresponding to the targeted row (not specified when targeting header or footer)
   * - `column`: the column element corresponding to the targeted cell (not specified when targeting row details)
   * - `section`: whether the event targeted the body, header, footer or details of the grid
   *
   * These additional properties are included when `item` is specified:
   * - `index`: the index of the item
   * - `selected`: the selected state of the item
   * - `detailsOpened`: whether the row details are open for the item
   * - `expanded`: the expanded state of the tree toggle
   * - `level`: the tree hierarchy level
   *
   * The returned object is populated only when a grid cell, header, footer or row details is found in `event.composedPath()`.
   * This means mostly mouse and keyboard events. If such a grid part is not found in the path, an empty object is returned.
   * This may be the case eg. if the event is fired on the `<vaadin-grid>` element and not any deeper in the DOM, or if
   * the event targets the empty part of the grid body.
   *
   * @param {!Event} event
   * @return {GridEventContext}
   */
  getEventContext(event) {
    const context = {};
    const { cell } = this._getGridEventLocation(event);
    if (!cell) {
      return context;
    }
    context.section = ["body", "header", "footer", "details"].find(
      (section) => cell.getAttribute("part").indexOf(section) > -1
    );
    if (cell._column) {
      context.column = cell._column;
    }
    if (context.section === "body" || context.section === "details") {
      Object.assign(context, this.__getRowModel(cell.parentElement));
    }
    return context;
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const FilterMixin = (superClass) => class FilterMixin extends superClass {
  static get properties() {
    return {
      /** @private */
      _filters: {
        type: Array,
        value: () => []
      }
    };
  }
  constructor() {
    super();
    this._filterChanged = this._filterChanged.bind(this);
    this.addEventListener("filter-changed", this._filterChanged);
  }
  /** @private */
  _filterChanged(e2) {
    e2.stopPropagation();
    this.__addFilter(e2.target);
    this.__applyFilters();
  }
  /** @private */
  __removeFilters(filtersToRemove) {
    if (filtersToRemove.length === 0) {
      return;
    }
    this._filters = this._filters.filter((filter2) => filtersToRemove.indexOf(filter2) < 0);
    this.__applyFilters();
  }
  /** @private */
  __addFilter(filter2) {
    const filterIndex = this._filters.indexOf(filter2);
    if (filterIndex === -1) {
      this._filters.push(filter2);
    }
  }
  /** @private */
  __applyFilters() {
    if (this.dataProvider && this.isAttached) {
      this.clearCache();
    }
  }
  /**
   * @return {!Array<!GridFilterDefinition>}
   * @protected
   */
  _mapFilters() {
    return this._filters.map((filter2) => {
      return {
        path: filter2.path,
        value: filter2.value
      };
    });
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function isRow(element) {
  return element instanceof HTMLTableRowElement;
}
function isCell(element) {
  return element instanceof HTMLTableCellElement;
}
function isDetailsCell(element) {
  return element.matches('[part~="details-cell"]');
}
const KeyboardNavigationMixin = (superClass) => class KeyboardNavigationMixin extends superClass {
  static get properties() {
    return {
      /** @private */
      _headerFocusable: {
        type: Object,
        observer: "_focusableChanged",
        sync: true
      },
      /**
       * @type {!HTMLElement | undefined}
       * @protected
       */
      _itemsFocusable: {
        type: Object,
        observer: "_focusableChanged",
        sync: true
      },
      /** @private */
      _footerFocusable: {
        type: Object,
        observer: "_focusableChanged",
        sync: true
      },
      /** @private */
      _navigatingIsHidden: Boolean,
      /**
       * @type {number}
       * @protected
       */
      _focusedItemIndex: {
        type: Number,
        value: 0
      },
      /** @private */
      _focusedColumnOrder: Number,
      /** @private */
      _focusedCell: {
        type: Object,
        observer: "_focusedCellChanged",
        sync: true
      },
      /**
       * Indicates whether the grid is currently in interaction mode.
       * In interaction mode the user is currently interacting with a control,
       * such as an input or a select, within a cell.
       * In interaction mode keyboard navigation between cells is disabled.
       * Interaction mode also prevents the focus target cell of that section of
       * the grid from receiving focus, allowing the user to switch focus to
       * controls in adjacent cells, rather than focussing the outer cell
       * itself.
       * @type {boolean}
       * @private
       */
      interacting: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        readOnly: true,
        observer: "_interactingChanged"
      }
    };
  }
  /** @private */
  get __rowFocusMode() {
    return [this._headerFocusable, this._itemsFocusable, this._footerFocusable].some(isRow);
  }
  set __rowFocusMode(value) {
    ["_itemsFocusable", "_footerFocusable", "_headerFocusable"].forEach((prop) => {
      const focusable = this[prop];
      if (value) {
        const parent = focusable && focusable.parentElement;
        if (isCell(focusable)) {
          this[prop] = parent;
        } else if (isCell(parent)) {
          this[prop] = parent.parentElement;
        }
      } else if (!value && isRow(focusable)) {
        const cell = focusable.firstElementChild;
        this[prop] = cell._focusButton || cell;
      }
    });
  }
  /** @private */
  get _visibleItemsCount() {
    return this._lastVisibleIndex - this._firstVisibleIndex - 1;
  }
  /** @protected */
  ready() {
    super.ready();
    if (this._ios || this._android) {
      return;
    }
    this.addEventListener("keydown", this._onKeyDown);
    this.addEventListener("keyup", this._onKeyUp);
    this.addEventListener("focusin", this._onFocusIn);
    this.addEventListener("focusout", this._onFocusOut);
    this.$.table.addEventListener("focusin", this._onContentFocusIn.bind(this));
    this.addEventListener("mousedown", () => {
      this.toggleAttribute("navigating", false);
      this._isMousedown = true;
      this._focusedColumnOrder = void 0;
    });
    this.addEventListener("mouseup", () => {
      this._isMousedown = false;
    });
  }
  /** @private */
  _focusableChanged(focusable, oldFocusable) {
    if (oldFocusable) {
      oldFocusable.setAttribute("tabindex", "-1");
    }
    if (focusable) {
      this._updateGridSectionFocusTarget(focusable);
    }
  }
  /** @private */
  _focusedCellChanged(focusedCell, oldFocusedCell) {
    if (oldFocusedCell) {
      removeValueFromAttribute(oldFocusedCell, "part", "focused-cell");
    }
    if (focusedCell) {
      addValueToAttribute(focusedCell, "part", "focused-cell");
    }
  }
  /** @private */
  _interactingChanged() {
    this._updateGridSectionFocusTarget(this._headerFocusable);
    this._updateGridSectionFocusTarget(this._itemsFocusable);
    this._updateGridSectionFocusTarget(this._footerFocusable);
  }
  /**
   * Since the focused cell/row state is stored as an element reference, the reference may get
   * out of sync when the virtual indexes for elements update due to effective size change.
   * This function updates the reference to the correct element after a possible index change.
   * @private
   */
  __updateItemsFocusable() {
    if (!this._itemsFocusable) {
      return;
    }
    const wasFocused = this.shadowRoot.activeElement === this._itemsFocusable;
    this._getRenderedRows().forEach((row) => {
      if (row.index === this._focusedItemIndex) {
        if (this.__rowFocusMode) {
          this._itemsFocusable = row;
        } else {
          let parent = this._itemsFocusable.parentElement;
          let cell = this._itemsFocusable;
          if (parent) {
            if (isCell(parent)) {
              cell = parent;
              parent = parent.parentElement;
            }
            const cellIndex = [...parent.children].indexOf(cell);
            this._itemsFocusable = this.__getFocusable(row, row.children[cellIndex]);
          }
        }
      }
    });
    if (wasFocused) {
      this._itemsFocusable.focus();
    }
  }
  /**
   * @param {!KeyboardEvent} e
   * @protected
   */
  _onKeyDown(e2) {
    const key = e2.key;
    let keyGroup;
    switch (key) {
      case "ArrowUp":
      case "ArrowDown":
      case "ArrowLeft":
      case "ArrowRight":
      case "PageUp":
      case "PageDown":
      case "Home":
      case "End":
        keyGroup = "Navigation";
        break;
      case "Enter":
      case "Escape":
      case "F2":
        keyGroup = "Interaction";
        break;
      case "Tab":
        keyGroup = "Tab";
        break;
      case " ":
        keyGroup = "Space";
        break;
    }
    this._detectInteracting(e2);
    if (this.interacting && keyGroup !== "Interaction") {
      keyGroup = void 0;
    }
    if (keyGroup) {
      this[`_on${keyGroup}KeyDown`](e2, key);
    }
  }
  /** @private */
  __ensureFlatIndexInViewport(index) {
    const targetRowInDom = [...this.$.items.children].find((child) => child.index === index);
    if (!targetRowInDom) {
      this._scrollToFlatIndex(index);
    } else {
      this.__scrollIntoViewport(index);
    }
  }
  /** @private */
  __isRowExpandable(row) {
    if (this.itemHasChildrenPath) {
      const item2 = row._item;
      return !!(item2 && get$1(this.itemHasChildrenPath, item2) && !this._isExpanded(item2));
    }
  }
  /** @private */
  __isRowCollapsible(row) {
    return this._isExpanded(row._item);
  }
  /** @private */
  _onNavigationKeyDown(e2, key) {
    e2.preventDefault();
    const isRTL = this.__isRTL;
    const activeRow = e2.composedPath().find(isRow);
    const activeCell = e2.composedPath().find(isCell);
    let dx = 0, dy = 0;
    switch (key) {
      case "ArrowRight":
        dx = isRTL ? -1 : 1;
        break;
      case "ArrowLeft":
        dx = isRTL ? 1 : -1;
        break;
      case "Home":
        if (this.__rowFocusMode) {
          dy = -Infinity;
        } else if (e2.ctrlKey) {
          dy = -Infinity;
        } else {
          dx = -Infinity;
        }
        break;
      case "End":
        if (this.__rowFocusMode) {
          dy = Infinity;
        } else if (e2.ctrlKey) {
          dy = Infinity;
        } else {
          dx = Infinity;
        }
        break;
      case "ArrowDown":
        dy = 1;
        break;
      case "ArrowUp":
        dy = -1;
        break;
      case "PageDown":
        if (this.$.items.contains(activeRow)) {
          const currentRowIndex = this.__getIndexInGroup(activeRow, this._focusedItemIndex);
          this._scrollToFlatIndex(currentRowIndex);
        }
        dy = this._visibleItemsCount;
        break;
      case "PageUp":
        dy = -this._visibleItemsCount;
        break;
    }
    if (this.__rowFocusMode && !activeRow || !this.__rowFocusMode && !activeCell) {
      return;
    }
    const forwardsKey = isRTL ? "ArrowLeft" : "ArrowRight";
    const backwardsKey = isRTL ? "ArrowRight" : "ArrowLeft";
    if (key === forwardsKey) {
      if (this.__rowFocusMode) {
        if (this.__isRowExpandable(activeRow)) {
          this.expandItem(activeRow._item);
          return;
        }
        this.__rowFocusMode = false;
        this._onCellNavigation(activeRow.firstElementChild, 0, 0);
        return;
      }
    } else if (key === backwardsKey) {
      if (this.__rowFocusMode) {
        if (this.__isRowCollapsible(activeRow)) {
          this.collapseItem(activeRow._item);
          return;
        }
      } else {
        const activeRowCells = [...activeRow.children].sort((a3, b2) => a3._order - b2._order);
        if (activeCell === activeRowCells[0] || isDetailsCell(activeCell)) {
          this.__rowFocusMode = true;
          this._onRowNavigation(activeRow, 0);
          return;
        }
      }
    }
    if (this.__rowFocusMode) {
      this._onRowNavigation(activeRow, dy);
    } else {
      this._onCellNavigation(activeCell, dx, dy);
    }
  }
  /**
   * Focuses the target row after navigating by the given dy offset.
   * If the row is not in the viewport, it is first scrolled to.
   * @private
   */
  _onRowNavigation(activeRow, dy) {
    const { dstRow } = this.__navigateRows(dy, activeRow);
    if (dstRow) {
      dstRow.focus();
    }
  }
  /** @private */
  __getIndexInGroup(row, bodyFallbackIndex) {
    const rowGroup = row.parentNode;
    if (rowGroup === this.$.items) {
      return bodyFallbackIndex !== void 0 ? bodyFallbackIndex : row.index;
    }
    return [...rowGroup.children].indexOf(row);
  }
  /**
   * Returns the target row after navigating by the given dy offset.
   * Also returns information whether the details cell should be the target on the target row.
   * If the row is not in the viewport, it is first scrolled to.
   * @private
   */
  __navigateRows(dy, activeRow, activeCell) {
    const currentRowIndex = this.__getIndexInGroup(activeRow, this._focusedItemIndex);
    const activeRowGroup = activeRow.parentNode;
    const maxRowIndex = (activeRowGroup === this.$.items ? this._flatSize : activeRowGroup.children.length) - 1;
    let dstRowIndex = Math.max(0, Math.min(currentRowIndex + dy, maxRowIndex));
    if (activeRowGroup !== this.$.items) {
      if (dstRowIndex > currentRowIndex) {
        while (dstRowIndex < maxRowIndex && activeRowGroup.children[dstRowIndex].hidden) {
          dstRowIndex += 1;
        }
      } else if (dstRowIndex < currentRowIndex) {
        while (dstRowIndex > 0 && activeRowGroup.children[dstRowIndex].hidden) {
          dstRowIndex -= 1;
        }
      }
      this.toggleAttribute("navigating", true);
      return { dstRow: activeRowGroup.children[dstRowIndex] };
    }
    let dstIsRowDetails = false;
    if (activeCell) {
      const isRowDetails = isDetailsCell(activeCell);
      if (activeRowGroup === this.$.items) {
        const item2 = activeRow._item;
        const { item: dstItem } = this._dataProviderController.getFlatIndexContext(dstRowIndex);
        if (isRowDetails) {
          dstIsRowDetails = dy === 0;
        } else {
          dstIsRowDetails = dy === 1 && this._isDetailsOpened(item2) || dy === -1 && dstRowIndex !== currentRowIndex && this._isDetailsOpened(dstItem);
        }
        if (dstIsRowDetails !== isRowDetails && (dy === 1 && dstIsRowDetails || dy === -1 && !dstIsRowDetails)) {
          dstRowIndex = currentRowIndex;
        }
      }
    }
    this.__ensureFlatIndexInViewport(dstRowIndex);
    this._focusedItemIndex = dstRowIndex;
    this.toggleAttribute("navigating", true);
    return {
      dstRow: [...activeRowGroup.children].find((el) => !el.hidden && el.index === dstRowIndex),
      dstIsRowDetails
    };
  }
  /**
   * Focuses the target cell after navigating by the given dx and dy offset.
   * If the cell is not in the viewport, it is first scrolled to.
   * @private
   */
  _onCellNavigation(activeCell, dx, dy) {
    const activeRow = activeCell.parentNode;
    const { dstRow, dstIsRowDetails } = this.__navigateRows(dy, activeRow, activeCell);
    if (!dstRow) {
      return;
    }
    let columnIndex = [...activeRow.children].indexOf(activeCell);
    if (this.$.items.contains(activeCell)) {
      columnIndex = [...this.$.sizer.children].findIndex((sizerCell) => sizerCell._column === activeCell._column);
    }
    const isCurrentCellRowDetails = isDetailsCell(activeCell);
    const activeRowGroup = activeRow.parentNode;
    const currentRowIndex = this.__getIndexInGroup(activeRow, this._focusedItemIndex);
    if (this._focusedColumnOrder === void 0) {
      if (isCurrentCellRowDetails) {
        this._focusedColumnOrder = 0;
      } else {
        this._focusedColumnOrder = this._getColumns(activeRowGroup, currentRowIndex).filter((c2) => !c2.hidden)[columnIndex]._order;
      }
    }
    if (dstIsRowDetails) {
      const dstCell = [...dstRow.children].find(isDetailsCell);
      dstCell.focus();
    } else {
      const dstRowIndex = this.__getIndexInGroup(dstRow, this._focusedItemIndex);
      const dstColumns = this._getColumns(activeRowGroup, dstRowIndex).filter((c2) => !c2.hidden);
      const dstSortedColumnOrders = dstColumns.map((c2) => c2._order).sort((b2, a3) => b2 - a3);
      const maxOrderedColumnIndex = dstSortedColumnOrders.length - 1;
      const orderedColumnIndex = dstSortedColumnOrders.indexOf(
        dstSortedColumnOrders.slice(0).sort((b2, a3) => Math.abs(b2 - this._focusedColumnOrder) - Math.abs(a3 - this._focusedColumnOrder))[0]
      );
      const dstOrderedColumnIndex = dy === 0 && isCurrentCellRowDetails ? orderedColumnIndex : Math.max(0, Math.min(orderedColumnIndex + dx, maxOrderedColumnIndex));
      if (dstOrderedColumnIndex !== orderedColumnIndex) {
        this._focusedColumnOrder = void 0;
      }
      const columnIndexByOrder = dstColumns.reduce((acc, col, i2) => {
        acc[col._order] = i2;
        return acc;
      }, {});
      const dstColumnIndex = columnIndexByOrder[dstSortedColumnOrders[dstOrderedColumnIndex]];
      let dstCell;
      if (this.$.items.contains(activeCell)) {
        const dstSizerCell = this.$.sizer.children[dstColumnIndex];
        if (this._lazyColumns) {
          if (!this.__isColumnInViewport(dstSizerCell._column)) {
            dstSizerCell.scrollIntoView();
          }
          this.__updateColumnsBodyContentHidden();
          this.__updateHorizontalScrollPosition();
        }
        dstCell = [...dstRow.children].find((cell) => cell._column === dstSizerCell._column);
        this._scrollHorizontallyToCell(dstCell);
      } else {
        dstCell = dstRow.children[dstColumnIndex];
        this._scrollHorizontallyToCell(dstCell);
      }
      dstCell.focus();
    }
  }
  /** @private */
  _onInteractionKeyDown(e2, key) {
    const localTarget = e2.composedPath()[0];
    const localTargetIsTextInput = localTarget.localName === "input" && !/^(button|checkbox|color|file|image|radio|range|reset|submit)$/iu.test(localTarget.type);
    let wantInteracting;
    switch (key) {
      case "Enter":
        wantInteracting = this.interacting ? !localTargetIsTextInput : true;
        break;
      case "Escape":
        wantInteracting = false;
        break;
      case "F2":
        wantInteracting = !this.interacting;
        break;
    }
    const { cell } = this._getGridEventLocation(e2);
    if (this.interacting !== wantInteracting && cell !== null) {
      if (wantInteracting) {
        const focusTarget = cell._content.querySelector("[focus-target]") || // If a child element hasn't been explicitly marked as a focus target,
        // fall back to any focusable element inside the cell.
        [...cell._content.querySelectorAll("*")].find((node) => this._isFocusable(node));
        if (focusTarget) {
          e2.preventDefault();
          focusTarget.focus();
          this._setInteracting(true);
          this.toggleAttribute("navigating", false);
        }
      } else {
        e2.preventDefault();
        this._focusedColumnOrder = void 0;
        cell.focus();
        this._setInteracting(false);
        this.toggleAttribute("navigating", true);
      }
    }
    if (key === "Escape") {
      this._hideTooltip(true);
    }
  }
  /** @private */
  _predictFocusStepTarget(srcElement, step) {
    const tabOrder = [
      this.$.table,
      this._headerFocusable,
      this.__emptyState ? this.$.emptystatecell : this._itemsFocusable,
      this._footerFocusable,
      this.$.focusexit
    ];
    let index = tabOrder.indexOf(srcElement);
    index += step;
    while (index >= 0 && index <= tabOrder.length - 1) {
      let rowElement = tabOrder[index];
      if (rowElement && !this.__rowFocusMode) {
        rowElement = tabOrder[index].parentNode;
      }
      if (!rowElement || rowElement.hidden) {
        index += step;
      } else {
        break;
      }
    }
    let focusStepTarget = tabOrder[index];
    if (focusStepTarget && !this.__isHorizontallyInViewport(focusStepTarget)) {
      const firstVisibleColumn = this._getColumnsInOrder().find((column) => this.__isColumnInViewport(column));
      if (firstVisibleColumn) {
        if (focusStepTarget === this._headerFocusable) {
          focusStepTarget = firstVisibleColumn._headerCell;
        } else if (focusStepTarget === this._itemsFocusable) {
          const rowIndex = focusStepTarget._column._cells.indexOf(focusStepTarget);
          focusStepTarget = firstVisibleColumn._cells[rowIndex];
        } else if (focusStepTarget === this._footerFocusable) {
          focusStepTarget = firstVisibleColumn._footerCell;
        }
      }
    }
    return focusStepTarget;
  }
  /** @private */
  _onTabKeyDown(e2) {
    let focusTarget = this._predictFocusStepTarget(e2.composedPath()[0], e2.shiftKey ? -1 : 1);
    if (!focusTarget) {
      return;
    }
    e2.stopPropagation();
    if (focusTarget === this._itemsFocusable) {
      this.__ensureFlatIndexInViewport(this._focusedItemIndex);
      this.__updateItemsFocusable();
      focusTarget = this._itemsFocusable;
    }
    focusTarget.focus();
    if (focusTarget !== this.$.table && focusTarget !== this.$.focusexit) {
      e2.preventDefault();
    }
    this.toggleAttribute("navigating", true);
  }
  /** @private */
  _onSpaceKeyDown(e2) {
    e2.preventDefault();
    const element = e2.composedPath()[0];
    const isElementRow = isRow(element);
    if (isElementRow || !element._content || !element._content.firstElementChild) {
      this.dispatchEvent(
        new CustomEvent(isElementRow ? "row-activate" : "cell-activate", {
          detail: {
            model: this.__getRowModel(isElementRow ? element : element.parentElement)
          }
        })
      );
    }
  }
  /** @private */
  _onKeyUp(e2) {
    if (!/^( |SpaceBar)$/u.test(e2.key) || this.interacting) {
      return;
    }
    e2.preventDefault();
    const cell = e2.composedPath()[0];
    if (cell._content && cell._content.firstElementChild) {
      const wasNavigating = this.hasAttribute("navigating");
      cell._content.firstElementChild.dispatchEvent(
        new MouseEvent("click", {
          shiftKey: e2.shiftKey,
          bubbles: true,
          composed: true,
          cancelable: true
        })
      );
      this.toggleAttribute("navigating", wasNavigating);
    }
  }
  /**
   * @param {!FocusEvent} e
   * @protected
   */
  _onFocusIn(e2) {
    if (!this._isMousedown) {
      this.toggleAttribute("navigating", true);
    }
    const rootTarget = e2.composedPath()[0];
    if (rootTarget === this.$.table || rootTarget === this.$.focusexit) {
      if (!this._isMousedown) {
        this._predictFocusStepTarget(rootTarget, rootTarget === this.$.table ? 1 : -1).focus();
      }
      this._setInteracting(false);
    } else {
      this._detectInteracting(e2);
    }
  }
  /**
   * @param {!FocusEvent} e
   * @protected
   */
  _onFocusOut(e2) {
    this.toggleAttribute("navigating", false);
    this._detectInteracting(e2);
    this._hideTooltip();
    this._focusedCell = null;
  }
  /** @private */
  _onContentFocusIn(e2) {
    const { section, cell, row } = this._getGridEventLocation(e2);
    if (!cell && !this.__rowFocusMode) {
      return;
    }
    this._detectInteracting(e2);
    if (section && (cell || row)) {
      this._activeRowGroup = section;
      if (section === this.$.header) {
        this._headerFocusable = this.__getFocusable(row, cell);
      } else if (section === this.$.items) {
        this._itemsFocusable = this.__getFocusable(row, cell);
        this._focusedItemIndex = row.index;
      } else if (section === this.$.footer) {
        this._footerFocusable = this.__getFocusable(row, cell);
      }
      if (cell) {
        const context = this.getEventContext(e2);
        this.__pendingBodyCellFocus = this.loading && context.section === "body";
        if (!this.__pendingBodyCellFocus && cell !== this.$.emptystatecell) {
          cell.dispatchEvent(new CustomEvent("cell-focus", { bubbles: true, composed: true, detail: { context } }));
        }
        this._focusedCell = cell._focusButton || cell;
        if (isKeyboardActive() && e2.target === cell) {
          this._showTooltip(e2);
        }
      } else {
        this._focusedCell = null;
      }
    }
  }
  /**
   * @private
   */
  __dispatchPendingBodyCellFocus() {
    if (this.__pendingBodyCellFocus && this.shadowRoot.activeElement === this._itemsFocusable) {
      this._itemsFocusable.dispatchEvent(new Event("focusin", { bubbles: true, composed: true }));
    }
  }
  /**
   * Get the focusable element depending on the current focus mode.
   * It can be a row, a cell, or a focusable div inside a cell.
   *
   * @param {HTMLElement} row
   * @param {HTMLElement} cell
   * @return {HTMLElement}
   * @private
   */
  __getFocusable(row, cell) {
    return this.__rowFocusMode ? row : cell._focusButton || cell;
  }
  /**
   * Enables interaction mode if a cells descendant receives focus or keyboard
   * input. Disables it if the event is not related to cell content.
   * @param {!KeyboardEvent|!FocusEvent} e
   * @private
   */
  _detectInteracting(e2) {
    const isInteracting = e2.composedPath().some((el) => el.localName === "slot" && this.shadowRoot.contains(el));
    this._setInteracting(isInteracting);
    this.__updateHorizontalScrollPosition();
  }
  /**
   * Enables or disables the focus target of the containing section of the
   * grid from receiving focus, based on whether the user is interacting with
   * that section of the grid.
   * @param {HTMLElement} focusTarget
   * @private
   */
  _updateGridSectionFocusTarget(focusTarget) {
    if (!focusTarget) {
      return;
    }
    const section = this._getGridSectionFromFocusTarget(focusTarget);
    const isInteractingWithinActiveSection = this.interacting && section === this._activeRowGroup;
    focusTarget.tabIndex = isInteractingWithinActiveSection ? -1 : 0;
  }
  /** @protected */
  _preventScrollerRotatingCellFocus() {
    if (this._activeRowGroup !== this.$.items) {
      return;
    }
    this.__preventScrollerRotatingCellFocusDebouncer = Debouncer$1.debounce(
      this.__preventScrollerRotatingCellFocusDebouncer,
      animationFrame,
      () => {
        const isItemsRowGroupActive = this._activeRowGroup === this.$.items;
        const isFocusedItemRendered = this._getRenderedRows().some((row) => row.index === this._focusedItemIndex);
        if (isFocusedItemRendered) {
          this.__updateItemsFocusable();
          if (isItemsRowGroupActive && !this.__rowFocusMode) {
            this._focusedCell = this._itemsFocusable;
          }
          if (this._navigatingIsHidden) {
            this.toggleAttribute("navigating", true);
            this._navigatingIsHidden = false;
          }
        } else if (isItemsRowGroupActive) {
          this._focusedCell = null;
          if (this.hasAttribute("navigating")) {
            this._navigatingIsHidden = true;
            this.toggleAttribute("navigating", false);
          }
        }
      }
    );
  }
  /**
   * @param {HTMLTableSectionElement=} rowGroup
   * @param {number=} rowIndex
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getColumns(rowGroup, rowIndex) {
    let columnTreeLevel = this._columnTree.length - 1;
    if (rowGroup === this.$.header) {
      columnTreeLevel = rowIndex;
    } else if (rowGroup === this.$.footer) {
      columnTreeLevel = this._columnTree.length - 1 - rowIndex;
    }
    return this._columnTree[columnTreeLevel];
  }
  /** @private */
  __isValidFocusable(element) {
    return this.$.table.contains(element) && element.offsetHeight;
  }
  /** @protected */
  _resetKeyboardNavigation() {
    if (!this.$ && this.performUpdate) {
      this.performUpdate();
    }
    ["header", "footer"].forEach((section) => {
      if (!this.__isValidFocusable(this[`_${section}Focusable`])) {
        const firstVisibleRow = [...this.$[section].children].find((row) => row.offsetHeight);
        const firstVisibleCell = firstVisibleRow ? [...firstVisibleRow.children].find((cell) => !cell.hidden) : null;
        if (firstVisibleRow && firstVisibleCell) {
          this[`_${section}Focusable`] = this.__getFocusable(firstVisibleRow, firstVisibleCell);
        }
      }
    });
    if (!this.__isValidFocusable(this._itemsFocusable) && this.$.items.firstElementChild) {
      const firstVisibleRow = this.__getFirstVisibleItem();
      const firstVisibleCell = firstVisibleRow ? [...firstVisibleRow.children].find((cell) => !cell.hidden) : null;
      if (firstVisibleCell && firstVisibleRow) {
        this._focusedColumnOrder = void 0;
        this._itemsFocusable = this.__getFocusable(firstVisibleRow, firstVisibleCell);
      }
    } else {
      this.__updateItemsFocusable();
    }
  }
  /**
   * @param {!HTMLElement} dstCell
   * @protected
   */
  _scrollHorizontallyToCell(dstCell) {
    if (dstCell.hasAttribute("frozen") || dstCell.hasAttribute("frozen-to-end") || isDetailsCell(dstCell)) {
      return;
    }
    const dstCellRect = dstCell.getBoundingClientRect();
    const dstRow = dstCell.parentNode;
    const dstCellIndex = Array.from(dstRow.children).indexOf(dstCell);
    const tableRect = this.$.table.getBoundingClientRect();
    let leftBoundary = tableRect.left, rightBoundary = tableRect.right;
    for (let i2 = dstCellIndex - 1; i2 >= 0; i2--) {
      const cell = dstRow.children[i2];
      if (cell.hasAttribute("hidden") || isDetailsCell(cell)) {
        continue;
      }
      if (cell.hasAttribute("frozen") || cell.hasAttribute("frozen-to-end")) {
        leftBoundary = cell.getBoundingClientRect().right;
        break;
      }
    }
    for (let i2 = dstCellIndex + 1; i2 < dstRow.children.length; i2++) {
      const cell = dstRow.children[i2];
      if (cell.hasAttribute("hidden") || isDetailsCell(cell)) {
        continue;
      }
      if (cell.hasAttribute("frozen") || cell.hasAttribute("frozen-to-end")) {
        rightBoundary = cell.getBoundingClientRect().left;
        break;
      }
    }
    if (dstCellRect.left < leftBoundary) {
      this.$.table.scrollLeft += Math.round(dstCellRect.left - leftBoundary);
    }
    if (dstCellRect.right > rightBoundary) {
      this.$.table.scrollLeft += Math.round(dstCellRect.right - rightBoundary);
    }
  }
  /**
   * @typedef {Object} GridEventLocation
   * @property {HTMLTableSectionElement | null} section - The table section element that the event occurred in (header, body, or footer), or null if the event did not occur in a section
   * @property {HTMLTableRowElement | null} row - The row element that the event occurred in, or null if the event did not occur in a row
   * @property {HTMLTableCellElement | null} cell - The cell element that the event occurred in, or null if the event did not occur in a cell
   * @private
   */
  /**
   * Takes an event and returns a location object describing in which part of the grid the event occurred.
   * The event may either target table section, a row, a cell or contents of a cell.
   * @param {Event} e
   * @returns {GridEventLocation}
   * @protected
   */
  _getGridEventLocation(e2) {
    const path = e2.__composedPath || e2.composedPath();
    const tableIndex = path.indexOf(this.$.table);
    const section = tableIndex >= 1 ? path[tableIndex - 1] : null;
    const row = tableIndex >= 2 ? path[tableIndex - 2] : null;
    const cell = tableIndex >= 3 ? path[tableIndex - 3] : null;
    return {
      section,
      row,
      cell
    };
  }
  /**
   * Helper method that maps a focus target cell to the containing grid section
   * @param {HTMLElement} focusTarget
   * @returns {HTMLTableSectionElement | null}
   * @private
   */
  _getGridSectionFromFocusTarget(focusTarget) {
    if (focusTarget === this._headerFocusable) {
      return this.$.header;
    }
    if (focusTarget === this._itemsFocusable) {
      return this.$.items;
    }
    if (focusTarget === this._footerFocusable) {
      return this.$.footer;
    }
    return null;
  }
  /**
   * Fired when a cell is focused with click or keyboard navigation.
   *
   * Use context property of @see {@link GridCellFocusEvent} to get detail information about the event.
   *
   * @event cell-focus
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const RowDetailsMixin = (superClass) => class RowDetailsMixin extends superClass {
  static get properties() {
    return {
      /**
       * An array containing references to items with open row details.
       * @type {!Array<!GridItem>}
       */
      detailsOpenedItems: {
        type: Array,
        value: () => [],
        sync: true
      },
      /**
       * Custom function for rendering the content of the row details.
       * Receives three arguments:
       *
       * - `root` The row details content DOM element. Append your content to it.
       * - `grid` The `<vaadin-grid>` element.
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.level` The number of the item's tree sublevel, starts from 0.
       *   - `model.expanded` True if the item's tree sublevel is expanded.
       *   - `model.selected` True if the item is selected.
       *
       * @type {GridRowDetailsRenderer | null | undefined}
       */
      rowDetailsRenderer: {
        type: Function,
        sync: true
      },
      /**
       * @type {!Array<!HTMLElement> | undefined}
       * @protected
       */
      _detailsCells: {
        type: Array
      }
    };
  }
  static get observers() {
    return [
      "_detailsOpenedItemsChanged(detailsOpenedItems, rowDetailsRenderer)",
      "_rowDetailsRendererChanged(rowDetailsRenderer)"
    ];
  }
  /** @protected */
  ready() {
    super.ready();
    this._detailsCellResizeObserver = new ResizeObserver((entries) => {
      entries.forEach(({ target: cell }) => {
        this._updateDetailsCellHeight(cell.parentElement);
      });
      this.__virtualizer.__adapter._resizeHandler();
    });
  }
  /** @private */
  _rowDetailsRendererChanged(rowDetailsRenderer) {
    if (!rowDetailsRenderer) {
      return;
    }
    if (this._columnTree) {
      iterateChildren(this.$.items, (row) => {
        if (!row.querySelector("[part~=details-cell]")) {
          this._updateRow(row, this._columnTree[this._columnTree.length - 1]);
          const isDetailsOpened = this._isDetailsOpened(row._item);
          this._toggleDetailsCell(row, isDetailsOpened);
        }
      });
    }
  }
  /** @private */
  _detailsOpenedItemsChanged(_detailsOpenedItems, rowDetailsRenderer) {
    iterateChildren(this.$.items, (row) => {
      if (row.hasAttribute("details-opened")) {
        this._updateItem(row, row._item);
        return;
      }
      if (rowDetailsRenderer && this._isDetailsOpened(row._item)) {
        this._updateItem(row, row._item);
      }
    });
  }
  /**
   * @param {!HTMLElement} cell
   * @protected
   */
  _configureDetailsCell(cell) {
    cell.setAttribute("part", "cell details-cell");
    cell.toggleAttribute("frozen", true);
    this._detailsCellResizeObserver.observe(cell);
  }
  /**
   * @param {!HTMLElement} row
   * @param {!GridItem} item
   * @protected
   */
  _toggleDetailsCell(row, detailsOpened) {
    const cell = row.querySelector('[part~="details-cell"]');
    if (!cell) {
      return;
    }
    cell.hidden = !detailsOpened;
    if (cell.hidden) {
      return;
    }
    if (this.rowDetailsRenderer) {
      cell._renderer = this.rowDetailsRenderer;
    }
  }
  /** @protected */
  _updateDetailsCellHeight(row) {
    const cell = row.querySelector('[part~="details-cell"]');
    if (!cell) {
      return;
    }
    this.__updateDetailsRowPadding(row, cell);
    requestAnimationFrame(() => this.__updateDetailsRowPadding(row, cell));
  }
  /** @private */
  __updateDetailsRowPadding(row, cell) {
    if (cell.hidden) {
      row.style.removeProperty("padding-bottom");
    } else {
      row.style.setProperty("padding-bottom", `${cell.offsetHeight}px`);
    }
  }
  /** @protected */
  _updateDetailsCellHeights() {
    iterateChildren(this.$.items, (row) => {
      this._updateDetailsCellHeight(row);
    });
  }
  /**
   * @param {!GridItem} item
   * @return {boolean}
   * @protected
   */
  _isDetailsOpened(item2) {
    return this.detailsOpenedItems && this._getItemIndexInArray(item2, this.detailsOpenedItems) !== -1;
  }
  /**
   * Open the details row of a given item.
   * @param {!GridItem} item
   */
  openItemDetails(item2) {
    if (!this._isDetailsOpened(item2)) {
      this.detailsOpenedItems = [...this.detailsOpenedItems, item2];
    }
  }
  /**
   * Close the details row of a given item.
   * @param {!GridItem} item
   */
  closeItemDetails(item2) {
    if (this._isDetailsOpened(item2)) {
      this.detailsOpenedItems = this.detailsOpenedItems.filter((i2) => !this._itemsEqual(i2, item2));
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const timeouts = {
  SCROLLING: 500,
  UPDATE_CONTENT_VISIBILITY: 100
};
const ScrollMixin = (superClass) => class ScrollMixin extends ResizeMixin(superClass) {
  static get properties() {
    return {
      /**
       * Allows you to choose between modes for rendering columns in the grid:
       *
       * "eager" (default): All columns are rendered upfront, regardless of their visibility within the viewport.
       * This mode should generally be preferred, as it avoids the limitations imposed by the "lazy" mode.
       * Use this mode unless the grid has a large number of columns and performance outweighs the limitations
       * in priority.
       *
       * "lazy": Optimizes the rendering of cells when there are multiple columns in the grid by virtualizing
       * horizontal scrolling. In this mode, body cells are rendered only when their corresponding columns are
       * inside the visible viewport.
       *
       * Using "lazy" rendering should be used only if you're dealing with a large number of columns and performance
       * is your highest priority. For most use cases, the default "eager" mode is recommended due to the
       * limitations imposed by the "lazy" mode.
       *
       * When using the "lazy" mode, keep the following limitations in mind:
       *
       * - Row Height: When only a number of columns are visible at once, the height of a row can only be that of
       * the highest cell currently visible on that row. Make sure each cell on a single row has the same height
       * as all other cells on that row. If row cells have different heights, users may experience jumpiness when
       * scrolling the grid horizontally as lazily rendered cells with different heights are scrolled into view.
       *
       * - Auto-width Columns: For the columns that are initially outside the visible viewport but still use auto-width,
       * only the header content is taken into account when calculating the column width because the body cells
       * of the columns outside the viewport are not initially rendered.
       *
       * - Screen Reader Compatibility: Screen readers may not be able to associate the focused cells with the correct
       * headers when only a subset of the body cells on a row is rendered.
       *
       * - Keyboard Navigation: Tabbing through focusable elements inside the grid body may not work as expected because
       * some of the columns that would include focusable elements in the body cells may be outside the visible viewport
       * and thus not rendered.
       *
       * @attr {eager|lazy} column-rendering
       * @type {!ColumnRendering}
       */
      columnRendering: {
        type: String,
        value: "eager",
        sync: true
      },
      /**
       * Cached array of frozen cells
       * @private
       */
      _frozenCells: {
        type: Array,
        value: () => []
      },
      /**
       * Cached array of cells frozen to end
       * @private
       */
      _frozenToEndCells: {
        type: Array,
        value: () => []
      }
    };
  }
  static get observers() {
    return ["__columnRenderingChanged(_columnTree, columnRendering)"];
  }
  /** @private */
  get _scrollLeft() {
    return this.$.table.scrollLeft;
  }
  /** @private */
  get _scrollTop() {
    return this.$.table.scrollTop;
  }
  /**
   * Override (from iron-scroll-target-behavior) to avoid document scroll
   * @private
   */
  set _scrollTop(top) {
    this.$.table.scrollTop = top;
  }
  /** @protected */
  get _lazyColumns() {
    return this.columnRendering === "lazy";
  }
  /** @protected */
  ready() {
    super.ready();
    this.scrollTarget = this.$.table;
    this.$.items.addEventListener("focusin", (e2) => {
      const composedPath = e2.composedPath();
      const row = composedPath[composedPath.indexOf(this.$.items) - 1];
      if (row) {
        if (!this._isMousedown) {
          this.__scrollIntoViewport(row.index);
        }
        if (!this.$.table.contains(e2.relatedTarget)) {
          this.$.table.dispatchEvent(new CustomEvent("virtualizer-element-focused", { detail: { element: row } }));
        }
      }
    });
    this.$.table.addEventListener("scroll", () => this._afterScroll());
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this._updateOverflow();
    this.__updateHorizontalScrollPosition();
    if (this._firefox) {
      const isVisible = !isElementHidden(this);
      if (isVisible && this.__previousVisible === false) {
        this._scrollTop = this.__memorizedScrollTop || 0;
      }
      this.__previousVisible = isVisible;
    }
  }
  /**
   * Scroll to a flat index in the grid. The method doesn't take into account
   * the hierarchy of the items.
   *
   * @param {number} index Row index to scroll to
   * @protected
   */
  _scrollToFlatIndex(index) {
    index = Math.min(this._flatSize - 1, Math.max(0, index));
    this.__virtualizer.scrollToIndex(index);
    this.__scrollIntoViewport(index);
  }
  /**
   * Makes sure the row with the given index (if found in the DOM) is fully
   * inside the visible viewport, taking header/footer into account.
   * @private
   */
  __scrollIntoViewport(index) {
    const rowElement = [...this.$.items.children].find((child) => child.index === index);
    if (rowElement) {
      const dstRect = rowElement.getBoundingClientRect();
      const footerTop = this.$.footer.getBoundingClientRect().top;
      const headerBottom = this.$.header.getBoundingClientRect().bottom;
      if (dstRect.bottom > footerTop) {
        this.$.table.scrollTop += dstRect.bottom - footerTop;
      } else if (dstRect.top < headerBottom) {
        this.$.table.scrollTop -= headerBottom - dstRect.top;
      }
    }
  }
  /** @private */
  _scheduleScrolling() {
    if (!this._scrollingFrame) {
      this._scrollingFrame = requestAnimationFrame(() => this.$.scroller.toggleAttribute("scrolling", true));
    }
    this._debounceScrolling = Debouncer$1.debounce(this._debounceScrolling, timeOut.after(timeouts.SCROLLING), () => {
      cancelAnimationFrame(this._scrollingFrame);
      delete this._scrollingFrame;
      this.$.scroller.toggleAttribute("scrolling", false);
    });
  }
  /** @private */
  _afterScroll() {
    this.__updateHorizontalScrollPosition();
    if (!this.hasAttribute("reordering")) {
      this._scheduleScrolling();
    }
    if (!this.hasAttribute("navigating")) {
      this._hideTooltip(true);
    }
    this._updateOverflow();
    this._debounceColumnContentVisibility = Debouncer$1.debounce(
      this._debounceColumnContentVisibility,
      timeOut.after(timeouts.UPDATE_CONTENT_VISIBILITY),
      () => {
        if (this._lazyColumns && this.__cachedScrollLeft !== this._scrollLeft) {
          this.__cachedScrollLeft = this._scrollLeft;
          this.__updateColumnsBodyContentHidden();
        }
      }
    );
    if (this._firefox) {
      const isVisible = !isElementHidden(this);
      if (isVisible && this.__previousVisible !== false) {
        this.__memorizedScrollTop = this._scrollTop;
      }
    }
  }
  /** @private */
  __updateColumnsBodyContentHidden() {
    if (!this._columnTree || !this._areSizerCellsAssigned()) {
      return;
    }
    const columnsInOrder = this._getColumnsInOrder();
    let bodyContentHiddenChanged = false;
    columnsInOrder.forEach((column) => {
      const bodyContentHidden = this._lazyColumns && !this.__isColumnInViewport(column);
      if (column._bodyContentHidden !== bodyContentHidden) {
        bodyContentHiddenChanged = true;
        column._cells.forEach((cell) => {
          if (cell !== column._sizerCell) {
            if (bodyContentHidden) {
              cell.remove();
            } else if (cell.__parentRow) {
              const followingColumnCell = [...cell.__parentRow.children].find(
                (child) => columnsInOrder.indexOf(child._column) > columnsInOrder.indexOf(column)
              );
              cell.__parentRow.insertBefore(cell, followingColumnCell);
            }
          }
        });
      }
      column._bodyContentHidden = bodyContentHidden;
    });
    if (bodyContentHiddenChanged) {
      this._frozenCellsChanged();
    }
    if (this._lazyColumns) {
      const lastFrozenColumn = [...columnsInOrder].reverse().find((column) => column.frozen);
      const lastFrozenColumnEnd = this.__getColumnEnd(lastFrozenColumn);
      const firstVisibleColumn = columnsInOrder.find((column) => !column.frozen && !column._bodyContentHidden);
      this.__lazyColumnsStart = this.__getColumnStart(firstVisibleColumn) - lastFrozenColumnEnd;
      this.$.items.style.setProperty("--_grid-lazy-columns-start", `${this.__lazyColumnsStart}px`);
      this._resetKeyboardNavigation();
    }
  }
  /** @private */
  __getColumnEnd(column) {
    if (!column) {
      return this.__isRTL ? this.$.table.clientWidth : 0;
    }
    return column._sizerCell.offsetLeft + (this.__isRTL ? 0 : column._sizerCell.offsetWidth);
  }
  /** @private */
  __getColumnStart(column) {
    if (!column) {
      return this.__isRTL ? this.$.table.clientWidth : 0;
    }
    return column._sizerCell.offsetLeft + (this.__isRTL ? column._sizerCell.offsetWidth : 0);
  }
  /**
   * Returns true if the given column is horizontally inside the viewport.
   * @private
   */
  __isColumnInViewport(column) {
    if (column.frozen || column.frozenToEnd) {
      return true;
    }
    return this.__isHorizontallyInViewport(column._sizerCell);
  }
  /** @private */
  __isHorizontallyInViewport(element) {
    return element.offsetLeft + element.offsetWidth >= this._scrollLeft && element.offsetLeft <= this._scrollLeft + this.clientWidth;
  }
  /** @private */
  __columnRenderingChanged(_columnTree, columnRendering) {
    if (columnRendering === "eager") {
      this.$.scroller.removeAttribute("column-rendering");
    } else {
      this.$.scroller.setAttribute("column-rendering", columnRendering);
    }
    this.__updateColumnsBodyContentHidden();
  }
  /** @private */
  _updateOverflow() {
    this._debounceOverflow = Debouncer$1.debounce(this._debounceOverflow, animationFrame, () => {
      this.__doUpdateOverflow();
    });
  }
  /** @private */
  __doUpdateOverflow() {
    let overflow = "";
    const table = this.$.table;
    if (table.scrollTop < table.scrollHeight - table.clientHeight) {
      overflow += " bottom";
    }
    if (table.scrollTop > 0) {
      overflow += " top";
    }
    const scrollLeft = getNormalizedScrollLeft(table, this.getAttribute("dir"));
    if (scrollLeft > 0) {
      overflow += " start";
    }
    if (scrollLeft < table.scrollWidth - table.clientWidth) {
      overflow += " end";
    }
    if (this.__isRTL) {
      overflow = overflow.replace(/start|end/giu, (matched) => {
        return matched === "start" ? "end" : "start";
      });
    }
    if (table.scrollLeft < table.scrollWidth - table.clientWidth) {
      overflow += " right";
    }
    if (table.scrollLeft > 0) {
      overflow += " left";
    }
    const value = overflow.trim();
    if (value.length > 0 && this.getAttribute("overflow") !== value) {
      this.setAttribute("overflow", value);
    } else if (value.length === 0 && this.hasAttribute("overflow")) {
      this.removeAttribute("overflow");
    }
  }
  /** @protected */
  _frozenCellsChanged() {
    this._debouncerCacheElements = Debouncer$1.debounce(this._debouncerCacheElements, microTask, () => {
      Array.from(this.shadowRoot.querySelectorAll('[part~="cell"]')).forEach((cell) => {
        cell.style.transform = "";
      });
      this._frozenCells = Array.prototype.slice.call(this.$.table.querySelectorAll("[frozen]"));
      this._frozenToEndCells = Array.prototype.slice.call(this.$.table.querySelectorAll("[frozen-to-end]"));
      this.__updateHorizontalScrollPosition();
    });
    this._debounceUpdateFrozenColumn();
  }
  /** @protected */
  _debounceUpdateFrozenColumn() {
    this.__debounceUpdateFrozenColumn = Debouncer$1.debounce(
      this.__debounceUpdateFrozenColumn,
      microTask,
      () => this._updateFrozenColumn()
    );
  }
  /** @private */
  _updateFrozenColumn() {
    if (!this._columnTree) {
      return;
    }
    const columnsRow = this._columnTree[this._columnTree.length - 1].slice(0);
    columnsRow.sort((a3, b2) => {
      return a3._order - b2._order;
    });
    let lastFrozen;
    let firstFrozenToEnd;
    for (let i2 = 0; i2 < columnsRow.length; i2++) {
      const col = columnsRow[i2];
      col._lastFrozen = false;
      col._firstFrozenToEnd = false;
      if (firstFrozenToEnd === void 0 && col.frozenToEnd && !col.hidden) {
        firstFrozenToEnd = i2;
      }
      if (col.frozen && !col.hidden) {
        lastFrozen = i2;
      }
    }
    if (lastFrozen !== void 0) {
      columnsRow[lastFrozen]._lastFrozen = true;
    }
    if (firstFrozenToEnd !== void 0) {
      columnsRow[firstFrozenToEnd]._firstFrozenToEnd = true;
    }
    this.__updateColumnsBodyContentHidden();
  }
  /** @private */
  __updateHorizontalScrollPosition() {
    if (!this._columnTree) {
      return;
    }
    const scrollWidth = this.$.table.scrollWidth;
    const clientWidth = this.$.table.clientWidth;
    const scrollLeft = Math.max(0, this.$.table.scrollLeft);
    const normalizedScrollLeft = getNormalizedScrollLeft(this.$.table, this.getAttribute("dir"));
    const transform = `translate(${-scrollLeft}px, 0)`;
    this.$.header.style.transform = transform;
    this.$.footer.style.transform = transform;
    this.$.items.style.transform = transform;
    const x2 = this.__isRTL ? normalizedScrollLeft + clientWidth - scrollWidth : scrollLeft;
    const transformFrozen = `translate(${x2}px, 0)`;
    this._frozenCells.forEach((cell) => {
      cell.style.transform = transformFrozen;
    });
    const remaining = this.__isRTL ? normalizedScrollLeft : scrollLeft + clientWidth - scrollWidth;
    const transformFrozenToEnd = `translate(${remaining}px, 0)`;
    let transformFrozenToEndBody = transformFrozenToEnd;
    if (this._lazyColumns && this._areSizerCellsAssigned()) {
      const columnsInOrder = this._getColumnsInOrder();
      const lastVisibleColumn = [...columnsInOrder].reverse().find((column) => !column.frozenToEnd && !column._bodyContentHidden);
      const lastVisibleColumnEnd = this.__getColumnEnd(lastVisibleColumn);
      const firstFrozenToEndColumn = columnsInOrder.find((column) => column.frozenToEnd);
      const firstFrozenToEndColumnStart = this.__getColumnStart(firstFrozenToEndColumn);
      const translateX = remaining + (firstFrozenToEndColumnStart - lastVisibleColumnEnd) + this.__lazyColumnsStart;
      transformFrozenToEndBody = `translate(${translateX}px, 0)`;
    }
    this._frozenToEndCells.forEach((cell) => {
      if (this.$.items.contains(cell)) {
        cell.style.transform = transformFrozenToEndBody;
      } else {
        cell.style.transform = transformFrozenToEnd;
      }
    });
    if (this.hasAttribute("navigating") && this.__rowFocusMode) {
      this.$.table.style.setProperty("--_grid-horizontal-scroll-position", `${-x2}px`);
    }
  }
  /** @private */
  _areSizerCellsAssigned() {
    return this._getColumnsInOrder().every((column) => column._sizerCell);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const SelectionMixin = (superClass) => class SelectionMixin extends superClass {
  static get properties() {
    return {
      /**
       * An array that contains the selected items.
       * @type {!Array<!GridItem>}
       */
      selectedItems: {
        type: Object,
        notify: true,
        value: () => [],
        sync: true
      },
      /**
       * A function to check whether a specific item in the grid may be
       * selected or deselected by the user. Used by the selection column to
       * conditionally enable to disable checkboxes for individual items. This
       * function does not prevent programmatic selection/deselection of
       * items. Changing the function does not modify the currently selected
       * items.
       *
       * Configuring this function hides the select all checkbox of the grid
       * selection column, which means users can not select or deselect all
       * items anymore, nor do they get feedback on whether all items are
       * selected or not.
       *
       * Receives an item instance and should return a boolean indicating
       * whether users may change the selection state of that item.
       *
       * @type {(item: !GridItem) => boolean}
       */
      isItemSelectable: {
        type: Function,
        notify: /* @__PURE__ */ (() => true)()
        // prevent Polymer analyzer from documenting a changed event
      },
      /**
       * Set of selected item ids
       * @private
       */
      __selectedKeys: {
        type: Object,
        computed: "__computeSelectedKeys(itemIdPath, selectedItems)"
      }
    };
  }
  static get observers() {
    return ["__selectedItemsChanged(itemIdPath, selectedItems, isItemSelectable)"];
  }
  /**
   * @param {!GridItem} item
   * @return {boolean}
   * @protected
   */
  _isSelected(item2) {
    return this.__selectedKeys.has(this.getItemId(item2));
  }
  /**
   * Determines whether the selection state of an item may be changed by the
   * user.
   *
   * @private
   */
  __isItemSelectable(item2) {
    if (!this.isItemSelectable || !item2) {
      return true;
    }
    return this.isItemSelectable(item2);
  }
  /**
   * Selects the given item.
   *
   * @method selectItem
   * @param {!GridItem} item The item object
   */
  selectItem(item2) {
    if (!this._isSelected(item2)) {
      this.selectedItems = [...this.selectedItems, item2];
    }
  }
  /**
   * Deselects the given item if it is already selected.
   *
   * @method deselect
   * @param {!GridItem} item The item object
   */
  deselectItem(item2) {
    if (this._isSelected(item2)) {
      this.selectedItems = this.selectedItems.filter((i2) => !this._itemsEqual(i2, item2));
    }
  }
  /** @private */
  __selectedItemsChanged() {
    this.requestContentUpdate();
  }
  /** @private */
  __computeSelectedKeys(_itemIdPath, selectedItems) {
    const selected = selectedItems || [];
    const selectedKeys = /* @__PURE__ */ new Set();
    selected.forEach((item2) => {
      selectedKeys.add(this.getItemId(item2));
    });
    return selectedKeys;
  }
  /**
   * Fired when the `selectedItems` property changes.
   *
   * @event selected-items-changed
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let defaultMultiSortPriority = "prepend";
const SortMixin = (superClass) => class SortMixin extends superClass {
  static get properties() {
    return {
      /**
       * When `true`, all `<vaadin-grid-sorter>` are applied for sorting.
       * @attr {boolean} multi-sort
       * @type {boolean}
       */
      multiSort: {
        type: Boolean,
        value: false
      },
      /**
       * Controls how columns are added to the sort order when using multi-sort.
       * The sort order is visually indicated by numbers in grid sorters placed in column headers.
       *
       * By default, whenever an unsorted column is sorted, or the sort-direction of a column is
       * changed, that column gets sort priority 1, thus affecting the priority for all the other
       * sorted columns. This is identical to using `multi-sort-priority="prepend"`.
       *
       * Using this property allows to change this behavior so that sorting an unsorted column
       * would add it to the "end" of the sort, and changing column's sort direction would retain
       * it's previous priority. To set this, use `multi-sort-priority="append"`.
       *
       * @attr {string} multi-sort-priority
       */
      multiSortPriority: {
        type: String,
        value: () => defaultMultiSortPriority
      },
      /**
       * When `true`, Shift-clicking an unsorted column's sorter adds it to the multi-sort.
       * Shift + Space does the same action via keyboard. This property has precedence over the
       * `multiSort` property. If `multiSortOnShiftClick` is true, the multiSort property is effectively ignored.
       *
       * @attr {boolean} multi-sort-on-shift-click
       * @type {boolean}
       */
      multiSortOnShiftClick: {
        type: Boolean,
        value: false
      },
      /**
       * @type {!Array<!GridSorterDefinition>}
       * @protected
       */
      _sorters: {
        type: Array,
        value: () => []
      },
      /** @private */
      _previousSorters: {
        type: Array,
        value: () => []
      }
    };
  }
  /**
   * Sets the default multi-sort priority to use for all grid instances.
   * This method should be called before creating any grid instances.
   * Changing this setting does not affect the default for existing grids.
   *
   * @param {string} priority
   */
  static setDefaultMultiSortPriority(priority) {
    defaultMultiSortPriority = ["append", "prepend"].includes(priority) ? priority : "prepend";
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("sorter-changed", this._onSorterChanged);
  }
  /** @private */
  _onSorterChanged(e2) {
    const sorter = e2.target;
    e2.stopPropagation();
    sorter._grid = this;
    this.__updateSorter(sorter, e2.detail.shiftClick, e2.detail.fromSorterClick);
    this.__applySorters();
  }
  /** @private */
  __removeSorters(sortersToRemove) {
    if (sortersToRemove.length === 0) {
      return;
    }
    this._sorters = this._sorters.filter((sorter) => !sortersToRemove.includes(sorter));
    this.__applySorters();
  }
  /** @private */
  __updateSortOrders() {
    this._sorters.forEach((sorter) => {
      sorter._order = null;
    });
    const activeSorters = this._getActiveSorters();
    if (activeSorters.length > 1) {
      activeSorters.forEach((sorter, index) => {
        sorter._order = index;
      });
    }
  }
  /** @private */
  __updateSorter(sorter, shiftClick, fromSorterClick) {
    if (!sorter.direction && !this._sorters.includes(sorter)) {
      return;
    }
    sorter._order = null;
    const restSorters = this._sorters.filter((s3) => s3 !== sorter);
    if (this.multiSort && (!this.multiSortOnShiftClick || !fromSorterClick) || this.multiSortOnShiftClick && shiftClick) {
      if (this.multiSortPriority === "append") {
        this._sorters = [...restSorters, sorter];
      } else {
        this._sorters = [sorter, ...restSorters];
      }
    } else if (sorter.direction || this.multiSortOnShiftClick) {
      this._sorters = sorter.direction ? [sorter] : [];
      restSorters.forEach((sorter2) => {
        sorter2._order = null;
        sorter2.direction = null;
      });
    }
  }
  /** @private */
  __applySorters() {
    this.__updateSortOrders();
    if (this.dataProvider && // No need to clear cache if sorters didn't change and grid is attached
    this.isAttached && JSON.stringify(this._previousSorters) !== JSON.stringify(this._mapSorters())) {
      this.__debounceClearCache();
    }
    this._a11yUpdateSorters();
    this._previousSorters = this._mapSorters();
  }
  /**
   * @type {GridSorterDefinition[]}
   * @protected
   */
  _getActiveSorters() {
    return this._sorters.filter((sorter) => sorter.direction && sorter.isConnected);
  }
  /**
   * @return {!Array<!GridSorterDefinition>}
   * @protected
   */
  _mapSorters() {
    return this._getActiveSorters().map((sorter) => {
      return {
        path: sorter.path,
        direction: sorter.direction
      };
    });
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const StylingMixin = (superClass) => class StylingMixin extends superClass {
  static get properties() {
    return {
      /**
       * A function that allows generating CSS class names for grid cells
       * based on their row and column. The return value should be the generated
       * class name as a string, or multiple class names separated by whitespace
       * characters.
       *
       * Receives two arguments:
       * - `column` The `<vaadin-grid-column>` element (`undefined` for details-cell).
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridCellClassNameGenerator | null | undefined}
       * @deprecated Use `cellPartNameGenerator` instead.
       */
      cellClassNameGenerator: {
        type: Function,
        sync: true
      },
      /**
       * A function that allows generating CSS `part` names for grid cells in Shadow DOM based
       * on their row and column, for styling from outside using the `::part()` selector.
       *
       * The return value should be the generated part name as a string, or multiple part names
       * separated by whitespace characters.
       *
       * Receives two arguments:
       * - `column` The `<vaadin-grid-column>` element (`undefined` for details-cell).
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridCellPartNameGenerator | null | undefined}
       */
      cellPartNameGenerator: {
        type: Function,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "__cellClassNameGeneratorChanged(cellClassNameGenerator)",
      "__cellPartNameGeneratorChanged(cellPartNameGenerator)"
    ];
  }
  /** @private */
  __cellClassNameGeneratorChanged() {
    this.generateCellClassNames();
  }
  /** @private */
  __cellPartNameGeneratorChanged() {
    this.generateCellPartNames();
  }
  /**
   * Runs the `cellClassNameGenerator` for the visible cells.
   * If the generator depends on varying conditions, you need to
   * call this function manually in order to update the styles when
   * the conditions change.
   *
   * @deprecated Use `cellPartNameGenerator` and `generateCellPartNames()` instead.
   */
  generateCellClassNames() {
    iterateChildren(this.$.items, (row) => {
      if (!row.hidden) {
        this._generateCellClassNames(row, this.__getRowModel(row));
      }
    });
  }
  /**
   * Runs the `cellPartNameGenerator` for the visible cells.
   * If the generator depends on varying conditions, you need to
   * call this function manually in order to update the styles when
   * the conditions change.
   */
  generateCellPartNames() {
    iterateChildren(this.$.items, (row) => {
      if (!row.hidden) {
        this._generateCellPartNames(row, this.__getRowModel(row));
      }
    });
  }
  /** @private */
  _generateCellClassNames(row, model) {
    iterateRowCells(row, (cell) => {
      if (cell.__generatedClasses) {
        cell.__generatedClasses.forEach((className) => cell.classList.remove(className));
      }
      if (this.cellClassNameGenerator && !row.hasAttribute("loading")) {
        const result = this.cellClassNameGenerator(cell._column, model);
        cell.__generatedClasses = result && result.split(" ").filter((className) => className.length > 0);
        if (cell.__generatedClasses) {
          cell.__generatedClasses.forEach((className) => cell.classList.add(className));
        }
      }
    });
  }
  /** @private */
  _generateCellPartNames(row, model) {
    iterateRowCells(row, (cell) => {
      if (cell.__generatedParts) {
        cell.__generatedParts.forEach((partName) => {
          updatePart(cell, null, partName);
        });
      }
      if (this.cellPartNameGenerator && !row.hasAttribute("loading")) {
        const result = this.cellPartNameGenerator(cell._column, model);
        cell.__generatedParts = result && result.split(" ").filter((partName) => partName.length > 0);
        if (cell.__generatedParts) {
          cell.__generatedParts.forEach((partName) => {
            updatePart(cell, true, partName);
          });
        }
      }
    });
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const GridMixin = (superClass) => class extends ArrayDataProviderMixin(
  DataProviderMixin(
    DynamicColumnsMixin(
      ActiveItemMixin(
        ScrollMixin(
          SelectionMixin(
            SortMixin(
              RowDetailsMixin(
                KeyboardNavigationMixin(
                  A11yMixin(
                    FilterMixin(
                      ColumnReorderingMixin(
                        ColumnResizingMixin(
                          EventContextMixin(DragAndDropMixin(StylingMixin(TabindexMixin(superClass))))
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) {
  static get observers() {
    return ["_columnTreeChanged(_columnTree)", "_flatSizeChanged(_flatSize, __virtualizer, _hasData, _columnTree)"];
  }
  static get properties() {
    return {
      /** @private */
      _safari: {
        type: Boolean,
        value: isSafari
      },
      /** @private */
      _ios: {
        type: Boolean,
        value: isIOS
      },
      /** @private */
      _firefox: {
        type: Boolean,
        value: isFirefox
      },
      /** @private */
      _android: {
        type: Boolean,
        value: isAndroid
      },
      /** @private */
      _touchDevice: {
        type: Boolean,
        value: isTouch
      },
      /**
       * If true, the grid's height is defined by its rows.
       *
       * Effectively, this disables the grid's virtual scrolling so that all the rows are rendered in the DOM at once.
       * If the grid has a large number of items, using the feature is discouraged to avoid performance issues.
       * @attr {boolean} all-rows-visible
       * @type {boolean}
       */
      allRowsVisible: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /** @private */
      __pendingRecalculateColumnWidths: {
        type: Boolean,
        value: true
      },
      /** @private */
      isAttached: {
        value: false
      },
      /**
       * An internal property that is mainly used by `vaadin-template-renderer`
       * to identify grid elements.
       *
       * @private
       */
      __gridElement: {
        type: Boolean,
        value: true
      },
      /** @private */
      __hasEmptyStateContent: {
        type: Boolean,
        value: false
      },
      /** @private */
      __emptyState: {
        type: Boolean,
        computed: "__computeEmptyState(_flatSize, __hasEmptyStateContent)"
      }
    };
  }
  constructor() {
    super();
    this.addEventListener("animationend", this._onAnimationEnd);
  }
  /** @private */
  get _firstVisibleIndex() {
    const firstVisibleItem = this.__getFirstVisibleItem();
    return firstVisibleItem ? firstVisibleItem.index : void 0;
  }
  /** @private */
  get _lastVisibleIndex() {
    const lastVisibleItem = this.__getLastVisibleItem();
    return lastVisibleItem ? lastVisibleItem.index : void 0;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.isAttached = true;
    this.recalculateColumnWidths();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.isAttached = false;
    this._hideTooltip(true);
  }
  /** @private */
  __getFirstVisibleItem() {
    return this._getRenderedRows().find((row) => this._isInViewport(row));
  }
  /** @private */
  __getLastVisibleItem() {
    return this._getRenderedRows().reverse().find((row) => this._isInViewport(row));
  }
  /** @private */
  _isInViewport(item2) {
    const scrollTargetRect = this.$.table.getBoundingClientRect();
    const itemRect = item2.getBoundingClientRect();
    const headerHeight = this.$.header.getBoundingClientRect().height;
    const footerHeight = this.$.footer.getBoundingClientRect().height;
    return itemRect.bottom > scrollTargetRect.top + headerHeight && itemRect.top < scrollTargetRect.bottom - footerHeight;
  }
  /** @private */
  _getRenderedRows() {
    return Array.from(this.$.items.children).filter((item2) => !item2.hidden).sort((a3, b2) => a3.index - b2.index);
  }
  /** @protected */
  _getRowContainingNode(node) {
    const content = getClosestElement("vaadin-grid-cell-content", node);
    if (!content) {
      return;
    }
    const cell = content.assignedSlot.parentElement;
    return cell.parentElement;
  }
  /** @protected */
  _isItemAssignedToRow(item2, row) {
    const model = this.__getRowModel(row);
    return this.getItemId(item2) === this.getItemId(model.item);
  }
  /** @protected */
  ready() {
    super.ready();
    this.__virtualizer = new Virtualizer({
      createElements: this._createScrollerRows.bind(this),
      updateElement: this._updateScrollerItem.bind(this),
      scrollContainer: this.$.items,
      scrollTarget: this.$.table,
      reorderElements: true
    });
    new ResizeObserver(
      () => setTimeout(() => {
        this.__updateColumnsBodyContentHidden();
        this.__tryToRecalculateColumnWidthsIfPending();
      })
    ).observe(this.$.table);
    const minHeightObserver = new ResizeObserver(
      () => setTimeout(() => {
        this.__updateMinHeight();
      })
    );
    minHeightObserver.observe(this.$.header);
    minHeightObserver.observe(this.$.items);
    minHeightObserver.observe(this.$.footer);
    processTemplates(this);
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setManual(true);
    this.__emptyStateContentObserver = new SlotObserver(this.$.emptystateslot, ({ currentNodes }) => {
      this.$.emptystatecell._content = currentNodes[0];
      this.__hasEmptyStateContent = !!this.$.emptystatecell._content;
    });
  }
  /** @private */
  __getBodyCellCoordinates(cell) {
    if (this.$.items.contains(cell) && cell.localName === "td") {
      return {
        item: cell.parentElement._item,
        column: cell._column
      };
    }
  }
  /** @private */
  __focusBodyCell({ item: item2, column }) {
    const row = this._getRenderedRows().find((row2) => row2._item === item2);
    const cell = row && [...row.children].find((cell2) => cell2._column === column);
    if (cell) {
      cell.focus();
    }
  }
  /** @protected */
  _focusFirstVisibleRow() {
    const row = this.__getFirstVisibleItem();
    this.__rowFocusMode = true;
    row.focus();
  }
  /** @private */
  _flatSizeChanged(flatSize, virtualizer, hasData, columnTree) {
    if (virtualizer && hasData && columnTree) {
      const cell = this.shadowRoot.activeElement;
      const cellCoordinates = this.__getBodyCellCoordinates(cell);
      const previousSize = virtualizer.size || 0;
      virtualizer.size = flatSize;
      virtualizer.update(previousSize - 1, previousSize - 1);
      if (flatSize < previousSize) {
        virtualizer.update(flatSize - 1, flatSize - 1);
      }
      if (cellCoordinates && cell.parentElement.hidden) {
        this.__focusBodyCell(cellCoordinates);
      }
      this._resetKeyboardNavigation();
    }
  }
  /** @private */
  __getIntrinsicWidth(col) {
    if (!this.__intrinsicWidthCache.has(col)) {
      this.__calculateAndCacheIntrinsicWidths([col]);
    }
    return this.__intrinsicWidthCache.get(col);
  }
  /** @private */
  __getDistributedWidth(col, innerColumn) {
    if (col == null || col === this) {
      return 0;
    }
    const columnWidth = Math.max(
      this.__getIntrinsicWidth(col),
      this.__getDistributedWidth((col.assignedSlot || col).parentElement, col)
    );
    if (!innerColumn) {
      return columnWidth;
    }
    const columnGroup = col;
    const columnGroupWidth = columnWidth;
    const sumOfWidthOfAllChildColumns = columnGroup._visibleChildColumns.map((col2) => this.__getIntrinsicWidth(col2)).reduce((sum, curr) => sum + curr, 0);
    const extraNecessarySpaceForGridColumnGroup = Math.max(0, columnGroupWidth - sumOfWidthOfAllChildColumns);
    const proportionOfExtraSpace = this.__getIntrinsicWidth(innerColumn) / sumOfWidthOfAllChildColumns;
    const shareOfInnerColumnFromNecessaryExtraSpace = proportionOfExtraSpace * extraNecessarySpaceForGridColumnGroup;
    return this.__getIntrinsicWidth(innerColumn) + shareOfInnerColumnFromNecessaryExtraSpace;
  }
  /**
   * @param {!Array<!GridColumn>} cols the columns to auto size based on their content width
   * @private
   */
  _recalculateColumnWidths(cols) {
    this.__virtualizer.flush();
    [...this.$.header.children, ...this.$.footer.children].forEach((row) => {
      if (row.__debounceUpdateHeaderFooterRowVisibility) {
        row.__debounceUpdateHeaderFooterRowVisibility.flush();
      }
    });
    if (this._debouncerHiddenChanged) {
      this._debouncerHiddenChanged.flush();
    }
    if (this.__debounceUpdateFrozenColumn) {
      this.__debounceUpdateFrozenColumn.flush();
    }
    this.__intrinsicWidthCache = /* @__PURE__ */ new Map();
    const fvi = this._firstVisibleIndex;
    const lvi = this._lastVisibleIndex;
    this.__viewportRowsCache = this._getRenderedRows().filter((row) => row.index >= fvi && row.index <= lvi);
    this.__calculateAndCacheIntrinsicWidths(cols);
    cols.forEach((col) => {
      col.width = `${this.__getDistributedWidth(col)}px`;
    });
  }
  /**
   * Toggles the cell content for the given column to use or not use auto width.
   *
   * While content for all the column cells uses auto width (instead of the default 100%),
   * their offsetWidth can be used to calculate the collective intrinsic width of the column.
   *
   * @private
   */
  __setVisibleCellContentAutoWidth(col, autoWidth) {
    col._allCells.filter((cell) => {
      if (this.$.items.contains(cell)) {
        return this.__viewportRowsCache.includes(cell.parentElement);
      }
      return true;
    }).forEach((cell) => {
      cell.__measuringAutoWidth = autoWidth;
      if (cell.__measuringAutoWidth) {
        cell.__originalWidth = cell.style.width;
        cell.style.width = "auto";
        cell.style.position = "absolute";
      } else {
        cell.style.width = cell.__originalWidth;
        delete cell.__originalWidth;
        cell.style.position = "";
      }
    });
    if (autoWidth) {
      this.$.scroller.setAttribute("measuring-auto-width", "");
    } else {
      this.$.scroller.removeAttribute("measuring-auto-width");
    }
  }
  /**
   * Returns the maximum intrinsic width of the cell content in the given column.
   * Only cells which are marked for measuring auto width are considered.
   *
   * @private
   */
  __getAutoWidthCellsMaxWidth(col) {
    return col._allCells.reduce((width, cell) => {
      return cell.__measuringAutoWidth ? Math.max(width, cell.offsetWidth + 1) : width;
    }, 0);
  }
  /**
   * Calculates and caches the intrinsic width of each given column.
   *
   * @private
   */
  __calculateAndCacheIntrinsicWidths(cols) {
    cols.forEach((col) => this.__setVisibleCellContentAutoWidth(col, true));
    cols.forEach((col) => {
      const width = this.__getAutoWidthCellsMaxWidth(col);
      this.__intrinsicWidthCache.set(col, width);
    });
    cols.forEach((col) => this.__setVisibleCellContentAutoWidth(col, false));
  }
  /**
   * Updates the `width` of all columns which have `autoWidth` set to `true`.
   */
  recalculateColumnWidths() {
    if (!this._columnTree) {
      return;
    }
    if (isElementHidden(this) || this._dataProviderController.isLoading()) {
      this.__pendingRecalculateColumnWidths = true;
      return;
    }
    const cols = this._getColumns().filter((col) => !col.hidden && col.autoWidth);
    const undefinedCols = cols.filter((col) => !customElements.get(col.localName));
    if (undefinedCols.length) {
      Promise.all(undefinedCols.map((col) => customElements.whenDefined(col.localName))).then(() => {
        this._recalculateColumnWidths(cols);
      });
    } else {
      this._recalculateColumnWidths(cols);
    }
  }
  /** @private */
  __tryToRecalculateColumnWidthsIfPending() {
    if (!this.__pendingRecalculateColumnWidths || isElementHidden(this) || this._dataProviderController.isLoading()) {
      return;
    }
    const hasRowsWithUndefinedIndex = [...this.$.items.children].some((row) => row.index === void 0);
    if (hasRowsWithUndefinedIndex) {
      return;
    }
    const hasRowsWithClientHeight = [...this.$.items.children].some((row) => row.clientHeight > 0);
    if (hasRowsWithClientHeight) {
      this.__pendingRecalculateColumnWidths = false;
      this.recalculateColumnWidths();
    }
  }
  /**
   * @protected
   * @override
   */
  _onDataProviderPageLoaded() {
    super._onDataProviderPageLoaded();
    this.__tryToRecalculateColumnWidthsIfPending();
  }
  /** @private */
  _createScrollerRows(count) {
    const rows = [];
    for (let i2 = 0; i2 < count; i2++) {
      const row = document.createElement("tr");
      row.setAttribute("part", "row body-row");
      row.setAttribute("role", "row");
      row.setAttribute("tabindex", "-1");
      if (this._columnTree) {
        this._updateRow(row, this._columnTree[this._columnTree.length - 1], "body", false, true);
      }
      rows.push(row);
    }
    if (this._columnTree) {
      this._columnTree[this._columnTree.length - 1].forEach((c2) => {
        if (c2.isConnected && c2._cells) {
          c2._cells = [...c2._cells];
        }
      });
    }
    this.__afterCreateScrollerRowsDebouncer = Debouncer$1.debounce(
      this.__afterCreateScrollerRowsDebouncer,
      animationFrame,
      () => {
        this._afterScroll();
        this.__tryToRecalculateColumnWidthsIfPending();
      }
    );
    return rows;
  }
  /** @private */
  _createCell(tagName, column) {
    const contentId = this._contentIndex = this._contentIndex + 1 || 0;
    const slotName = `vaadin-grid-cell-content-${contentId}`;
    const cellContent = document.createElement("vaadin-grid-cell-content");
    cellContent.setAttribute("slot", slotName);
    const cell = document.createElement(tagName);
    cell.id = slotName.replace("-content-", "-");
    cell.setAttribute("role", tagName === "td" ? "gridcell" : "columnheader");
    if (!isAndroid && !isIOS) {
      cell.addEventListener("mouseenter", (event) => {
        if (!this.$.scroller.hasAttribute("scrolling")) {
          this._showTooltip(event);
        }
      });
      cell.addEventListener("mouseleave", () => {
        this._hideTooltip();
      });
      cell.addEventListener("mousedown", () => {
        this._hideTooltip(true);
      });
    }
    const slot = document.createElement("slot");
    slot.setAttribute("name", slotName);
    if (column && column._focusButtonMode) {
      const div = document.createElement("div");
      div.setAttribute("role", "button");
      div.setAttribute("tabindex", "-1");
      cell.appendChild(div);
      cell._focusButton = div;
      cell.focus = function(options) {
        cell._focusButton.focus(options);
      };
      div.appendChild(slot);
    } else {
      cell.setAttribute("tabindex", "-1");
      cell.appendChild(slot);
    }
    cell._content = cellContent;
    cellContent.addEventListener("mousedown", () => {
      if (isChrome) {
        const mouseUpListener = (event) => {
          const contentContainsFocusedElement = cellContent.contains(this.getRootNode().activeElement);
          const mouseUpWithinCell = event.composedPath().includes(cellContent);
          if (!contentContainsFocusedElement && mouseUpWithinCell) {
            cell.focus({ preventScroll: true });
          }
          document.removeEventListener("mouseup", mouseUpListener, true);
        };
        document.addEventListener("mouseup", mouseUpListener, true);
      } else {
        setTimeout(() => {
          if (!cellContent.contains(this.getRootNode().activeElement)) {
            cell.focus({ preventScroll: true });
          }
        });
      }
    });
    return cell;
  }
  /**
   * @param {!HTMLTableRowElement} row
   * @param {!Array<!GridColumn>} columns
   * @param {?string} section
   * @param {boolean} isColumnRow
   * @param {boolean} noNotify
   * @protected
   */
  _updateRow(row, columns, section = "body", isColumnRow = false, noNotify = false) {
    const contentsFragment = document.createDocumentFragment();
    iterateRowCells(row, (cell) => {
      cell._vacant = true;
    });
    row.innerHTML = "";
    if (section === "body") {
      row.__cells = [];
      row.__detailsCell = null;
    }
    columns.filter((column) => !column.hidden).forEach((column, index, cols) => {
      let cell;
      if (section === "body") {
        if (!column._cells) {
          column._cells = [];
        }
        cell = column._cells.find((cell2) => cell2._vacant);
        if (!cell) {
          cell = this._createCell("td", column);
          if (column._onCellKeyDown) {
            cell.addEventListener("keydown", column._onCellKeyDown.bind(column));
          }
          column._cells.push(cell);
        }
        cell.setAttribute("part", "cell body-cell");
        cell.__parentRow = row;
        row.__cells.push(cell);
        const isSizerRow = row === this.$.sizer;
        if (!column._bodyContentHidden || isSizerRow) {
          row.appendChild(cell);
        }
        if (isSizerRow) {
          column._sizerCell = cell;
        }
        if (index === cols.length - 1 && this.rowDetailsRenderer) {
          if (!this._detailsCells) {
            this._detailsCells = [];
          }
          const detailsCell = this._detailsCells.find((cell2) => cell2._vacant) || this._createCell("td");
          if (this._detailsCells.indexOf(detailsCell) === -1) {
            this._detailsCells.push(detailsCell);
          }
          if (!detailsCell._content.parentElement) {
            contentsFragment.appendChild(detailsCell._content);
          }
          this._configureDetailsCell(detailsCell);
          row.appendChild(detailsCell);
          row.__detailsCell = detailsCell;
          this._a11ySetRowDetailsCell(row, detailsCell);
          detailsCell._vacant = false;
        }
        if (!noNotify) {
          column._cells = [...column._cells];
        }
      } else {
        const tagName = section === "header" ? "th" : "td";
        if (isColumnRow || column.localName === "vaadin-grid-column-group") {
          cell = column[`_${section}Cell`];
          if (!cell) {
            cell = this._createCell(tagName);
            if (column._onCellKeyDown) {
              cell.addEventListener("keydown", column._onCellKeyDown.bind(column));
            }
          }
          cell._column = column;
          row.appendChild(cell);
          column[`_${section}Cell`] = cell;
        } else {
          if (!column._emptyCells) {
            column._emptyCells = [];
          }
          cell = column._emptyCells.find((cell2) => cell2._vacant) || this._createCell(tagName);
          cell._column = column;
          row.appendChild(cell);
          if (column._emptyCells.indexOf(cell) === -1) {
            column._emptyCells.push(cell);
          }
        }
        cell.part.add("cell", `${section}-cell`);
      }
      if (!cell._content.parentElement) {
        contentsFragment.appendChild(cell._content);
      }
      cell._vacant = false;
      cell._column = column;
    });
    if (section !== "body") {
      this.__debounceUpdateHeaderFooterRowVisibility(row);
    }
    this.appendChild(contentsFragment);
    this._frozenCellsChanged();
    this._updateFirstAndLastColumnForRow(row);
  }
  /**
   * @param {HTMLTableRowElement} row
   * @protected
   */
  __debounceUpdateHeaderFooterRowVisibility(row) {
    row.__debounceUpdateHeaderFooterRowVisibility = Debouncer$1.debounce(
      row.__debounceUpdateHeaderFooterRowVisibility,
      microTask,
      () => this.__updateHeaderFooterRowVisibility(row)
    );
  }
  /**
   * @param {HTMLTableRowElement} row
   * @protected
   */
  __updateHeaderFooterRowVisibility(row) {
    if (!row) {
      return;
    }
    const visibleRowCells = Array.from(row.children).filter((cell) => {
      const column = cell._column;
      if (column._emptyCells && column._emptyCells.indexOf(cell) > -1) {
        return false;
      }
      if (row.parentElement === this.$.header) {
        if (column.headerRenderer) {
          return true;
        }
        if (column.header === null) {
          return false;
        }
        if (column.path || column.header !== void 0) {
          return true;
        }
      } else if (column.footerRenderer) {
        return true;
      }
      return false;
    });
    if (row.hidden !== !visibleRowCells.length) {
      row.hidden = !visibleRowCells.length;
    }
    this._resetKeyboardNavigation();
  }
  /** @private */
  _updateScrollerItem(row, index) {
    this._preventScrollerRotatingCellFocus(row, index);
    if (!this._columnTree) {
      return;
    }
    this._updateRowOrderParts(row, index);
    this._a11yUpdateRowRowindex(row, index);
    this._getItem(index, row);
  }
  /** @private */
  _columnTreeChanged(columnTree) {
    this._renderColumnTree(columnTree);
    this.recalculateColumnWidths();
    this.__updateColumnsBodyContentHidden();
  }
  /** @private */
  _updateRowOrderParts(row, index = row.index) {
    updateBooleanRowStates(row, {
      first: index === 0,
      last: index === this._flatSize - 1,
      odd: index % 2 !== 0,
      even: index % 2 === 0
    });
  }
  /** @private */
  _updateRowStateParts(row, { item: item2, expanded, selected, detailsOpened }) {
    updateBooleanRowStates(row, {
      expanded,
      collapsed: this.__isRowExpandable(row),
      selected,
      nonselectable: this.__isItemSelectable(item2) === false,
      "details-opened": detailsOpened
    });
  }
  /** @private */
  __computeEmptyState(flatSize, hasEmptyStateContent) {
    return flatSize === 0 && hasEmptyStateContent;
  }
  /**
   * @param {!Array<!GridColumn>} columnTree
   * @protected
   */
  _renderColumnTree(columnTree) {
    iterateChildren(this.$.items, (row) => {
      this._updateRow(row, columnTree[columnTree.length - 1], "body", false, true);
      const model = this.__getRowModel(row);
      this._updateRowOrderParts(row);
      this._updateRowStateParts(row, model);
      this._filterDragAndDrop(row, model);
    });
    while (this.$.header.children.length < columnTree.length) {
      const headerRow = document.createElement("tr");
      headerRow.setAttribute("part", "row");
      headerRow.setAttribute("role", "row");
      headerRow.setAttribute("tabindex", "-1");
      this.$.header.appendChild(headerRow);
      const footerRow = document.createElement("tr");
      footerRow.setAttribute("part", "row");
      footerRow.setAttribute("role", "row");
      footerRow.setAttribute("tabindex", "-1");
      this.$.footer.appendChild(footerRow);
    }
    while (this.$.header.children.length > columnTree.length) {
      this.$.header.removeChild(this.$.header.firstElementChild);
      this.$.footer.removeChild(this.$.footer.firstElementChild);
    }
    iterateChildren(this.$.header, (headerRow, index, rows) => {
      this._updateRow(headerRow, columnTree[index], "header", index === columnTree.length - 1);
      const cells = getBodyRowCells(headerRow);
      updateCellsPart(cells, "first-header-row-cell", index === 0);
      updateCellsPart(cells, "last-header-row-cell", index === rows.length - 1);
    });
    iterateChildren(this.$.footer, (footerRow, index, rows) => {
      this._updateRow(footerRow, columnTree[columnTree.length - 1 - index], "footer", index === 0);
      const cells = getBodyRowCells(footerRow);
      updateCellsPart(cells, "first-footer-row-cell", index === 0);
      updateCellsPart(cells, "last-footer-row-cell", index === rows.length - 1);
    });
    this._updateRow(this.$.sizer, columnTree[columnTree.length - 1]);
    this._resizeHandler();
    this._frozenCellsChanged();
    this._updateFirstAndLastColumn();
    this._resetKeyboardNavigation();
    this._a11yUpdateHeaderRows();
    this._a11yUpdateFooterRows();
    this.generateCellClassNames();
    this.generateCellPartNames();
    this.__updateHeaderAndFooter();
  }
  /**
   * @param {!HTMLElement} row
   * @param {GridItem} item
   * @protected
   */
  _updateItem(row, item2) {
    row._item = item2;
    const model = this.__getRowModel(row);
    this._toggleDetailsCell(row, model.detailsOpened);
    this._a11yUpdateRowLevel(row, model.level);
    this._a11yUpdateRowSelected(row, model.selected);
    this._updateRowStateParts(row, model);
    this._generateCellClassNames(row, model);
    this._generateCellPartNames(row, model);
    this._filterDragAndDrop(row, model);
    this.__updateDragSourceParts(row, model);
    iterateChildren(row, (cell) => {
      if (cell._column && !cell._column.isConnected) {
        return;
      }
      if (cell._renderer) {
        const owner = cell._column || this;
        cell._renderer.call(owner, cell._content, owner, model);
      }
    });
    this._updateDetailsCellHeight(row);
    this._a11yUpdateRowExpanded(row, model.expanded);
  }
  /** @private */
  _resizeHandler() {
    this._updateDetailsCellHeights();
    this.__updateHorizontalScrollPosition();
  }
  /** @private */
  _onAnimationEnd(e2) {
    if (e2.animationName.indexOf("vaadin-grid-appear") === 0) {
      e2.stopPropagation();
      this.__tryToRecalculateColumnWidthsIfPending();
      this._resetKeyboardNavigation();
      requestAnimationFrame(() => {
        this.__scrollToPendingIndexes();
      });
    }
  }
  /**
   * @param {!HTMLTableRowElement} row
   * @return {!GridItemModel}
   * @protected
   */
  __getRowModel(row) {
    return {
      index: row.index,
      item: row._item,
      level: this._getIndexLevel(row.index),
      expanded: this._isExpanded(row._item),
      selected: this._isSelected(row._item),
      detailsOpened: !!this.rowDetailsRenderer && this._isDetailsOpened(row._item)
    };
  }
  /**
   * @param {Event} event
   * @protected
   */
  _showTooltip(event) {
    const tooltip = this._tooltipController.node;
    if (tooltip && tooltip.isConnected) {
      const target = event.target;
      if (!this.__isCellFullyVisible(target)) {
        return;
      }
      this._tooltipController.setTarget(target);
      this._tooltipController.setContext(this.getEventContext(event));
      tooltip._stateController.open({
        focus: event.type === "focusin",
        hover: event.type === "mouseenter"
      });
    }
  }
  /** @private */
  __isCellFullyVisible(cell) {
    if (cell.hasAttribute("frozen") || cell.hasAttribute("frozen-to-end")) {
      return true;
    }
    let { left, right } = this.getBoundingClientRect();
    const frozen = [...cell.parentNode.children].find((cell2) => cell2.hasAttribute("last-frozen"));
    if (frozen) {
      const frozenRect = frozen.getBoundingClientRect();
      left = this.__isRTL ? left : frozenRect.right;
      right = this.__isRTL ? frozenRect.left : right;
    }
    const frozenToEnd = [...cell.parentNode.children].find((cell2) => cell2.hasAttribute("first-frozen-to-end"));
    if (frozenToEnd) {
      const frozenToEndRect = frozenToEnd.getBoundingClientRect();
      left = this.__isRTL ? frozenToEndRect.right : left;
      right = this.__isRTL ? right : frozenToEndRect.left;
    }
    const cellRect = cell.getBoundingClientRect();
    return cellRect.left >= left && cellRect.right <= right;
  }
  /** @protected */
  _hideTooltip(immediate) {
    const tooltip = this._tooltipController && this._tooltipController.node;
    if (tooltip) {
      tooltip._stateController.close(immediate);
    }
  }
  /**
   * Requests an update for the content of cells.
   *
   * While performing the update, the following renderers are invoked:
   * - `Grid.rowDetailsRenderer`
   * - `GridColumn.renderer`
   * - `GridColumn.headerRenderer`
   * - `GridColumn.footerRenderer`
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    this.__updateHeaderAndFooter();
    this.__updateVisibleRows();
  }
  /** @private */
  __updateHeaderAndFooter() {
    (this._columnTree || []).forEach((level) => {
      level.forEach((column) => {
        if (column._renderHeaderAndFooter) {
          column._renderHeaderAndFooter();
        }
      });
    });
  }
  /** @protected */
  __updateVisibleRows(start, end) {
    if (this.__virtualizer) {
      this.__virtualizer.update(start, end);
    }
  }
  /** @private */
  __updateMinHeight() {
    const rowHeight = 36;
    const headerHeight = this.$.header.clientHeight;
    const footerHeight = this.$.footer.clientHeight;
    const scrollbarHeight = this.$.table.offsetHeight - this.$.table.clientHeight;
    const minHeight = headerHeight + rowHeight + footerHeight + scrollbarHeight;
    if (!this.__minHeightStyleSheet && supportsAdoptingStyleSheets) {
      this.__minHeightStyleSheet = new CSSStyleSheet();
      this.shadowRoot.adoptedStyleSheets = [...this.shadowRoot.adoptedStyleSheets, this.__minHeightStyleSheet];
    }
    if (this.__minHeightStyleSheet) {
      this.__minHeightStyleSheet.replaceSync(`:host { --_grid-min-height: ${minHeight}px; }`);
    } else {
      this.style.setProperty("--_grid-min-height", `${minHeight}px`);
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const gridStyles = css`
  @keyframes vaadin-grid-appear {
    to {
      opacity: 1;
    }
  }

  :host {
    display: flex;
    flex-direction: column;
    animation: 1ms vaadin-grid-appear;
    height: 400px;
    min-height: var(--_grid-min-height, 0);
    flex: 1 1 auto;
    align-self: stretch;
    position: relative;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([disabled]) {
    pointer-events: none;
  }

  #scroller {
    display: flex;
    flex-direction: column;
    min-height: 100%;
    transform: translateY(0);
    width: auto;
    height: auto;
    position: absolute;
    inset: 0;
  }

  :host([all-rows-visible]) {
    height: auto;
    align-self: flex-start;
    min-height: auto;
    flex-grow: 0;
    width: 100%;
  }

  :host([all-rows-visible]) #scroller {
    width: 100%;
    height: 100%;
    position: relative;
  }

  :host([all-rows-visible]) #items {
    min-height: 1px;
  }

  #table {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    overflow: auto;
    position: relative;
    outline: none;
    /* Workaround for a Desktop Safari bug: new stacking context here prevents the scrollbar from getting hidden */
    z-index: 0;
  }

  #header,
  #footer {
    display: block;
    position: -webkit-sticky;
    position: sticky;
    left: 0;
    overflow: visible;
    width: 100%;
    z-index: 1;
  }

  #header {
    top: 0;
  }

  th {
    text-align: inherit;
  }

  /* Safari doesn't work with "inherit" */
  [safari] th {
    text-align: initial;
  }

  #footer {
    bottom: 0;
  }

  #items {
    flex-grow: 1;
    flex-shrink: 0;
    display: block;
    position: -webkit-sticky;
    position: sticky;
    width: 100%;
    left: 0;
    overflow: visible;
  }

  [part~='row'] {
    display: flex;
    width: 100%;
    box-sizing: border-box;
    margin: 0;
  }

  [part~='row'][loading] [part~='body-cell'] ::slotted(vaadin-grid-cell-content) {
    visibility: hidden;
  }

  [column-rendering='lazy'] [part~='body-cell']:not([frozen]):not([frozen-to-end]) {
    transform: translateX(var(--_grid-lazy-columns-start));
  }

  #items [part~='row'] {
    position: absolute;
  }

  #items [part~='row']:empty {
    height: 100%;
  }

  [part~='cell']:not([part~='details-cell']) {
    flex-shrink: 0;
    flex-grow: 1;
    box-sizing: border-box;
    display: flex;
    width: 100%;
    position: relative;
    align-items: center;
    padding: 0;
    white-space: nowrap;
  }

  [part~='cell'] {
    outline: none;
  }

  [part~='cell'] > [tabindex] {
    display: flex;
    align-items: inherit;
    outline: none;
    position: absolute;
    inset: 0;
  }

  /* Switch the focusButtonMode wrapping element to "position: static" temporarily
     when measuring real width of the cells in the auto-width columns. */
  [measuring-auto-width] [part~='cell'] > [tabindex] {
    position: static;
  }

  [part~='details-cell'] {
    position: absolute;
    bottom: 0;
    width: 100%;
    box-sizing: border-box;
    padding: 0;
  }

  [part~='cell'] ::slotted(vaadin-grid-cell-content) {
    display: block;
    width: 100%;
    box-sizing: border-box;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  [hidden] {
    display: none !important;
  }

  [frozen],
  [frozen-to-end] {
    z-index: 2;
    will-change: transform;
  }

  [no-scrollbars][safari] #table,
  [no-scrollbars][firefox] #table {
    overflow: hidden;
  }

  /* Empty state */

  #scroller:not([empty-state]) #emptystatebody,
  #scroller[empty-state] #items {
    display: none;
  }

  #emptystatebody {
    display: flex;
    position: sticky;
    inset: 0;
    flex: 1;
    overflow: hidden;
  }

  #emptystaterow {
    display: flex;
    flex: 1;
  }

  #emptystatecell {
    display: block;
    flex: 1;
    overflow: auto;
  }

  /* Reordering styles */
  :host([reordering]) [part~='cell'] ::slotted(vaadin-grid-cell-content),
  :host([reordering]) [part~='resize-handle'],
  #scroller[no-content-pointer-events] [part~='cell'] ::slotted(vaadin-grid-cell-content) {
    pointer-events: none;
  }

  [part~='reorder-ghost'] {
    visibility: hidden;
    position: fixed;
    pointer-events: none;
    opacity: 0.5;

    /* Prevent overflowing the grid in Firefox */
    top: 0;
    left: 0;
  }

  :host([reordering]) {
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
  }

  /* Resizing styles */
  [part~='resize-handle'] {
    position: absolute;
    top: 0;
    right: 0;
    height: 100%;
    cursor: col-resize;
    z-index: 1;
  }

  [part~='resize-handle']::before {
    position: absolute;
    content: '';
    height: 100%;
    width: 35px;
    transform: translateX(-50%);
  }

  [last-column] [part~='resize-handle']::before,
  [last-frozen] [part~='resize-handle']::before {
    width: 18px;
    transform: none;
    right: 0;
  }

  [frozen-to-end] [part~='resize-handle'] {
    left: 0;
    right: auto;
  }

  [frozen-to-end] [part~='resize-handle']::before {
    left: 0;
    right: auto;
  }

  [first-frozen-to-end] [part~='resize-handle']::before {
    width: 18px;
    transform: none;
  }

  [first-frozen-to-end] {
    margin-inline-start: auto;
  }

  /* Hide resize handle if scrolled to end */
  :host(:not([overflow~='end'])) [first-frozen-to-end] [part~='resize-handle'] {
    display: none;
  }

  #scroller[column-resizing] {
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
  }

  /* Sizer styles */
  #sizer {
    display: flex;
    position: absolute;
    visibility: hidden;
  }

  #sizer [part~='details-cell'] {
    display: none !important;
  }

  #sizer [part~='cell'][hidden] {
    display: none !important;
  }

  #sizer [part~='cell'] {
    display: block;
    flex-shrink: 0;
    line-height: 0;
    height: 0 !important;
    min-height: 0 !important;
    max-height: 0 !important;
    padding: 0 !important;
    border: none !important;
  }

  #sizer [part~='cell']::before {
    content: '-';
  }

  #sizer [part~='cell'] ::slotted(vaadin-grid-cell-content) {
    display: none !important;
  }

  /* RTL specific styles */

  :host([dir='rtl']) #items,
  :host([dir='rtl']) #header,
  :host([dir='rtl']) #footer {
    left: auto;
  }

  :host([dir='rtl']) [part~='reorder-ghost'] {
    left: auto;
    right: 0;
  }

  :host([dir='rtl']) [part~='resize-handle'] {
    left: 0;
    right: auto;
  }

  :host([dir='rtl']) [part~='resize-handle']::before {
    transform: translateX(50%);
  }

  :host([dir='rtl']) [last-column] [part~='resize-handle']::before,
  :host([dir='rtl']) [last-frozen] [part~='resize-handle']::before {
    left: 0;
    right: auto;
  }

  :host([dir='rtl']) [frozen-to-end] [part~='resize-handle'] {
    right: 0;
    left: auto;
  }

  :host([dir='rtl']) [frozen-to-end] [part~='resize-handle']::before {
    right: 0;
    left: auto;
  }

  @media (forced-colors: active) {
    [part~='selected-row'] [part~='first-column-cell']::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      border: 2px solid;
    }

    [part~='focused-cell']::before {
      outline: 2px solid !important;
      outline-offset: -1px;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-grid", gridStyles, { moduleId: "vaadin-grid-styles" });
class Grid extends GridMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <div
        id="scroller"
        safari$="[[_safari]]"
        ios$="[[_ios]]"
        loading$="[[loading]]"
        column-reordering-allowed$="[[columnReorderingAllowed]]"
        empty-state$="[[__emptyState]]"
      >
        <table id="table" role="treegrid" aria-multiselectable="true" tabindex="0" aria-label$="[[accessibleName]]">
          <caption id="sizer" part="row"></caption>
          <thead id="header" role="rowgroup"></thead>
          <tbody id="items" role="rowgroup"></tbody>
          <tbody id="emptystatebody">
            <tr id="emptystaterow">
              <td part="empty-state" id="emptystatecell" tabindex="0">
                <slot name="empty-state" id="emptystateslot"></slot>
              </td>
            </tr>
          </tbody>
          <tfoot id="footer" role="rowgroup"></tfoot>
        </table>

        <div part="reorder-ghost"></div>
      </div>

      <slot name="tooltip"></slot>

      <div id="focusexit" tabindex="0"></div>
    `;
  }
  static get is() {
    return "vaadin-grid";
  }
}
defineCustomElement(Grid);
registerStyles$1(
  "vaadin-grid-sorter",
  css`
    :host {
      justify-content: flex-start;
      align-items: baseline;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
      cursor: var(--lumo-clickable-cursor);
    }

    [part='content'] {
      display: inline-block;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    [part='indicators'] {
      margin-left: var(--lumo-space-s);
    }

    [part='indicators']::before {
      transform: scale(0.8);
    }

    :host(:not([direction]):not(:hover)) [part='indicators'] {
      color: var(--lumo-tertiary-text-color);
    }

    :host([direction]) {
      color: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
    }

    [part='order'] {
      font-size: var(--lumo-font-size-xxs);
      line-height: 1;
    }

    /* RTL specific styles */

    :host([dir='rtl']) [part='indicators'] {
      margin-right: var(--lumo-space-s);
      margin-left: 0;
    }
  `,
  { moduleId: "lumo-grid-sorter" }
);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const template$4 = document.createElement("template");
template$4.innerHTML = `
  <style>
    @font-face {
      font-family: 'vaadin-grid-sorter-icons';
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAQwAA0AAAAABuwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAEFAAAABkAAAAcfep+mUdERUYAAAP4AAAAHAAAAB4AJwAOT1MvMgAAAZgAAAA/AAAAYA8TBPpjbWFwAAAB7AAAAFUAAAFeF1fZ4mdhc3AAAAPwAAAACAAAAAgAAAAQZ2x5ZgAAAlgAAABcAAAAnMvguMloZWFkAAABMAAAAC8AAAA2C5Ap72hoZWEAAAFgAAAAHQAAACQGbQPHaG10eAAAAdgAAAAUAAAAHAoAAABsb2NhAAACRAAAABIAAAASAIwAYG1heHAAAAGAAAAAFgAAACAACwAKbmFtZQAAArQAAAECAAACZxWCgKhwb3N0AAADuAAAADUAAABZCrApUXicY2BkYGAA4rDECVrx/DZfGbhZGEDgyqNPOxH0/wNMq5kPALkcDEwgUQBWRA0dAHicY2BkYGA+8P8AAwMLAwgwrWZgZEAFbABY4QM8AAAAeJxjYGRgYOAAQiYGEICQSAAAAi8AFgAAeJxjYGY6yziBgZWBgWkm0xkGBoZ+CM34msGYkZMBFTAKoAkwODAwvmRiPvD/AIMDMxCD1CDJKjAwAgBktQsXAHicY2GAAMZQCM0EwqshbAALxAEKeJxjYGBgZoBgGQZGBhCIAPIYwXwWBhsgzcXAwcAEhIwMCi+Z/v/9/x+sSuElA4T9/4k4K1gHFwMMMILMY2QDYmaoABOQYGJABUA7WBiGNwAAJd4NIQAAAAAAAAAACAAIABAAGAAmAEAATgAAeJyNjLENgDAMBP9tIURJwQCMQccSZgk2i5fIYBDAidJjycXr7x5EPwE2wY8si7jmyBNXGo/bNBerxJNrpxhbO3/fEFpx8ZICpV+ghxJ74fAMe+h7Ox14AbrsHB14nK2QQWrDMBRER4mTkhQK3ZRQKOgCNk7oGQqhhEIX2WSlWEI1BAlkJ5CDdNsj5Ey9Rncdi38ES+jzNJo/HwTgATcoDEthhY3wBHc4CE+pfwsX5F/hGe7Vo/AcK/UhvMSz+mGXKhZU6pww8ISz3oWn1BvhgnwTnuEJf8Jz1OpFeIlX9YULDLdFi4ASHolkSR0iuYdjLak1vAequBhj21D61Nqyi6l3qWybGPjySbPHGScGJl6dP58MYcQRI0bts7mjebBqrFENH7t3qWtj0OuqHnXcW7b0HOTZFnKryRGW2hFX1m0O2vEM3opNMfTau+CS6Z3Vx6veNnEXY6jwDxhsc2gAAHicY2BiwA84GBgYmRiYGJkZmBlZGFkZ2djScyoLMgzZS/MyDQwMwLSrpYEBlIbxjQDrzgsuAAAAAAEAAf//AA94nGNgZGBg4AFiMSBmYmAEQnYgZgHzGAAD6wA2eJxjYGBgZACCKyoz1cD0o087YTQATOcIewAAAA==) format('woff');
      font-weight: normal;
      font-style: normal;
    }
  </style>
`;
document.head.appendChild(template$4.content);
registerStyles$1(
  "vaadin-grid-sorter",
  css`
    :host {
      display: inline-flex;
      cursor: pointer;
      max-width: 100%;
    }

    [part='content'] {
      flex: 1 1 auto;
    }

    [part='indicators'] {
      position: relative;
      align-self: center;
      flex: none;
    }

    [part='order'] {
      display: inline;
      vertical-align: super;
    }

    [part='indicators']::before {
      font-family: 'vaadin-grid-sorter-icons';
      display: inline-block;
    }

    :host(:not([direction])) [part='indicators']::before {
      content: '\\e901';
    }

    :host([direction='asc']) [part='indicators']::before {
      content: '\\e900';
    }

    :host([direction='desc']) [part='indicators']::before {
      content: '\\e902';
    }
  `,
  { moduleId: "vaadin-grid-sorter-styles" }
);
const GridSorterMixin = (superClass) => class GridSorterMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * JS Path of the property in the item used for sorting the data.
       */
      path: String,
      /**
       * How to sort the data.
       * Possible values are `asc` to use an ascending algorithm, `desc` to sort the data in
       * descending direction, or `null` for not sorting the data.
       * @type {GridSorterDirection | undefined}
       */
      direction: {
        type: String,
        reflectToAttribute: true,
        notify: true,
        value: null,
        sync: true
      },
      /**
       * @type {number | null}
       * @protected
       */
      _order: {
        type: Number,
        value: null,
        sync: true
      }
    };
  }
  static get observers() {
    return ["_pathOrDirectionChanged(path, direction)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("click", this._onClick.bind(this));
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this._grid) {
      this._grid.__applySorters();
    } else {
      this.__dispatchSorterChangedEvenIfPossible();
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    if (!this.parentNode && this._grid) {
      this._grid.__removeSorters([this]);
    } else if (this._grid) {
      this._grid.__applySorters();
    }
  }
  /** @private */
  _pathOrDirectionChanged() {
    this.__dispatchSorterChangedEvenIfPossible();
  }
  /** @private */
  __dispatchSorterChangedEvenIfPossible() {
    if (this.path === void 0 || this.direction === void 0 || !this.isConnected) {
      return;
    }
    this.dispatchEvent(
      new CustomEvent("sorter-changed", {
        detail: { shiftClick: Boolean(this._shiftClick), fromSorterClick: Boolean(this._fromSorterClick) },
        bubbles: true,
        composed: true
      })
    );
    this._fromSorterClick = false;
    this._shiftClick = false;
  }
  /** @private */
  _getDisplayOrder(order) {
    return order === null ? "" : order + 1;
  }
  /** @private */
  _onClick(e2) {
    if (e2.defaultPrevented) {
      return;
    }
    const activeElement = this.getRootNode().activeElement;
    if (this !== activeElement && this.contains(activeElement)) {
      return;
    }
    e2.preventDefault();
    this._shiftClick = e2.shiftKey;
    this._fromSorterClick = true;
    if (this.direction === "asc") {
      this.direction = "desc";
    } else if (this.direction === "desc") {
      this.direction = null;
    } else {
      this.direction = "asc";
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class GridSorter extends GridSorterMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get template() {
    return html`
      <div part="content">
        <slot></slot>
      </div>
      <div part="indicators">
        <span part="order">[[_getDisplayOrder(_order)]]</span>
      </div>
    `;
  }
  static get is() {
    return "vaadin-grid-sorter";
  }
}
defineCustomElement(GridSorter);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const GridSelectionColumnBaseMixin = (superClass) => class GridSelectionColumnBaseMixin extends superClass {
  static get properties() {
    return {
      /**
       * Width of the cells for this column.
       */
      width: {
        type: String,
        value: "58px",
        sync: true
      },
      /**
       * Override `autoWidth` to enable auto-width
       */
      autoWidth: {
        type: Boolean,
        value: true
      },
      /**
       * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.
       * @attr {number} flex-grow
       * @type {number}
       */
      flexGrow: {
        type: Number,
        value: 0,
        sync: true
      },
      /**
       * When true, all the items are selected.
       * @attr {boolean} select-all
       * @type {boolean}
       */
      selectAll: {
        type: Boolean,
        value: false,
        notify: true,
        sync: true
      },
      /**
       * When true, the active gets automatically selected.
       * @attr {boolean} auto-select
       * @type {boolean}
       */
      autoSelect: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * When true, rows can be selected by dragging over the selection column.
       * @attr {boolean} drag-select
       * @type {boolean}
       */
      dragSelect: {
        type: Boolean,
        value: false,
        sync: true
      },
      /** @protected */
      _indeterminate: {
        type: Boolean,
        sync: true
      },
      /** @protected */
      _selectAllHidden: Boolean
    };
  }
  static get observers() {
    return [
      "_onHeaderRendererOrBindingChanged(_headerRenderer, _headerCell, path, header, selectAll, _indeterminate, _selectAllHidden)"
    ];
  }
  constructor() {
    super();
    this.__onCellTrack = this.__onCellTrack.bind(this);
    this.__onCellClick = this.__onCellClick.bind(this);
    this.__onCellMouseDown = this.__onCellMouseDown.bind(this);
    this.__onActiveItemChanged = this.__onActiveItemChanged.bind(this);
    this.__onSelectRowCheckboxChange = this.__onSelectRowCheckboxChange.bind(this);
    this.__onSelectAllCheckboxChange = this.__onSelectAllCheckboxChange.bind(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this._grid) {
      this._grid.addEventListener("active-item-changed", this.__onActiveItemChanged);
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this._grid) {
      this._grid.removeEventListener("active-item-changed", this.__onActiveItemChanged);
    }
  }
  /**
   * Renders the Select All checkbox to the header cell.
   *
   * @override
   */
  _defaultHeaderRenderer(root2, _column) {
    let checkbox = root2.firstElementChild;
    if (!checkbox) {
      checkbox = document.createElement("vaadin-checkbox");
      checkbox.setAttribute("aria-label", "Select All");
      checkbox.classList.add("vaadin-grid-select-all-checkbox");
      checkbox.addEventListener("change", this.__onSelectAllCheckboxChange);
      root2.appendChild(checkbox);
    }
    const checked = this.__isChecked(this.selectAll, this._indeterminate);
    checkbox.checked = checked;
    checkbox.hidden = this._selectAllHidden;
    checkbox.indeterminate = this._indeterminate;
  }
  /**
   * Renders the Select Row checkbox to the body cell.
   *
   * @override
   */
  _defaultRenderer(root2, _column, { item: item2, selected }) {
    let checkbox = root2.firstElementChild;
    if (!checkbox) {
      checkbox = document.createElement("vaadin-checkbox");
      checkbox.setAttribute("aria-label", "Select Row");
      checkbox.addEventListener("change", this.__onSelectRowCheckboxChange);
      root2.appendChild(checkbox);
      addListener(root2, "track", this.__onCellTrack);
      root2.addEventListener("mousedown", this.__onCellMouseDown);
      root2.addEventListener("click", this.__onCellClick);
    }
    checkbox.__item = item2;
    checkbox.checked = selected;
    const isSelectable = this._grid.__isItemSelectable(item2);
    checkbox.readonly = !isSelectable;
    checkbox.hidden = !isSelectable && !selected;
  }
  /**
   * Updates the select all state when the Select All checkbox is switched.
   * The listener handles only user-fired events.
   *
   * @private
   */
  __onSelectAllCheckboxChange(e2) {
    if (this._indeterminate || e2.currentTarget.checked) {
      this._selectAll();
    } else {
      this._deselectAll();
    }
  }
  /**
   * Selects or deselects the row when the Select Row checkbox is switched.
   * The listener handles only user-fired events.
   *
   * @private
   */
  __onSelectRowCheckboxChange(e2) {
    this.__toggleItem(e2.currentTarget.__item, e2.currentTarget.checked);
  }
  /** @private */
  __onCellTrack(event) {
    if (!this.dragSelect) {
      return;
    }
    this.__dragCurrentY = event.detail.y;
    this.__dragDy = event.detail.dy;
    if (event.detail.state === "start") {
      const renderedRows = this._grid._getRenderedRows();
      const dragStartRow = renderedRows.find((row) => row.contains(event.currentTarget.assignedSlot));
      this.__selectOnDrag = !this._grid._isSelected(dragStartRow._item);
      this.__dragStartIndex = dragStartRow.index;
      this.__dragStartItem = dragStartRow._item;
      this.__dragAutoScroller();
    } else if (event.detail.state === "end") {
      if (this.__dragStartItem) {
        this.__toggleItem(this.__dragStartItem, this.__selectOnDrag);
      }
      setTimeout(() => {
        this.__dragStartIndex = void 0;
      });
    }
  }
  /** @private */
  __onCellMouseDown(e2) {
    if (this.dragSelect) {
      e2.preventDefault();
    }
  }
  /** @private */
  __onCellClick(e2) {
    if (this.__dragStartIndex !== void 0) {
      e2.preventDefault();
    }
  }
  /** @private */
  _onCellKeyDown(e2) {
    const target = e2.composedPath()[0];
    if (e2.keyCode !== 32) {
      return;
    }
    if (target === this._headerCell) {
      if (this.selectAll) {
        this._deselectAll();
      } else {
        this._selectAll();
      }
    } else if (this._cells.includes(target) && !this.autoSelect) {
      const checkbox = target._content.firstElementChild;
      this.__toggleItem(checkbox.__item);
    }
  }
  /** @private */
  __onActiveItemChanged(e2) {
    const activeItem = e2.detail.value;
    if (this.autoSelect) {
      const item2 = activeItem || this.__previousActiveItem;
      if (item2) {
        this.__toggleItem(item2);
      }
    }
    this.__previousActiveItem = activeItem;
  }
  /** @private */
  __dragAutoScroller() {
    if (this.__dragStartIndex === void 0) {
      return;
    }
    const renderedRows = this._grid._getRenderedRows();
    const hoveredRow = renderedRows.find((row) => {
      const rowRect = row.getBoundingClientRect();
      return this.__dragCurrentY >= rowRect.top && this.__dragCurrentY <= rowRect.bottom;
    });
    let hoveredIndex = hoveredRow ? hoveredRow.index : void 0;
    const scrollableArea = this.__getScrollableArea();
    if (this.__dragCurrentY < scrollableArea.top) {
      hoveredIndex = this._grid._firstVisibleIndex;
    } else if (this.__dragCurrentY > scrollableArea.bottom) {
      hoveredIndex = this._grid._lastVisibleIndex;
    }
    if (hoveredIndex !== void 0) {
      renderedRows.forEach((row) => {
        if (hoveredIndex > this.__dragStartIndex && row.index >= this.__dragStartIndex && row.index <= hoveredIndex || hoveredIndex < this.__dragStartIndex && row.index <= this.__dragStartIndex && row.index >= hoveredIndex) {
          this.__toggleItem(row._item, this.__selectOnDrag);
          this.__dragStartItem = void 0;
        }
      });
    }
    const scrollTriggerArea = scrollableArea.height * 0.15;
    const maxScrollAmount = 10;
    if (this.__dragDy < 0 && this.__dragCurrentY < scrollableArea.top + scrollTriggerArea) {
      const dy = scrollableArea.top + scrollTriggerArea - this.__dragCurrentY;
      const percentage = Math.min(1, dy / scrollTriggerArea);
      this._grid.$.table.scrollTop -= percentage * maxScrollAmount;
    }
    if (this.__dragDy > 0 && this.__dragCurrentY > scrollableArea.bottom - scrollTriggerArea) {
      const dy = this.__dragCurrentY - (scrollableArea.bottom - scrollTriggerArea);
      const percentage = Math.min(1, dy / scrollTriggerArea);
      this._grid.$.table.scrollTop += percentage * maxScrollAmount;
    }
    setTimeout(() => this.__dragAutoScroller(), 10);
  }
  /**
   * Gets the scrollable area of the grid as a bounding client rect. The
   * scrollable area is the bounding rect of the grid minus the header and
   * footer.
   *
   * @private
   */
  __getScrollableArea() {
    const gridRect = this._grid.$.table.getBoundingClientRect();
    const headerRect = this._grid.$.header.getBoundingClientRect();
    const footerRect = this._grid.$.footer.getBoundingClientRect();
    return {
      top: gridRect.top + headerRect.height,
      bottom: gridRect.bottom - footerRect.height,
      left: gridRect.left,
      right: gridRect.right,
      height: gridRect.height - headerRect.height - footerRect.height,
      width: gridRect.width
    };
  }
  /**
   * Override to handle the user selecting all items.
   * @protected
   */
  _selectAll() {
  }
  /**
   * Override to handle the user deselecting all items.
   * @protected
   */
  _deselectAll() {
  }
  /**
   * Override to handle the user selecting an item.
   * @param {Object} item the item to select
   * @protected
   */
  _selectItem(_item) {
  }
  /**
   * Override to handle the user deselecting an item.
   * @param {Object} item the item to deselect
   * @protected
   */
  _deselectItem(_item) {
  }
  /**
   * Toggles the selected state of the given item.
   *
   * @param item the item to toggle
   * @param {boolean} [selected] whether to select or deselect the item
   * @private
   */
  __toggleItem(item2, selected = !this._grid._isSelected(item2)) {
    if (selected === this._grid._isSelected(item2)) {
      return;
    }
    if (selected) {
      this._selectItem(item2);
    } else {
      this._deselectItem(item2);
    }
  }
  /**
   * IOS needs indeterminate + checked at the same time
   * @private
   */
  __isChecked(selectAll, indeterminate) {
    return indeterminate || selectAll;
  }
};
class GridFlowSelectionColumn extends GridSelectionColumnBaseMixin(GridColumn) {
  static get is() {
    return "vaadin-grid-flow-selection-column";
  }
  static get properties() {
    return {
      /**
       * Override property to enable auto-width
       */
      autoWidth: {
        type: Boolean,
        value: true
      },
      /**
       * Override property to set custom width
       */
      width: {
        type: String,
        value: "56px"
      }
    };
  }
  /**
   * Override method from `GridSelectionColumnBaseMixin` to add ID to select all
   * checkbox
   *
   * @override
   */
  _defaultHeaderRenderer(root2, _column) {
    super._defaultHeaderRenderer(root2, _column);
    const checkbox = root2.firstElementChild;
    if (checkbox) {
      checkbox.id = "selectAllCheckbox";
    }
  }
  /**
   * Override a method from `GridSelectionColumnBaseMixin` to handle the user
   * selecting all items.
   *
   * @protected
   * @override
   */
  _selectAll() {
    this.selectAll = true;
    this.$server.selectAll();
  }
  /**
   * Override a method from `GridSelectionColumnBaseMixin` to handle the user
   * deselecting all items.
   *
   * @protected
   * @override
   */
  _deselectAll() {
    this.selectAll = false;
    this.$server.deselectAll();
  }
  /**
   * Override a method from `GridSelectionColumnBaseMixin` to handle the user
   * selecting an item.
   *
   * @param {Object} item the item to select
   * @protected
   * @override
   */
  _selectItem(item2) {
    this._grid.$connector.doSelection([item2], true);
  }
  /**
   * Override a method from `GridSelectionColumnBaseMixin` to handle the user
   * deselecting an item.
   *
   * @param {Object} item the item to deselect
   * @protected
   * @override
   */
  _deselectItem(item2) {
    this._grid.$connector.doDeselection([item2], true);
    this.selectAll = false;
  }
}
customElements.define(GridFlowSelectionColumn.is, GridFlowSelectionColumn);
window.Vaadin.Flow.gridConnector = {};
window.Vaadin.Flow.gridConnector.initLazy = (grid) => {
  if (grid.$connector) {
    return;
  }
  const dataProviderController = grid._dataProviderController;
  dataProviderController.ensureFlatIndexHierarchyOriginal = dataProviderController.ensureFlatIndexHierarchy;
  dataProviderController.ensureFlatIndexHierarchy = function(flatIndex) {
    const { item: item2 } = this.getFlatIndexContext(flatIndex);
    if (!item2 || !this.isExpanded(item2)) {
      return;
    }
    const isCached = grid.$connector.hasCacheForParentKey(grid.getItemId(item2));
    if (isCached) {
      this.ensureFlatIndexHierarchyOriginal(flatIndex);
    } else {
      grid.$connector.beforeEnsureFlatIndexHierarchy(flatIndex, item2);
    }
  };
  dataProviderController.isLoadingOriginal = dataProviderController.isLoading;
  dataProviderController.isLoading = function() {
    return grid.$connector.hasEnsureSubCacheQueue() || this.isLoadingOriginal();
  };
  dataProviderController.getItemSubCache = function(item2) {
    var _a2;
    return (_a2 = this.getItemContext(item2)) == null ? void 0 : _a2.subCache;
  };
  let cache = {};
  const parentRequestDelay = 50;
  const parentRequestBatchMaxSize = 20;
  let parentRequestQueue = [];
  let parentRequestDebouncer;
  let ensureSubCacheQueue = [];
  let ensureSubCacheDebouncer;
  const rootRequestDelay = 150;
  let rootRequestDebouncer;
  let lastRequestedRanges = {};
  const root2 = "null";
  lastRequestedRanges[root2] = [0, 0];
  let currentUpdateClearRange = null;
  let currentUpdateSetRange = null;
  const validSelectionModes = ["SINGLE", "NONE", "MULTI"];
  let selectedKeys = {};
  let selectionMode = "SINGLE";
  let sorterDirectionsSetFromServer = false;
  grid.size = 0;
  grid.itemIdPath = "key";
  function createEmptyItemFromKey(key) {
    return { [grid.itemIdPath]: key };
  }
  grid.$connector = {};
  grid.$connector.hasCacheForParentKey = (parentKey) => {
    var _a2;
    return ((_a2 = cache[parentKey]) == null ? void 0 : _a2.size) !== void 0;
  };
  grid.$connector.hasEnsureSubCacheQueue = () => ensureSubCacheQueue.length > 0;
  grid.$connector.hasParentRequestQueue = () => parentRequestQueue.length > 0;
  grid.$connector.hasRootRequestQueue = () => {
    const { pendingRequests } = dataProviderController.rootCache;
    return Object.keys(pendingRequests).length > 0 || !!(rootRequestDebouncer == null ? void 0 : rootRequestDebouncer.isActive());
  };
  grid.$connector.beforeEnsureFlatIndexHierarchy = function(flatIndex, item2) {
    ensureSubCacheQueue.push({
      flatIndex,
      itemkey: grid.getItemId(item2)
    });
    ensureSubCacheDebouncer = Debouncer2.debounce(ensureSubCacheDebouncer, animationFrame$1, () => {
      while (ensureSubCacheQueue.length) {
        grid.$connector.flushEnsureSubCache();
      }
    });
  };
  grid.$connector.doSelection = function(items, userOriginated) {
    if (selectionMode === "NONE" || !items.length || userOriginated && grid.hasAttribute("disabled")) {
      return;
    }
    if (selectionMode === "SINGLE") {
      selectedKeys = {};
    }
    let selectedItemsChanged = false;
    items.forEach((item2) => {
      const selectable = !userOriginated || grid.isItemSelectable(item2);
      selectedItemsChanged = selectedItemsChanged || selectable;
      if (item2 && selectable) {
        selectedKeys[item2.key] = item2;
        item2.selected = true;
        if (userOriginated) {
          grid.$server.select(item2.key);
        }
      }
      const isSelectedItemDifferentOrNull = !grid.activeItem || !item2 || item2.key != grid.activeItem.key;
      if (!userOriginated && selectionMode === "SINGLE" && isSelectedItemDifferentOrNull) {
        grid.activeItem = item2;
      }
    });
    if (selectedItemsChanged) {
      grid.selectedItems = Object.values(selectedKeys);
    }
  };
  grid.$connector.doDeselection = function(items, userOriginated) {
    if (selectionMode === "NONE" || !items.length || userOriginated && grid.hasAttribute("disabled")) {
      return;
    }
    const updatedSelectedItems = grid.selectedItems.slice();
    while (items.length) {
      const itemToDeselect = items.shift();
      const selectable = !userOriginated || grid.isItemSelectable(itemToDeselect);
      if (!selectable) {
        continue;
      }
      for (let i2 = 0; i2 < updatedSelectedItems.length; i2++) {
        const selectedItem = updatedSelectedItems[i2];
        if ((itemToDeselect == null ? void 0 : itemToDeselect.key) === selectedItem.key) {
          updatedSelectedItems.splice(i2, 1);
          break;
        }
      }
      if (itemToDeselect) {
        delete selectedKeys[itemToDeselect.key];
        delete itemToDeselect.selected;
        if (userOriginated) {
          grid.$server.deselect(itemToDeselect.key);
        }
      }
    }
    grid.selectedItems = updatedSelectedItems;
  };
  grid.__activeItemChanged = function(newVal, oldVal) {
    if (selectionMode != "SINGLE") {
      return;
    }
    if (!newVal) {
      if (oldVal && selectedKeys[oldVal.key]) {
        if (grid.__deselectDisallowed) {
          grid.activeItem = oldVal;
        } else {
          oldVal = dataProviderController.getItemContext(oldVal).item;
          grid.$connector.doDeselection([oldVal], true);
        }
      }
    } else if (!selectedKeys[newVal.key]) {
      grid.$connector.doSelection([newVal], true);
    }
  };
  grid._createPropertyObserver("activeItem", "__activeItemChanged", true);
  grid.__activeItemChangedDetails = function(newVal, oldVal) {
    if (grid.__disallowDetailsOnClick) {
      return;
    }
    if (newVal == null && oldVal === void 0) {
      return;
    }
    if (newVal && !newVal.detailsOpened) {
      grid.$server.setDetailsVisible(newVal.key);
    } else {
      grid.$server.setDetailsVisible(null);
    }
  };
  grid._createPropertyObserver("activeItem", "__activeItemChangedDetails", true);
  grid.$connector._getSameLevelPage = function(parentKey, currentCache, currentCacheItemIndex) {
    const currentParentKey = currentCache.parentItem ? grid.getItemId(currentCache.parentItem) : root2;
    if (currentParentKey === parentKey) {
      return Math.floor(currentCacheItemIndex / grid.pageSize);
    }
    const { parentCache, parentCacheIndex } = currentCache;
    if (!parentCache) {
      return null;
    }
    return this._getSameLevelPage(parentKey, parentCache, parentCacheIndex);
  };
  grid.$connector.flushEnsureSubCache = function() {
    const pendingFetch = ensureSubCacheQueue.shift();
    if (pendingFetch) {
      dataProviderController.ensureFlatIndexHierarchyOriginal(pendingFetch.flatIndex);
      return true;
    }
    return false;
  };
  grid.$connector.debounceRootRequest = function(page) {
    const delay = grid._hasData ? rootRequestDelay : 0;
    rootRequestDebouncer = Debouncer2.debounce(rootRequestDebouncer, timeOut$1.after(delay), () => {
      grid.$connector.fetchPage(
        (firstIndex, size) => grid.$server.setRequestedRange(firstIndex, size),
        page,
        root2
      );
    });
  };
  grid.$connector.flushParentRequests = function() {
    const pendingFetches = [];
    parentRequestQueue.splice(0, parentRequestBatchMaxSize).forEach(({ parentKey, page }) => {
      grid.$connector.fetchPage(
        (firstIndex, size) => pendingFetches.push({ parentKey, firstIndex, size }),
        page,
        parentKey
      );
    });
    if (pendingFetches.length) {
      grid.$server.setParentRequestedRanges(pendingFetches);
    }
  };
  grid.$connector.debounceParentRequest = function(parentKey, page) {
    parentRequestQueue = parentRequestQueue.filter((request) => request.parentKey !== parentKey);
    parentRequestQueue.push({ parentKey, page });
    parentRequestDebouncer = Debouncer2.debounce(parentRequestDebouncer, timeOut$1.after(parentRequestDelay), () => {
      while (parentRequestQueue.length) {
        grid.$connector.flushParentRequests();
      }
    });
  };
  grid.$connector.fetchPage = function(fetch2, page, parentKey) {
    if (parentKey === root2) {
      page = Math.min(page, Math.floor((grid.size - 1) / grid.pageSize));
    }
    const visibleRows = grid._getRenderedRows();
    let start = visibleRows.length > 0 ? visibleRows[0].index : 0;
    let end = visibleRows.length > 0 ? visibleRows[visibleRows.length - 1].index : 0;
    let buffer = end - start;
    let firstNeededIndex = Math.max(0, start - buffer);
    let lastNeededIndex = Math.min(end + buffer, grid._flatSize);
    let pageRange = [null, null];
    for (let idx = firstNeededIndex; idx <= lastNeededIndex; idx++) {
      const { cache: cache2, index } = dataProviderController.getFlatIndexContext(idx);
      const sameLevelPage = grid.$connector._getSameLevelPage(parentKey, cache2, index);
      if (sameLevelPage === null) {
        continue;
      }
      pageRange[0] = Math.min(pageRange[0] ?? sameLevelPage, sameLevelPage);
      pageRange[1] = Math.max(pageRange[1] ?? sameLevelPage, sameLevelPage);
    }
    if (pageRange.some((p) => p === null) || page < pageRange[0] || page > pageRange[1]) {
      pageRange = [page, page];
    }
    let lastRequestedRange = lastRequestedRanges[parentKey] || [-1, -1];
    if (lastRequestedRange[0] != pageRange[0] || lastRequestedRange[1] != pageRange[1]) {
      lastRequestedRanges[parentKey] = pageRange;
      let pageCount = pageRange[1] - pageRange[0] + 1;
      fetch2(pageRange[0] * grid.pageSize, pageCount * grid.pageSize);
    }
  };
  grid.dataProvider = function(params, callback) {
    var _a2, _b2;
    if (params.pageSize != grid.pageSize) {
      throw "Invalid pageSize";
    }
    let page = params.page;
    if (params.parentItem) {
      let parentUniqueKey = grid.getItemId(params.parentItem);
      const parentItemSubCache = dataProviderController.getItemSubCache(params.parentItem);
      if (((_a2 = cache[parentUniqueKey]) == null ? void 0 : _a2[page]) && parentItemSubCache) {
        ensureSubCacheQueue = [];
        callback(cache[parentUniqueKey][page], cache[parentUniqueKey].size);
      } else {
        grid.$connector.debounceParentRequest(parentUniqueKey, page);
      }
    } else {
      if (grid.size === 0) {
        callback([], 0);
        return;
      }
      if ((_b2 = cache[root2]) == null ? void 0 : _b2[page]) {
        callback(cache[root2][page]);
      } else {
        grid.$connector.debounceRootRequest(page);
      }
    }
  };
  grid.$connector.setSorterDirections = function(directions) {
    sorterDirectionsSetFromServer = true;
    setTimeout(() => {
      try {
        const sorters = Array.from(grid.querySelectorAll("vaadin-grid-sorter"));
        grid._sorters.forEach((sorter) => {
          if (!sorters.includes(sorter)) {
            sorters.push(sorter);
          }
        });
        sorters.forEach((sorter) => {
          sorter.direction = null;
        });
        if (grid.multiSortPriority !== "append") {
          directions = directions.reverse();
        }
        directions.forEach(({ column, direction }) => {
          sorters.forEach((sorter) => {
            if (sorter.getAttribute("path") === column) {
              sorter.direction = direction;
            }
          });
        });
        grid.__applySorters();
      } finally {
        sorterDirectionsSetFromServer = false;
      }
    });
  };
  grid._updateItem = function(row, item2) {
    Grid.prototype._updateItem.call(grid, row, item2);
    if (!row.hidden) {
      Array.from(row.children).forEach((cell) => {
        var _a2, _b2;
        Array.from(((_b2 = (_a2 = cell == null ? void 0 : cell._content) == null ? void 0 : _a2.__templateInstance) == null ? void 0 : _b2.children) || []).forEach((content) => {
          if (content._attachRenderedComponentIfAble) {
            content._attachRenderedComponentIfAble();
          }
          Array.from((content == null ? void 0 : content.children) || []).forEach((innerContent) => {
            if (innerContent._attachRenderedComponentIfAble) {
              innerContent._attachRenderedComponentIfAble();
            }
          });
        });
      });
    }
    if (selectionMode === validSelectionModes[1]) {
      row.removeAttribute("aria-selected");
      Array.from(row.children).forEach((cell) => cell.removeAttribute("aria-selected"));
    }
  };
  const itemExpandedChanged = function(item2, expanded) {
    if (item2 == void 0 || grid.$server.updateExpandedState == void 0) {
      return;
    }
    let parentKey = grid.getItemId(item2);
    grid.$server.updateExpandedState(parentKey, expanded);
  };
  grid.expandItem = function(item2) {
    itemExpandedChanged(item2, true);
    Grid.prototype.expandItem.call(grid, item2);
  };
  grid.collapseItem = function(item2) {
    itemExpandedChanged(item2, false);
    Grid.prototype.collapseItem.call(grid, item2);
  };
  const itemsUpdated = function(items) {
    if (!items || !Array.isArray(items)) {
      throw "Attempted to call itemsUpdated with an invalid value: " + JSON.stringify(items);
    }
    let detailsOpenedItems = Array.from(grid.detailsOpenedItems);
    for (let i2 = 0; i2 < items.length; ++i2) {
      const item2 = items[i2];
      if (!item2) {
        continue;
      }
      if (item2.detailsOpened) {
        if (grid._getItemIndexInArray(item2, detailsOpenedItems) < 0) {
          detailsOpenedItems.push(item2);
        }
      } else if (grid._getItemIndexInArray(item2, detailsOpenedItems) >= 0) {
        detailsOpenedItems.splice(grid._getItemIndexInArray(item2, detailsOpenedItems), 1);
      }
    }
    grid.detailsOpenedItems = detailsOpenedItems;
  };
  const updateGridCache = function(page, parentKey = root2) {
    const items = cache[parentKey][page];
    const parentItem = createEmptyItemFromKey(parentKey);
    let gridCache = parentKey === root2 ? dataProviderController.rootCache : dataProviderController.getItemSubCache(parentItem);
    if (gridCache && !gridCache.pendingRequests[page]) {
      gridCache.setPage(page, items || Array.from({ length: grid.pageSize }));
    }
    return items;
  };
  const updateAllGridRowsInDomBasedOnCache = function() {
    updateGridFlatSize();
    grid.__updateVisibleRows();
  };
  const updateGridFlatSize = function() {
    dataProviderController.recalculateFlatSize();
    grid._flatSize = dataProviderController.flatSize;
  };
  const updateGridItemsInDomBasedOnCache = function(items) {
    if (!items || !grid.$ || grid.$.items.childElementCount === 0) {
      return;
    }
    const itemKeys = items.map((item2) => item2.key);
    const indexes = grid._getRenderedRows().filter((row) => row._item && itemKeys.includes(row._item.key)).map((row) => row.index);
    if (indexes.length > 0) {
      grid.__updateVisibleRows(indexes[0], indexes[indexes.length - 1]);
    }
  };
  grid.$connector.set = function(index, items, parentKey) {
    if (index % grid.pageSize != 0) {
      throw "Got new data to index " + index + " which is not aligned with the page size of " + grid.pageSize;
    }
    let pkey = parentKey || root2;
    const firstPage = index / grid.pageSize;
    const updatedPageCount = Math.ceil(items.length / grid.pageSize);
    if (pkey === root2) {
      currentUpdateSetRange = [firstPage, firstPage + updatedPageCount - 1];
    }
    for (let i2 = 0; i2 < updatedPageCount; i2++) {
      let page = firstPage + i2;
      let slice = items.slice(i2 * grid.pageSize, (i2 + 1) * grid.pageSize);
      if (!cache[pkey]) {
        cache[pkey] = {};
      }
      cache[pkey][page] = slice;
      grid.$connector.doSelection(slice.filter((item2) => item2.selected));
      grid.$connector.doDeselection(slice.filter((item2) => !item2.selected && selectedKeys[item2.key]));
      const updatedItems = updateGridCache(page, pkey);
      if (updatedItems) {
        itemsUpdated(updatedItems);
        updateGridItemsInDomBasedOnCache(updatedItems);
      }
    }
  };
  const itemToCacheLocation = function(item2) {
    let parent = item2.parentUniqueKey || root2;
    if (cache[parent]) {
      for (let page in cache[parent]) {
        for (let index in cache[parent][page]) {
          if (grid.getItemId(cache[parent][page][index]) === grid.getItemId(item2)) {
            return { page, index, parentKey: parent };
          }
        }
      }
    }
    return null;
  };
  grid.$connector.updateHierarchicalData = function(updatedItems) {
    let pagesToUpdate = [];
    for (let i2 = 0; i2 < updatedItems.length; i2++) {
      let cacheLocation = itemToCacheLocation(updatedItems[i2]);
      if (cacheLocation) {
        cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i2];
        let key = cacheLocation.parentKey + ":" + cacheLocation.page;
        if (!pagesToUpdate[key]) {
          pagesToUpdate[key] = {
            parentKey: cacheLocation.parentKey,
            page: cacheLocation.page
          };
        }
      }
    }
    let keys = Object.keys(pagesToUpdate);
    for (let i2 = 0; i2 < keys.length; i2++) {
      let pageToUpdate = pagesToUpdate[keys[i2]];
      const affectedUpdatedItems = updateGridCache(pageToUpdate.page, pageToUpdate.parentKey);
      if (affectedUpdatedItems) {
        itemsUpdated(affectedUpdatedItems);
        updateGridItemsInDomBasedOnCache(affectedUpdatedItems);
      }
    }
  };
  grid.$connector.updateFlatData = function(updatedItems) {
    for (let i2 = 0; i2 < updatedItems.length; i2++) {
      let cacheLocation = itemToCacheLocation(updatedItems[i2]);
      if (cacheLocation) {
        cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i2];
        const index = parseInt(cacheLocation.page) * grid.pageSize + parseInt(cacheLocation.index);
        const { rootCache } = dataProviderController;
        if (rootCache.items[index]) {
          rootCache.items[index] = updatedItems[i2];
        }
      }
    }
    itemsUpdated(updatedItems);
    updateGridItemsInDomBasedOnCache(updatedItems);
  };
  grid.$connector.clearExpanded = function() {
    grid.expandedItems = [];
    ensureSubCacheQueue = [];
    parentRequestQueue = [];
  };
  const sanitizeLastRequestedRange = function() {
    const range = lastRequestedRanges[root2];
    if (!range || !currentUpdateClearRange) {
      return;
    }
    const numClearedPages = currentUpdateClearRange[1] - currentUpdateClearRange[0] + 1;
    const clearedPages = Array.from({ length: numClearedPages }, (_, i2) => currentUpdateClearRange[0] + i2);
    if (currentUpdateSetRange) {
      const [first, last] = currentUpdateSetRange;
      for (let page = first; page <= last; page++) {
        const index = clearedPages.indexOf(page);
        if (index >= 0) {
          clearedPages.splice(index, 1);
        }
      }
    }
    if (clearedPages.some((page) => page >= range[0] && page <= range[1])) {
      range[0] = -1;
      range[1] = -1;
    }
  };
  grid.$connector.clear = function(index, length, parentKey) {
    let pkey = parentKey || root2;
    if (!cache[pkey] || Object.keys(cache[pkey]).length === 0) {
      return;
    }
    if (index % grid.pageSize != 0) {
      throw "Got cleared data for index " + index + " which is not aligned with the page size of " + grid.pageSize;
    }
    let firstPage = Math.floor(index / grid.pageSize);
    let updatedPageCount = Math.ceil(length / grid.pageSize);
    if (pkey === root2) {
      currentUpdateClearRange = [firstPage, firstPage + updatedPageCount - 1];
    }
    for (let i2 = 0; i2 < updatedPageCount; i2++) {
      let page = firstPage + i2;
      let items = cache[pkey][page];
      grid.$connector.doDeselection(items.filter((item2) => selectedKeys[item2.key]));
      items.forEach((item2) => grid.closeItemDetails(item2));
      delete cache[pkey][page];
      updateGridCache(page, parentKey);
      updateGridItemsInDomBasedOnCache(items);
    }
    let cacheToClear = dataProviderController.rootCache;
    if (parentKey) {
      const parentItem = createEmptyItemFromKey(pkey);
      cacheToClear = dataProviderController.getItemSubCache(parentItem);
    }
    const endIndex = index + updatedPageCount * grid.pageSize;
    for (let itemIndex = index; itemIndex < endIndex; itemIndex++) {
      delete cacheToClear.items[itemIndex];
      cacheToClear.removeSubCache(itemIndex);
    }
    updateGridFlatSize();
  };
  grid.$connector.reset = function() {
    grid.size = 0;
    cache = {};
    dataProviderController.rootCache.items = [];
    lastRequestedRanges = {};
    if (ensureSubCacheDebouncer) {
      ensureSubCacheDebouncer.cancel();
    }
    if (parentRequestDebouncer) {
      parentRequestDebouncer.cancel();
    }
    if (rootRequestDebouncer) {
      rootRequestDebouncer.cancel();
    }
    ensureSubCacheDebouncer = void 0;
    parentRequestDebouncer = void 0;
    ensureSubCacheQueue = [];
    parentRequestQueue = [];
    updateAllGridRowsInDomBasedOnCache();
  };
  grid.$connector.updateSize = (newSize) => grid.size = newSize;
  grid.$connector.updateUniqueItemIdPath = (path) => grid.itemIdPath = path;
  grid.$connector.expandItems = function(items) {
    let newExpandedItems = Array.from(grid.expandedItems);
    items.filter((item2) => !grid._isExpanded(item2)).forEach((item2) => newExpandedItems.push(item2));
    grid.expandedItems = newExpandedItems;
  };
  grid.$connector.collapseItems = function(items) {
    let newExpandedItems = Array.from(grid.expandedItems);
    items.forEach((item2) => {
      let index = grid._getItemIndexInArray(item2, newExpandedItems);
      if (index >= 0) {
        newExpandedItems.splice(index, 1);
      }
    });
    grid.expandedItems = newExpandedItems;
    items.forEach((item2) => grid.$connector.removeFromQueue(item2));
  };
  grid.$connector.removeFromQueue = function(item2) {
    const itemSubCache = dataProviderController.getItemSubCache(item2);
    Object.values((itemSubCache == null ? void 0 : itemSubCache.pendingRequests) || {}).forEach((callback) => callback([]));
    const itemId = grid.getItemId(item2);
    ensureSubCacheQueue = ensureSubCacheQueue.filter((item22) => item22.itemkey !== itemId);
    parentRequestQueue = parentRequestQueue.filter((item22) => item22.parentKey !== itemId);
  };
  grid.$connector.confirmParent = function(id, parentKey, levelSize) {
    if (!cache[parentKey]) {
      cache[parentKey] = {};
    }
    const hasSizeChanged = cache[parentKey].size !== levelSize;
    cache[parentKey].size = levelSize;
    if (levelSize === 0) {
      cache[parentKey][0] = [];
    }
    const parentItem = createEmptyItemFromKey(parentKey);
    const parentItemSubCache = dataProviderController.getItemSubCache(parentItem);
    if (parentItemSubCache) {
      const { pendingRequests } = parentItemSubCache;
      Object.entries(pendingRequests).forEach(([page, callback]) => {
        let lastRequestedRange = lastRequestedRanges[parentKey] || [0, 0];
        if (cache[parentKey] && cache[parentKey][page] || page < lastRequestedRange[0] || page > lastRequestedRange[1]) {
          let items = cache[parentKey][page] || new Array(levelSize);
          callback(items, levelSize);
        } else if (callback && levelSize === 0) {
          callback([], levelSize);
        }
      });
      if (hasSizeChanged && Object.keys(pendingRequests).length === 0) {
        parentItemSubCache.size = levelSize;
        updateGridFlatSize();
      }
    }
    grid.$server.confirmParentUpdate(id, parentKey);
  };
  grid.$connector.confirm = function(id) {
    const { pendingRequests } = dataProviderController.rootCache;
    Object.entries(pendingRequests).forEach(([page, callback]) => {
      var _a2;
      const lastRequestedRange = lastRequestedRanges[root2] || [0, 0];
      const lastAvailablePage = grid.size ? Math.ceil(grid.size / grid.pageSize) - 1 : 0;
      const lastRequestedRangeEnd = Math.min(lastRequestedRange[1], lastAvailablePage);
      if ((_a2 = cache[root2]) == null ? void 0 : _a2[page]) {
        callback(cache[root2][page]);
      } else if (page < lastRequestedRange[0] || +page > lastRequestedRangeEnd) {
        callback(new Array(grid.pageSize));
        grid.requestContentUpdate();
      } else if (callback && grid.size === 0) {
        callback([]);
      }
    });
    sanitizeLastRequestedRange();
    currentUpdateSetRange = null;
    currentUpdateClearRange = null;
    grid.$server.confirmUpdate(id);
  };
  grid.$connector.ensureHierarchy = function() {
    for (let parentKey in cache) {
      if (parentKey !== root2) {
        delete cache[parentKey];
      }
    }
    lastRequestedRanges = {};
    dataProviderController.rootCache.removeSubCaches();
    updateAllGridRowsInDomBasedOnCache();
  };
  grid.$connector.setSelectionMode = function(mode) {
    if ((typeof mode === "string" || mode instanceof String) && validSelectionModes.indexOf(mode) >= 0) {
      selectionMode = mode;
      selectedKeys = {};
      grid.selectedItems = [];
      grid.$connector.updateMultiSelectable();
    } else {
      throw "Attempted to set an invalid selection mode";
    }
  };
  grid.$connector.updateMultiSelectable = function() {
    if (!grid.$) {
      return;
    }
    if (selectionMode === validSelectionModes[0]) {
      grid.$.table.setAttribute("aria-multiselectable", false);
    } else if (selectionMode === validSelectionModes[1]) {
      grid.$.table.removeAttribute("aria-multiselectable");
    } else {
      grid.$.table.setAttribute("aria-multiselectable", true);
    }
  };
  grid._createPropertyObserver("isAttached", () => grid.$connector.updateMultiSelectable());
  const singleTimeRenderer = (renderer) => {
    return (root22) => {
      if (renderer) {
        renderer(root22);
        renderer = null;
      }
    };
  };
  grid.$connector.setHeaderRenderer = function(column, options) {
    const { content, showSorter, sorterPath } = options;
    if (content === null) {
      column.headerRenderer = null;
      return;
    }
    column.headerRenderer = singleTimeRenderer((root22) => {
      root22.innerHTML = "";
      let contentRoot = root22;
      if (showSorter) {
        const sorter = document.createElement("vaadin-grid-sorter");
        sorter.setAttribute("path", sorterPath);
        const ariaLabel = content instanceof Node ? content.textContent : content;
        if (ariaLabel) {
          sorter.setAttribute("aria-label", `Sort by ${ariaLabel}`);
        }
        root22.appendChild(sorter);
        contentRoot = sorter;
      }
      if (content instanceof Node) {
        contentRoot.appendChild(content);
      } else {
        contentRoot.textContent = content;
      }
    });
  };
  grid._getActiveSorters = function() {
    return this._sorters.filter((sorter) => sorter.direction);
  };
  grid.__applySorters = () => {
    const sorters = grid._mapSorters();
    const sortersChanged = JSON.stringify(grid._previousSorters) !== JSON.stringify(sorters);
    grid._previousSorters = sorters;
    Grid.prototype.__applySorters.call(grid);
    if (sortersChanged && !sorterDirectionsSetFromServer) {
      grid.$server.sortersChanged(sorters);
    }
  };
  grid.$connector.setFooterRenderer = function(column, options) {
    const { content } = options;
    if (content === null) {
      column.footerRenderer = null;
      return;
    }
    column.footerRenderer = singleTimeRenderer((root22) => {
      root22.innerHTML = "";
      if (content instanceof Node) {
        root22.appendChild(content);
      } else {
        root22.textContent = content;
      }
    });
  };
  grid.addEventListener("vaadin-context-menu-before-open", function(e2) {
    const { key, columnId } = e2.detail;
    grid.$server.updateContextMenuTargetItem(key, columnId);
  });
  grid.getContextMenuBeforeOpenDetail = function(event) {
    var _a2, _b2;
    const sourceEvent = event.detail.sourceEvent || event;
    const eventContext = grid.getEventContext(sourceEvent);
    const key = ((_a2 = eventContext.item) == null ? void 0 : _a2.key) || "";
    const columnId = ((_b2 = eventContext.column) == null ? void 0 : _b2.id) || "";
    return { key, columnId };
  };
  grid.preventContextMenu = function(event) {
    const isLeftClick = event.type === "click";
    const { column } = grid.getEventContext(event);
    return isLeftClick && column instanceof GridFlowSelectionColumn;
  };
  grid.addEventListener("click", (e2) => _fireClickEvent(e2, "item-click"));
  grid.addEventListener("dblclick", (e2) => _fireClickEvent(e2, "item-double-click"));
  grid.addEventListener("column-resize", (e2) => {
    const cols = grid._getColumnsInOrder().filter((col) => !col.hidden);
    cols.forEach((col) => {
      col.dispatchEvent(new CustomEvent("column-drag-resize"));
    });
    grid.dispatchEvent(
      new CustomEvent("column-drag-resize", {
        detail: {
          resizedColumnKey: e2.detail.resizedColumn._flowId
        }
      })
    );
  });
  grid.addEventListener("column-reorder", (e2) => {
    const columns = grid._columnTree.slice(0).pop().filter((c2) => c2._flowId).sort((b2, a3) => b2._order - a3._order).map((c2) => c2._flowId);
    grid.dispatchEvent(
      new CustomEvent("column-reorder-all-columns", {
        detail: { columns }
      })
    );
  });
  grid.addEventListener("cell-focus", (e2) => {
    const eventContext = grid.getEventContext(e2);
    const expectedSectionValues = ["header", "body", "footer"];
    if (expectedSectionValues.indexOf(eventContext.section) === -1) {
      return;
    }
    grid.dispatchEvent(
      new CustomEvent("grid-cell-focus", {
        detail: {
          itemKey: eventContext.item ? eventContext.item.key : null,
          internalColumnId: eventContext.column ? eventContext.column._flowId : null,
          section: eventContext.section
        }
      })
    );
  });
  function _fireClickEvent(event, eventName) {
    if (event.defaultPrevented) {
      return;
    }
    const path = event.composedPath();
    const idx = path.findIndex((node) => node.localName === "td" || node.localName === "th");
    const content = path.slice(0, idx);
    if (content.some((node) => isFocusable(node) || node instanceof HTMLLabelElement)) {
      return;
    }
    const eventContext = grid.getEventContext(event);
    const section = eventContext.section;
    if (eventContext.item && section !== "details") {
      event.itemKey = eventContext.item.key;
      if (eventContext.column) {
        event.internalColumnId = eventContext.column._flowId;
      }
      grid.dispatchEvent(new CustomEvent(eventName, { detail: event }));
    }
  }
  grid.cellClassNameGenerator = function(column, rowData) {
    const style = rowData.item.style;
    if (!style) {
      return;
    }
    return (style.row || "") + " " + (column && style[column._flowId] || "");
  };
  grid.cellPartNameGenerator = function(column, rowData) {
    const part = rowData.item.part;
    if (!part) {
      return;
    }
    return (part.row || "") + " " + (column && part[column._flowId] || "");
  };
  grid.dropFilter = (rowData) => rowData.item && !rowData.item.dropDisabled;
  grid.dragFilter = (rowData) => rowData.item && !rowData.item.dragDisabled;
  grid.addEventListener("grid-dragstart", (e2) => {
    if (grid._isSelected(e2.detail.draggedItems[0])) {
      if (grid.__selectionDragData) {
        Object.keys(grid.__selectionDragData).forEach((type) => {
          e2.detail.setDragData(type, grid.__selectionDragData[type]);
        });
      } else {
        (grid.__dragDataTypes || []).forEach((type) => {
          e2.detail.setDragData(type, e2.detail.draggedItems.map((item2) => item2.dragData[type]).join("\n"));
        });
      }
      if (grid.__selectionDraggedItemsCount > 1) {
        e2.detail.setDraggedItemsCount(grid.__selectionDraggedItemsCount);
      }
    } else {
      (grid.__dragDataTypes || []).forEach((type) => {
        e2.detail.setDragData(type, e2.detail.draggedItems[0].dragData[type]);
      });
    }
  });
  grid.isItemSelectable = (item2) => {
    return (item2 == null ? void 0 : item2.selectable) === void 0 || item2.selectable;
  };
};
registerStyles$1(
  "vaadin-icon",
  css`
    :host {
      width: var(--lumo-icon-size-m);
      height: var(--lumo-icon-size-m);
    }
  `,
  { moduleId: "lumo-icon" }
);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const HTML_RESULT = 1;
class UnsafeHTMLDirective extends Directive {
  constructor(partInfo) {
    super(partInfo);
    this._value = nothing;
    if (partInfo.type !== PartType.CHILD) {
      throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);
    }
  }
  render(value) {
    if (value === nothing || value == null) {
      this._templateResult = void 0;
      return this._value = value;
    }
    if (value === noChange) {
      return value;
    }
    if (typeof value != "string") {
      throw new Error(`${this.constructor.directiveName}() called with a non-string value`);
    }
    if (value === this._value) {
      return this._templateResult;
    }
    this._value = value;
    const strings = [value];
    strings.raw = strings;
    return this._templateResult = {
      // Cast to a known set of integers that satisfy ResultType so that we
      // don't have to export ResultType and possibly encourage this pattern.
      // This property needs to remain unminified.
      ["_$litType$"]: this.constructor.resultType,
      strings,
      values: []
    };
  }
}
UnsafeHTMLDirective.directiveName = "unsafeHTML";
UnsafeHTMLDirective.resultType = HTML_RESULT;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const SVG_RESULT = 2;
class UnsafeSVGDirective extends UnsafeHTMLDirective {
}
UnsafeSVGDirective.directiveName = "unsafeSVG";
UnsafeSVGDirective.resultType = SVG_RESULT;
const unsafeSVG = directive(UnsafeSVGDirective);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function cloneSvgNode(source) {
  let result = nothing;
  if (source) {
    const content = source.cloneNode(true);
    content.removeAttribute("id");
    result = svg`${unsafeSVG(content.outerHTML)}`;
  }
  return result;
}
function isValidSvg(source) {
  return isTemplateResult(source, TemplateResultType.SVG) || source === nothing;
}
function ensureSvgLiteral(source) {
  let result = source == null || source === "" ? nothing : source;
  if (!isValidSvg(result)) {
    console.error("[vaadin-icon] Invalid svg passed, please use Lit svg literal.");
    result = nothing;
  }
  return result;
}
function renderSvg(source, container) {
  const result = ensureSvgLiteral(source);
  render(result, container);
}
function unsafeSvgLiteral(source) {
  return svg`${unsafeSVG(source)}`;
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const iconsetRegistry = {};
const attachedIcons = /* @__PURE__ */ new Set();
function getIconId(id, name) {
  return (id || "").replace(`${name}:`, "");
}
function getIconsetName(icon) {
  if (!icon) {
    return;
  }
  const parts = icon.split(":");
  return parts[0] || "vaadin";
}
function initIconsMap(iconset, name) {
  iconset._icons = [...iconset.querySelectorAll("[id]")].reduce((map, svg2) => {
    const key = getIconId(svg2.id, name);
    map[key] = svg2;
    return map;
  }, {});
}
const IconsetMixin = (superClass) => class extends superClass {
  static get properties() {
    return {
      /**
       * The name of the iconset. Every iconset is required to have its own unique name.
       * All the SVG icons in the iconset must have IDs conforming to its name.
       *
       * See also [`name`](#/elements/vaadin-icon#property-name) property of `vaadin-icon`.
       */
      name: {
        type: String,
        observer: "__nameChanged",
        sync: true
      },
      /**
       * The size of an individual icon. Note that icons must be square.
       *
       * When using `vaadin-icon`, the size of the iconset will take precedence
       * over the size defined by the user to ensure correct appearance.
       */
      size: {
        type: Number,
        value: 24,
        sync: true
      }
    };
  }
  /**
   * Set of the `vaadin-icon` instances in the DOM.
   *
   * @return {Set<Icon>}
   */
  static get attachedIcons() {
    return attachedIcons;
  }
  /**
   * Returns an instance of the iconset by its name.
   *
   * @param {string} name
   * @return {Iconset}
   */
  static getIconset(name) {
    return iconsetRegistry[name];
  }
  /**
   * Returns SVGTemplateResult for the `icon` ID matching `name` of the
   * iconset, or `nothing` literal if there is no matching icon found.
   *
   * @param {string} icon
   * @param {?string} name
   */
  static getIconSvg(icon, name) {
    const iconsetName = name || getIconsetName(icon);
    const iconset = this.getIconset(iconsetName);
    if (!icon || !iconset) {
      return {
        svg: cloneSvgNode(null)
      };
    }
    const iconId = getIconId(icon, iconsetName);
    const iconSvg = iconset._icons[iconId];
    return {
      preserveAspectRatio: iconSvg ? iconSvg.getAttribute("preserveAspectRatio") : null,
      svg: cloneSvgNode(iconSvg),
      size: iconset.size,
      viewBox: iconSvg ? iconSvg.getAttribute("viewBox") : null
    };
  }
  /**
   * Register an iconset without adding to the DOM.
   *
   * @param {string} name
   * @param {number} size
   * @param {?HTMLTemplateElement} template
   */
  static register(name, size, template2) {
    if (!iconsetRegistry[name]) {
      const iconset = document.createElement("vaadin-iconset");
      iconset.appendChild(template2.content.cloneNode(true));
      iconsetRegistry[name] = iconset;
      initIconsMap(iconset, name);
      iconset.size = size;
      iconset.name = name;
      iconset.__nameChanged(name);
    }
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.style.display = "none";
    const { name } = this;
    iconsetRegistry[name] = this;
    initIconsMap(this, name);
    this.__updateIcons(name);
  }
  /**
   * Update all the icons instances in the DOM.
   *
   * @param {string} name
   * @private
   */
  __updateIcons(name) {
    attachedIcons.forEach((element) => {
      if (name === getIconsetName(element.icon)) {
        element._applyIcon();
      }
    });
  }
  /** @private */
  __nameChanged(name, oldName) {
    if (oldName) {
      iconsetRegistry[name] = iconsetRegistry[oldName];
      delete iconsetRegistry[oldName];
    }
    if (name) {
      this.__updateIcons(name);
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let Iconset$1 = class Iconset extends IconsetMixin(ElementMixin(PolymerElement)) {
  static get template() {
    return null;
  }
  static get is() {
    return "vaadin-iconset";
  }
};
defineCustomElement(Iconset$1);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function supportsCQUnitsForPseudoElements() {
  const testStyle = document.createElement("style");
  testStyle.textContent = `
    .vaadin-icon-test-element {
      container-type: size;
      height: 2px;
      visibility: hidden;
      position: fixed;
    }

    .vaadin-icon-test-element::before {
      content: '';
      display: block;
      height: 100cqh;
    `;
  const testElement = document.createElement("div");
  testElement.classList.add("vaadin-icon-test-element");
  document.body.append(testStyle, testElement);
  const { height } = getComputedStyle(testElement, "::before");
  testStyle.remove();
  testElement.remove();
  return height === "2px";
}
function needsFontIconSizingFallback() {
  if (!CSS.supports("container-type: inline-size")) {
    return true;
  }
  if (!isSafari) {
    return false;
  }
  return !supportsCQUnitsForPseudoElements();
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const usesFontIconSizingFallback = needsFontIconSizingFallback();
if (usesFontIconSizingFallback) {
  registerStyles$1(
    "vaadin-icon",
    css`
      :host::after,
      :host::before {
        font-size: var(--_vaadin-font-icon-size);
      }
    `,
    "vaadin-icon-font-size-mixin-styles"
  );
}
const IconFontSizeMixin = dedupingMixin(
  (superclass) => !usesFontIconSizingFallback ? superclass : class extends ResizeMixin(superclass) {
    static get observers() {
      return ["__iconFontSizeMixinfontChanged(iconClass, char, ligature)"];
    }
    /** @protected */
    ready() {
      super.ready();
      this.__updateFontIconSize();
    }
    /** @private */
    __iconFontSizeMixinfontChanged(_iconClass, _char, _ligature) {
      this.__updateFontIconSize();
    }
    /**
     * @protected
     * @override
     */
    _onResize() {
      this.__updateFontIconSize();
    }
    /**
     * Updates the --_vaadin-font-icon-size CSS variable value if font icons are used.
     *
     * @private
     */
    __updateFontIconSize() {
      if (this.char || this.iconClass || this.ligature) {
        const { paddingTop, paddingBottom, height } = getComputedStyle(this);
        const fontIconSize = parseFloat(height) - parseFloat(paddingTop) - parseFloat(paddingBottom);
        this.style.setProperty("--_vaadin-font-icon-size", `${fontIconSize}px`);
      }
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const srcCache = /* @__PURE__ */ new Map();
const Iconset2 = customElements.get("vaadin-iconset");
const IconMixin = (superClass) => class extends IconFontSizeMixin(SlotStylesMixin(superClass)) {
  static get properties() {
    return {
      /**
       * The name of the icon to use. The name should be of the form:
       * `iconset_name:icon_name`. When using `vaadin-icons` it is possible
       * to omit the first part and only use `icon_name` as a value.
       *
       * Setting the `icon` property updates the `svg` and `size` based on the
       * values provided by the corresponding `vaadin-iconset` element.
       *
       * See also [`name`](#/elements/vaadin-iconset#property-name) property of `vaadin-iconset`.
       *
       * @attr {string} icon
       * @type {string}
       */
      icon: {
        type: String,
        reflectToAttribute: true,
        observer: "__iconChanged",
        sync: true
      },
      /**
       * The SVG icon wrapped in a Lit template literal.
       */
      svg: {
        type: Object,
        sync: true
      },
      /**
       * The SVG source to be loaded as the icon. It can be:
       * - an URL to a file containing the icon
       * - an URL in the format "/path/to/file.svg#objectID", where the "objectID" refers to an ID attribute contained
       *   inside the SVG referenced by the path. Note that the file needs to follow the same-origin policy.
       * - a string in the format "data:image/svg+xml,<svg>...</svg>". You may need to use the "encodeURIComponent"
       *   function for the SVG content passed
       *
       * @type {string}
       */
      src: {
        type: String,
        sync: true
      },
      /**
       * The symbol identifier that references an ID of an element contained in the SVG element assigned to the
       * `src` property
       *
       * @type {string}
       */
      symbol: {
        type: String,
        sync: true
      },
      /**
       * Class names defining an icon font and/or a specific glyph inside an icon font.
       *
       * Example: "fa-solid fa-user"
       *
       * @attr {string} icon-class
       * @type {string}
       */
      iconClass: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * A hexadecimal code point that specifies a glyph from an icon font.
       *
       * Example: "e001"
       *
       * @type {string}
       */
      char: {
        type: String,
        sync: true
      },
      /**
       * A ligature name that specifies an icon from an icon font with support for ligatures.
       *
       * Example: "home".
       *
       * @type {string}
       */
      ligature: {
        type: String,
        sync: true
      },
      /**
       * The font family to use for the font icon.
       *
       * @attr {string} font-family
       * @type {string}
       */
      fontFamily: {
        type: String,
        observer: "__fontFamilyChanged",
        sync: true
      },
      /**
       * The size of an icon, used to set the `viewBox` attribute.
       */
      size: {
        type: Number,
        value: 24,
        sync: true
      },
      /** @private */
      __defaultPAR: {
        type: String,
        value: "xMidYMid meet"
      },
      /** @private */
      __preserveAspectRatio: String,
      /** @private */
      __useRef: Object,
      /** @private */
      __svgElement: String,
      /** @private */
      __viewBox: String,
      /** @private */
      __fill: String,
      /** @private */
      __stroke: String,
      /** @private */
      __strokeWidth: String,
      /** @private */
      __strokeLinecap: String,
      /** @private */
      __strokeLinejoin: String
    };
  }
  static get observers() {
    return [
      "__svgChanged(svg, __svgElement)",
      "__fontChanged(iconClass, char, ligature)",
      "__srcChanged(src, symbol)"
    ];
  }
  static get observedAttributes() {
    return [...super.observedAttributes, "class"];
  }
  constructor() {
    super();
    this.__fetch = fetch.bind(window);
  }
  /** @protected */
  get slotStyles() {
    const tag = this.localName;
    return [
      `
        ${tag}[icon-class] {
          display: inline-flex;
          vertical-align: middle;
          font-size: inherit;
        }
      `
    ];
  }
  /** @private */
  get __iconClasses() {
    return this.iconClass ? this.iconClass.split(" ") : [];
  }
  /** @protected */
  ready() {
    super.ready();
    this.__svgElement = this.shadowRoot.querySelector("#svg-group");
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    Iconset2.attachedIcons.add(this);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    Iconset2.attachedIcons.delete(this);
  }
  /** @protected */
  _applyIcon() {
    const { preserveAspectRatio, svg: svg2, size, viewBox } = Iconset2.getIconSvg(this.icon);
    if (viewBox) {
      this.__viewBox = viewBox;
    }
    if (preserveAspectRatio) {
      this.__preserveAspectRatio = preserveAspectRatio;
    }
    if (size && size !== this.size) {
      this.size = size;
    }
    this.svg = svg2;
  }
  /** @private */
  __iconChanged(icon) {
    if (icon) {
      this._applyIcon();
    } else {
      this.svg = ensureSvgLiteral(null);
    }
  }
  /** @private */
  async __srcChanged(src, symbol) {
    if (!src) {
      this.svg = null;
      return;
    }
    this.icon = "";
    if (!src.startsWith("data:") && (symbol || src.includes("#"))) {
      const [path, iconId] = src.split("#");
      this.__useRef = `${path}#${symbol || iconId}`;
    } else {
      try {
        if (!srcCache.has(src)) {
          srcCache.set(
            src,
            this.__fetch(src, {
              mode: "cors"
            }).then((data) => {
              if (!data.ok) {
                throw new Error("Error loading icon");
              }
              return data.text();
            })
          );
        }
        const svgData = await srcCache.get(src);
        if (!superClass.__domParser) {
          superClass.__domParser = new DOMParser();
        }
        const parsedResponse = superClass.__domParser.parseFromString(svgData, "text/html");
        const svgElement = parsedResponse.querySelector("svg");
        if (!svgElement) {
          throw new Error(`SVG element not found on path: ${src}`);
        }
        this.svg = unsafeSvgLiteral(svgElement.innerHTML);
        if (symbol) {
          this.__useRef = `#${symbol}`;
        }
        this.__viewBox = svgElement.getAttribute("viewBox");
        this.__fill = svgElement.getAttribute("fill");
        this.__stroke = svgElement.getAttribute("stroke");
        this.__strokeWidth = svgElement.getAttribute("stroke-width");
        this.__strokeLinecap = svgElement.getAttribute("stroke-linecap");
        this.__strokeLinejoin = svgElement.getAttribute("stroke-linejoin");
      } catch (e2) {
        console.error(e2);
        this.svg = null;
      }
    }
  }
  /** @private */
  __svgChanged(svg2, svgElement) {
    if (!svgElement) {
      return;
    }
    renderSvg(svg2, svgElement);
  }
  /** @private */
  __computePAR(defaultPAR, preserveAspectRatio) {
    return preserveAspectRatio || defaultPAR;
  }
  /** @private */
  __computeVisibility(__useRef) {
    return __useRef ? "visible" : "hidden";
  }
  /** @private */
  __computeViewBox(size, viewBox) {
    return viewBox || `0 0 ${size} ${size}`;
  }
  /** @private */
  __fontChanged(iconClass, char, ligature) {
    this.classList.remove(...this.__addedIconClasses || []);
    if (iconClass) {
      this.__addedIconClasses = [...this.__iconClasses];
      this.classList.add(...this.__addedIconClasses);
    }
    if (char) {
      this.setAttribute("font-icon-content", char.length > 1 ? String.fromCodePoint(parseInt(char, 16)) : char);
    } else if (ligature) {
      this.setAttribute("font-icon-content", ligature);
    } else {
      this.removeAttribute("font-icon-content");
    }
    if ((iconClass || char || ligature) && !this.icon) {
      this.icon = "";
    }
  }
  /** @protected */
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (name === "class" && this.__iconClasses.some((className) => !this.classList.contains(className))) {
      this.classList.add(...this.__iconClasses);
    }
  }
  /** @private */
  __fontFamilyChanged(fontFamily) {
    this.style.fontFamily = `'${fontFamily}'`;
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const iconStyles = css`
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    box-sizing: border-box;
    vertical-align: middle;
    width: 24px;
    height: 24px;
    fill: currentColor;
    container-type: size;
  }

  :host::after,
  :host::before {
    line-height: 1;
    font-size: 100cqh;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
    -moz-osx-font-smoothing: grayscale;
  }

  :host([hidden]) {
    display: none !important;
  }

  svg {
    display: block;
    width: 100%;
    height: 100%;
    /* prevent overflowing icon from clipping, see https://github.com/vaadin/flow-components/issues/5872 */
    overflow: visible;
  }

  :host(:is([icon-class], [font-icon-content])) svg {
    display: none;
  }

  :host([font-icon-content])::before {
    content: attr(font-icon-content);
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-icon", iconStyles, { moduleId: "vaadin-icon-styles" });
class Icon extends IconMixin(ControllerMixin(ElementMixin(ThemableMixin(PolymerElement)))) {
  static get template() {
    return html`
      <svg
        version="1.1"
        xmlns="http://www.w3.org/2000/svg"
        xmlns:xlink="http://www.w3.org/1999/xlink"
        viewBox="[[__computeViewBox(size, __viewBox)]]"
        preserveAspectRatio="[[__computePAR(__defaultPAR, __preserveAspectRatio)]]"
        fill$="[[__fill]]"
        stroke$="[[__stroke]]"
        stroke-width$="[[__strokeWidth]]"
        stroke-linecap$="[[__strokeLinecap]]"
        stroke-linejoin$="[[__strokeLinejoin]]"
        aria-hidden="true"
      >
        <g id="svg-group"></g>
        <g id="use-group" visibility$="[[__computeVisibility(__useRef, svg)]]">
          <use href$="[[__useRef]]" />
        </g>
      </svg>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-icon";
  }
}
defineCustomElement(Icon);
/**
 * @license
 * Copyright (c) 2015 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const template$3 = document.createElement("template");
template$3.innerHTML = `<svg><defs>
<g id="vaadin:abacus"><path d="M0 0v16h16v-16h-16zM14 2v3h-0.1c-0.2-0.6-0.8-1-1.4-1s-1.2 0.4-1.4 1h-3.2c-0.2-0.6-0.7-1-1.4-1s-1.2 0.4-1.4 1h-0.2c-0.2-0.6-0.7-1-1.4-1s-1.2 0.4-1.4 1h-0.1v-3h12zM13.9 10c-0.2-0.6-0.8-1-1.4-1s-1.2 0.4-1.4 1h-0.2c-0.2-0.6-0.8-1-1.4-1s-1.2 0.4-1.4 1h-3.2c-0.2-0.6-0.7-1-1.4-1s-1.2 0.4-1.4 1h-0.1v-4h0.1c0.2 0.6 0.8 1 1.4 1s1.2-0.4 1.4-1h0.2c0.2 0.6 0.8 1 1.4 1s1.2-0.4 1.4-1h3.2c0.2 0.6 0.8 1 1.4 1s1.2-0.4 1.4-1h0.1l-0.1 4zM2 14v-3h0.1c0.2 0.6 0.8 1 1.4 1s1.2-0.4 1.4-1h3.2c0.2 0.6 0.8 1 1.4 1s1.2-0.4 1.4-1h0.2c0.2 0.6 0.8 1 1.4 1s1.2-0.4 1.4-1h0.1v3h-12z"></path></g>
<g id="vaadin:absolute-position"><path d="M0 0v16h16v-16h-16zM15 15h-14v-6h3v1l3-2-3-2v1h-3v-6h6v3h-1l2 3 2-3h-1v-3h6v14z"></path></g>
<g id="vaadin:academy-cap"><path d="M15.090 12.79c0.235-0.185 0.385-0.469 0.385-0.789 0-0.358-0.188-0.672-0.471-0.849l-0.004-5.822-1 0.67v5.15c-0.283 0.18-0.468 0.492-0.468 0.847 0 0.316 0.147 0.598 0.376 0.782l-0.378 0.502c-0.323 0.41-0.521 0.931-0.53 1.498l-0 1.222h0.81c0.002 0 0.004 0 0.005 0 0.411 0 0.757-0.282 0.853-0.664l0.331-1.336v2h1v-1.21c-0.009-0.569-0.207-1.090-0.534-1.505z"></path><path d="M8 0l-8 4 8 5 8-5-8-4z"></path><path d="M8 10l-5-3.33v1.71c0 0.91 2.94 3.62 5 3.62s5-2.71 5-3.62v-1.71z"></path></g>
<g id="vaadin:accessibility"><path d="M10.4 10h-0.5c0.1 0.3 0.1 0.7 0.1 1 0 2.2-1.8 4-4 4s-4-1.8-4-4c0-2.1 1.6-3.8 3.7-4l-0.2-1c-2.6 0.4-4.5 2.4-4.5 5 0 2.8 2.2 5 5 5 2.4 0 4.4-1.7 4.9-3.9l-0.5-2.1z"></path><path d="M13.1 13l-1.1-5h-4.1l-0.2-1h3.3v-1h-3.5l-0.6-2.5c0.9-0.1 1.6-0.8 1.6-1.7 0-1-0.8-1.8-1.8-1.8s-1.7 0.8-1.7 1.8c0 0.6 0.3 1.2 0.8 1.5l1.3 5.7h4.1l1.2 5h2.6v-1h-1.9z"></path></g>
<g id="vaadin:accordion-menu"><path d="M0 4v8h16v-8h-16zM15 11h-14v-4h14v4z"></path><path d="M0 0h16v3h-16v-3z"></path><path d="M0 13h16v3h-16v-3z"></path></g>
<g id="vaadin:add-dock"><path d="M0 11v5h16v-5h-16zM12 15h-3v-3h3v3z"></path><path d="M12 7v-2c0-5-8-5-8-5s5 0 5 5v2h-2l3.5 3 3.5-3h-2z"></path></g>
<g id="vaadin:adjust"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM2 8c0-3.3 2.7-6 6-6v12c-3.3 0-6-2.7-6-6z"></path></g>
<g id="vaadin:adobe-flash"><path d="M0 0v16h16v-16h-16zM13 4.4c-3 0-3.3 2.6-3.3 2.6h1.3v2h-2.4c-1.8 5.8-5.6 5-5.6 5v-2.5c0 0 2.5 0.6 3.9-4 1.8-6.1 6.1-5.5 6.1-5.5v2.4z"></path></g>
<g id="vaadin:airplane"><path d="M12.3 6.5c0.5-0.5 0.9-0.8 1.2-1.1 1.6-1.6 3.2-4.1 2.2-5.1s-3.4 0.6-5 2.2c-0.3 0.3-0.6 0.7-1.1 1.2l-7-3.2c-0.7-0.3-1.5-0.2-2 0.3l-0.6 0.5 6.6 5.7c-1.3 1.6-2.7 3.1-3.4 4l-1.1-0.6c-0.5-0.3-1.2-0.3-1.6 0.2l-0.3 0.3 2.8 2.1 2 2.8 0.3-0.3c0.4-0.4 0.5-1.1 0.2-1.6l-0.5-1.1c0.9-0.7 2.4-2.1 4-3.4l5.7 6.6 0.5-0.5c0.5-0.5 0.6-1.3 0.3-2l-3.2-7z"></path></g>
<g id="vaadin:alarm"><path d="M8 5h-1v5h4v-1l-2.93 0.070-0.070-4.070z"></path><path d="M5.46 0.87c-0.387-0.522-1-0.856-1.692-0.856-0.41 0-0.793 0.118-1.117 0.321l-0.991 0.765c-0.41 0.384-0.666 0.929-0.666 1.534 0 0.496 0.172 0.951 0.459 1.31z"></path><path d="M14.34 1.1l-1-0.77c-0.315-0.198-0.698-0.316-1.108-0.316-0.692 0-1.305 0.334-1.688 0.85l3.996 3.076c0.287-0.356 0.46-0.813 0.46-1.312 0-0.602-0.253-1.145-0.659-1.528z"></path><path d="M12.87 14c1.308-1.268 2.122-3.038 2.13-4.998-0.028-3.856-3.145-6.973-6.997-7.002-3.857 0.028-6.975 3.145-7.003 6.997 0.008 1.965 0.822 3.735 2.128 5.001l-0.938 0.942c-0.075 0.102-0.12 0.231-0.12 0.37 0 0.348 0.282 0.63 0.63 0.63 0.139 0 0.268-0.045 0.372-0.122l0.998-0.999c1.092 0.758 2.446 1.211 3.905 1.211s2.813-0.453 3.928-1.226l0.977 1.015c0.102 0.075 0.231 0.12 0.37 0.12 0.348 0 0.63-0.282 0.63-0.63 0-0.139-0.045-0.268-0.122-0.372zM2.87 9c0.028-2.822 2.308-5.102 5.127-5.13 2.825 0.028 5.105 2.308 5.133 5.127-0.028 2.825-2.308 5.105-5.127 5.133-2.825-0.028-5.105-2.308-5.133-5.127z"></path></g>
<g id="vaadin:align-center"><path d="M5 0h6v3h-6v-3z"></path><path d="M1 4h14v3h-14v-3z"></path><path d="M3 8h10v3h-10v-3z"></path><path d="M0 12h16v3h-16v-3z"></path></g>
<g id="vaadin:align-justify"><path d="M0 0h16v3h-16v-3z"></path><path d="M0 4h16v3h-16v-3z"></path><path d="M0 12h16v3h-16v-3z"></path><path d="M0 8h16v3h-16v-3z"></path></g>
<g id="vaadin:align-left"><path d="M0 0h11v3h-11v-3z"></path><path d="M0 4h15v3h-15v-3z"></path><path d="M0 8h13v3h-13v-3z"></path><path d="M0 12h16v3h-16v-3z"></path></g>
<g id="vaadin:align-right"><path d="M5 0h11v3h-11v-3z"></path><path d="M1 4h15v3h-15v-3z"></path><path d="M3 8h13v3h-13v-3z"></path><path d="M0 12h16v3h-16v-3z"></path></g>
<g id="vaadin:alt-a"><path d="M14 7v-1h-1v-1h-1v1h-0.5v1h0.5v3.56c0 1 0.56 1.44 2 1.44v-1c-0.055 0.012-0.119 0.019-0.185 0.019-0.359 0-0.669-0.21-0.813-0.514l-0.002-3.505h1z"></path><path d="M9 3h1v9h-1v-9z"></path><path d="M3 12l0.57-2h2.82l0.61 2h1l-2.27-8h-1.46l-2.27 8h1zM5 5.1l1.11 3.9h-2.22z"></path></g>
<g id="vaadin:alt"><path d="M3.89 9h2.22l-1.11-3.9-1.11 3.9z"></path><path d="M0 0v16h16v-16h-16zM7 12l-0.61-2h-2.78l-0.61 2h-1l2.27-8h1.46l2.27 8h-1zM10 12h-1v-9h1v9zM14 7h-1v3.5s0 0.5 1 0.5v1c-1 0-2-0.44-2-1.44v-3.56h-0.5v-1h0.5v-1h1v1h1v1z"></path></g>
<g id="vaadin:ambulance"><path d="M6.18 14c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M14 14c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M5 6h-1v1h-1v1h1v1h1v-1h1v-1h-1v-1z"></path><path d="M15.76 8.64l-3-4.53c-0.455-0.673-1.215-1.11-2.078-1.11-0.008 0-0.015 0-0.023 0l-2.659-0v-1c0-0.552-0.448-1-1-1s-1 0.448-1 1v1h-4.5c-0.828 0-1.5 0.672-1.5 1.5v8.5h1.37c0.474-1.135 1.546-1.931 2.812-2 1.278 0.072 2.345 0.868 2.81 1.978l2.188 0.021c0.474-1.135 1.546-1.931 2.812-2 1.303 0.003 2.405 0.827 2.822 1.979l1.187 0.021v-3.57c-0.001-0.294-0.090-0.568-0.243-0.795zM6.92 8.12c-0.266 1.117-1.255 1.935-2.435 1.935-1.381 0-2.5-1.119-2.5-2.5 0-1.18 0.818-2.17 1.918-2.432 0.195-0.049 0.399-0.075 0.609-0.075 1.37 0 2.48 1.11 2.48 2.48 0 0.21-0.026 0.414-0.075 0.609zM10 8v-3h0.85c0.003-0 0.006-0 0.009-0 0.777 0 1.461 0.394 1.866 0.992l1.325 2.008z"></path></g>
<g id="vaadin:anchor"><path d="M13 9v2c0 0-0.8 1.7-4 1.9v-6.9h2.2c0.2 0.3 0.5 0.5 0.8 0.5 0.6 0 1-0.4 1-1s-0.4-1-1-1c-0.4 0-0.7 0.2-0.8 0.5h-2.2v-1.3c0.6-0.3 1-1 1-1.7 0-1.1-0.9-2-2-2s-2 0.9-2 2c0 0.7 0.4 1.4 1 1.7v1.3h-2.2c-0.1-0.3-0.4-0.5-0.8-0.5-0.6 0-1 0.4-1 1s0.4 1 1 1c0.4 0 0.7-0.2 0.8-0.5h2.2v7c-3.3-0.3-4-2-4-2v-2h-3c0 0 2.8 7 8 7 5 0 8-7 8-7h-3zM8 1c0.6 0 1 0.4 1 1s-0.4 1-1 1-1-0.4-1-1 0.4-1 1-1z"></path></g>
<g id="vaadin:angle-double-down"><path d="M3 2v2l5 5 5-5v-2l-5 5z"></path><path d="M3 7v2l5 5 5-5v-2l-5 5z"></path></g>
<g id="vaadin:angle-double-left"><path d="M14 3h-2l-5 5 5 5h2l-5-5z"></path><path d="M9 3h-2l-5 5 5 5h2l-5-5z"></path></g>
<g id="vaadin:angle-double-right"><path d="M2 13h2l5-5-5-5h-2l5 5z"></path><path d="M7 13h2l5-5-5-5h-2l5 5z"></path></g>
<g id="vaadin:angle-double-up"><path d="M13 14v-2l-5-5-5 5v2l5-5z"></path><path d="M13 9v-2l-5-5-5 5v2l5-5z"></path></g>
<g id="vaadin:angle-down"><path d="M13 4v2l-5 5-5-5v-2l5 5z"></path></g>
<g id="vaadin:angle-left"><path d="M12 13h-2l-5-5 5-5h2l-5 5z"></path></g>
<g id="vaadin:angle-right"><path d="M4 13h2l5-5-5-5h-2l5 5z"></path></g>
<g id="vaadin:angle-up"><path d="M3 12v-2l5-5 5 5v2l-5-5z"></path></g>
<g id="vaadin:archive"><path d="M0 1h16v3h-16v-3z"></path><path d="M1 5v11h14v-11h-14zM11 9h-6v-2h6v2z"></path></g>
<g id="vaadin:archives"><path d="M11 2h-6v4h6v-4zM9 4h-2v-1h2v1z"></path><path d="M3 0v16h2v-1h6v1h2v-16h-10zM12 14h-8v-6h8v6zM12 7h-8v-6h8v6z"></path><path d="M11 9h-6v4h6v-4zM9 11h-2v-1h2v1z"></path></g>
<g id="vaadin:area-select"><path d="M7.9 7.9l2.1 7.5 1.7-2.6 3.2 3.2 1.1-1.1-3.3-3.2 2.7-1.6z"></path><path d="M8 12h-7v-9h12v5.4l1 0.2v-6.6h-14v11h8.2z"></path></g>
<g id="vaadin:arrow-backward"><path d="M0 7.9l6-4.9v3c0 0 1.1 0 2 0 8 0 8 8 8 8s-1-4-7.8-4c-1.1 0-1.8 0-2.2 0v2.9l-6-5z"></path></g>
<g id="vaadin:arrow-circle-down-o"><path d="M1 8c0-3.9 3.1-7 7-7s7 3.1 7 7-3.1 7-7 7-7-3.1-7-7zM0 8c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8-8 3.6-8 8v0z"></path><path d="M9 9.6l1.8-1.8 1.4 1.4-4.2 4.2-4.2-4.2 1.4-1.4 1.8 1.8v-6.6h2v6.6z"></path></g>
<g id="vaadin:arrow-circle-down"><path d="M0 8c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8c-4.4 0-8 3.6-8 8zM9 9.6l1.8-1.8 1.4 1.4-4.2 4.2-4.2-4.2 1.4-1.4 1.8 1.8v-6.6h2v6.6z"></path></g>
<g id="vaadin:arrow-circle-left-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M6.4 9l1.8 1.8-1.4 1.4-4.2-4.2 4.2-4.2 1.4 1.4-1.8 1.8h6.6v2h-6.6z"></path></g>
<g id="vaadin:arrow-circle-left"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM6.4 9l1.8 1.8-1.4 1.4-4.2-4.2 4.2-4.2 1.4 1.4-1.8 1.8h6.6v2h-6.6z"></path></g>
<g id="vaadin:arrow-circle-right-o"><path d="M8 15c-3.9 0-7-3.1-7-7s3.1-7 7-7 7 3.1 7 7-3.1 7-7 7zM8 16c4.4 0 8-3.6 8-8s-3.6-8-8-8-8 3.6-8 8 3.6 8 8 8v0z"></path><path d="M9.6 7l-1.8-1.8 1.4-1.4 4.2 4.2-4.2 4.2-1.4-1.4 1.8-1.8h-6.6v-2h6.6z"></path></g>
<g id="vaadin:arrow-circle-right"><path d="M8 16c4.4 0 8-3.6 8-8s-3.6-8-8-8-8 3.6-8 8 3.6 8 8 8zM9.6 7l-1.8-1.8 1.4-1.4 4.2 4.2-4.2 4.2-1.4-1.4 1.8-1.8h-6.6v-2h6.6z"></path></g>
<g id="vaadin:arrow-circle-up-o"><path d="M15 8c0 3.9-3.1 7-7 7s-7-3.1-7-7 3.1-7 7-7 7 3.1 7 7zM16 8c0-4.4-3.6-8-8-8s-8 3.6-8 8c0 4.4 3.6 8 8 8s8-3.6 8-8v0z"></path><path d="M7 6.4l-1.8 1.8-1.4-1.4 4.2-4.2 4.2 4.2-1.4 1.4-1.8-1.8v6.6h-2v-6.6z"></path></g>
<g id="vaadin:arrow-circle-up"><path d="M16 8c0-4.4-3.6-8-8-8s-8 3.6-8 8 3.6 8 8 8 8-3.6 8-8zM7 6.4l-1.8 1.8-1.4-1.4 4.2-4.2 4.2 4.2-1.4 1.4-1.8-1.8v6.6h-2v-6.6z"></path></g>
<g id="vaadin:arrow-down"><path d="M12.5 8.6l-3.5 3.6v-12.2h-2v12.2l-3.5-3.6-1.4 1.5 5.9 5.9 5.9-5.9z"></path></g>
<g id="vaadin:arrow-forward"><path d="M16 7.9l-6-4.9v3c-0.5 0-1.1 0-2 0-8 0-8 8-8 8s1-4 7.8-4c1.1 0 1.8 0 2.2 0v2.9l6-5z"></path></g>
<g id="vaadin:arrow-left"><path d="M7.4 12.5l-3.6-3.5h12.2v-2h-12.2l3.6-3.5-1.5-1.4-5.9 5.9 5.9 5.9z"></path></g>
<g id="vaadin:arrow-long-down"><path d="M7 1h2v11h2l-3 3-3-3h2z"></path></g>
<g id="vaadin:arrow-long-left"><path d="M15 7v2h-11v2l-3-3 3-3v2z"></path></g>
<g id="vaadin:arrow-right"><path d="M8.6 3.5l3.5 3.5h-12.1v2h12.1l-3.5 3.5 1.4 1.4 6-5.9-6-5.9z"></path></g>
<g id="vaadin:arrow-up"><path d="M3.4 7.4l3.6-3.6v12.2h2v-12.2l3.5 3.6 1.4-1.5-5.9-5.9-6 5.9z"></path></g>
<g id="vaadin:arrows-cross"><path d="M15 5v-4h-4l1.3 1.3-4.3 4.3-4.3-4.3 1.3-1.3h-4v4l1.3-1.3 4.3 4.3-4.3 4.3-1.3-1.3v4h4l-1.3-1.3 4.3-4.3 4.3 4.3-1.3 1.3h4v-4l-1.3 1.3-4.3-4.3 4.3-4.3z"></path></g>
<g id="vaadin:arrows-long-h"><path d="M16 8l-3-3v2h-10v-2l-3 3 3 3v-2h10v2z"></path></g>
<g id="vaadin:arrows-long-right"><path d="M1 9v-2h11v-2l3 3-3 3v-2z"></path></g>
<g id="vaadin:arrows-long-up"><path d="M9 15h-2v-11h-2l3-3 3 3h-2z"></path></g>
<g id="vaadin:arrows-long-v"><path d="M9 3h2l-3-3-3 3h2v10h-2l3 3 3-3h-2z"></path></g>
<g id="vaadin:arrows"><path d="M16 8l-3-3v2h-4v-4h2l-3-3-3 3h2v4h-4v-2l-3 3 3 3v-2h4v4h-2l3 3 3-3h-2v-4h4v2z"></path></g>
<g id="vaadin:asterisk"><path d="M15.9 5.7l-2-3.4-3.9 2.2v-4.5h-4v4.5l-4-2.2-2 3.4 3.9 2.3-3.9 2.3 2 3.4 4-2.2v4.5h4v-4.5l3.9 2.2 2-3.4-4-2.3z"></path></g>
<g id="vaadin:at"><path d="M7.5 12.2c-2.3 0-4.2-1.9-4.2-4.2s1.9-4.2 4.2-4.2 4.2 1.9 4.2 4.2c0.1 2.3-1.9 4.2-4.2 4.2zM7.5 5.2c-1.5 0-2.7 1.3-2.7 2.8s1.2 2.8 2.8 2.8 2.8-1.2 2.8-2.8-1.4-2.8-2.9-2.8z"></path><path d="M8 16c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8c0 1.5-0.4 3-1.2 4.2-0.3 0.5-1.1 1.2-2.3 1.2-0.8 0-1.3-0.3-1.6-0.6-0.7-0.7-0.6-1.8-0.6-1.9v-6.9h1.5v7c0 0.2 0 0.6 0.2 0.8 0 0 0.2 0.2 0.5 0.2 0.7 0 1.1-0.5 1.1-0.5 0.6-1 1-2.2 1-3.4 0-3.6-2.9-6.5-6.5-6.5s-6.6 2.8-6.6 6.4 2.9 6.5 6.5 6.5c0.7 0 1.3-0.1 1.9-0.3l0.4 1.4c-0.7 0.3-1.5 0.4-2.3 0.4z"></path></g>
<g id="vaadin:automation"><path d="M14 12c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M11.7 16v0c-0.8 0-1.6-0.2-2.3-0.7l-6.2-3.3c-0.5-0.4-0.9-0.6-1.3-1-1.2-1.2-1.9-2.9-1.9-4.6s0.7-3.3 1.9-4.5c1.2-1.2 2.8-1.9 4.5-1.9s3.3 0.7 4.6 1.9c0.4 0.4 0.6 0.7 1 1.2l3.5 6.4c1 1.7 0.7 3.8-0.7 5.2-0.9 0.9-1.9 1.3-3.1 1.3zM6.4 1c-1.4 0-2.8 0.6-3.8 1.6s-1.6 2.4-1.6 3.8c0 1.5 0.6 2.8 1.6 3.8 0.3 0.3 0.6 0.5 1.1 0.8l6.3 3.4c0.6 0.4 1.2 0.5 1.8 0.5v0c0.9 0 1.7-0.3 2.3-1 1.1-1.1 1.3-2.7 0.5-4l-3.5-6.4c-0.3-0.4-0.5-0.7-0.8-1-1.1-0.9-2.4-1.5-3.9-1.5z"></path><path d="M11 7v-1l-1.4-0.5c-0.1-0.2-0.1-0.3-0.2-0.5l0.6-1.3-0.7-0.7-1.3 0.6c-0.2-0.1-0.3-0.1-0.5-0.2l-0.5-1.4h-1l-0.5 1.4c-0.2 0.1-0.3 0.1-0.5 0.2l-1.3-0.6-0.7 0.7 0.6 1.3c-0.1 0.2-0.1 0.3-0.2 0.5l-1.4 0.5v1l1.4 0.5c0.1 0.2 0.1 0.3 0.2 0.5l-0.6 1.3 0.7 0.7 1.3-0.6c0.2 0.1 0.3 0.2 0.5 0.2l0.5 1.4h1l0.5-1.4c0.2-0.1 0.3-0.1 0.5-0.2l1.3 0.6 0.7-0.7-0.6-1.3c0.1-0.2 0.2-0.3 0.2-0.5l1.4-0.5zM6.5 8c-0.8 0-1.5-0.7-1.5-1.5s0.7-1.5 1.5-1.5 1.5 0.7 1.5 1.5-0.7 1.5-1.5 1.5z"></path></g>
<g id="vaadin:backspace-a"><path d="M5 12l-5-4 5-4v2h11v4h-11v2z"></path></g>
<g id="vaadin:backspace"><path d="M0 2v12h16v-12h-16zM13 9h-7v2l-3-3 3-3v2h7v2z"></path></g>
<g id="vaadin:backwards"><path d="M16 15v-14l-8 7z"></path><path d="M8 15v-14l-8 7z"></path></g>
<g id="vaadin:ban"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM8 2c1.3 0 2.5 0.4 3.5 1.1l-8.4 8.4c-0.7-1-1.1-2.2-1.1-3.5 0-3.3 2.7-6 6-6zM8 14c-1.3 0-2.5-0.4-3.5-1.1l8.4-8.4c0.7 1 1.1 2.2 1.1 3.5 0 3.3-2.7 6-6 6z"></path></g>
<g id="vaadin:bar-chart-h"><path d="M1 15v-15h-1v16h16v-1h-15z"></path><path d="M2 8h4v6h-4v-6z"></path><path d="M7 2h4v12h-4v-12z"></path><path d="M12 6h4v8h-4v-8z"></path></g>
<g id="vaadin:bar-chart-v"><path d="M1 15v-15h-1v16h16v-1h-15z"></path><path d="M8 0v4h-6v-4h6z"></path><path d="M14 5v4h-12v-4h12z"></path><path d="M10 10v4h-8v-4h8z"></path></g>
<g id="vaadin:bar-chart"><path d="M0 15h15v1h-15v-1z"></path><path d="M0 11h3v3h-3v-3z"></path><path d="M4 9h3v5h-3v-5z"></path><path d="M8 5h3v9h-3v-9z"></path><path d="M12 0h3v14h-3v-14z"></path></g>
<g id="vaadin:barcode"><path d="M0 3h1v10h-1v-10z"></path><path d="M8 3h2v10h-2v-10z"></path><path d="M11 3h1v10h-1v-10z"></path><path d="M13 3h1v10h-1v-10z"></path><path d="M15 3h1v10h-1v-10z"></path><path d="M2 3h3v10h-3v-10z"></path><path d="M6 3h1v10h-1v-10z"></path></g>
<g id="vaadin:bed"><path d="M4.28 7h2.72l-1.15-1.68c-0.542-0.725-1.36-1.216-2.295-1.319l-0.555-0.001v1.54c-0.011 0.063-0.018 0.136-0.018 0.211 0 0.69 0.56 1.25 1.25 1.25 0.017 0 0.034-0 0.050-0.001z"></path><path d="M13 7v-0.28c0-0.003 0-0.007 0-0.010 0-0.934-0.749-1.693-1.678-1.71l-4.692-0c0.5 0.62 1.37 2 1.37 2h5z"></path><path d="M15 5.1c-0.552 0-1 0.448-1 1v1.9h-12v-4c0-0.552-0.448-1-1-1s-1 0.448-1 1v9h2v-2h12v2h2v-6.9c0-0.552-0.448-1-1-1z"></path></g>
<g id="vaadin:bell-o"><path d="M12.7 11.4c-0.5-0.2-0.7-0.7-0.7-1.2v-5.2c0 0 0-2.4-3-2.9v-1.1c0 0 0.1-1-1-1s-1 1-1 1v1.1c-3 0.5-3 2.9-3 2.9v5.2c0 0.5-0.3 1-0.7 1.2l-1.3 0.6v2h4c0 0-0.1 2 2 2s2-2 2-2h4v-2l-1.3-0.6zM13 13h-10v-0.4l0.7-0.4c0.8-0.3 1.3-1.1 1.3-2v-5.2c0-0.1 0-1.6 2.2-1.9l0.8-0.2 0.8 0.1c2 0.4 2.2 1.7 2.2 2v5.2c0 0.9 0.5 1.7 1.3 2.1l0.7 0.4v0.3z"></path></g>
<g id="vaadin:bell-slash-o"><path d="M15.2 0l-3.6 3.6c-0.4-0.6-1.2-1.3-2.6-1.5v-1.1c0 0 0.1-1-1-1s-1 1-1 1v1.1c-3 0.5-3 2.9-3 2.9v5.2c0 0.5-0.3 1-0.7 1.2l-1.3 0.6v1.3l-2 2v0.7h0.7l15.3-15.4v-0.6h-0.8zM5 10.3c0-0.1 0-0.1 0 0v-5.3c0-0.1 0.1-1.6 2.2-1.9l0.8-0.2 0.8 0.1c1.2 0.2 1.8 0.8 2 1.3l-5.8 6z"></path><path d="M12 10.2v-4.6l-1 1v3.5c0 0.9 0.5 1.7 1.3 2.1l0.7 0.4v0.4h-8.3l-1 1h2.4c0 0-0.1 2 2 2s2-2 2-2h3.9v-2l-1.3-0.6c-0.4-0.3-0.7-0.7-0.7-1.2z"></path></g>
<g id="vaadin:bell-slash"><path d="M15.2 0l-3.6 3.6c-0.5-0.6-1.2-1.3-2.6-1.5v-1.1c0 0 0.1-1-1-1s-1 1-1 1v1.1c-2.8 0.5-3 2.9-3 2.9v5.2c0 0.5-0.3 1-0.7 1.2l-1.3 0.6v1h0.3l-2.3 2.3v0.7h0.7l15.3-15.4v-0.6h-0.8zM6 4.8v4.5l-1 1v-5.3c0 0 0-0.8 0.7-1.4 0.7-0.7 1.3-0.6 1.3-0.6s-1 0.7-1 1.8z"></path><path d="M8 16c2.1 0 2-2 2-2h-4c0 0-0.1 2 2 2z"></path><path d="M12 10.2v-4.6l-6 6-0.3 0.4-1 1h9.3v-1l-1.3-0.6c-0.4-0.3-0.7-0.7-0.7-1.2z"></path></g>
<g id="vaadin:bell"><path d="M6 14h4c0 0 0.1 2-2 2s-2-2-2-2z"></path><path d="M12.7 11.4c-0.5-0.2-0.7-0.7-0.7-1.2v-5.2c0 0-0.2-2.4-3-2.9v-1.1c0 0 0.1-1-1-1s-1 1-1 1v1.1c-2.8 0.5-3 2.9-3 2.9v5.2c0 0.5-0.3 1-0.7 1.2l-1.3 0.6v1h12v-1l-1.3-0.6zM6 4.8v7.2h-2c0.8 0 1-1 1-1v-6c0 0 0-0.8 0.7-1.4 0.7-0.7 1.3-0.6 1.3-0.6s-1 0.7-1 1.8z"></path></g>
<g id="vaadin:boat"><path d="M1.5 9.6c1.1 0.7 2.5 1.9 2.5 3.3 0 0.4 0 0.7 0 1.1 0 0 0.1 0 0.1 0s0.9 0 2-1c1 1 2 1 2 1s1 0 2-1c1 1 1.9 1 1.9 1s0.1 0 0.1 0c0-0.3 0-0.7 0-1.1 0-1.4 1.4-2.6 2.5-3.3 0.6-0.4 0.5-1.2-0.2-1.4l-1.4-0.4v-3.8h-1v-1h-3v-2h-2v2h-3v1h-1v3.8l-1.3 0.4c-0.8 0.2-0.8 1-0.2 1.4zM4 5h1v-1h6v1h1v2.5l-3.3-1c-0.5-0.1-1-0.1-1.5 0l-3.2 1v-2.5z"></path><path d="M14 14c-1 1-2 1-2 1s-1 0-2-1c-1 1-2 1-2 1s-1 0-2-1c-1 1-2 1-2 1s-1 0-2-1c-1 1-2 1-2 1v1h16v-1c0 0-1 0-2-1z"></path></g>
<g id="vaadin:bold"><path d="M11 7.5c0 0 2-0.8 2-3.6 0-4.1-5.1-3.9-7-3.9h-4v16h4c3.7 0 8 0 8-4.4 0-3.8-3-4.1-3-4.1zM9 4.4c0 1.8-1.5 1.6-3 1.6v-3c1.8 0 3 0.1 3 1.4zM6 13v-4c1.8 0 4-0.3 4 2.2 0 1.9-2.5 1.8-4 1.8z"></path></g>
<g id="vaadin:bolt"><path d="M7.99 0l-7.010 9.38 6.020-0.42-4.96 7.040 12.96-10-7.010 0.47 7.010-6.47h-7.010z"></path></g>
<g id="vaadin:bomb"><path d="M12 1h1v1h-1v-1z"></path><path d="M12 5h1v1h-1v-1z"></path><path d="M14 3h1v1h-1v-1z"></path><path d="M10 3h1v1h-1v-1z"></path><path d="M14.6 2.1l0.7-0.7-0.7-0.7-1.4 1.4 0.7 0.7z"></path><path d="M13.9 4.2l-0.7 0.7 1.4 1.4 0.7-0.7-0.7-0.7z"></path><path d="M11.1 2.8l0.7-0.7-1.4-1.4-0.7 0.7 0.7 0.7z"></path><path d="M10.4 6.4l2-2-0.7-0.7-2 2-0.7-0.7-0.7 0.8c-0.8-0.5-1.8-0.8-2.8-0.8-3 0-5.5 2.5-5.5 5.5s2.5 5.5 5.5 5.5 5.5-2.5 5.5-5.5c0-1-0.3-1.9-0.7-2.8l0.7-0.7-0.6-0.6zM6 7.2c-2 0-3.4 1.8-3.4 2.8h-1c0-2 2.4-3.8 4.4-3.8v1z"></path></g>
<g id="vaadin:book-dollar"><path d="M12.9 2.5c-1.6-1.2-1.4-2.5-1.4-2.5h-9.5v12.5c0 1.9 2.1 3.5 4 3.5h8v-13c0 0-0.8-0.2-1.1-0.5zM7 6.3c-0.9-0.3-2.3-0.8-2.3-1.9 0.1-0.8 1.3-1.4 1.3-1.6v-0.8h1v0.7c1 0.1 1.8 0.4 1.9 0.4l-0.3 0.9c0 0-0.7-0.3-1.5-0.3-0.7 0-1.1 0.3-1.2 0.8 0 0.3 0.5 0.6 1.3 0.9 1.5 0.5 1.9 1.1 1.9 1.9 0 0.7-0.1 1.6-2.1 1.8v0.9h-1v-0.8c0-0.1-1.4-0.5-1.5-0.5l0.5-0.9c0 0 1.1 0.5 2 0.4s1.3-0.6 1.3-1c0.1-0.3-0.4-0.6-1.3-0.9zM13 15h-7c-1 0-1.8-0.6-2-1.3-0.1-0.3 0-0.7 0.4-0.7h6.6v-10.3c1 0.6 2 1.1 2 1.3v11z"></path></g>
<g id="vaadin:book-percent"><path d="M12.6 2.5c-1.6-1.2-1.6-2.5-1.6-2.5h-9v12.5c0 1.9 1.6 3.5 3.5 3.5h8.5v-13c0 0-1-0.2-1.4-0.5zM5.5 3.2c0.8 0 1.5 0.7 1.5 1.6s-0.7 1.4-1.5 1.4-1.5-0.6-1.5-1.4 0.7-1.6 1.5-1.6zM9 3h1l-5 7h-1l5-7zM10 8.5c0 0.8-0.7 1.5-1.5 1.5s-1.5-0.7-1.5-1.5 0.7-1.5 1.5-1.5 1.5 0.7 1.5 1.5zM13 15h-7.5c-1 0-1.8-0.6-2-1.3-0.1-0.4 0-0.7 0.4-0.7h7.1v-10.3c0 0.6 1 1.1 2 1.3v11z"></path><path d="M9 8.5c0 0.276-0.224 0.5-0.5 0.5s-0.5-0.224-0.5-0.5c0-0.276 0.224-0.5 0.5-0.5s0.5 0.224 0.5 0.5z"></path><path d="M6 4.8c0 0.276-0.224 0.5-0.5 0.5s-0.5-0.224-0.5-0.5c0-0.276 0.224-0.5 0.5-0.5s0.5 0.224 0.5 0.5z"></path></g>
<g id="vaadin:book"><path d="M12.6 2.5c-1.6-1.2-1.6-2.5-1.6-2.5h-9v12.5c0 1.9 1.6 3.5 3.5 3.5h8.5v-13c0 0-1-0.2-1.4-0.5zM4 2h5v2h-5v-2zM13 15h-7.5c-1 0-1.8-0.6-2-1.3-0.1-0.4 0-0.7 0.4-0.7h7.1v-10.3c0.4 0.6 1.2 1.1 2 1.3v11z"></path></g>
<g id="vaadin:bookmark-o"><path d="M3 0v16l5-5 5 5v-16h-10zM12 13.7l-4-3.9-4 3.9v-10.7h8v10.7zM12 2h-8v-1h8v1z"></path></g>
<g id="vaadin:bookmark"><path d="M3 0v0 1h10l0.1-1z"></path><path d="M3 2h10v14l-5-5-5 5z"></path></g>
<g id="vaadin:briefcase"><path d="M11 3v-2h-6v2h-5v12h16v-12h-5zM10 3h-4v-1h4v1z"></path></g>
<g id="vaadin:browser"><path d="M15 1v-1h-15v15h1v1h15v-15h-1zM3 1h9v1h-9v-1zM1 1h1v1h-1v-1zM1 3h13v11h-13v-11z"></path></g>
<g id="vaadin:bug-o"><path d="M13 8v-1c1.216-1.124 1.981-2.721 2-4.497 0-0.28-0.224-0.503-0.5-0.503s-0.5 0.224-0.5 0.5c-0.018 1.112-0.431 2.125-1.105 2.906-0.876 0.978-2.15 1.594-3.569 1.594-0.020 0-0.040-0-0.059-0l-2.537 0c-0.022 0-0.049 0.001-0.075 0.001-1.414 0-2.684-0.612-3.561-1.586-0.669-0.781-1.079-1.793-1.094-2.901-0-0.279-0.224-0.503-0.5-0.503s-0.5 0.224-0.5 0.5c0.022 1.776 0.786 3.368 1.996 4.486l0.004 1.004c-3 0.060-3 1.42-3 3.47 0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5c0-1.72 0-2.4 2-2.47 0.031 1.11 0.245 2.161 0.612 3.136-0.383 0.006-0.696 0.176-0.942 0.414-0.445 0.624-0.711 1.402-0.711 2.242 0 0.2 0.015 0.397 0.044 0.589l-0.003 0.118c0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5v-0.14c-0.022-0.144-0.035-0.311-0.035-0.48 0-0.587 0.154-1.139 0.424-1.616 0.165-0.152 0.401-0.257 0.66-0.264 0.681 1.007 1.714 1.731 2.92 1.994l0.031-0.994h2v1c1.237-0.269 2.271-0.993 2.939-1.983 0.013-0.017 0.016-0.017 0.019-0.017 0.254 0 0.486 0.095 0.663 0.251 0.262 0.462 0.418 1.015 0.418 1.605 0 0.178-0.014 0.352-0.041 0.522l0.002 0.121c0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5v-0.14c0.025-0.165 0.039-0.356 0.039-0.551 0-0.839-0.266-1.616-0.717-2.251-0.238-0.226-0.551-0.396-0.9-0.466 0.336-0.917 0.55-1.975 0.578-3.080 2-0.012 2 0.708 2 2.458 0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5c0-2.030 0-3.39-3-3.47zM6 13.5c-0.44-0.253-0.805-0.589-1.083-0.989l-0.247-0.411-0.15-0.39c-0.302-0.802-0.49-1.73-0.52-2.697l-0-0.013v-1.65c0.578 0.326 1.254 0.556 1.973 0.647l0.027 5.573zM9 13h-2v-1h2v1zM9 11h-2v-1h2v1zM9 9h-2v-1h2v1zM12 9c-0.030 0.98-0.218 1.908-0.54 2.77l-0.13 0.33-0.24 0.4c-0.285 0.411-0.65 0.747-1.074 0.992l-0.016-5.492c0.743-0.081 1.421-0.297 2.029-0.624l-0.029 1.624z"></path><path d="M8 6.2c1.433-0.018 2.767-0.429 3.903-1.129 0.046-0.036 0.098-0.126 0.098-0.229 0-0.008-0-0.016-0.001-0.023-0.066-1.142-0.781-2.103-1.781-2.522-0.137-0.050-0.219-0.16-0.219-0.29 0-0.002 0-0.005 0-0.008v-1.5c0-0.276-0.224-0.5-0.5-0.5s-0.5 0.224-0.5 0.5v1.2c0 0.166-0.134 0.3-0.3 0.3 0 0 0 0 0 0h-1.4c-0.166 0-0.3-0.134-0.3-0.3v-1.2c0-0.276-0.224-0.5-0.5-0.5s-0.5 0.224-0.5 0.5v1.5c-0.006 0.125-0.086 0.229-0.198 0.269-1.026 0.43-1.744 1.4-1.802 2.544-0.001 0.014-0.001 0.021-0.001 0.029 0 0.102 0.051 0.193 0.13 0.247 0.959 0.703 2.161 1.125 3.462 1.125 0.144 0 0.287-0.005 0.428-0.015zM10 3c0.552 0 1 0.448 1 1s-0.448 1-1 1c-0.552 0-1-0.448-1-1s0.448-1 1-1zM6 3c0.552 0 1 0.448 1 1s-0.448 1-1 1c-0.552 0-1-0.448-1-1s0.448-1 1-1z"></path></g>
<g id="vaadin:bug"><path d="M8 6.2c1.433-0.018 2.767-0.429 3.903-1.129 0.046-0.036 0.098-0.126 0.098-0.229 0-0.008-0-0.016-0.001-0.023-0.066-1.142-0.781-2.103-1.781-2.522-0.137-0.050-0.219-0.16-0.219-0.29 0-0.002 0-0.005 0-0.008v-1.5c0-0.276-0.224-0.5-0.5-0.5s-0.5 0.224-0.5 0.5v1.2c0 0.166-0.134 0.3-0.3 0.3 0 0 0 0 0 0h-1.4c-0.166 0-0.3-0.134-0.3-0.3v-1.2c0-0.276-0.224-0.5-0.5-0.5s-0.5 0.224-0.5 0.5v1.5c-0.006 0.125-0.086 0.229-0.198 0.269-1.026 0.43-1.744 1.4-1.802 2.544-0.001 0.014-0.001 0.021-0.001 0.029 0 0.102 0.051 0.193 0.13 0.247 0.959 0.703 2.161 1.125 3.462 1.125 0.144 0 0.287-0.005 0.428-0.015zM10 3c0.552 0 1 0.448 1 1s-0.448 1-1 1c-0.552 0-1-0.448-1-1s0.448-1 1-1zM6 3c0.552 0 1 0.448 1 1s-0.448 1-1 1c-0.552 0-1-0.448-1-1s0.448-1 1-1z"></path><path d="M13 8v-1c1.216-1.124 1.981-2.721 2-4.497 0-0.28-0.224-0.503-0.5-0.503s-0.5 0.224-0.5 0.5c-0.018 1.112-0.431 2.125-1.105 2.906-0.876 0.978-2.15 1.594-3.569 1.594-0.020 0-0.040-0-0.059-0l-2.537 0c-0.022 0-0.049 0.001-0.075 0.001-1.414 0-2.684-0.612-3.561-1.586-0.669-0.781-1.079-1.793-1.094-2.901-0-0.279-0.224-0.503-0.5-0.503s-0.5 0.224-0.5 0.5c0.022 1.776 0.786 3.368 1.996 4.486l0.004 1.004c-3 0.060-3 1.42-3 3.47 0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5c0-1.72 0-2.4 2-2.47 0.031 1.11 0.245 2.161 0.612 3.136-0.383 0.006-0.696 0.176-0.942 0.414-0.445 0.624-0.711 1.402-0.711 2.242 0 0.2 0.015 0.397 0.044 0.589l-0.003 0.118c0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5v-0.14c-0.022-0.144-0.035-0.311-0.035-0.48 0-0.587 0.154-1.139 0.424-1.616 0.165-0.152 0.401-0.257 0.66-0.264 0.588 1.095 1.667 1.859 2.934 1.998l0.017-0.998h2v1c1.284-0.141 2.364-0.905 2.94-1.98 0.012-0.020 0.015-0.020 0.018-0.020 0.254 0 0.486 0.095 0.663 0.251 0.262 0.462 0.418 1.015 0.418 1.605 0 0.178-0.014 0.352-0.041 0.522l0.002 0.121c0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5v-0.14c0.025-0.165 0.039-0.356 0.039-0.551 0-0.839-0.266-1.616-0.717-2.251-0.238-0.226-0.551-0.396-0.9-0.466 0.336-0.917 0.55-1.975 0.578-3.080 2-0.012 2 0.708 2 2.458 0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5c0-2.030 0-3.39-3-3.47zM9 13h-2v-1h2v1zM9 11h-2v-1h2v1zM9 9h-2v-1h2v1z"></path></g>
<g id="vaadin:building-o"><path d="M2 0v16h12v-16h-12zM13 15h-4v-3h-2v3h-4v-14h10v14z"></path><path d="M4 9h2v2h-2v-2z"></path><path d="M7 9h2v2h-2v-2z"></path><path d="M10 9h2v2h-2v-2z"></path><path d="M4 6h2v2h-2v-2z"></path><path d="M7 6h2v2h-2v-2z"></path><path d="M10 6h2v2h-2v-2z"></path><path d="M4 3h2v2h-2v-2z"></path><path d="M7 3h2v2h-2v-2z"></path><path d="M10 3h2v2h-2v-2z"></path></g>
<g id="vaadin:building"><path d="M3 0v16h4v-3h2v3h4v-16h-10zM6 12h-2v-2h2v2zM6 9h-2v-2h2v2zM6 6h-2v-2h2v2zM6 3h-2v-2h2v2zM9 12h-2v-2h2v2zM9 9h-2v-2h2v2zM9 6h-2v-2h2v2zM9 3h-2v-2h2v2zM12 12h-2v-2h2v2zM12 9h-2v-2h2v2zM12 6h-2v-2h2v2zM12 3h-2v-2h2v2z"></path></g>
<g id="vaadin:bullets"><path d="M0 2.5v0c0 0.8 0.7 1.5 1.5 1.5v0c0.8 0 1.5-0.7 1.5-1.5v0c0-0.8-0.7-1.5-1.5-1.5v0c-0.8 0-1.5 0.7-1.5 1.5z"></path><path d="M0 7.5v0c0 0.8 0.7 1.5 1.5 1.5v0c0.8 0 1.5-0.7 1.5-1.5v0c0-0.8-0.7-1.5-1.5-1.5v0c-0.8 0-1.5 0.7-1.5 1.5z"></path><path d="M0 12.5v0c0 0.8 0.7 1.5 1.5 1.5v0c0.8 0 1.5-0.7 1.5-1.5v0c0-0.8-0.7-1.5-1.5-1.5v0c-0.8 0-1.5 0.7-1.5 1.5z"></path><path d="M5 1h11v3h-11v-3z"></path><path d="M5 6h11v3h-11v-3z"></path><path d="M5 11h11v3h-11v-3z"></path></g>
<g id="vaadin:bullseye"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM8 14.9c-3.8 0-6.9-3.1-6.9-6.9s3.1-6.9 6.9-6.9 6.9 3.1 6.9 6.9-3.1 6.9-6.9 6.9z"></path><path d="M8 2.3c-3.2 0-5.7 2.5-5.7 5.7s2.6 5.7 5.7 5.7 5.7-2.6 5.7-5.7-2.5-5.7-5.7-5.7zM8 12.6c-2.5 0-4.6-2.1-4.6-4.6s2.1-4.6 4.6-4.6 4.6 2.1 4.6 4.6c0 2.5-2.1 4.6-4.6 4.6z"></path><path d="M8 4.6c-1.9 0-3.4 1.5-3.4 3.4s1.5 3.4 3.4 3.4c1.9 0 3.4-1.5 3.4-3.4s-1.5-3.4-3.4-3.4z"></path></g>
<g id="vaadin:bus"><path d="M14.67 4h-0.67v-2c0-1.105-0.895-2-2-2h-8c-1.105 0-2 0.895-2 2v2h-0.68c-0 0-0 0-0 0-0.177 0-0.32 0.143-0.32 0.32 0 0.004 0 0.007 0 0.011l-0 2.339c-0 0.003-0 0.006-0 0.010 0 0.177 0.143 0.32 0.32 0.32 0 0 0 0 0 0h0.68v6c0 0.55 0 1 1 1v1.5c0 0.276 0.224 0.5 0.5 0.5h2c0.276 0 0.5-0.224 0.5-0.5v-1.5h4v1.5c0 0.276 0.224 0.5 0.5 0.5h2c0.276 0 0.5-0.224 0.5-0.5v-1.5c1 0 1-0.45 1-1v-6h0.67c0.182 0 0.33-0.148 0.33-0.33s-0.148-0.33-0.33-0.33c-0.182 0-0.33 0.148-0.33 0.33s0.148 0.33 0.33 0.33c0.182 0 0.33-0.148 0.33-0.33v-2.34c0-0.182-0.148-0.33-0.33-0.33 0 0 0 0 0 0zM6 1h4v1h-4v-1zM4 12c-0.552 0-1-0.448-1-1s0.448-1 1-1c0.552 0 1 0.448 1 1s-0.448 1-1 1zM3 8v-5h10v5h-10zM12 12c-0.552 0-1-0.448-1-1s0.448-1 1-1c0.552 0 1 0.448 1 1s-0.448 1-1 1z"></path></g>
<g id="vaadin:button"><path d="M15.7 5.3l-1-1c-0.2-0.2-0.4-0.3-0.7-0.3h-13c-0.6 0-1 0.4-1 1v5c0 0.3 0.1 0.6 0.3 0.7l1 1c0.2 0.2 0.4 0.3 0.7 0.3h13c0.6 0 1-0.4 1-1v-5c0-0.3-0.1-0.5-0.3-0.7zM14 10h-13v-5h13v5z"></path></g>
<g id="vaadin:calc-book"><path d="M11.9 0c-1.3 0-2 0.4-2.4 0.8-0.4-0.4-1.1-0.8-2.5-0.8-3.4 0-4 2-4 2v0 0 4h-3v10h7v-4.6l1.5-0.2c0 0 0.2-0.3 0.3 0.7h1.3c0.1-1 0.4-0.7 0.4-0.7l5.5 0.7v-9.8c0 0-0.6-2.1-4.1-2.1zM1 7h5v2h-5v-2zM6 10v1h-1v-1h1zM4 10v1h-1v-1h1zM2 15h-1v-1h1v1zM2 13h-1v-1h1v1zM2 11h-1v-1h1v1zM4 15h-1v-1h1v1zM4 13h-1v-1h1v1zM6 15h-1v-1h1v1zM6 13h-1v-1h1v1zM9 9.5c-0.9-0.1-1.3-0.3-2-0.3v-3.2h-3v-3.9c0-0.4 0.8-1.5 3-1.5 1.8 0 1.9 0.8 1.9 1 0 0 0 0 0 0v7.9zM15 9.9c-1-0.4-1.1-0.7-2.5-0.7-0.1 0-0.2 0-0.2 0-1 0-1.3 0.2-2.3 0.4v-7.6c0 0 0-0.1 0-0.1s0-0.1 0-0.1c0-0.2 0.2-1.1 1.9-1.1 2.3 0 3.1 0.9 3.1 1.4v7.8z"></path></g>
<g id="vaadin:calc"><path d="M9 3h6v2h-6v-2z"></path><path d="M9 11h6v2h-6v-2z"></path><path d="M5 1h-2v2h-2v2h2v2h2v-2h2v-2h-2z"></path><path d="M7 10.4l-1.4-1.4-1.6 1.6-1.6-1.6-1.4 1.4 1.6 1.6-1.6 1.6 1.4 1.4 1.6-1.6 1.6 1.6 1.4-1.4-1.6-1.6z"></path><path d="M13 14.5c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M13 9.5c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:calendar-briefcase"><path d="M3 0h1v3h-1v-3z"></path><path d="M11 0h1v3h-1v-3z"></path><path d="M13 1v3h-3v-3h-5v3h-3v-3h-2v14h5v-1h-4v-8h13v3h1v-8z"></path><path d="M13 10v-2h-4v2h-3v6h10v-6h-3zM10 9h2v1h-2v-1z"></path></g>
<g id="vaadin:calendar-clock"><path d="M3 0h1v3h-1v-3z"></path><path d="M11 0h1v3h-1v-3z"></path><path d="M6.6 14h-5.6v-8h13v0.6c0.4 0.2 0.7 0.4 1 0.7v-6.3h-2v3h-3v-3h-5v3h-3v-3h-2v14h7.3c-0.3-0.3-0.5-0.6-0.7-1z"></path><path d="M14 12h-3v-3h1v2h2z"></path><path d="M11.5 8c1.9 0 3.5 1.6 3.5 3.5s-1.6 3.5-3.5 3.5-3.5-1.6-3.5-3.5 1.6-3.5 3.5-3.5zM11.5 7c-2.5 0-4.5 2-4.5 4.5s2 4.5 4.5 4.5 4.5-2 4.5-4.5-2-4.5-4.5-4.5v0z"></path></g>
<g id="vaadin:calendar-envelope"><path d="M3 0h1v2h-1v-2z"></path><path d="M9 0h1v2h-1v-2z"></path><path d="M13 7v-6h-2v2h-3v-2h-3v2h-3v-2h-2v12h4v3h12v-9h-3zM4 12h-3v-7h11v2h-8v5zM5 10.2l2.6 1.5-2.6 2.6v-4.1zM5.7 15l2.8-2.8 1.5 0.9 1.5-0.8 2.8 2.8h-8.6zM15 14.3l-2.6-2.6 2.6-1.4v4zM15 9.2l-5 2.7-5-2.9v-1h10v1.2zM15.4 9.6v0 0 0z"></path></g>
<g id="vaadin:calendar-o"><path d="M14 1v3h-3v-3h-6v3h-3v-3h-2v15h16v-15h-2zM15 15h-14v-9h14v9z"></path><path d="M3 0h1v3h-1v-3z"></path><path d="M12 0h1v3h-1v-3z"></path></g>
<g id="vaadin:calendar-user"><path d="M3 0h1v3h-1v-3z"></path><path d="M11 0h1v3h-1v-3z"></path><path d="M9 14.1c0-0.1 0-0.1 0 0l-8-0.1v-8h13v1.2c0.4 0.1 0.7 0.3 1 0.6v-6.8h-2v3h-3v-3h-5v3h-3v-3h-2v14h9v-0.9z"></path><path d="M15 10c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M13.9 12h-1.8c-1.1 0-2.1 0.9-2.1 2.1v1.9h6v-1.9c0-1.2-0.9-2.1-2.1-2.1z"></path></g>
<g id="vaadin:calendar"><path d="M14 1v3h-3v-3h-6v3h-3v-3h-2v15h16v-15h-2zM3 15h-2v-2h2v2zM3 12h-2v-2h2v2zM3 9h-2v-2h2v2zM6 15h-2v-2h2v2zM6 12h-2v-2h2v2zM6 9h-2v-2h2v2zM9 15h-2v-2h2v2zM9 12h-2v-2h2v2zM9 9h-2v-2h2v2zM12 15h-2v-2h2v2zM12 12h-2v-2h2v2zM12 9h-2v-2h2v2zM15 15h-2v-2h2v2zM15 12h-2v-2h2v2zM15 9h-2v-2h2v2z"></path><path d="M3 0h1v3h-1v-3z"></path><path d="M12 0h1v3h-1v-3z"></path></g>
<g id="vaadin:camera"><path d="M11 9c0 1.657-1.343 3-3 3s-3-1.343-3-3c0-1.657 1.343-3 3-3s3 1.343 3 3z"></path><path d="M11 4v-3h-6v3h-5v9h5c0.8 0.6 1.9 1 3 1s2.2-0.4 3-1h5v-9h-5zM6 2h4v2h-4v-2zM8 13c-2.2 0-4-1.8-4-4s1.8-4 4-4c2.2 0 4 1.8 4 4s-1.8 4-4 4zM15 6h-2v-1h2v1z"></path></g>
<g id="vaadin:car"><path d="M15 6.1l-1.4-2.9c-0.4-0.7-1.1-1.2-1.9-1.2h-7.4c-0.8 0-1.5 0.5-1.9 1.2l-1.4 2.9c-0.6 0.1-1 0.6-1 1.1v3.5c0 0.6 0.4 1.1 1 1.2v2c0 0.6 0.5 1.1 1.1 1.1h0.9c0.5 0 1-0.5 1-1.1v-1.9h8v1.9c0 0.6 0.5 1.1 1.1 1.1h0.9c0.6 0 1.1-0.5 1.1-1.1v-2c0.6-0.1 1-0.6 1-1.2v-3.5c-0.1-0.5-0.5-1-1.1-1.1zM4 8.4c0 0.3-0.3 0.6-0.6 0.6h-1.8c-0.3 0-0.6-0.3-0.6-0.6v-0.8c0-0.3 0.3-0.6 0.6-0.6h1.8c0.3 0 0.6 0.3 0.6 0.6v0.8zM10 11h-4v-1h4v1zM2.1 6l1.2-2.4c0.2-0.4 0.6-0.6 1-0.6h7.4c0.4 0 0.8 0.2 1 0.6l1.2 2.4h-11.8zM15 8.4c0 0.3-0.3 0.6-0.6 0.6h-1.8c-0.3 0-0.6-0.3-0.6-0.6v-0.8c0-0.3 0.3-0.6 0.6-0.6h1.8c0.3 0 0.6 0.3 0.6 0.6v0.8z"></path></g>
<g id="vaadin:caret-down"><path d="M3 4h10l-5 7z"></path></g>
<g id="vaadin:caret-left"><path d="M11 3v10l-7-5z"></path></g>
<g id="vaadin:caret-right"><path d="M5 13v-10l7 5z"></path></g>
<g id="vaadin:caret-square-down-o"><path d="M15 1h-14v14h14v-14zM14 14h-12v-12h12v12z"></path><path d="M4 6h8l-4 5z"></path></g>
<g id="vaadin:caret-square-left-o"><path d="M15 1h-14v14h14v-14zM14 14h-12v-12h12v12z"></path><path d="M10 4v8l-5-4z"></path></g>
<g id="vaadin:caret-square-right-o"><path d="M15 1h-14v14h14v-14zM14 14h-12v-12h12v12z"></path><path d="M5.9 12v-8l5 4z"></path></g>
<g id="vaadin:caret-square-up-o"><path d="M15 1h-14v14h14v-14zM14 14h-12v-12h12v12z"></path><path d="M12 10h-8l4-5z"></path></g>
<g id="vaadin:caret-up"><path d="M13 12h-10l5-7z"></path></g>
<g id="vaadin:cart-o"><path d="M14 13.1v-1.1h-9.4l0.6-1.1 9.2-0.9 1.6-6h-12.3l-0.7-3h-3v1h2.2l2.1 8.4-1.3 2.6v1.5c0 0.8 0.7 1.5 1.5 1.5s1.5-0.7 1.5-1.5-0.7-1.5-1.5-1.5h7.5v1.5c0 0.8 0.7 1.5 1.5 1.5s1.5-0.7 1.5-1.5c0-0.7-0.4-1.2-1-1.4zM4 5h10.7l-1.1 4-8.4 0.9-1.2-4.9z"></path></g>
<g id="vaadin:cart"><path d="M14 13.1v-1.1h-9.4l0.6-1.1 9.2-0.9 1.6-6h-12.3l-0.7-3h-3v1h2.2l2.1 8.4-1.3 2.6v1.5c0 0.8 0.7 1.5 1.5 1.5s1.5-0.7 1.5-1.5-0.7-1.5-1.5-1.5h7.5v1.5c0 0.8 0.7 1.5 1.5 1.5s1.5-0.7 1.5-1.5c0-0.7-0.4-1.2-1-1.4z"></path></g>
<g id="vaadin:cash"><path d="M16 14h-14v-1h13v-7h1v8z"></path><path d="M13 4v7h-12v-7h12zM14 3h-14v9h14v-9z"></path><path d="M3 6h-1v3h1v1h4c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5h-4v1z"></path><path d="M11 6v-1h-4c1.381 0 2.5 1.119 2.5 2.5s-1.119 2.5-2.5 2.5h4v-1h1v-3h-1z"></path></g>
<g id="vaadin:chart-3d"><path d="M12 4v-2l-4-2-4 2v1l-4 2v5l12 6 4-2v-8zM4 10.88l-3-1.5v-3.3l3 1.53v3.27zM4 6.49l-2.34-1.2 2.34-1.17v2.37zM8 12.88l-3-1.5v-8.31l3 1.54v8.27zM5.66 2.29l2.34-1.17 2.34 1.17-2.34 1.2zM12 14.88l-3-1.5v-6.31l3 1.54v6.27zM12 7.49l-2.34-1.2 2.34-1.17 2.34 1.17z"></path></g>
<g id="vaadin:chart-grid"><path d="M0 9v7h16v-7h-16zM5 15h-4v-1h4v1zM5 13h-4v-1h4v1zM5 11h-4v-1h4v1zM10 15h-4v-1h4v1zM10 13h-4v-1h4v1zM10 11h-4v-1h4v1zM15 15h-4v-1h4v1zM15 13h-4v-1h4v1zM15 11h-4v-1h4v1z"></path><path d="M16 8h-16v-8h1v7h15v1z"></path><path d="M15 1.57l-5.020 2.86-3.96-1.98-4.020 1.61v1.080l3.98-1.59 4.040 2.020 4.98-2.85v-1.15z"></path></g>
<g id="vaadin:chart-line"><path d="M0 16h16v-16h-1v2.6l-4 3.4v-6h-1v6.4l-4-0.9v-5.5h-1v5.7l-4 2.9v-8.6h-1zM5 14h-4v-1.7l4-2.9v4.6zM10 14h-4v-5.3l0.1-0.1 3.9 0.9v4.5zM15 14h-4v-4.3h0.1l3.9-3.2v7.5z"></path></g>
<g id="vaadin:chart-timeline"><path d="M16 13v-1h-15v-12h-1v13h5v2h-5v1h16v-1h-5v-2h5z"></path><path d="M9 7l-3-3-4 4v3h14v-11l-7 7z"></path></g>
<g id="vaadin:chart"><path d="M0 15h16v1h-16v-1z"></path><path d="M0 0h1v16h-1v-16z"></path><path d="M9 8l-2.9-3-4.1 4v5h14v-13.1z"></path></g>
<g id="vaadin:chat"><path d="M14 14.2c0 0 0 0 0 0 0-0.6 2-1.8 2-3.1 0-1.5-1.4-2.7-3.1-3.2 0.7-0.8 1.1-1.7 1.1-2.8 0-2.8-2.9-5.1-6.6-5.1-3.5 0-7.4 2.1-7.4 5.1 0 2.1 1.6 3.6 2.3 4.2-0.1 1.2-0.6 1.7-0.6 1.7l-1.2 1h1.5c1.6 0 2.9-0.5 3.7-1.1 0 0.1 0 0.1 0 0.2 0 2 2.2 3.6 5 3.6 0.2 0 0.4 0 0.6 0 0.4 0.5 1.7 1.4 3.4 1.4 0.1-0.1-0.7-0.5-0.7-1.9zM7.4 1c3.1 0 5.6 1.9 5.6 4.1s-2.6 4.1-5.8 4.1c-0.2 0-0.6 0-0.8 0h-0.3l-0.1 0.2c-0.3 0.4-1.5 1.2-3.1 1.5 0.1-0.4 0.1-1 0.1-1.8v-0.3c-1-0.8-2.1-2.2-2.1-3.6 0-2.2 3.2-4.2 6.5-4.2z"></path></g>
<g id="vaadin:check-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M7.1 11.7l-4.2-4.1 1.4-1.4 2.8 2.7 4.9-4.9 1.4 1.4z"></path></g>
<g id="vaadin:check-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM7.1 11.7l-4.2-4.1 1.4-1.4 2.7 2.7 5-4.9 1.4 1.4-6.3 6.3z"></path></g>
<g id="vaadin:check-square-o"><path d="M14 6.2v7.8h-12v-12h10.5l1-1h-12.5v14h14v-9.8z"></path><path d="M7.9 10.9l-4.2-4.2 1.5-1.4 2.7 2.8 6.7-6.7 1.4 1.4z"></path></g>
<g id="vaadin:check-square"><path d="M13 0.9l-1 1.1h-12v14h14v-10.5l1.7-2-2.7-2.6zM6.5 11.7l-4.2-4.2 1.4-1.4 2.7 2.7 6.6-6.6 1.4 1.4-7.9 8.1z"></path></g>
<g id="vaadin:check"><path d="M7.3 14.2l-7.1-5.2 1.7-2.4 4.8 3.5 6.6-8.5 2.3 1.8z"></path></g>
<g id="vaadin:chevron-circle-down-o"><path d="M13 6.6l-5 5-5-5 1.4-1.4 3.6 3.6 3.6-3.6z"></path><path d="M1 8c0-3.9 3.1-7 7-7s7 3.1 7 7-3.1 7-7 7-7-3.1-7-7zM0 8c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8-8 3.6-8 8v0z"></path></g>
<g id="vaadin:chevron-circle-down"><path d="M0 8c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8-8 3.6-8 8zM11.6 5.2l1.4 1.4-5 5-5-5 1.4-1.4 3.6 3.6 3.6-3.6z"></path></g>
<g id="vaadin:chevron-circle-left-o"><path d="M9.4 13l-5-5 5-5 1.4 1.4-3.6 3.6 3.6 3.6z"></path><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path></g>
<g id="vaadin:chevron-circle-left"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM10.8 11.6l-1.4 1.4-5-5 5-5 1.4 1.4-3.6 3.6 3.6 3.6z"></path></g>
<g id="vaadin:chevron-circle-right-o"><path d="M6.6 13l5-5-5-5-1.4 1.4 3.6 3.6-3.6 3.6z"></path><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path></g>
<g id="vaadin:chevron-circle-right"><path d="M8 16c4.4 0 8-3.6 8-8s-3.6-8-8-8-8 3.6-8 8 3.6 8 8 8zM5.2 4.4l1.4-1.4 5 5-5 5-1.4-1.4 3.6-3.6-3.6-3.6z"></path></g>
<g id="vaadin:chevron-circle-up-o"><path d="M3 9.4l5-5 5 5-1.4 1.4-3.6-3.6-3.6 3.6z"></path><path d="M15 8c0 3.9-3.1 7-7 7s-7-3.1-7-7 3.1-7 7-7 7 3.1 7 7zM16 8c0-4.4-3.6-8-8-8s-8 3.6-8 8 3.6 8 8 8 8-3.6 8-8v0z"></path></g>
<g id="vaadin:chevron-circle-up"><path d="M16 8c0-4.4-3.6-8-8-8s-8 3.6-8 8 3.6 8 8 8 8-3.6 8-8zM4.4 10.8l-1.4-1.4 5-5 5 5-1.4 1.4-3.6-3.6-3.6 3.6z"></path></g>
<g id="vaadin:chevron-down-small"><path d="M8 12l-6.32-6.32 1.67-1.68 4.65 4.65 4.65-4.65 1.67 1.68-6.32 6.32z"></path></g>
<g id="vaadin:chevron-down"><path d="M8 13.1l-8-8 2.1-2.2 5.9 5.9 5.9-5.9 2.1 2.2z"></path></g>
<g id="vaadin:chevron-left-small"><path d="M4 8l6.32-6.32 1.68 1.67-4.65 4.65 4.65 4.65-1.68 1.67-6.32-6.32z"></path></g>
<g id="vaadin:chevron-left"><path d="M2.9 8l8-8 2.2 2.1-5.9 5.9 5.9 5.9-2.2 2.1z"></path></g>
<g id="vaadin:chevron-right-small"><path d="M12 8l-6.32-6.32-1.68 1.67 4.65 4.65-4.65 4.65 1.68 1.67 6.32-6.32z"></path></g>
<g id="vaadin:chevron-right"><path d="M13.1 8l-8 8-2.2-2.1 5.9-5.9-5.9-5.9 2.2-2.1z"></path></g>
<g id="vaadin:chevron-up-small"><path d="M8 4l-6.32 6.32 1.67 1.68 4.65-4.65 4.65 4.65 1.67-1.68-6.32-6.32z"></path></g>
<g id="vaadin:chevron-up"><path d="M8 2.9l8 8-2.1 2.2-5.9-5.9-5.9 5.9-2.1-2.2z"></path></g>
<g id="vaadin:child"><path d="M10 5c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M12.79 10.32l-2.6-2.63c-0.421-0.426-1.004-0.69-1.65-0.69h-1.070c-0 0-0 0-0.001 0-0.648 0-1.235 0.264-1.659 0.69l-2.6 2.63c-0.216 0.129-0.358 0.362-0.358 0.628 0 0.403 0.327 0.73 0.73 0.73 0.266 0 0.499-0.142 0.626-0.355l1.792-1.793v6.47h1.5v-4h1v4h1.5v-6.47l1.75 1.8c0.135 0.175 0.344 0.287 0.58 0.287 0.403 0 0.73-0.327 0.73-0.73 0-0.228-0.105-0.432-0.269-0.566z"></path></g>
<g id="vaadin:circle-thin"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path></g>
<g id="vaadin:circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8z"></path></g>
<g id="vaadin:clipboard-check"><path d="M11 1v-1h-6v1h-2v1h-1v14h12v-1h1v-14h-4zM6 1h4v2h-4v-2zM13 15h-10v-12h2v1h6v-1h2v12z"></path><path d="M7.39 12.47l-3-2.73 1.35-1.48 1.58 1.44 2.87-2.9 1.42 1.4-4.22 4.27z"></path></g>
<g id="vaadin:clipboard-cross"><path d="M11 1v-1h-6v1h-2v1h-1v14h12v-1h1v-14h-4zM6 1h4v2h-4v-2zM13 15h-10v-12h2v1h6v-1h2v12z"></path><path d="M11 8h-2v-2h-2v2h-2v2h2v2h2v-2h2z"></path></g>
<g id="vaadin:clipboard-heart"><path d="M9.5 7c0 0 0 0 0 0-0.6 0-1.1 0.6-1.5 1-0.4-0.4-0.9-1-1.5-1 0 0 0 0 0 0-1.5 0-2.1 1.9-1 2.9l2.5 2.1 2.5-2.1c1.1-1 0.5-2.9-1-2.9z"></path><path d="M11 1v-1h-6v1h-2v1h-1v14h12v-1h1v-14h-4zM6 1h4v2h-4v-2zM13 15h-10v-12h2v1h6v-1h2v12z"></path></g>
<g id="vaadin:clipboard-pulse"><path d="M11 1v-1h-6v1h-2v1h-1v14h12v-1h1v-14h-4zM6 1h4v2h-4v-2zM13 15h-10v-12h2v1h6v-1h2v12z"></path><path d="M9.3 13c0 0 0 0 0 0-0.2 0-0.3-0.1-0.4-0.3l-0.8-4.8-0.7 3.1c0 0.1-0.1 0.2-0.3 0.3-0.1 0-0.3 0-0.4-0.1l-1-1.3h-1.3c-0.2 0-0.4-0.2-0.4-0.4s0.2-0.4 0.4-0.4h1.6c0.1 0 0.2 0.1 0.3 0.1l0.6 0.8 0.9-4.3c0-0.2 0.2-0.3 0.4-0.3 0 0 0 0 0 0 0.2 0 0.3 0.2 0.3 0.4l0.9 5.3 0.6-1.7c0.1-0.1 0.2-0.2 0.3-0.2h1.3c0.2 0 0.4 0.2 0.4 0.4s-0.2 0.4-0.4 0.4h-1l-1 2.9c0 0-0.2 0.1-0.3 0.1z"></path></g>
<g id="vaadin:clipboard-text"><path d="M4 6h8v1h-8v-1z"></path><path d="M4 8h8v1h-8v-1z"></path><path d="M4 10h5v1h-5v-1z"></path><path d="M11 1v-1h-6v1h-2v1h-1v14h12v-1h1v-14h-4zM6 1h4v2h-4v-2zM13 15h-10v-12h2v1h6v-1h2v12z"></path></g>
<g id="vaadin:clipboard-user"><path d="M11 1v-1h-6v1h-2v1h-1v14h12v-1h1v-14h-4zM6 1h4v2h-4v-2zM13 15h-10v-12h2v1h6v-1h2v12z"></path><path d="M8 6c-2.5 0-1.3 3.2-1.3 3.2 0.3 0.4 0.7 0.4 0.7 0.6 0 0.3-0.3 0.3-0.6 0.4-0.5 0.1-0.9-0.1-1.4 0.8-0.3 0.4-0.4 2-0.4 2h6c0 0-0.1-1.6-0.4-2-0.4-0.8-0.9-0.7-1.4-0.8-0.3 0-0.6-0.1-0.6-0.4s0.3-0.2 0.6-0.6c0.1 0 1.3-3.2-1.2-3.2z"></path></g>
<g id="vaadin:clipboard"><path d="M11 1v-1h-6v1h-2v1h-1v14h12v-1h1v-14h-4zM6 1h4v2h-4v-2zM13 15h-10v-12h2v1h6v-1h2v12z"></path></g>
<g id="vaadin:clock"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM8 14c-3.3 0-6-2.7-6-6s2.7-6 6-6 6 2.7 6 6-2.7 6-6 6z"></path><path d="M8 3h-1v6h5v-1h-4z"></path></g>
<g id="vaadin:close-big"><path d="M16 0l-1 0.010-7 6.99-7-6.99-1-0.010v1l7 7-7 7v1h1l7-7 7 7h1v-1l-7-7 7-7v-1z"></path></g>
<g id="vaadin:close-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M12.2 10.8l-2.8-2.8 2.8-2.8-1.4-1.4-2.8 2.8-2.8-2.8-1.4 1.4 2.8 2.8-2.8 2.8 1.4 1.4 2.8-2.8 2.8 2.8z"></path></g>
<g id="vaadin:close-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM12.2 10.8l-1.4 1.4-2.8-2.8-2.8 2.8-1.4-1.4 2.8-2.8-2.8-2.8 1.4-1.4 2.8 2.8 2.8-2.8 1.4 1.4-2.8 2.8 2.8 2.8z"></path></g>
<g id="vaadin:close-small"><path d="M12.96 4.46l-1.42-1.42-3.54 3.55-3.54-3.55-1.42 1.42 3.55 3.54-3.55 3.54 1.42 1.42 3.54-3.55 3.54 3.55 1.42-1.42-3.55-3.54 3.55-3.54z"></path></g>
<g id="vaadin:close"><path d="M15.1 3.1l-2.2-2.2-4.9 5-4.9-5-2.2 2.2 5 4.9-5 4.9 2.2 2.2 4.9-5 4.9 5 2.2-2.2-5-4.9z"></path></g>
<g id="vaadin:cloud-download-o"><path d="M14.1 9.8c0-0.2 0-0.4 0-0.6 0-2.4-1.9-4.3-4.2-4.3-0.3 0.1-0.6 0.1-0.9 0.1v-3h-2v2.4c-0.4-0.3-0.9-0.4-1.3-0.4-1.6 0-2.9 1.3-2.9 2.9 0 0.3 0.1 0.6 0.2 0.9-1.6 0.2-3 1.8-3 3.6 0 1.9 1.5 3.6 3.3 3.6h10.3c1.4 0 2.4-1.5 2.4-2.7s-0.8-2.3-1.9-2.5zM13.6 14h-10.3c-1.2 0-2.3-1.3-2.3-2.6s1.1-2.6 2.3-2.6c0.1 0 0.3 0 0.4 0l1.4 0.2-0.9-1c-0.2-0.3-0.4-0.7-0.4-1.2 0-1 0.8-1.8 1.8-1.8 0.5 0 1 0.2 1.3 0.6v2.4h-1.9l3 4 3-4h-2v-1.9c0.3-0.1 0.6-0.1 0.9-0.1 1.8 0 3.2 1.5 3.2 3.3 0 0.3 0 0.6-0.1 0.9l-0.2 0.6 0.8 0.1c0.7 0 1.4 0.7 1.4 1.5 0 0.7-0.6 1.6-1.4 1.6z"></path></g>
<g id="vaadin:cloud-download"><path d="M14 10c0 0-0.1 0-0.1 0 0-0.3 0.1-0.6 0.1-1 0-2.2-1.8-4-4-4v-4h-4v3.1c-0.2-0.1-0.3-0.1-0.5-0.1-1.4 0-2.5 1.1-2.5 2.5 0 0.6 0.2 1.1 0.6 1.6-0.2-0.1-0.4-0.1-0.6-0.1-1.7 0-3 1.3-3 3s1.3 3 3 3h11c1.1 0 2-0.9 2-2s-0.9-2-2-2zM8 11.4l-2.9-3.4h1.9v-6h2v6h1.9l-2.9 3.4z"></path></g>
<g id="vaadin:cloud-o"><path d="M14.1 8.9c0-0.2 0-0.4 0-0.6 0-2.4-1.9-4.3-4.2-4.3-0.6 0-1.2 0.1-1.8 0.4-0.5-0.7-1.5-1.2-2.4-1.2-1.6 0-2.9 1.2-2.9 2.8 0 0.3 0.1 0.6 0.2 0.9-1.6 0.2-3 1.8-3 3.5 0 1.9 1.5 3.6 3.3 3.6h10.3c1.4 0 2.4-1.4 2.4-2.6s-0.8-2.2-1.9-2.5zM13.6 13h-10.3c-1.2 0-2.3-1.2-2.3-2.5s1.1-2.5 2.3-2.5c0.1 0 0.3 0 0.4 0l1.3 0.3-0.8-1.2c-0.2-0.3-0.4-0.7-0.4-1.1 0-1 0.8-1.8 1.8-1.8 0.8 0 1.5 0.5 1.7 1.2l0.3 0.6 0.5-0.3c0.5-0.3 1.1-0.5 1.8-0.5 1.8 0 3.2 1.5 3.2 3.3 0 0.3 0 0.6-0.1 0.9l-0.2 0.6h0.8c0.7 0 1.4 0.7 1.4 1.5 0 0.6-0.6 1.5-1.4 1.5z"></path></g>
<g id="vaadin:cloud-upload-o"><path d="M14.1 10.9c0-0.2 0-0.4 0-0.6 0-2.4-1.9-4.3-4.2-4.3-0.3 0-0.6 0-0.9 0.1v-2.1h2l-3-4-3 4h2v1.5c-0.4-0.2-0.9-0.3-1.3-0.3-1.6 0-2.9 1.2-2.9 2.8 0 0.3 0.1 0.6 0.2 0.9-1.6 0.2-3 1.8-3 3.5 0 1.9 1.5 3.6 3.3 3.6h10.3c1.4 0 2.4-1.4 2.4-2.6s-0.8-2.2-1.9-2.5zM13.6 15h-10.3c-1.2 0-2.3-1.2-2.3-2.5s1.1-2.5 2.3-2.5c0.1 0 0.3 0 0.4 0l1.3 0.3-0.8-1.2c-0.2-0.3-0.4-0.7-0.4-1.1 0-1 0.8-1.8 1.8-1.8 0.5 0 1 0.2 1.3 0.6v3.2h2v-2.8c0.3-0.1 0.6-0.1 0.9-0.1 1.8 0 3.2 1.5 3.2 3.3 0 0.3 0 0.6-0.1 0.9l-0.2 0.6h0.8c0.7 0 1.4 0.7 1.4 1.5 0.1 0.7-0.5 1.6-1.3 1.6z"></path></g>
<g id="vaadin:cloud-upload"><path d="M14 10c0 0-0.1 0-0.1 0 0-0.3 0.1-0.6 0.1-1 0-1.6-1-3-2.4-3.6l-3.6-4.4-2.5 3c-1.4 0-2.5 1.1-2.5 2.5 0 0.6 0.2 1.1 0.6 1.6-0.2-0.1-0.4-0.1-0.6-0.1-1.7 0-3 1.3-3 3s1.3 3 3 3h11c1.1 0 2-0.9 2-2s-0.9-2-2-2zM9 6v6h-2v-6h-1.9l2.9-3.4 2.9 3.4h-1.9z"></path></g>
<g id="vaadin:cloud"><path d="M14 13c1.1 0 2-0.9 2-2s-0.9-2-2-2c0 0-0.1 0-0.1 0 0-0.3 0.1-0.6 0.1-1 0-2.2-1.8-4-4-4-0.8 0-1.5 0.2-2.2 0.6-0.3-0.9-1.2-1.6-2.3-1.6-1.4 0-2.5 1.1-2.5 2.5 0 0.6 0.2 1.1 0.6 1.6-0.2-0.1-0.4-0.1-0.6-0.1-1.7 0-3 1.3-3 3s1.3 3 3 3h11z"></path></g>
<g id="vaadin:cluster"><path d="M14 12c-0.372 0.011-0.716 0.121-1.008 0.305l-2.212-2.155c0.434-0.547 0.708-1.239 0.74-1.993l1.57-0.157c0.225 0.556 0.76 0.941 1.385 0.941 0.823 0 1.49-0.667 1.49-1.49s-0.667-1.49-1.49-1.49c-0.749 0-1.368 0.552-1.474 1.271l-1.591 0.128c-0.224-1.136-0.973-2.060-1.978-2.521l0.308-0.839h0.26c1.099-0.008 1.986-0.9 1.986-2 0-1.105-0.895-2-2-2s-2 0.895-2 2c0 0.742 0.404 1.39 1.004 1.735l-0.27 0.855c-0.227-0.054-0.487-0.084-0.754-0.084-0.83 0-1.59 0.296-2.181 0.789l-2.994-3.004c0.141-0.224 0.225-0.497 0.225-0.79 0-0.828-0.672-1.5-1.5-1.5s-1.5 0.672-1.5 1.5c0 0.823 0.663 1.492 1.484 1.5 0.281-0.001 0.544-0.079 0.767-0.214l2.993 3.004c-0.474 0.588-0.76 1.344-0.76 2.168 0 0.015 0 0.030 0 0.045-0 0.058-0 0.108-0 0.158l-0.66 0.11c-0.313-0.72-1.019-1.214-1.839-1.214-1.105 0-2 0.895-2 2s0.895 2 2 2c1.105 0 2-0.895 2-2 0-0.020-0-0.039-0.001-0.059l0.63-0.097c0.242 0.843 0.768 1.538 1.466 1.992l-0.556 1.188c-0.161-0.049-0.347-0.078-0.539-0.080-0.006-0-0.012-0-0.017-0-1.105 0-2 0.895-2 2s0.895 2 2 2c1.105 0 2-0.895 2-2 0-0.64-0.301-1.211-0.769-1.577l0.566-1.153c0.364 0.146 0.787 0.231 1.229 0.231 0.847 0 1.621-0.311 2.216-0.824l2.176 2.124c-0.25 0.33-0.4 0.748-0.4 1.2 0 1.105 0.895 2 2 2s2-0.895 2-2c0-1.105-0.895-2-2-2 0 0 0 0 0 0zM5 15c-0.552 0-1-0.448-1-1s0.448-1 1-1c0.552 0 1 0.448 1 1s-0.448 1-1 1zM8 10.5c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5c1.381 0 2.5 1.119 2.5 2.5s-1.119 2.5-2.5 2.5z"></path></g>
<g id="vaadin:code"><path d="M5.2 14l4.5-12h1.1l-4.5 12z"></path><path d="M11.1 13h1.2l3.7-5-3.7-5h-1.3l3.8 5z"></path><path d="M4.9 13h-1.2l-3.7-5 3.7-5h1.3l-3.8 5z"></path></g>
<g id="vaadin:coffee"><path d="M14 13l-4 1h-6l-4-1v-1h14z"></path><path d="M14.7 3h-1.7v-1h-12v5c0 1.5 0.8 2.8 2 3.4v0.6h8v-0.6c0.9-0.5 1.6-1.4 1.9-2.4 0 0 0.1 0 0.1 0 2.3 0 2.9-2 3-3.5 0.1-0.8-0.5-1.5-1.3-1.5zM13 7v-3h1.7c0.1 0 0.2 0.1 0.2 0.1s0.1 0.1 0.1 0.3c-0.2 2.6-1.6 2.6-2 2.6z"></path></g>
<g id="vaadin:cog-o"><path d="M15.2 6l-1.1-0.2c-0.1-0.2-0.1-0.4-0.2-0.6l0.6-0.9 0.5-0.7-2.6-2.6-0.7 0.5-0.9 0.6c-0.2-0.1-0.4-0.1-0.6-0.2l-0.2-1.1-0.2-0.8h-3.6l-0.2 0.8-0.2 1.1c-0.2 0.1-0.4 0.1-0.6 0.2l-0.9-0.6-0.7-0.4-2.5 2.5 0.5 0.7 0.6 0.9c-0.2 0.2-0.2 0.4-0.3 0.6l-1.1 0.2-0.8 0.2v3.6l0.8 0.2 1.1 0.2c0.1 0.2 0.1 0.4 0.2 0.6l-0.6 0.9-0.5 0.7 2.6 2.6 0.7-0.5 0.9-0.6c0.2 0.1 0.4 0.1 0.6 0.2l0.2 1.1 0.2 0.8h3.6l0.2-0.8 0.2-1.1c0.2-0.1 0.4-0.1 0.6-0.2l0.9 0.6 0.7 0.5 2.6-2.6-0.5-0.7-0.6-0.9c0.1-0.2 0.2-0.4 0.2-0.6l1.1-0.2 0.8-0.2v-3.6l-0.8-0.2zM15 9l-1.7 0.3c-0.1 0.5-0.3 1-0.6 1.5l0.9 1.4-1.4 1.4-1.4-0.9c-0.5 0.3-1 0.5-1.5 0.6l-0.3 1.7h-2l-0.3-1.7c-0.5-0.1-1-0.3-1.5-0.6l-1.4 0.9-1.4-1.4 0.9-1.4c-0.3-0.5-0.5-1-0.6-1.5l-1.7-0.3v-2l1.7-0.3c0.1-0.5 0.3-1 0.6-1.5l-1-1.4 1.4-1.4 1.4 0.9c0.5-0.3 1-0.5 1.5-0.6l0.4-1.7h2l0.3 1.7c0.5 0.1 1 0.3 1.5 0.6l1.4-0.9 1.4 1.4-0.9 1.4c0.3 0.5 0.5 1 0.6 1.5l1.7 0.3v2z"></path><path d="M8 4.5c-1.9 0-3.5 1.6-3.5 3.5s1.6 3.5 3.5 3.5 3.5-1.6 3.5-3.5c0-1.9-1.6-3.5-3.5-3.5zM8 10.5c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5c0 1.4-1.1 2.5-2.5 2.5z"></path></g>
<g id="vaadin:cog"><path d="M16 9v-2l-1.7-0.6c-0.2-0.6-0.4-1.2-0.7-1.8l0.8-1.6-1.4-1.4-1.6 0.8c-0.5-0.3-1.1-0.6-1.8-0.7l-0.6-1.7h-2l-0.6 1.7c-0.6 0.2-1.2 0.4-1.7 0.7l-1.6-0.8-1.5 1.5 0.8 1.6c-0.3 0.5-0.5 1.1-0.7 1.7l-1.7 0.6v2l1.7 0.6c0.2 0.6 0.4 1.2 0.7 1.8l-0.8 1.6 1.4 1.4 1.6-0.8c0.5 0.3 1.1 0.6 1.8 0.7l0.6 1.7h2l0.6-1.7c0.6-0.2 1.2-0.4 1.8-0.7l1.6 0.8 1.4-1.4-0.8-1.6c0.3-0.5 0.6-1.1 0.7-1.8l1.7-0.6zM8 12c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4z"></path><path d="M10.6 7.9c0 1.381-1.119 2.5-2.5 2.5s-2.5-1.119-2.5-2.5c0-1.381 1.119-2.5 2.5-2.5s2.5 1.119 2.5 2.5z"></path></g>
<g id="vaadin:cogs"><path d="M12 7v-2l-1.2-0.4c-0.1-0.3-0.2-0.7-0.4-1l0.6-1.2-1.5-1.3-1.1 0.5c-0.3-0.2-0.6-0.3-1-0.4l-0.4-1.2h-2l-0.4 1.2c-0.3 0.1-0.7 0.2-1 0.4l-1.1-0.5-1.4 1.4 0.6 1.2c-0.2 0.3-0.3 0.6-0.4 1l-1.3 0.3v2l1.2 0.4c0.1 0.3 0.2 0.7 0.4 1l-0.5 1.1 1.4 1.4 1.2-0.6c0.3 0.2 0.6 0.3 1 0.4l0.3 1.3h2l0.4-1.2c0.3-0.1 0.7-0.2 1-0.4l1.2 0.6 1.4-1.4-0.6-1.2c0.2-0.3 0.3-0.6 0.4-1l1.2-0.4zM3 6c0-1.7 1.3-3 3-3s3 1.3 3 3c0 1.7-1.3 3-3 3s-3-1.3-3-3z"></path><path d="M7.5 6c0 0.828-0.672 1.5-1.5 1.5s-1.5-0.672-1.5-1.5c0-0.828 0.672-1.5 1.5-1.5s1.5 0.672 1.5 1.5z"></path><path d="M16 3v-1h-0.6c0-0.2-0.1-0.4-0.2-0.5l0.4-0.4-0.7-0.7-0.4 0.4c-0.2-0.1-0.3-0.2-0.5-0.2v-0.6h-1v0.6c-0.2 0-0.4 0.1-0.5 0.2l-0.4-0.4-0.7 0.7 0.4 0.4c-0.1 0.2-0.2 0.3-0.2 0.5h-0.6v1h0.6c0 0.2 0.1 0.4 0.2 0.5l-0.4 0.4 0.7 0.7 0.4-0.4c0.2 0.1 0.3 0.2 0.5 0.2v0.6h1v-0.6c0.2 0 0.4-0.1 0.5-0.2l0.4 0.4 0.7-0.7-0.4-0.4c0.1-0.2 0.2-0.3 0.2-0.5h0.6zM13.5 3.5c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1c0 0.6-0.4 1-1 1z"></path><path d="M15.4 11.8c-0.1-0.3-0.2-0.6-0.4-0.9l0.3-0.6-0.7-0.7-0.5 0.4c-0.3-0.2-0.6-0.3-0.9-0.4l-0.2-0.6h-1l-0.2 0.6c-0.3 0.1-0.6 0.2-0.9 0.4l-0.6-0.3-0.7 0.7 0.3 0.6c-0.2 0.3-0.3 0.6-0.4 0.9l-0.5 0.1v1l0.6 0.2c0.1 0.3 0.2 0.6 0.4 0.9l-0.3 0.6 0.7 0.7 0.6-0.3c0.3 0.2 0.6 0.3 0.9 0.4l0.1 0.5h1l0.2-0.6c0.3-0.1 0.6-0.2 0.9-0.4l0.6 0.3 0.7-0.7-0.4-0.5c0.2-0.3 0.3-0.6 0.4-0.9l0.6-0.2v-1l-0.6-0.2zM12.5 14c-0.8 0-1.5-0.7-1.5-1.5s0.7-1.5 1.5-1.5 1.5 0.7 1.5 1.5-0.7 1.5-1.5 1.5z"></path></g>
<g id="vaadin:coin-piles"><path d="M10.5 0c-3.040 0-5.5 0.88-5.5 2 0 0 0 0 0 0v2c-3 0.1-5 0.94-5 2 0 0 0 0 0 0v2s0 0 0 0v2s0 0 0 0v2c0 1.090 2.46 2 5.5 2 0.020 0 0.043 0 0.067 0 0.732 0 1.45-0.055 2.153-0.16 0.698 1.305 2.094 2.158 3.69 2.158 2.017 0 3.715-1.363 4.224-3.217 0.209-0.199 0.344-0.442 0.367-0.717l0-2.064v-8c0-1.12-2.46-2-5.5-2zM5.5 5c2.5 0 4.5 0.45 4.5 1s-2 1-4.5 1-4.5-0.45-4.5-1 2-1 4.5-1zM5.5 13c-2.71 0-4.25-0.71-4.5-1v-0.8c1.199 0.512 2.595 0.809 4.060 0.809 0.155 0 0.309-0.003 0.462-0.010 0.508-0.001 1.030-0.030 1.544-0.085-0.043 0.371 0.022 0.712 0.123 1.037-0.452 0.021-0.967 0.051-1.488 0.051-0.070 0-0.141-0.001-0.211-0.002zM7.070 10.91c-0.467 0.057-1.008 0.090-1.556 0.090-0.005 0-0.010 0-0.014 0-2.709 0-4.249-0.71-4.499-1v-0.84c1.223 0.535 2.649 0.846 4.147 0.846 0.124 0 0.248-0.002 0.371-0.006 0.632-0.001 1.271-0.044 1.897-0.128-0.197 0.306-0.291 0.654-0.342 1.015zM5.5 9c-2.71 0-4.25-0.71-4.5-1v-0.9c1.223 0.535 2.649 0.846 4.147 0.846 0.124 0 0.248-0.002 0.371-0.006 0.088 0.004 0.212 0.006 0.337 0.006 1.498 0 2.923-0.311 4.214-0.872l-0.068 0.366c-0.777 0.265-1.432 0.717-1.935 1.304-0.752 0.165-1.611 0.256-2.491 0.256-0.026 0-0.052-0-0.077-0zM11.41 15c-1.883 0-3.41-1.527-3.41-3.41s1.527-3.41 3.41-3.41c1.883 0 3.41 1.527 3.41 3.41s-1.527 3.41-3.41 3.41zM15 8c-0.175 0.167-0.385 0.3-0.617 0.386-0.288-0.244-0.6-0.46-0.938-0.634 0.575-0.153 1.101-0.352 1.593-0.61l-0.038 0.858zM15 6c-0.24 0.31-1.61 0.94-4 1v-1c0.003 0 0.007 0 0.011 0 1.443 0 2.814-0.305 4.053-0.855l-0.064 0.855zM15 4c-0.25 0.33-1.79 1-4.5 1h-0.23c-1.213-0.63-2.648-1-4.169-1-0.014 0-0.029 0-0.043 0l-0.058-0v-0.9c1.223 0.535 2.649 0.846 4.147 0.846 0.124 0 0.248-0.002 0.371-0.006 0.088 0.004 0.212 0.006 0.337 0.006 1.498 0 2.923-0.311 4.214-0.872l-0.068 0.926zM10.5 3c-2.5 0-4.5-0.45-4.5-1s2-1 4.5-1 4.5 0.45 4.5 1-2 1-4.5 1z"></path><path d="M10.5 11h0.5v3h1v-5h-0.5l-1 2z"></path></g>
<g id="vaadin:coins"><path d="M11.5 0c-2.485 0-4.5 2.015-4.5 4.5 0.004 0.261 0.029 0.513 0.074 0.758-0.479-0.176-1.025-0.261-1.591-0.261-3.043 0-5.51 2.467-5.51 5.51s2.467 5.51 5.51 5.51c3.043 0 5.51-2.467 5.51-5.51 0-0.566-0.085-1.112-0.244-1.626 0.23 0.077 0.484 0.099 0.742 0.099 2.48 0 4.49-2.010 4.49-4.49 0-2.477-2.005-4.485-4.481-4.49zM10 10.5c0 2.485-2.015 4.5-4.5 4.5s-4.5-2.015-4.5-4.5c0-2.485 2.015-4.5 4.5-4.5 2.483 0.006 4.494 2.017 4.5 4.499zM12.5 7h-2v-0.5h0.5v-3h-0.5l1-1.5h0.5v4.5h0.5v0.5z"></path><path d="M5.63 8c0.033-0.003 0.072-0.005 0.111-0.005 0.696 0 1.26 0.564 1.26 1.26 0 0.016-0 0.031-0.001 0.047 0 1.698-1.86 2.698-1.86 2.698h1.37v-0.5h0.49v1.5h-3v-1s2-1.27 2-2.33c0-0.37 0-0.67-0.42-0.67-0.69 0-0.65 1-0.65 1h-0.93s-0.23-2 1.63-2z"></path></g>
<g id="vaadin:combobox"><path d="M15 4h-14c-0.6 0-1 0.4-1 1v6c0 0.6 0.4 1 1 1h14c0.6 0 1-0.4 1-1v-6c0-0.6-0.4-1-1-1zM10 11h-9v-6h9v6zM13 8.4l-2-1.4h4l-2 1.4z"></path><path d="M2 6h1v4h-1v-4z"></path></g>
<g id="vaadin:comment-ellipsis-o"><path d="M3 11.2c0 0.1 0 0.1 0 0 0 0.1 0 0.1 0 0 0 0 0 0 0 0z"></path><path d="M8.3 1c-4.4 0-8.3 2.6-8.3 5.6 0 2 1.1 3.7 3 4.7 0 0 0 0 0 0s0 0.1 0 0.1c-0.1 1.3-0.9 1.7-0.9 1.7l-1.8 0.9h2c2.5 0 4.3-1.1 5.1-1.9 0.3 0 0.6 0 0.8 0 4.3 0 7.8-2.5 7.8-5.6s-3.4-5.5-7.7-5.5zM8.2 11.1c-0.3 0-0.7 0-0.9 0h-0.2l-0.2 0.2c-0.5 0.5-1.6 1.4-3.3 1.7 0.3-0.5 0.5-1.1 0.5-2v-0.3l-0.3-0.1c-1.8-0.9-2.8-2.3-2.8-4 0-2.4 3.5-4.6 7.3-4.6 3.7 0 6.7 2 6.7 4.6 0 2.4-3.1 4.5-6.8 4.5z"></path><path d="M6 7c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M9 7c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M12 7c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:comment-ellipsis"><path d="M8 1c-4.4 0-8 2.5-8 5.5 0 2 2 3.8 4 4.8 0 0 0 0 0 0 0 2.1-2 2.8-2 2.8 2.8 0 4.4-1.3 5.1-2.1 0.3 0 0.6 0 0.9 0 4.4 0 8-2.5 8-5.5s-3.6-5.5-8-5.5zM5 8c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1c0 0.6-0.4 1-1 1zM8 8c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1c0 0.6-0.4 1-1 1zM11 8c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1c0 0.6-0.4 1-1 1z"></path></g>
<g id="vaadin:comment-o"><path d="M3 11.2c0 0.1 0 0.1 0 0 0 0.1 0 0.1 0 0 0 0 0 0 0 0z"></path><path d="M8.3 1c-4.4 0-8.3 2.6-8.3 5.6 0 2 1.1 3.7 3 4.7 0 0 0 0 0 0s0 0.1 0 0.1c-0.1 1.3-0.9 1.7-0.9 1.7l-1.8 0.9h2c2.5 0 4.3-1.1 5.1-1.9 0.3 0 0.5 0 0.8 0 4.3 0 7.8-2.5 7.8-5.6s-3.4-5.5-7.7-5.5zM8.2 11.1c-0.3 0-0.7 0-0.9 0h-0.3l-0.2 0.2c-0.5 0.5-1.6 1.4-3.3 1.7 0.3-0.5 0.5-1.1 0.5-2v-0.3l-0.3-0.1c-1.8-0.9-2.7-2.3-2.7-4 0-2.4 3.5-4.6 7.3-4.6 3.7 0 6.7 2 6.7 4.6 0 2.4-3.1 4.5-6.8 4.5z"></path></g>
<g id="vaadin:comment"><path d="M8 1c-4.4 0-8 2.5-8 5.5 0 2 2 3.8 4 4.8 0 0 0 0 0 0 0 2.1-2 2.8-2 2.8 2.8 0 4.4-1.3 5.1-2.1 0.3 0 0.6 0 0.9 0 4.4 0 8-2.5 8-5.5s-3.6-5.5-8-5.5z"></path></g>
<g id="vaadin:comments-o"><path d="M14.2 14c0.6-0.5 1.8-1.6 1.8-3.2 0-1.4-1.2-2.6-2.8-3.3 0.5-0.6 0.8-1.5 0.8-2.4 0-2.8-2.9-5.1-6.6-5.1-3.5 0-7.4 2.1-7.4 5.1 0 2.1 1.6 3.6 2.3 4.2-0.1 1.2-0.6 1.7-0.6 1.7l-1.2 1h1.5c1.2 0 2.2-0.3 3-0.7 0.3 1.9 2.5 3.4 5.3 3.4 0.1 0 0.3 0 0.5 0 0.6 0.5 1.8 1.3 3.5 1.3h1.4l-1.1-0.9c0 0-0.3-0.3-0.4-1.1zM10.3 13.7c-2.3 0-4.3-1.3-4.3-2.8 0-0.1 0-0.1 0-0.2 0.2-0.2 0.4-0.3 0.5-0.5 0.2 0 0.5 0 0.7 0 2.1 0 4-0.7 5.2-1.9 1.5 0.5 2.6 1.5 2.6 2.5s-0.9 2-1.7 2.5l-0.3 0.2v0.3c0 0.5 0.2 0.8 0.3 1.1-1-0.2-1.7-0.7-1.9-1l-0.1-0.2h-0.2c-0.3 0-0.6 0-0.8 0zM7.4 1c3.1 0 5.6 1.9 5.6 4.1s-2.6 4.1-5.8 4.1c-0.2 0-0.6 0-0.8 0h-0.3l-0.1 0.2c-0.3 0.4-1.5 1.2-3.1 1.5 0.1-0.4 0.1-1 0.1-1.8v-0.3c-1-0.8-2.1-2.2-2.1-3.6 0-2.2 3.2-4.2 6.5-4.2z"></path></g>
<g id="vaadin:comments"><path d="M16 11.1c0-1.5-1.5-2.8-3.2-3.3-1.3 1.5-3.9 2.4-6.4 2.4-0.1 0-0.3 0-0.4 0 0 0 0 0-0.1 0-0.1 0.3-0.1 0.5-0.1 0.8 0 2 2.2 3.6 5 3.6 0.2 0 0.4 0 0.6 0 0.4 0.5 1.7 1.4 3.4 1.4 0 0-0.8-0.4-0.8-1.8 0 0 0 0 0 0 0-0.6 2-1.8 2-3.1z"></path><path d="M13 4.6c0-2.5-2.8-4.6-6.4-4.6s-6.6 2.1-6.6 4.6c0 1.7 2 3.2 3 4 0 0 0 0 0 0 0 1.8-1.4 2.4-1.4 2.4 2.3 0 3.6-1.1 4.2-1.8 0.2 0 0.5 0 0.8 0 3.5 0.1 6.4-2 6.4-4.6z"></path></g>
<g id="vaadin:compile"><path d="M1 12h4v4h-4v-4z"></path><path d="M6 12h4v4h-4v-4z"></path><path d="M11 12h4v4h-4v-4z"></path><path d="M1 7h4v4h-4v-4z"></path><path d="M1 2h4v4h-4v-4z"></path><path d="M6 7h4v4h-4v-4z"></path><path d="M7 1h4v4h-4v-4z"></path><path d="M11 7h4v4h-4v-4z"></path><path d="M13 0h3v3h-3v-3z"></path></g>
<g id="vaadin:compress-square"><path d="M12 0h-12v12l1-1v-10h10z"></path><path d="M4 16h12v-12l-1 1v10h-10z"></path><path d="M7 9h-5l1.8 1.8-3.8 3.8 1.4 1.4 3.8-3.8 1.8 1.8z"></path><path d="M16 1.4l-1.4-1.4-3.8 3.8-1.8-1.8v5h5l-1.8-1.8z"></path></g>
<g id="vaadin:compress"><path d="M5.3 9.3l-5 5 1.4 1.4 5-5 1.3 1.3v-4h-4z"></path><path d="M15.7 1.7l-1.4-1.4-4 4-1.3-1.3v4h4l-1.3-1.3z"></path></g>
<g id="vaadin:connect-o"><path d="M12.5 9c-1 0-1.8 0.4-2.4 1l-3.2-1.7c0.1-0.3 0.1-0.5 0.1-0.8 0-0.2 0-0.3 0-0.4l2.9-1.3c0.6 0.7 1.5 1.2 2.6 1.2 1.9 0 3.5-1.6 3.5-3.5s-1.6-3.5-3.5-3.5-3.5 1.6-3.5 3.5c0 0.2 0 0.3 0 0.4l-2.9 1.3c-0.6-0.7-1.5-1.2-2.6-1.2-1.9 0-3.5 1.6-3.5 3.5s1.6 3.5 3.5 3.5c1 0 1.8-0.4 2.4-1l3.1 1.7c0 0.3 0 0.5 0 0.8 0 1.9 1.6 3.5 3.5 3.5s3.5-1.6 3.5-3.5-1.6-3.5-3.5-3.5zM12.5 1c1.4 0 2.5 1.1 2.5 2.5s-1.1 2.5-2.5 2.5-2.5-1.1-2.5-2.5c0-1.4 1.1-2.5 2.5-2.5zM3.5 10c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5c0 1.4-1.1 2.5-2.5 2.5zM12.5 15c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5c0 1.4-1.1 2.5-2.5 2.5z"></path></g>
<g id="vaadin:connect"><path d="M12 10c-0.8 0-1.4 0.3-2 0.8l-3.2-1.8c0.1-0.3 0.2-0.7 0.2-1s-0.1-0.7-0.2-1l3.2-1.8c0.6 0.5 1.2 0.8 2 0.8 1.7 0 3-1.3 3-3s-1.3-3-3-3-3 1.3-3 3c0 0.2 0 0.3 0 0.5l-3.5 1.9c-0.4-0.2-0.9-0.4-1.5-0.4-1.6 0-3 1.3-3 3v0c0 1.6 1.4 3 3 3 0.6 0 1.1-0.2 1.5-0.4l3.5 1.9c0 0.2 0 0.3 0 0.5 0 1.7 1.3 3 3 3s3-1.3 3-3-1.3-3-3-3z"></path></g>
<g id="vaadin:controller"><path d="M5.951 0.249l0.981-0.195 0.195 0.981-0.981 0.195-0.195-0.981z"></path><path d="M8.877 14.966l0.981-0.195 0.195 0.981-0.981 0.195-0.195-0.981z"></path><path d="M0.055 9.071l0.981-0.195 0.195 0.981-0.981 0.195-0.195-0.981z"></path><path d="M14.773 6.145l0.981-0.195 0.195 0.981-0.981 0.195-0.195-0.981z"></path><path d="M11.471 1.897l0.556-0.831 0.831 0.556-0.556 0.831-0.831-0.556z"></path><path d="M3.139 14.441l0.56-0.83 0.83 0.56-0.56 0.83-0.83-0.56z"></path><path d="M1.069 3.989l0.56-0.83 0.83 0.56-0.56 0.83-0.83-0.56z"></path><path d="M13.547 12.299l0.556-0.831 0.831 0.556-0.556 0.831-0.831-0.556z"></path><path d="M8.875 1.039l0.195-0.981 0.981 0.195-0.195 0.981-0.981-0.195z"></path><path d="M5.953 15.745l0.195-0.981 0.981 0.195-0.195 0.981-0.981-0.195z"></path><path d="M0.061 6.931l0.195-0.981 0.981 0.195-0.195 0.981-0.981-0.195z"></path><path d="M14.767 9.854l0.195-0.981 0.981 0.195-0.195 0.981-0.981-0.195z"></path><path d="M3.139 1.628l0.831-0.556 0.556 0.831-0.831 0.556-0.556-0.831z"></path><path d="M11.477 14.101l0.831-0.556 0.556 0.831-0.831 0.556-0.556-0.831z"></path><path d="M1.071 12.033l0.831-0.556 0.556 0.831-0.831 0.556-0.556-0.831z"></path><path d="M13.539 3.63l0.83-0.56 0.56 0.83-0.83 0.56-0.56-0.83z"></path><path d="M14 8c-0.003-1.895-0.884-3.583-2.258-4.681l-3.322 4.991-0.84-0.59 3.32-5c-0.836-0.47-1.836-0.747-2.9-0.747-3.314 0-6 2.686-6 6s2.686 6 6 6c3.304 0 5.984-2.671 6-5.971z"></path></g>
<g id="vaadin:copy-o"><path d="M13 3h-3l-3-3h-7v13h6v3h10v-10l-3-3zM7 1l2 2h-2v-2zM1 12v-11h5v3h3v8h-8zM15 15h-8v-2h3v-9h2v3h3v8zM13 6v-2l2 2h-2z"></path></g>
<g id="vaadin:copy"><path d="M6 0v3h3z"></path><path d="M9 4h-4v-4h-5v12h9z"></path><path d="M13 4v3h3z"></path><path d="M12 4h-2v9h-3v3h9v-8h-4z"></path></g>
<g id="vaadin:copyright"><path d="M8 1.5c3.6 0 6.5 2.9 6.5 6.5s-2.9 6.5-6.5 6.5-6.5-2.9-6.5-6.5 2.9-6.5 6.5-6.5zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M9.9 10.3c-0.5 0.4-1.2 0.7-1.9 0.7-1.7 0-3-1.3-3-3s1.3-3 3-3c0.8 0 1.6 0.3 2.1 0.9l1.1-1.1c-0.8-0.8-2-1.3-3.2-1.3-2.5 0-4.5 2-4.5 4.5s2 4.5 4.5 4.5c1.1 0 2-0.4 2.8-1l-0.9-1.2z"></path></g>
<g id="vaadin:corner-lower-left"><path d="M16 16l-16-16v16z"></path></g>
<g id="vaadin:corner-lower-right"><path d="M16 16h-16l16-16z"></path></g>
<g id="vaadin:corner-upper-left"><path d="M0 16l16-16h-16z"></path></g>
<g id="vaadin:corner-upper-right"><path d="M16 16l-16-16h16z"></path></g>
<g id="vaadin:credit-card"><path d="M0 2v12h16v-12h-16zM15 13h-14v-5h14v5zM15 5h-14v-2h14v2z"></path><path d="M10 11h3v1h-3v-1z"></path><path d="M2 11h6v1h-6v-1z"></path></g>
<g id="vaadin:crop"><path d="M16 0.7v-0.7h-0.7l-3 3h-7.3v-3h-2v3h-3v2h3v8h8v3h2v-3h3v-2h-3v-7.3l3-3zM5 5h5.3l-5.3 5.3v-5.3zM11 11h-5.3l5.3-5.3v5.3z"></path></g>
<g id="vaadin:cross-cutlery"><path d="M10.9 8.6c0 0 0 0 0 0 0.6-0.1 1.2-0.4 1.6-0.9l3.1-3.1c0.4-0.4 0.4-1 0-1.4l-0.1-0.2-3 3c-0.2 0.2-0.6 0.2-0.9 0s-0.2-0.6 0-0.9l2.6-2.6c0.2-0.2 0.2-0.6 0-0.9-0.2-0.2-0.6-0.2-0.9 0l-2.6 2.6c-0.2 0.2-0.6 0.2-0.9 0-0.2-0.2-0.2-0.6 0-0.9l3-3-0.1-0.1c-0.4-0.4-1-0.4-1.4 0l-3.1 3.3c-0.4 0.4-0.7 1-0.8 1.6l-4.9-4.8c-0.4-0.4-1-0.3-1.3 0l-0.2 0.2c-1.4 1.4-0.9 4.2 1.5 6.6l0.8 0.8c0.4 0.4 0.9 0.7 1.5 0.8-0.5 0.4-0.8 0.8-0.8 0.8l-3.4 3.4c-0.7 0.7-0.7 1.9 0 2.6s1.9 0.7 2.6 0l3.3-3.5c0.2-0.2 0.7-0.8 1.3-1.5 0.3 0.4 0.5 0.6 0.5 0.6l4.3 4.3c0.7 0.7 1.9 0.7 2.6 0s0.7-1.9 0-2.6l-4.3-4.2z"></path></g>
<g id="vaadin:crosshairs"><path d="M7.5 0h1v4l-0.5 2-0.5-2v-4z"></path><path d="M8.5 16h-1v-4l0.5-2 0.5 2v4z"></path><path d="M16 7.5v1h-4l-2-0.5 2-0.5h4z"></path><path d="M0 8.5v-1h4l2 0.5-2 0.5h-4z"></path><path d="M8 2.5c3.038 0 5.5 2.462 5.5 5.5s-2.462 5.5-5.5 5.5c-3.038 0-5.5-2.462-5.5-5.5 0.006-3.035 2.465-5.494 5.499-5.5zM8 1c-3.866 0-7 3.134-7 7s3.134 7 7 7c3.866 0 7-3.134 7-7s-3.134-7-7-7v0z"></path></g>
<g id="vaadin:css"><path d="M4.1 11c1.4 0 1.9-1 1.9-1l-0.8-0.5c0 0-0.3 0.5-1 0.5s-1.2-0.9-1.2-2.2c0-1.2 0.6-1.8 1.2-1.8 0.5 0 0.9 0.4 0.9 0.4l0.8-0.6c0 0-0.7-0.8-1.7-0.8-1.1 0-2.2 0.9-2.2 2.8s0.9 3.2 2.1 3.2zM8.7 9.9c-0.3 0.1-0.7 0-1-0.4l-0.8 0.5c0.4 0.6 1 1 1.6 1 0.1 0 0.3 0 0.4-0.1 0.7-0.2 1.1-0.8 1.1-1.6 0-1.2-0.8-1.6-1.3-1.8-0.5-0.3-0.7-0.4-0.7-0.8s0.1-0.7 0.6-0.7c0.3 0 0.6 0.4 0.6 0.4l0.8-0.6c-0.2-0.3-0.7-0.8-1.4-0.8-0.9 0-1.6 0.6-1.6 1.6 0 1.1 0.7 1.5 1.2 1.8 0.6 0.2 0.8 0.4 0.8 0.9 0 0.3 0 0.6-0.3 0.6zM12.7 9.9c-0.3 0.1-0.7 0-1-0.4l-0.8 0.5c0.4 0.6 1 1 1.6 1 0.1 0 0.3 0 0.4-0.1 0.7-0.2 1.1-0.8 1.1-1.6 0-1.2-0.8-1.6-1.3-1.8-0.5-0.3-0.7-0.4-0.7-0.8s0.1-0.7 0.6-0.7c0.3 0 0.6 0.4 0.6 0.4l0.8-0.6c-0.2-0.3-0.7-0.8-1.4-0.8-0.9 0-1.6 0.6-1.6 1.6 0 1.1 0.7 1.5 1.2 1.8 0.6 0.2 0.8 0.4 0.8 0.9 0 0.3 0 0.6-0.3 0.6zM0 0v16h16v-16h-16zM15 15h-14v-14h14v14z"></path></g>
<g id="vaadin:ctrl-a"><path d="M9 7v-1h-1v-1h-1v1h-0.5v1h0.5v3.56c0.176 0.835 0.907 1.453 1.783 1.453 0.077 0 0.152-0.005 0.226-0.014l-0.009-0.999c-0.055 0.012-0.119 0.019-0.185 0.019-0.359 0-0.669-0.21-0.813-0.514l-0.002-3.505h1z"></path><path d="M14 3h1v9h-1v-9z"></path><path d="M13 6c-0.025-0.001-0.055-0.001-0.085-0.001-0.773 0-1.462 0.358-1.911 0.917l-0.004-0.915h-1v6h1v-3c-0.003-0.037-0.004-0.080-0.004-0.124 0-1.038 0.842-1.88 1.88-1.88 0.044 0 0.087 0.001 0.13 0.004l-0.006-1z"></path><path d="M4.19 12c-2.030 0-3.19-1.46-3.19-4s1.16-4 3.19-4c0.009-0 0.019-0 0.029-0 0.539 0 1.052 0.114 1.515 0.32l-0.424 0.901c-0.319-0.139-0.69-0.22-1.080-0.22-0.014 0-0.028 0-0.042 0-1.808-0-2.188 1.63-2.188 3s0.38 3 2.19 3c0.497-0.013 0.96-0.145 1.366-0.368l0.444 0.898c-0.524 0.285-1.146 0.458-1.806 0.47z"></path></g>
<g id="vaadin:ctrl"><path d="M0 0v16h16v-16h-16zM4.19 12c-2.030 0-3.19-1.46-3.19-4s1.16-4 3.19-4c0.009-0 0.019-0 0.029-0 0.539 0 1.052 0.114 1.515 0.32l-0.424 0.901c-0.319-0.139-0.69-0.22-1.080-0.22-0.014 0-0.028 0-0.042 0-1.808-0-2.188 1.63-2.188 3s0.38 3 2.19 3c0.497-0.013 0.96-0.145 1.366-0.368l0.444 0.898c-0.524 0.285-1.146 0.458-1.806 0.47zM9 7h-1v3.5c0.147 0.309 0.457 0.519 0.815 0.519 0.065 0 0.129-0.007 0.19-0.020l-0.006 1.001c-0.065 0.008-0.141 0.013-0.217 0.013-0.875 0-1.606-0.618-1.781-1.441l-0.002-3.572h-0.51v-1h0.51v-1h1v1h1v1zM11 9v3h-1v-6h1v0.92c0.453-0.564 1.142-0.921 1.915-0.921 0.030 0 0.060 0.001 0.090 0.002l-0.004 1c-0.037-0.003-0.080-0.004-0.124-0.004-1.038 0-1.88 0.842-1.88 1.88 0 0.044 0.001 0.087 0.004 0.13zM15 12h-1v-9h1v9z"></path></g>
<g id="vaadin:cube"><path d="M8 0l-8 2v10l8 4 8-4v-10l-8-2zM14.4 2.6l-5.9 2.2-6.6-2.2 6.1-1.6 6.4 1.6zM1 11.4v-8.1l7 2.4v9.2l-7-3.5z"></path></g>
<g id="vaadin:cubes"><path d="M12 6v-4l-4-2-4 2v4l-4 2v5l4 2 4-2 4 2 4-2v-5zM8.090 1.12l2.91 1.44-2.6 1.3-2.91-1.44zM5 2.78l3 1.5v3.6l-3-1.5v-3.6zM4 13.88l-3-1.5v-3.6l3 1.5v3.6zM4.28 9.88l-2.88-1.46 2.6-1.3 2.88 1.44zM12 13.88l-3-1.5v-3.6l3 1.5v3.6zM12.28 9.88l-2.88-1.46 2.6-1.3 2.88 1.44z"></path></g>
<g id="vaadin:curly-brackets"><path d="M2.1 3.1c0.2 1.3 0.4 1.6 0.4 2.9 0 0.8-1.5 1.5-1.5 1.5v1c0 0 1.5 0.7 1.5 1.5 0 1.3-0.2 1.6-0.4 2.9-0.3 2.1 0.8 3.1 1.8 3.1s2.1 0 2.1 0v-2c0 0-1.8 0.2-1.8-1 0-0.9 0.2-0.9 0.4-2.9 0.1-0.9-0.5-1.6-1.1-2.1 0.6-0.5 1.2-1.1 1.1-2-0.3-2-0.4-2-0.4-2.9 0-1.2 1.8-1.1 1.8-1.1v-2c0 0-1 0-2.1 0s-2.1 1-1.8 3.1z"></path><path d="M13.9 3.1c-0.2 1.3-0.4 1.6-0.4 2.9 0 0.8 1.5 1.5 1.5 1.5v1c0 0-1.5 0.7-1.5 1.5 0 1.3 0.2 1.6 0.4 2.9 0.3 2.1-0.8 3.1-1.8 3.1s-2.1 0-2.1 0v-2c0 0 1.8 0.2 1.8-1 0-0.9-0.2-0.9-0.4-2.9-0.1-0.9 0.5-1.6 1.1-2.1-0.6-0.5-1.2-1.1-1.1-2 0.2-2 0.4-2 0.4-2.9 0-1.2-1.8-1.1-1.8-1.1v-2c0 0 1 0 2.1 0s2.1 1 1.8 3.1z"></path></g>
<g id="vaadin:cursor-o"><path d="M5 2.6l5.75 6.4h-2.46l0.63 1.41 1.8 4-0.91 0.34-1.88-4.3-0.5-1.11-1 0.71-1.43 1.020v-8.47zM4 0v13l3-2.14 2.26 5.14 2.8-1-2.23-5h3.17l-9-10z"></path></g>
<g id="vaadin:cursor"><path d="M4 0v13l3.31-3.47 2.69 6.47 1.37-0.63-2.72-6.37h4.35l-9-9z"></path></g>
<g id="vaadin:cutlery"><path d="M13 0.8c0-0.5-0.4-0.8-0.8-0.8h-0.2c-1.7 0-3 1.9-3 4.7v0.9c0 1 0.5 1.9 1.4 2.4-0.3 1.2-0.4 2.5-0.4 2.5v4c0 0.8 0.7 1.5 1.5 1.5s1.5-0.7 1.5-1.5v-4c0-0.4-0.1-1.4-0.3-2.3 0.2-0.2 0.3-0.4 0.3-0.7v-6.7z"></path><path d="M7.2 0h-0.2v3.5c0 0.3-0.2 0.5-0.5 0.5s-0.5-0.2-0.5-0.5v-3c0-0.3-0.2-0.5-0.5-0.5s-0.5 0.2-0.5 0.5v3c0 0.3-0.2 0.5-0.5 0.5s-0.5-0.2-0.5-0.5v-3.5h-0.2c-0.4 0-0.8 0.4-0.8 0.8v3.7c0 1 0.6 1.9 1.5 2.3-0.4 1.6-0.5 3.7-0.5 3.7v4c0 0.8 0.7 1.5 1.5 1.5s1.5-0.7 1.5-1.5v-4c0-0.5-0.1-2.3-0.4-3.7 0.8-0.4 1.4-1.3 1.4-2.3v-3.7c0-0.4-0.4-0.8-0.8-0.8z"></path></g>
<g id="vaadin:dashboard"><path d="M16 10.1c0-4.4-3.6-8.1-8-8.1s-8 3.7-8 8.1c0 1.4 0.3 2.9 0.9 3.9h4.9c0.5 0.6 1.3 1 2.2 1s1.7-0.4 2.2-1h4.9c0.6-1 0.9-2.5 0.9-3.9zM14 7v1l-4.1 3.5c0 0.1 0.1 0.3 0.1 0.5 0 1.1-0.9 2-2 2s-2-0.9-2-2 0.9-2 2-2c0.3 0 0.6 0.1 0.8 0.2l4.2-3.2h1zM10 4h1v1h-1v-1zM5 4h1v1h-1v-1zM2 12h-1v-1h1v1zM3 8h-1v-1h1v1zM15 12h-1v-1h1v1z"></path><path d="M9 12c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:database"><path d="M14 2.5c0 0.828-2.686 1.5-6 1.5s-6-0.672-6-1.5c0-0.828 2.686-1.5 6-1.5s6 0.672 6 1.5z"></path><path d="M8 5c-3.3 0-6-0.7-6-1.5v3c0 0.8 2.7 1.5 6 1.5s6-0.7 6-1.5v-3c0 0.8-2.7 1.5-6 1.5z"></path><path d="M8 9c-3.3 0-6-0.7-6-1.5v3c0 0.8 2.7 1.5 6 1.5s6-0.7 6-1.5v-3c0 0.8-2.7 1.5-6 1.5z"></path><path d="M8 13c-3.3 0-6-0.7-6-1.5v3c0 0.8 2.7 1.5 6 1.5s6-0.7 6-1.5v-3c0 0.8-2.7 1.5-6 1.5z"></path></g>
<g id="vaadin:date-input"><path d="M14 1v3h-3v-3h-6v3h-3v-3h-2v15h16v-15h-2zM15 15h-14v-9h14v9z"></path><path d="M3 0h1v3h-1v-3z"></path><path d="M12 0h1v3h-1v-3z"></path><path d="M3 8h1v5h-1v-5z"></path></g>
<g id="vaadin:deindent"><path d="M4 10.5v-6l-4 3z"></path><path d="M0 0h16v3h-16v-3z"></path><path d="M6 4h10v3h-10v-3z"></path><path d="M6 8h10v3h-10v-3z"></path><path d="M0 12h16v3h-16v-3z"></path></g>
<g id="vaadin:del-a"><path d="M14 3h1v9h-1v-9z"></path><path d="M3 12h-2v-9h2c2.23 0.051 4.019 1.871 4.019 4.109 0 0.138-0.007 0.274-0.020 0.408 0.013 0.1 0.020 0.236 0.020 0.374 0 2.238-1.788 4.058-4.014 4.109zM2 11h1c0.31 0 3-0.12 3-3.5s-2.88-3.5-3-3.5h-1v7z"></path><path d="M13 9v-0.5c-0.017-0.77-0.31-1.468-0.783-2.003-0.419-0.412-0.999-0.668-1.638-0.668-0.031 0-0.063 0.001-0.094 0.002-0.013-0.001-0.034-0.001-0.054-0.001-0.594 0-1.132 0.241-1.521 0.631-0.566 0.685-0.91 1.572-0.91 2.54 0 0.003-0 0.006-0 0.009 0 0.881 0.322 1.686 0.854 2.306 0.43 0.429 1.030 0.697 1.692 0.697 0.030 0 0.059-0.001 0.089-0.002 0.861-0.026 1.642-0.372 2.228-0.922l-0.712-0.708c-0.401 0.368-0.931 0.603-1.515 0.63-0.026 0.001-0.051 0.002-0.076 0.002-0.385 0-0.734-0.153-0.99-0.402-0.355-0.435-0.57-0.997-0.57-1.61l4-0zM10.5 6.8c0.020-0.001 0.043-0.002 0.066-0.002 0.362 0 0.691 0.141 0.935 0.372 0.209 0.224 0.361 0.505 0.427 0.818l-2.778 0.011c0.11-0.661 0.661-1.165 1.337-1.2z"></path></g>
<g id="vaadin:del"><path d="M0 0v16h16v-16h-16zM3 12h-2v-9h2c2.23 0.051 4.019 1.871 4.019 4.109 0 0.138-0.007 0.274-0.020 0.408 0.013 0.1 0.020 0.236 0.020 0.374 0 2.238-1.788 4.058-4.014 4.109zM13 9h-4c-0 0.004-0 0.008-0 0.012 0 0.607 0.211 1.164 0.564 1.603 0.252 0.244 0.601 0.397 0.986 0.397 0.025 0 0.049-0.001 0.074-0.002 0.586-0.027 1.115-0.261 1.518-0.631l0.708 0.712c-0.584 0.548-1.364 0.893-2.225 0.92-0.030 0.001-0.060 0.002-0.090 0.002-0.662 0-1.261-0.268-1.696-0.702-0.522-0.613-0.84-1.414-0.84-2.289 0-0.007 0-0.014 0-0.022-0-0.005-0-0.012-0-0.019 0-0.968 0.344-1.855 0.915-2.547 0.384-0.383 0.922-0.624 1.516-0.624 0.021 0 0.041 0 0.062 0.001 0.024-0.001 0.055-0.002 0.086-0.002 0.639 0 1.219 0.256 1.641 0.672 0.47 0.532 0.762 1.23 0.78 1.996l0 0.524zM15 12h-1v-9h1v9z"></path><path d="M3 4h-1v7h1c0.31 0 3-0.12 3-3.5s-2.88-3.5-3-3.5z"></path><path d="M10.49 6.8c-0.679 0.035-1.23 0.539-1.339 1.192l2.779 0.008c-0.069-0.324-0.22-0.606-0.431-0.831-0.242-0.229-0.571-0.371-0.934-0.371-0.027 0-0.053 0.001-0.079 0.002z"></path></g>
<g id="vaadin:dental-chair"><path d="M11.5 8.2c-0.3-0.1-0.6-0.2-0.8-0.2h-2.7v-1h3c0-0.6-0.4-1-1-1h-4c0 0.6 0.4 1 1 1v1c-0.5 0-1-0.2-1.2-0.6l-1.1-1.8c-0.3-0.4-0.7-0.6-1.1-0.6h-0.6v-0.7c0-0.3-0.1-0.5-0.2-0.8l-0.3-0.7c-0.3-0.5-0.9-0.8-1.5-0.8h-1l5 7c0.4 0.6 1.1 1 1.8 1h1.2v1h-1v2h-0.6c-0.9 0-1.8 0.4-2.4 1v0h-1v1h11v-1h-1c-0.6-0.6-1.5-1-2.4-1h-0.6v-2h-1v-1h1.6c0.2 0 0.5 0.1 0.7 0.2l1.7 0.9c0.9 0.5 2 0.5 2.9 0h0.1l-4.5-2.9z"></path></g>
<g id="vaadin:desktop"><path d="M16 0h-16v13h6v2h-2v1h8v-1h-2v-2h6v-13zM9 12h-2v-1h2v1zM15 10h-14v-8.9c0-0.1 0-0.1 0-0.1h14c0 0 0 0 0 0.1v8.9z"></path></g>
<g id="vaadin:diamond-o"><path d="M13 2h-10l-3 3.5 8 9.5 8-9.5zM4.64 5h-2.89l1.52-1.78zM6.42 5l1.58-1.84 1.58 1.84h-3.16zM10 6l-2 6.68-2-6.68h4zM5.26 6l1.89 6.44-5.42-6.44h3.53zM10.75 6h3.53l-5.43 6.44zM11.37 5l1.37-1.78 1.51 1.78h-2.9zM12 3l-1.44 1.81-1.46-1.81h2.9zM5.43 4.83l-1.43-1.83h2.9z"></path></g>
<g id="vaadin:diamond"><path d="M0 6h4l3 8.6-7-8.6z"></path><path d="M16 6h-4l-3 8.6 7-8.6z"></path><path d="M8 15l-3-9h6l-3 9z"></path><path d="M4 5h-4l2-3 2 3z"></path><path d="M16 5h-4l2-3 2 3z"></path><path d="M10 5h-4l2-3 2 3z"></path><path d="M3.34 2h3.66l-2 3-1.66-3z"></path><path d="M9 2h4l-2 3-2-3z"></path></g>
<g id="vaadin:diploma-scroll"><path d="M12.61 8.41c-0.53-0.079-1.008-0.223-1.454-0.424 2.104-1.876 4.424-3.536 4.454-3.556l0.1-0.070 0.060-0.11c0.177-0.367 0.281-0.797 0.281-1.252 0-0.901-0.407-1.707-1.046-2.244-0.523-0.482-1.219-0.776-1.983-0.776-0.538 0-1.043 0.146-1.476 0.4l-0.126 0.133c-1.578 2.181-3.182 4.099-4.908 5.899-1.836 1.638-3.87 3.195-6.018 4.592l-0.394 0.248v0.23c-0.077 0.314-0.122 0.675-0.122 1.046 0 0.97 0.304 1.87 0.822 2.609 0.507 0.53 1.237 0.87 2.045 0.87 0.055 0 0.109-0.002 0.162-0.005 0.026 0.002 0.065 0.003 0.104 0.003 0.701 0 1.317-0.36 1.674-0.905 0.245-0.308 2.065-2.608 4.005-4.708 0.268 0.464 0.476 1.003 0.594 1.575 0.032 0.249 0.046 0.496 0.046 0.747 0 0.823-0.158 1.61-0.445 2.331l1.685-2.043 1.33 1c-0.041-1.174-0.243-2.286-0.584-3.336-0.227-0.416-0.542-0.845-0.915-1.214 0.406 0.346 0.871 0.643 1.372 0.874 0.94 0.338 1.989 0.572 3.076 0.672l-0.949-1.266 2-1.73c-0.83 0.273-1.785 0.431-2.777 0.431-0.216 0-0.43-0.007-0.642-0.022zM12.16 1.18c0.246-0.123 0.536-0.194 0.842-0.194 0.506 0 0.966 0.196 1.309 0.516 0.441 0.356 0.721 0.897 0.721 1.504 0 0.242-0.045 0.474-0.126 0.688-0.486 0.307-2.346 1.717-4.146 3.307-0.055-0.521-0.302-0.975-0.668-1.298-0.28-0.239-0.643-0.384-1.039-0.384-0.068 0-0.135 0.004-0.201 0.012 1.568-1.771 2.978-3.691 3.308-4.151zM2.7 11.81c0.073-0.051 0.164-0.082 0.262-0.082 0.014 0 0.027 0.001 0.040 0.002l0.068-0c0.179 0.052 0.334 0.142 0.461 0.261l-0.871 0.719c-0.081-0.165-0.128-0.358-0.128-0.563 0-0.052 0.003-0.103 0.009-0.153 0.027-0.077 0.084-0.144 0.158-0.183zM4 14.5c-0.175 0.306-0.499 0.508-0.871 0.508-0.046 0-0.090-0.003-0.134-0.009-0.046 0.006-0.106 0.008-0.167 0.008-0.515 0-0.981-0.209-1.318-0.548-0.365-0.54-0.583-1.206-0.583-1.922 0-0.251 0.027-0.495 0.077-0.73l0.706-0.457c-0.094 0.14-0.164 0.304-0.199 0.481-0.007 0.076-0.010 0.154-0.010 0.234 0 0.642 0.202 1.237 0.545 1.724l0.354 0.44 1.7-1.4c0.066 0.209 0.104 0.45 0.104 0.7 0 0.351-0.075 0.685-0.21 0.985zM4.86 12.050c-0.345-0.6-0.889-1.053-1.54-1.274-0.071-0.012-0.13-0.016-0.19-0.016s-0.119 0.004-0.177 0.010c-0.046-0.007-0.106-0.011-0.168-0.011s-0.122 0.004-0.182 0.011c1.489-1.018 2.766-2.003 3.988-3.052 0.398 0.071 0.812 0.25 1.131 0.533 0.297 0.313 0.48 0.739 0.48 1.209 0 0.032-0.001 0.063-0.002 0.094-1.14 1.226-2.25 2.536-3 3.506-0.054-0.379-0.177-0.719-0.357-1.023z"></path></g>
<g id="vaadin:diploma"><path d="M14 10.58c0.024-0.048 0.038-0.105 0.038-0.165s-0.014-0.117-0.039-0.167l-0.479-0.698c-0.009-0.013-0.014-0.028-0.014-0.045s0.005-0.032 0.014-0.045l0.48-0.7c0.024-0.048 0.038-0.105 0.038-0.165s-0.014-0.117-0.039-0.167c-0.040-0.11-0.127-0.196-0.236-0.237l-0.823-0.301c-0.031-0.011-0.054-0.037-0.060-0.069l-0-0.841c-0.007-0.125-0.072-0.233-0.169-0.299-0.066-0.045-0.145-0.071-0.231-0.071-0.004 0-0.007 0-0.011 0l-0.159-0-0.85 0.22c-0.010 0.004-0.022 0.007-0.035 0.007s-0.025-0.003-0.036-0.007l-0.549-0.65c-0.079-0.085-0.191-0.137-0.315-0.137s-0.236 0.053-0.315 0.137l-0.55 0.65c-0.010 0.004-0.022 0.007-0.035 0.007s-0.025-0.003-0.036-0.007l0.001 0-0.9-0.23h-0.1c-0.002-0-0.005-0-0.008-0-0.087 0-0.167 0.026-0.234 0.071-0.096 0.066-0.161 0.174-0.168 0.298l-0 0.841c-0.006 0.033-0.029 0.059-0.059 0.070l-0.821 0.3c-0.134 0.023-0.245 0.11-0.299 0.228-0.025 0.051-0.039 0.107-0.039 0.167s0.014 0.117 0.039 0.167l0.479 0.698c0.009 0.013 0.014 0.028 0.014 0.045s-0.005 0.032-0.014 0.045l-0.48 0.7c-0.024 0.048-0.038 0.105-0.038 0.165s0.014 0.117 0.039 0.167c0.040 0.11 0.127 0.196 0.236 0.237l0.823 0.301c0.031 0.011 0.054 0.037 0.060 0.069l0 0.841c0.007 0.125 0.072 0.233 0.169 0.299 0.067 0.045 0.147 0.071 0.234 0.071 0.003 0 0.005-0 0.008-0h0.16l0.31-0.070v3.69l1.53-2 1.47 2v-3.69l0.31 0.080h0.11c0.002 0 0.005 0 0.008 0 0.087 0 0.167-0.026 0.234-0.071 0.096-0.066 0.161-0.174 0.168-0.298l0-0.841c0.006-0.033 0.029-0.059 0.059-0.070l0.821-0.3c0.13-0.026 0.236-0.112 0.289-0.227z"></path><path d="M0 1v12h8l-0.11-0.050c-0.282-0.195-0.469-0.508-0.49-0.867l-0-0.083h-6.4v-10h14v10h-1.43v0.080c-0.021 0.361-0.208 0.675-0.486 0.868l-0.084 0.052h3v-12h-16z"></path><path d="M7.43 6.91c0.007-0.377 0.198-0.708 0.486-0.908 0.016-0.005 0.030-0.006 0.044-0.006s0.028 0.001 0.041 0.004l-5.001-0v1h4.43v-0.090z"></path><path d="M6.42 8h-3.42v1h3.36c-0.074-0.136-0.117-0.298-0.117-0.47 0-0.13 0.025-0.253 0.070-0.367 0.014-0.063 0.054-0.122 0.107-0.163z"></path><path d="M3 4h10v1h-10v-1z"></path></g>
<g id="vaadin:disc"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM15 8c0 1.1-0.2 2.1-0.7 3l-2.7-1.2c0.2-0.6 0.4-1.2 0.4-1.8 0-2.2-1.8-4-4-4-0.5 0-0.9 0.1-1.4 0.3l-1.2-2.8c0.6-0.2 1.2-0.4 1.8-0.5l0.3 3h0.5v-3c3.9 0 7 3.1 7 7zM8 5c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3 1.3-3 3-3zM1 8c0-1.1 0.2-2.1 0.7-3l2.7 1.2c-0.2 0.6-0.4 1.2-0.4 1.8 0 2.2 1.8 4 4 4 0.5 0 0.9-0.1 1.4-0.3l1.2 2.8c-0.6 0.2-1.2 0.4-1.8 0.5l-0.3-3h-0.5v3c-3.9 0-7-3.1-7-7z"></path><path d="M10 8c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:doctor-briefcase"><path d="M16 12l-1.4-6.7c-0.2-0.7-0.9-1.3-1.7-1.3h-1.9v-1.2c0-1-0.8-1.8-1.8-1.8h-2.4c-1 0-1.8 0.8-1.8 1.8v1.2h-1.9c-0.8 0-1.5 0.6-1.7 1.3l-1.4 6.7c-0.2 1 0.6 2 1.7 2h12.5c1.2 0 2-1 1.8-2zM6 2.8c0-0.4 0.4-0.8 0.8-0.8h2.4c0.4 0 0.8 0.4 0.8 0.8v1.2h-4v-1.2zM11 10h-2v2h-2v-2h-2v-2h2v-2h2v2h2v2z"></path></g>
<g id="vaadin:doctor"><path d="M14 11.3c-1-1.9-2-1.6-3.1-1.7 0.1 0.3 0.1 0.6 0.1 1 1.6 0.4 2 2.3 2 3.4v1h-2v-1h1c0 0 0-2.5-1.5-2.5s-1.5 2.4-1.5 2.5h1v1h-2v-1c0-1.1 0.4-3.1 2-3.4 0-0.6-0.1-1.1-0.2-1.3-0.2-0.1-0.4-0.3-0.4-0.6 0-0.6 0.8-0.4 1.4-1.5 0 0 0.9-2.3 0.6-4.3h-1c0-0.2 0.1-0.3 0.1-0.5s0-0.3-0.1-0.5h0.8c-0.3-1-1.3-1.9-3.2-1.9 0 0 0 0 0 0s0 0 0 0 0 0 0 0c-1.9 0-2.9 0.9-3.3 2h0.8c0 0.2-0.1 0.3-0.1 0.5s0 0.3 0.1 0.5h-1c-0.2 2 0.6 4.3 0.6 4.3 0.6 1 1.4 0.8 1.4 1.5 0 0.5-0.5 0.7-1.1 0.8-0.2 0.2-0.4 0.6-0.4 1.4 0 0.4 0 0.8 0 1.2 0.6 0.2 1 0.8 1 1.4 0 0.7-0.7 1.4-1.5 1.4s-1.5-0.7-1.5-1.5c0-0.7 0.4-1.2 1-1.4 0-0.3 0-0.7 0-1.2s0.1-0.9 0.2-1.3c-0.7 0.1-1.5 0.4-2.2 1.7-0.6 1.1-0.9 4.7-0.9 4.7h13.7c0.1 0-0.2-3.6-0.8-4.7zM6.5 2.5c0-0.8 0.7-1.5 1.5-1.5s1.5 0.7 1.5 1.5-0.7 1.5-1.5 1.5-1.5-0.7-1.5-1.5z"></path><path d="M5 13.5c0 0.276-0.224 0.5-0.5 0.5s-0.5-0.224-0.5-0.5c0-0.276 0.224-0.5 0.5-0.5s0.5 0.224 0.5 0.5z"></path></g>
<g id="vaadin:dollar"><path d="M8.2 6.8c-0.1 0-0.1-0.1-0.2-0.1v-3.1c1.2 0.1 2.2 0.6 2.2 0.6l0.9-1.8c-0.1 0-1.5-0.8-3.1-0.8v-1.6h-1v1.6c-0.8 0.2-1.4 0.5-2 0.9-0.6 0.6-1 1.4-1 2.3 0 0.7 0.2 2.3 3 3.6v3.9c-0.9-0.2-2-0.7-2.4-0.9l-1 1.7c0.2 0.1 1.8 1 3.4 1.2v1.7h1v-1.7c0 0 0 0 0 0 2.3-0.3 3.6-2.1 3.6-3.8 0-1.5-1-2.7-3.4-3.7zM7 6.2c-0.8-0.5-1-1-1-1.3 0-0.4 0.1-0.7 0.4-0.9 0.2-0.1 0.4-0.2 0.6-0.3v2.5zM8 12.3v-3.4c1.1 0.5 1.6 1.1 1.6 1.6 0 0.6-0.3 1.6-1.6 1.8z"></path></g>
<g id="vaadin:dot-circle"><path d="M8 4c-2.2 0-4 1.8-4 4s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4z"></path><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path></g>
<g id="vaadin:download-alt"><path d="M0 14h16v2h-16v-2z"></path><path d="M8 13l5-5h-3v-8h-4v8h-3z"></path></g>
<g id="vaadin:download"><path d="M16 10h-5.5l-2.5 2.5-2.5-2.5h-5.5v6h16v-6zM4 14h-2v-2h2v2z"></path><path d="M10 6v-6h-4v6h-3l5 5 5-5z"></path></g>
<g id="vaadin:drop"><path d="M8 0c0 0-5 8.2-5 11s2.2 5 5 5 5-2.2 5-5-5-11-5-11zM8.9 14.9l-0.2-1c1.4-0.3 2.4-1.7 2.4-3.2 0-0.3-0.1-1.1-0.8-2.6l0.9-0.4c0.6 1.4 0.8 2.4 0.8 3 0 2-1.3 3.8-3.1 4.2z"></path></g>
<g id="vaadin:edit"><path d="M16 4c0 0 0-1-1-2s-1.9-1-1.9-1l-1.1 1.1v-2.1h-12v16h12v-8l4-4zM6.3 11.4l-0.6-0.6 0.3-1.1 1.5 1.5-1.2 0.2zM7.2 9.5l-0.6-0.6 5.2-5.2c0.2 0.1 0.4 0.3 0.6 0.5zM14.1 2.5l-0.9 1c-0.2-0.2-0.4-0.3-0.6-0.5l0.9-0.9c0.1 0.1 0.3 0.2 0.6 0.4zM11 15h-10v-14h10v2.1l-5.9 5.9-1.1 4.1 4.1-1.1 2.9-3v6z"></path></g>
<g id="vaadin:eject"><path d="M1 11h14l-7-10z"></path><path d="M1 12h14v3h-14v-3z"></path></g>
<g id="vaadin:elastic"><path d="M4.7 16v0c-1.7 0-3.1-0.8-4-2.1-1.1-1.7-0.9-4 0.4-5.8 0.9-1.3 2.1-2.1 3.6-2.4 1.2-0.3 2.2-1.1 2.5-2.2 0.2-0.8 0.7-1.5 1.3-2 0.9-1 2.2-1.5 3.5-1.5 1.1 0 2.2 0.4 2.9 1.2 1.5 1.6 1.5 4.2-0.1 6-0.5 0.6-1.2 1.1-2 1.4-1.2 0.5-2.2 1.6-2.6 3-0.3 1-0.8 1.9-1.5 2.6-1.1 1.2-2.6 1.8-4 1.8zM12 1c-1 0-2 0.4-2.8 1.2-0.5 0.5-0.8 1-1 1.6-0.5 1.5-1.8 2.5-3.3 2.9-1.2 0.2-2.2 0.9-3 2-1.1 1.5-1.2 3.3-0.3 4.7 0.6 1 1.8 1.6 3.1 1.6v0c1.2 0 2.4-0.5 3.3-1.4 0.6-0.6 1.1-1.4 1.3-2.2 0.4-1.7 1.6-3 3.2-3.6 0.6-0.2 1.2-0.7 1.6-1.2 1.2-1.4 1.3-3.5 0.1-4.7-0.6-0.6-1.4-0.9-2.2-0.9z"></path></g>
<g id="vaadin:ellipsis-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M4 7h2v2h-2v-2z"></path><path d="M7 7h2v2h-2v-2z"></path><path d="M10 7h2v2h-2v-2z"></path></g>
<g id="vaadin:ellipsis-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM6 9h-2v-2h2v2zM9 9h-2v-2h2v2zM12 9h-2v-2h2v2z"></path></g>
<g id="vaadin:ellipsis-dots-h"><path d="M4 8c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M10 8c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M16 8c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:ellipsis-dots-v"><path d="M10 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M10 8c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M10 14c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:ellipsis-h"><path d="M0 6h4v4h-4v-4z"></path><path d="M6 6h4v4h-4v-4z"></path><path d="M12 6h4v4h-4v-4z"></path></g>
<g id="vaadin:ellipsis-v"><path d="M6 0h4v4h-4v-4z"></path><path d="M6 6h4v4h-4v-4z"></path><path d="M6 12h4v4h-4v-4z"></path></g>
<g id="vaadin:enter-arrow"><path d="M0 9l7 4v-3h9v-7l-3 2v2h-6v-3l-7 5z"></path></g>
<g id="vaadin:enter"><path d="M4 0v6h-3v10h14v-16h-11zM12 11h-5v2l-3-2.5 3-2.5v2h4v-3h1v4z"></path></g>
<g id="vaadin:envelope-o"><path d="M0 3v11h16v-11h-16zM1 7.1l3.9 2-3.9 3.4v-5.4zM1.9 13l4-3.5 2.1 1.1 2.1-1.1 4 3.5h-12.2zM15 12.5l-3.9-3.5 3.9-2v5.5zM15 5.9l-7 3.5-7-3.5v-1.9h14v1.9z"></path></g>
<g id="vaadin:envelope-open-o"><path d="M14 3.7v-0.7h-1.5l-4.5-3-4.6 3h-1.4v0.7l-2 1.3v11h16v-10.9l-2-1.4zM8 1.2l2.7 1.8h-5.5l2.8-1.8zM3 4h10v3.7l-3.5 1.7-1.5-1.3-1.5 1.4-3.5-1.7v-3.8zM1 5.5l1-0.7v2.4l-1-0.4v-1.3zM1 7.9l4.6 2.3-4.6 4v-6.3zM1.9 15l6.1-5.3 6.1 5.3h-12.2zM15 14.2l-4.7-4.1 4.7-2.3v6.4zM15 6.7l-1 0.5v-2.3l1 0.7v1.1z"></path></g>
<g id="vaadin:envelope-open"><path d="M14 3.7v3.7l2-1v-1.4z"></path><path d="M2 3.8l-2 1.2v1.5l2 1z"></path><path d="M11.2 2l-3.2-2-3.2 2z"></path><path d="M13 3h-10v4.9l3.4 1.7 1.6-1.2 1.6 1.2 3.4-1.7z"></path><path d="M16 7.6l-5.5 2.7 5.5 4.4z"></path><path d="M8 9.6l-8 6.4h16z"></path><path d="M5.5 10.3l-5.5-2.7v7.1z"></path></g>
<g id="vaadin:envelope"><path d="M0 3h16v2.4l-8 4-8-4z"></path><path d="M0 14l5.5-4.8 2.5 1.4 2.5-1.4 5.5 4.8z"></path><path d="M4.6 8.8l-4.6-2.3v6.5z"></path><path d="M11.4 8.8l4.6-2.3v6.5z"></path></g>
<g id="vaadin:envelopes-o"><path d="M14 2h-14v10h14v-10zM5.71 8l1.29 0.55 1.29-0.55 4.71 3h-12zM1 9.83v-4l3.64 1.63zM9.36 7.46l3.64-1.68v4zM13 3v1.68l-6 2.77-6-2.77v-1.68h12z"></path><path d="M15 4v9h-13v1h14v-10h-1z"></path></g>
<g id="vaadin:envelopes"><path d="M16 14h-14v-1h13v-9h1v10z"></path><path d="M14 10.77v-5.48l-4.68 2.18 4.68 3.3z"></path><path d="M8.28 7.96l-1.28 0.59-1.28-0.59-5.72 4.030v0.010l14-0.010-5.72-4.030z"></path><path d="M7 7.45l7-3.27v-2.18h-14v2.18l7 3.27z"></path><path d="M4.68 7.47l-4.68-2.18v5.48l4.68-3.3z"></path></g>
<g id="vaadin:eraser"><path d="M8.1 14l6.4-7.2c0.6-0.7 0.6-1.8-0.1-2.5l-2.7-2.7c-0.3-0.4-0.8-0.6-1.3-0.6h-1.8c-0.5 0-1 0.2-1.4 0.6l-6.7 7.6c-0.6 0.7-0.6 1.9 0.1 2.5l2.7 2.7c0.3 0.4 0.8 0.6 1.3 0.6h11.4v-1h-7.9zM6.8 13.9c0 0 0-0.1 0 0l-2.7-2.7c-0.4-0.4-0.4-0.9 0-1.3l3.4-3.9h-1l-3 3.3c-0.6 0.7-0.6 1.7 0.1 2.4l2.3 2.3h-1.3c-0.2 0-0.4-0.1-0.6-0.2l-2.8-2.8c-0.3-0.3-0.3-0.8 0-1.1l3.5-3.9h1.8l3.5-4h1l-3.5 4 3.1 3.7-3.5 4c-0.1 0.1-0.2 0.1-0.3 0.2z"></path></g>
<g id="vaadin:esc-a"><path d="M8 12c-0.726-0.029-1.409-0.177-2.043-0.425l0.403-0.915c0.435 0.202 0.945 0.319 1.482 0.319 0.326 0 0.643-0.043 0.943-0.125 0.121-0.109 0.215-0.285 0.215-0.484 0-0 0-0 0-0 0.070-0.43-0.22-0.62-1.17-1-0.83-0.29-2.040-0.76-1.83-2.080 0.072-0.594 0.46-1.082 0.989-1.296 0.223-0.053 0.466-0.081 0.715-0.081 0.724 0 1.393 0.235 1.934 0.633l-0.569 0.754c-0.366-0.248-0.817-0.396-1.302-0.396-0.123 0-0.243 0.009-0.361 0.028-0.215 0.084-0.377 0.296-0.387 0.547-0.080 0.401 0.14 0.581 1.15 1.001 0.85 0.33 2 0.77 1.8 2.080-0.067 0.511-0.364 0.94-0.782 1.186-0.323 0.163-0.696 0.256-1.090 0.256-0.034 0-0.069-0.001-0.103-0.002z"></path><path d="M13.71 12c-0.027 0.001-0.058 0.001-0.089 0.001-0.583 0-1.124-0.18-1.57-0.488-0.646-0.548-1.059-1.37-1.059-2.289 0-0.079 0.003-0.157 0.009-0.235-0.011-0.079-0.016-0.183-0.016-0.288 0-0.899 0.413-1.701 1.060-2.228 0.5-0.282 1.091-0.446 1.72-0.446 0.443 0 0.868 0.081 1.259 0.23l-0.374 0.922c-0.276-0.111-0.595-0.176-0.93-0.176-0.388 0-0.756 0.087-1.086 0.242-0.395 0.361-0.652 0.893-0.652 1.485 0 0.095 0.007 0.188 0.019 0.279-0.010 0.063-0.016 0.148-0.016 0.234 0 0.599 0.255 1.138 0.663 1.514 0.346 0.177 0.754 0.28 1.185 0.28 0.292 0 0.573-0.047 0.835-0.134l0.331 0.905c-0.383 0.121-0.823 0.19-1.279 0.19-0.004 0-0.008 0-0.012-0z"></path><path d="M5 4v-1h-4v9h4v-1h-3v-3h3v-1h-3v-3h3z"></path></g>
<g id="vaadin:esc"><path d="M0 0v16h16v-16h-16zM5 4h-3v3h3v1h-3v3h3v1h-4v-9h4v1zM10 10.54c-0.067 0.511-0.364 0.94-0.782 1.186-0.333 0.175-0.719 0.276-1.129 0.276-0.031 0-0.062-0.001-0.093-0.002-0.722-0.029-1.405-0.177-2.038-0.425l0.403-0.915c0.435 0.202 0.945 0.319 1.482 0.319 0.326 0 0.643-0.043 0.943-0.125 0.121-0.109 0.215-0.285 0.215-0.484 0-0 0-0 0-0 0.070-0.43-0.22-0.62-1.17-1-0.83-0.29-2.040-0.76-1.83-2.080 0.072-0.594 0.46-1.082 0.989-1.296 0.223-0.053 0.466-0.081 0.715-0.081 0.724 0 1.393 0.235 1.934 0.633l-0.569 0.754c-0.366-0.248-0.817-0.396-1.302-0.396-0.123 0-0.243 0.009-0.361 0.028-0.215 0.084-0.377 0.296-0.387 0.547-0.080 0.401 0.14 0.581 1.15 1.001 0.83 0.3 2.020 0.75 1.83 2.060zM12.67 10.72c0.345 0.176 0.752 0.279 1.183 0.279 0.292 0 0.573-0.047 0.835-0.134l0.311 0.945c-0.383 0.121-0.823 0.19-1.279 0.19-0 0-0.001 0-0.001 0-0.027 0.001-0.058 0.001-0.089 0.001-0.583 0-1.124-0.18-1.57-0.488-0.651-0.548-1.069-1.374-1.069-2.297 0-0.076 0.003-0.152 0.008-0.227-0.010-0.079-0.016-0.183-0.016-0.288 0-0.899 0.413-1.701 1.060-2.228 0.5-0.282 1.091-0.446 1.72-0.446 0.443 0 0.868 0.081 1.259 0.23l-0.374 0.922c-0.276-0.111-0.595-0.176-0.93-0.176-0.388 0-0.756 0.087-1.086 0.242-0.395 0.361-0.652 0.893-0.652 1.485 0 0.095 0.007 0.188 0.019 0.279-0.008 0.055-0.013 0.13-0.013 0.206 0 0.592 0.25 1.126 0.65 1.502z"></path></g>
<g id="vaadin:euro"><path d="M10.89 3c1.166 0.009 2.244 0.383 3.127 1.011l-0.017-2.321c-0.918-0.433-1.994-0.686-3.129-0.686-3.606 0-6.616 2.551-7.323 5.947l-1.548 0.049v1h1.41c0 0.17 0 0.33 0 0.5-0.005 0.075-0.008 0.162-0.008 0.25s0.003 0.175 0.008 0.262l-1.411-0.012v1h1.54c0.882 3.353 3.805 5.818 7.331 5.999 1.149-0.002 2.218-0.256 3.175-0.708l-0.045-2.291c-0.866 0.617-1.944 0.991-3.108 1-2.461-0.128-4.512-1.744-5.28-3.959l6.388-0.041v-1h-6.59c-0.006-0.075-0.009-0.162-0.009-0.25s0.003-0.175 0.010-0.261c-0.001-0.159-0.001-0.319-0.001-0.489h6.59v-1h-6.4c0.678-2.325 2.788-3.996 5.29-4z"></path></g>
<g id="vaadin:exchange"><path d="M16 5v2h-13v2l-3-3 3-3v2z"></path><path d="M0 12v-2h13v-2l3 3-3 3v-2z"></path></g>
<g id="vaadin:exclamation-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M7 3h2v7h-2v-7z"></path><path d="M7 11h2v2h-2v-2z"></path></g>
<g id="vaadin:exclamation-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM9 13h-2v-2h2v2zM9 10h-2v-7h2v7z"></path></g>
<g id="vaadin:exclamation"><path d="M6 0h4v4l-1 7h-2l-1-7z"></path><path d="M10 14c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:exit-o"><path d="M10 0c1.1 0 2 0.9 2 2 0 0.9-0.6 1.7-1.5 1.9 0 0 0 0.1 0 0.1 0.4 0 0.7 0.2 1 0.5l1.3 1.3c0.1 0.1 0.3 0.2 0.5 0.2h1.7v-6h-5z"></path><path d="M11.8 14.5l-3.8-4.5v2.5c0 0.8-0.7 1.5-1.5 1.5h-3.5c-0.6 0-1-0.4-1-1s0.4-1 1-1h2.5c0.3 0 0.5-0.2 0.5-0.5v-2c0-0.7 0.1-1.3 0.4-2l0.7-1.5h-0.8c-0.5 0-0.9 0.2-1.2 0.6l-0.5 0.7c-0.2 0.4-0.7 0.5-1.2 0.3-0.4-0.3-0.6-0.9-0.2-1.3l0.6-0.8c0.7-1 1.9-1.5 3.1-1.5h2l0.1-0.3c-0.6-0.3-1-1-1-1.7 0-1.1 0.9-2 2-2h-7v4.9l-0.6 0.8c-0.3 0.4-0.5 0.9-0.4 1.5 0.1 0.5 0.4 1 0.9 1.3 0 0 0 0 0 0v2.5c-1.1 0-2 0.9-2 2s0.9 2 2 2v1h11.6c-1.1 0-2.1-0.6-2.7-1.5z"></path><path d="M11.4 7.3l-0.7-0.8-0.6 1.5c-0.2 0.5-0.3 0.9 0 1.3l4.9 6.1v-7.4h-2.1c-0.6 0-1.1-0.2-1.5-0.7z"></path></g>
<g id="vaadin:exit"><path d="M14 6h-1.7c-0.2 0-0.4-0.1-0.6-0.2l-1.3-1.3c-0.2-0.3-0.6-0.5-1.1-0.5h-0.3c1.1 0 2-0.9 2-2s-0.9-2-2-2-2 0.9-2 2c0 0.7 0.4 1.4 1 1.7l-0.2 0.3h-2c-1.1 0-2.3 0.5-3 1.5l-0.6 0.8c-0.4 0.4-0.2 1 0.2 1.3 0.4 0.2 0.9 0.1 1.2-0.3l0.5-0.7c0.3-0.4 0.7-0.6 1.2-0.6h0.8l-0.7 1.6c-0.3 0.6-0.4 1.2-0.4 1.9v2c0 0.3-0.2 0.5-0.5 0.5h-2.5c-0.6 0-1 0.4-1 1s0.4 1 1 1h3.5c0.8 0 1.5-0.7 1.5-1.5v-2.5l3.8 4.5c0.6 0.9 1.7 1.5 2.8 1.5h0.9l-5.4-6.7c-0.3-0.4-0.2-0.8 0-1.3l0.6-1.5 0.7 0.8c0.4 0.4 1 0.7 1.6 0.7h2c0.6 0 1-0.4 1-1s-0.4-1-1-1z"></path></g>
<g id="vaadin:expand-full"><path d="M5.3 6.7l1.4-1.4-3-3 1.3-1.3h-4v4l1.3-1.3z"></path><path d="M6.7 10.7l-1.4-1.4-3 3-1.3-1.3v4h4l-1.3-1.3z"></path><path d="M10.7 9.3l-1.4 1.4 3 3-1.3 1.3h4v-4l-1.3 1.3z"></path><path d="M11 1l1.3 1.3-3 3 1.4 1.4 3-3 1.3 1.3v-4z"></path></g>
<g id="vaadin:expand-square"><path d="M11 2h-9v9l1-1v-7h7z"></path><path d="M5 14h9v-9l-1 1v7h-7z"></path><path d="M16 0h-5l1.8 1.8-4.5 4.5 1.4 1.4 4.5-4.5 1.8 1.8z"></path><path d="M7.7 9.7l-1.4-1.4-4.5 4.5-1.8-1.8v5h5l-1.8-1.8z"></path></g>
<g id="vaadin:expand"><path d="M15 1h-4l1.3 1.3-4.5 4.5 1.4 1.4 4.5-4.5 1.3 1.3z"></path><path d="M6.8 7.8l-4.5 4.5-1.3-1.3v4h4l-1.3-1.3 4.5-4.5z"></path></g>
<g id="vaadin:external-browser"><path d="M11 10l-2.9-3.2-3.3 3.2h2.2v1.8c0 1.7-0.9 4.2-4 4.2 4.8 0 6-1.4 6-4.3v-1.7h2z"></path><path d="M0 0v13h6v-1h-5v-9h14v9h-5v1h6v-13h-16zM2 2h-1v-1h1v1zM13 2h-10v-1h10v1z"></path></g>
<g id="vaadin:external-link"><path d="M14 16v-11l-1 1v9h-12v-12h9l1-1h-11v14z"></path><path d="M16 0h-5l1.8 1.8-6.8 6.8 1.4 1.4 6.8-6.8 1.8 1.8z"></path></g>
<g id="vaadin:eye-slash"><path d="M12.9 5.2l-0.8 0.8c1.7 0.9 2.5 2.3 2.8 3-0.7 0.9-2.8 3.1-7 3.1-0.7 0-1.2-0.1-1.8-0.2l-0.8 0.8c0.8 0.3 1.7 0.4 2.6 0.4 5.7 0 8.1-4 8.1-4s-0.6-2.4-3.1-3.9z"></path><path d="M12 7.1c0-0.3 0-0.6-0.1-0.8l-4.8 4.7c0.3 0 0.6 0.1 0.9 0.1 2.2 0 4-1.8 4-4z"></path><path d="M15.3 0l-4.4 4.4c-0.8-0.2-1.8-0.4-2.9-0.4-6.7 0-8 5.1-8 5.1s1 1.8 3.3 3l-3.3 3.2v0.7h0.7l15.3-15.3v-0.7h-0.7zM4 11.3c-1.6-0.7-2.5-1.8-2.9-2.3 0.3-0.7 1.1-2.2 3.1-3.2-0.1 0.4-0.2 0.8-0.2 1.3 0 1.1 0.5 2.2 1.3 2.9l-1.3 1.3zM6.2 7.9l-1 0.2c0 0-0.3-0.5-0.3-1.2 0-0.8 0.4-1.5 0.4-1.5 0.5-0.3 1.3-0.3 1.3-0.3s-0.5 0.9-0.5 1.7c-0.1 0.7 0.1 1.1 0.1 1.1z"></path></g>
<g id="vaadin:eye"><path d="M8 3.9c-6.7 0-8 5.1-8 5.1s2.2 4.1 7.9 4.1 8.1-4 8.1-4-1.3-5.2-8-5.2zM5.3 5.4c0.5-0.3 1.3-0.3 1.3-0.3s-0.5 0.9-0.5 1.6c0 0.7 0.2 1.1 0.2 1.1l-1.1 0.2c0 0-0.3-0.5-0.3-1.2 0-0.8 0.4-1.4 0.4-1.4zM7.9 12.1c-4.1 0-6.2-2.3-6.8-3.2 0.3-0.7 1.1-2.2 3.1-3.2-0.1 0.4-0.2 0.8-0.2 1.3 0 2.2 1.8 4 4 4s4-1.8 4-4c0-0.5-0.1-0.9-0.2-1.3 2 0.9 2.8 2.5 3.1 3.2-0.7 0.9-2.8 3.2-7 3.2z"></path></g>
<g id="vaadin:eyedropper"><path d="M15 1c-1.8-1.8-3.7-0.7-4.6 0.1-0.4 0.4-0.7 0.9-0.7 1.5v0c0 1.1-1.1 1.8-2.1 1.5l-0.1-0.1-0.7 0.8 0.7 0.7-6 6-0.8 2.3-0.7 0.7 1.5 1.5 0.8-0.8 2.3-0.8 6-6 0.7 0.7 0.7-0.6-0.1-0.2c-0.3-1 0.4-2.1 1.5-2.1v0c0.6 0 1.1-0.2 1.4-0.6 0.9-0.9 2-2.8 0.2-4.6zM3.9 13.6l-2 0.7-0.2 0.1 0.1-0.2 0.7-2 5.8-5.8 1.5 1.5-5.9 5.7z"></path></g>
<g id="vaadin:facebook-square"><path d="M0 0v16h16v-16h-16zM12.9 8.4h-2.1v5.6h-2.1v-5.6h-1.5v-2h1.5c0 0 0-0.8 0-1.7 0-1.5 0.9-2.7 2.9-2.7 0.8 0 1.4 0.1 1.4 0.1v1.9c0 0-0.6 0-1.3 0s-0.8 0.3-0.8 0.9c0 0.1 0 0.1 0 0.1 0 0.2 0 0.5 0 1.4h2.1l-0.1 2z"></path></g>
<g id="vaadin:facebook"><path d="M7.2 16v-7.5h-2v-2.7h2c0 0 0-1.1 0-2.3 0-1.8 1.2-3.5 3.9-3.5 1.1 0 1.9 0.1 1.9 0.1l-0.1 2.5c0 0-0.8 0-1.7 0-1 0-1.1 0.4-1.1 1.2 0 0.6 0-1.3 0 2h2.9l-0.1 2.7h-2.8v7.5h-2.9z"></path></g>
<g id="vaadin:factory"><path d="M4.4 1.3c-0.6 0.3-0.8 1.1-0.4 1.5 0.5-0.9 1.3-0.6 2.5 0.4 0.8 0.7 1.9 0.1 1.9 0.1s0.2 1.2 1.7 1.4c1.7 0.2 2.3-0.8 2.3-0.8s0.4 1 1.9 0.4c1.1-0.4 0.7-1.1 0.7-1.1s1 0 1-0.7c0-0.9-1.1-0.8-1.1-0.8s0.2-1-0.9-1.1c-1-0.1-1.3 0.5-1.3 0.5s-0.3-1.1-1.8-1.1c-1.4 0-1.9 1.3-1.9 1.3s-0.4-0.6-1.6-0.6c-0.9 0-1.3 0.7-1.3 0.7s-1.1-0.5-1.7-0.1z"></path><path d="M12 12.1v-2.1l-4 2.1v-2.1h-2.4l-0.6-7h-2l-0.6 7h-2.4v6h16v-6l-4 2.1zM6 14h-4v-2h4v2z"></path></g>
<g id="vaadin:family"><path d="M9.5 7.5c0 0.828-0.672 1.5-1.5 1.5s-1.5-0.672-1.5-1.5c0-0.828 0.672-1.5 1.5-1.5s1.5 0.672 1.5 1.5z"></path><path d="M14.27 4h-2.54c0 0 0 0 0 0-0.955 0-1.73 0.775-1.73 1.73v3.27c0 0.552 0.448 1 1 1v6h4v-6c0.552 0 1-0.448 1-1v-3.27c0-0.955-0.775-1.73-1.73-1.73 0 0 0 0 0 0z"></path><path d="M15 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M4.27 5h-2.54c-0.955 0-1.73 0.775-1.73 1.73s0.775 1.73 1.73 1.73c0.955 0 1.73-0.775 1.73-1.73s-0.775-1.73-1.73-1.73c-0.955 0-1.73 0.775-1.73 1.73v2.27c0 0.552 0.448 1 1 1l-1 3h1v3h4v-3h1l-1-3c0.552 0 1-0.448 1-1v-2.27c0-0.955-0.775-1.73-1.73-1.73 0 0 0 0 0 0z"></path><path d="M5 3c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M7 13v3h2v-3c0.552 0 1-0.448 1-1v-1.54c0-0.806-0.654-1.46-1.46-1.46 0 0 0 0 0 0h-1.080c-0.806 0-1.46 0.654-1.46 1.46 0 0 0 0 0 0v1.54c0 0.552 0.448 1 1 1z"></path></g>
<g id="vaadin:fast-backward"><path d="M16 15v-14l-7 7z"></path><path d="M9 15v-14l-7 7z"></path><path d="M0 1h2v14h-2v-14z"></path></g>
<g id="vaadin:fast-forward"><path d="M0 1v14l7-7z"></path><path d="M7 1v14l7-7z"></path><path d="M14 1h2v14h-2v-14z"></path></g>
<g id="vaadin:female"><path d="M10 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M10 8v-1.5l1.8 1.8c0.3 0.3 0.7 0.3 1 0s0.3-0.8 0-1l-2.6-2.6c-0.4-0.5-1-0.7-1.7-0.7h-1c-0.7 0-1.3 0.2-1.7 0.7l-2.6 2.6c-0.3 0.3-0.3 0.8 0 1 0.3 0.3 0.7 0.3 1 0l1.8-1.8v1.5l-4 5h4v3h4v-3h4l-4-5z"></path></g>
<g id="vaadin:file-add"><path d="M12 15h-10v-14h6v4h4v1h1v-2l-4-4h-8v16h12v-2h-1v1zM9 1l3 3h-3v-3z"></path><path d="M13 7h-2v2h-2v2h2v2h2v-2h2v-2h-2v-2z"></path></g>
<g id="vaadin:file-code"><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path><path d="M6.2 13h-0.7l-2-2.5 2-2.5h0.7l-2 2.5z"></path><path d="M9.8 13h0.7l2-2.5-2-2.5h-0.7l2 2.5z"></path><path d="M6.7 14h0.6l2.1-7h-0.8z"></path></g>
<g id="vaadin:file-font"><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path><path d="M5 7v2h2v5h2v-5h2v-2z"></path></g>
<g id="vaadin:file-movie"><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path><path d="M10 10v-2h-6v5h6v-2l2 2v-5z"></path></g>
<g id="vaadin:file-o"><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path></g>
<g id="vaadin:file-picture"><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path><path d="M4 11.5v2.5h8v-1.7c0 0 0.1-1.3-1.3-1.5-1.3-0.2-1.5 0.4-2.5 0.5-0.8 0-0.6-1.3-2.2-1.3-1.2 0-2 1.5-2 1.5z"></path><path d="M12 8.5c0 0.828-0.672 1.5-1.5 1.5s-1.5-0.672-1.5-1.5c0-0.828 0.672-1.5 1.5-1.5s1.5 0.672 1.5 1.5z"></path></g>
<g id="vaadin:file-presentation"><path d="M10 0h-8v16h12v-12l-4-4zM13 15h-10v-14h6v4h4v10zM10 4v-3l3 3h-3z"></path><path d="M9 6h-2v1h-3v6h2v1h1v-1h2v1h1v-1h2v-6h-3v-1zM11 8v4h-6v-4h6z"></path><path d="M7 9v2l2-1z"></path></g>
<g id="vaadin:file-process"><path d="M12 0h-7v6h0.7l0.2 0.7 0.1 0.1v-5.8h5v4h4v9h-6l0.3 0.5-0.5 0.5h7.2v-11l-4-4zM12 4v-3l3 3h-3z"></path><path d="M5.5 11.5c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M7.9 12.4l1.1-0.4v-1l-1.1-0.4c-0.1-0.3-0.2-0.6-0.4-0.9l0.5-1-0.7-0.7-1 0.5c-0.3-0.2-0.6-0.3-0.9-0.4l-0.4-1.1h-1l-0.4 1.1c-0.3 0.1-0.6 0.2-0.9 0.4l-1-0.5-0.7 0.7 0.5 1.1c-0.2 0.3-0.3 0.6-0.4 0.9l-1.1 0.3v1l1.1 0.4c0.1 0.3 0.2 0.6 0.4 0.9l-0.5 1 0.7 0.7 1.1-0.5c0.3 0.2 0.6 0.3 0.9 0.4l0.3 1.1h1l0.4-1.1c0.3-0.1 0.6-0.2 0.9-0.4l1 0.5 0.7-0.7-0.5-1.1c0.2-0.2 0.3-0.5 0.4-0.8zM4.5 13.5c-1.1 0-2-0.9-2-2s0.9-2 2-2 2 0.9 2 2c0 1.1-0.9 2-2 2z"></path></g>
<g id="vaadin:file-refresh"><path d="M10 0h-8v16h12v-12l-4-4zM13 15h-10v-14h6v4h4v10zM10 4v-3l3 3h-3z"></path><path d="M4.7 7.7l-0.7-0.7v3h3l-1.2-1.2c0.4-0.8 1.3-1.3 2.2-1.3 1.4 0 2.5 1.1 2.5 2.5h1.5c0-2.2-1.8-4-4-4-1.3 0-2.5 0.7-3.3 1.7z"></path><path d="M9.8 11.8c-0.5 0.5-1.1 0.8-1.8 0.7-1 0-1.9-0.6-2.3-1.5h-1.6c0.4 1.7 2 3 3.8 3 1.1 0 2.1-0.5 2.8-1.2l1.3 1.2v-3h-3l0.8 0.8z"></path></g>
<g id="vaadin:file-remove"><path d="M12 15h-10v-14h6v4h4v2.59l1-1v-2.59l-4-4h-8v16h12v-2.59l-1-1v2.59zM9 1l3 3h-3v-3z"></path><path d="M15 8l-1-1-2 2-2-2-1 1 2 2-2 2 1 1 2-2 2 2 1-1-2-2 2-2z"></path></g>
<g id="vaadin:file-search"><path d="M12 13.47v1.53h-10v-14h6v4h4v0.56c0.386 0.229 0.716 0.504 0.996 0.825l0.004-2.385-4-4h-8v16h12v-1.53zM9 1l3 3h-3v-3z"></path><path d="M14.78 12.72l-1.92-1.92c-0.089-0.085-0.201-0.148-0.325-0.179 0.292-0.458 0.468-1.018 0.468-1.618 0-1.657-1.343-3-3-3s-3 1.343-3 3c0 1.657 1.343 3 3 3 0.6 0 1.16-0.176 1.629-0.48 0.020 0.136 0.083 0.248 0.169 0.337l1.92 1.92c0.134 0.125 0.313 0.201 0.511 0.201 0.414 0 0.75-0.336 0.75-0.75 0-0.198-0.077-0.378-0.202-0.512zM10 11c-1.105 0-2-0.895-2-2s0.895-2 2-2c1.105 0 2 0.895 2 2s-0.895 2-2 2z"></path></g>
<g id="vaadin:file-sound"><path d="M11.4 10.5c0 1.2-0.4 2.2-1 3l0.4 0.5c0.7-0.9 1.2-2.1 1.2-3.5s-0.5-2.6-1.2-3.5l-0.4 0.5c0.6 0.8 1 1.9 1 3z"></path><path d="M9.9 8l-0.4 0.5c0.4 0.5 0.7 1.2 0.7 2s-0.3 1.5-0.7 2l0.4 0.5c0.5-0.6 0.8-1.5 0.8-2.5s-0.3-1.8-0.8-2.5z"></path><path d="M9.1 9l-0.4 0.5c0.2 0.3 0.3 0.6 0.3 1s-0.1 0.7-0.3 1l0.4 0.5c0.3-0.4 0.5-0.9 0.5-1.5s-0.2-1.1-0.5-1.5z"></path><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path><path d="M6 9h-2v3h2l2 2v-7z"></path></g>
<g id="vaadin:file-start"><path d="M10 0h-8v16h12v-12l-4-4zM13 15h-10v-14h6v4h4v10zM10 4v-3l3 3h-3z"></path><path d="M5 6v6l6-3z"></path></g>
<g id="vaadin:file-table"><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path><path d="M4 7v6h8v-6h-8zM6 12h-1v-1h1v1zM6 10h-1v-1h1v1zM9 12h-2v-1h2v1zM9 10h-2v-1h2v1zM11 12h-1v-1h1v1zM11 10h-1v-1h1v1z"></path></g>
<g id="vaadin:file-text-o"><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path><path d="M4 7h8v1h-8v-1z"></path><path d="M4 9h8v1h-8v-1z"></path><path d="M4 11h8v1h-8v-1z"></path></g>
<g id="vaadin:file-text"><path d="M10 0v4h4z"></path><path d="M9 0h-7v16h12v-11h-5v-5zM12 12h-8v-1h8v1zM12 10h-8v-1h8v1zM12 7v1h-8v-1h8z"></path></g>
<g id="vaadin:file-tree-small"><path d="M5 12v2h11v-5h-11v2h-2v-4h9v-5h-12v5h2v5z"></path></g>
<g id="vaadin:file-tree-sub"><path d="M8 11v1h-1v-2h5v-4h-8v1h-1v-2h6v-4h-9v4h2v3h2v2h2v3h2v2h8v-4z"></path></g>
<g id="vaadin:file-tree"><path d="M16 10v-4h-11v1h-2v-3h9v-4h-12v4h2v10h3v2h11v-4h-11v1h-2v-5h2v2z"></path></g>
<g id="vaadin:file-zip"><path d="M10 0h-8v16h12v-12l-4-4zM9 15h-4v-2.8l0.7-2.2h2.4l0.9 2.2v2.8zM13 15h-3v-3l-1-3h-2v-1h-2v1l-1 3v3h-1v-14h4v1h2v1h-2v1h2v1h4v10zM10 4v-3l3 3h-3z"></path><path d="M5 6h2v1h-2v-1z"></path><path d="M5 2h2v1h-2v-1z"></path><path d="M5 4h2v1h-2v-1z"></path><path d="M7 5h2v1h-2v-1z"></path><path d="M7 7h2v1h-2v-1z"></path><path d="M6 12h2v2h-2v-2z"></path></g>
<g id="vaadin:file"><path d="M9 5h5v11h-12v-16h7v5zM10 4v-4l4 4h-4z"></path></g>
<g id="vaadin:fill"><path d="M13 14.5c0.468-2.207 0.985-4.050 1.604-5.846 0.411 1.796 0.928 3.638 1.337 5.521 0.059 1.153-0.612 1.825-1.441 1.825s-1.5-0.672-1.5-1.5z"></path><path d="M8 1l-1.44 1.44-2-2c-0.276-0.262-0.649-0.423-1.060-0.423s-0.784 0.161-1.061 0.423c-0.27 0.271-0.438 0.645-0.438 1.059s0.168 0.789 0.439 1.060l2 2-4.44 4.44 7 7 8-8zM8 2.41l5.59 5.59h-11.18l2.75-2.75c0.071 0.042 0.156 0.067 0.247 0.067 0.271 0 0.49-0.219 0.49-0.49 0-0.091-0.025-0.176-0.068-0.249l0.721-0.718 1.54 1.53c0.091 0.091 0.216 0.147 0.355 0.147 0.277 0 0.502-0.225 0.502-0.502 0-0.139-0.056-0.264-0.147-0.355l-1.53-1.53zM3.15 1.85c-0.091-0.091-0.148-0.216-0.148-0.355s0.057-0.264 0.148-0.355c0.092-0.089 0.217-0.144 0.355-0.144s0.263 0.055 0.355 0.144l2 2-0.71 0.71z"></path></g>
<g id="vaadin:film"><path d="M0 0v16h1v-1h1v1h12v-1h1v1h1v-16h-16zM2 14h-1v-1h1v1zM2 12h-1v-1h1v1zM2 10h-1v-1h1v1zM2 8h-1v-1h1v1zM2 6h-1v-1h1v1zM2 4h-1v-1h1v1zM2 2h-1v-1h1v1zM13 15h-10v-6h10v6zM13 7h-10v-6h10v6zM15 14h-1v-1h1v1zM15 12h-1v-1h1v1zM15 10h-1v-1h1v1zM15 8h-1v-1h1v1zM15 6h-1v-1h1v1zM15 4h-1v-1h1v1zM15 2h-1v-1h1v1z"></path></g>
<g id="vaadin:filter"><path d="M1 2h14v2l-6 5v7l-2-2v-5l-6-5v-2z"></path><path d="M1 0h14v1h-14v-1z"></path></g>
<g id="vaadin:fire"><path d="M4.9 15.8c0 0-3.9-0.4-3.9-5.7 0-4.1 3.1-6.5 3.1-6.5s1.3 1.4 2.3 1.9c1 0.6 1.4-5.5 1.4-5.5s7.2 3.9 7.2 9.8c0 6.1-4 5.9-4 5.9s1.8-2.4 1.8-5.2c0-3-3.9-6.7-3.9-6.7s-0.5 4.4-2.1 5c-1.6-0.9-2.5-2.3-2.5-2.3s-3.7 5.8 0.6 9.3z"></path><path d="M8.2 16.1c-2-0.1-3.7-1.4-3.7-3.2s0.7-2.6 0.7-2.6 0.5 1 1.1 1.5 1.8 0.8 2.4 0.1c0.6-0.6 0.8-2.3 0.8-2.3s1.4 1.1 1.2 3c-0.1 2-0.9 3.5-2.5 3.5z"></path></g>
<g id="vaadin:flag-checkered"><path d="M2 0c-1.1 0-2 0.9-2 2 0 0.7 0.4 1.4 1 1.7v12.3h2v-12.3c0.6-0.3 1-1 1-1.7 0-1.1-0.9-2-2-2z"></path><path d="M12 2c-2.1 0-1.8-1-4.4-1s-3.6 3-3.6 3v8c0 0 0.7-2 3-2 2.7 0 2.8 1 5 1 3.3 0 4-2 4-2v-8c0 0-1.6 1-4 1zM15 4.5c-0.2 0.2-0.8 0.4-2 0.6v-2.2c0.8-0.1 1.5-0.2 2-0.4v2zM5 7.9v-2.6c0.4-0.6 1.1-1.1 2-1.1v-2.1c0.2-0.1 0.4-0.1 0.6-0.1 1.2 0 1.6 0.2 2.1 0.4 0.1 0.1 0.2 0.2 0.3 0.2v2.2c0.5 0.2 1.1 0.4 2 0.4 0.4 0 0.7 0 1-0.1v2.6c-0.3 0-0.6 0.1-1 0.1-1.1 0-1.5-0.2-2-0.5v2.3c-0.7-0.3-1.5-0.6-3-0.6v-2.2c-0.9 0.2-1.5 0.6-2 1.1zM13 9.9v-2.2c1.1-0.2 1.7-0.6 2-0.8v1.8c-0.2 0.3-0.7 1-2 1.2z"></path><path d="M10 7.2v-2.4c0 0-1.2-0.6-3-0.6v2.6c1.7-0.4 3 0.4 3 0.4z"></path></g>
<g id="vaadin:flag-o"><path d="M4 2c0-1.1-0.9-2-2-2s-2 0.9-2 2c0 0.7 0.4 1.4 1 1.7v12.3h2v-12.3c0.6-0.3 1-1 1-1.7z"></path><path d="M7.6 2c1.2 0 1.6 0.2 2.1 0.4 0.5 0.3 1.1 0.6 2.3 0.6s2.2-0.2 3-0.5v6.3c-0.2 0.3-0.9 1.2-3 1.2-0.9 0-1.3-0.2-1.9-0.4-0.7-0.3-1.5-0.6-3.1-0.6-0.8 0-1.5 0.2-2 0.5v-5.3c0.2-0.5 1-2.2 2.6-2.2zM16 1c0 0-1.6 1-4 1-2.1 0-1.8-1-4.4-1s-3.6 3-3.6 3v8c0 0 0.7-2 3-2 2.7 0 2.8 1 5 1 3.3 0 4-2 4-2v-8z"></path></g>
<g id="vaadin:flag"><path d="M4 2c0-1.1-0.9-2-2-2s-2 0.9-2 2c0 0.7 0.4 1.4 1 1.7v12.3h2v-12.3c0.6-0.3 1-1 1-1.7z"></path><path d="M4 4c0 0 1-3 3.6-3 2.7 0 2.3 1 4.4 1 2.4 0 4-1 4-1v8c0 0-0.7 2-4 2-2.2 0-2.3-1-5-1-2.3 0-3 2-3 2v-8z"></path></g>
<g id="vaadin:flash"><path d="M16 8l-2.2-1.6 1.1-2.4-2.7-0.2-0.2-2.7-2.4 1.1-1.6-2.2-1.6 2.2-2.4-1.1-0.2 2.7-2.7 0.2 1.1 2.4-2.2 1.6 2.2 1.6-1.1 2.4 2.7 0.2 0.2 2.7 2.4-1.1 1.6 2.2 1.6-2.2 2.4 1.1 0.2-2.7 2.7-0.2-1.1-2.4 2.2-1.6z"></path></g>
<g id="vaadin:flask"><path d="M2 16h12l-4-8v-7h1v-1h-6v1h1v7l-4 8zM9 1v7.2l1.9 3.8h-5.8l1.9-3.8v-7.2h2z"></path></g>
<g id="vaadin:flight-landing"><path d="M13.64 7c-0.71-0.2-1.89-0.43-3.23-0.67l-3.82-4.24c-0.209-0.23-0.462-0.416-0.746-0.544l-1.194-0.546c-0.090 0-0.15 0-0.1 0.11s1.45 2.89 2.29 4.59c-1.84-0.29-3.5-0.53-4.23-0.63-0.258-0.047-0.474-0.198-0.608-0.406l-0.722-1.074c-0.115-0.168-0.28-0.294-0.474-0.358l-0.806-0.232 0.61 3.26c0.067 0.34 0.318 0.609 0.644 0.699 1.326 0.381 4.816 1.341 7.526 1.921 6 1.28 6.8 1.28 7.12 0.91s-0.67-2.38-2.26-2.79z"></path><path d="M0 13h16v1h-16v-1z"></path></g>
<g id="vaadin:flight-takeoff"><path d="M12.57 2.26c-0.65 0.29-1.66 0.85-2.8 1.5l-5.46-0.76c-0.093-0.014-0.2-0.022-0.309-0.022-0.211 0-0.414 0.030-0.607 0.086l-1.185 0.336c-0.1 0-0.1 0.1 0 0.14l4.56 2c-1.54 0.92-2.91 1.76-3.51 2.14-0.13 0.082-0.288 0.13-0.458 0.13-0.094 0-0.184-0.015-0.268-0.042l-1.194-0.378c-0.086-0.031-0.186-0.049-0.29-0.049s-0.204 0.018-0.296 0.051l-0.754 0.308 2.52 2.1c0.152 0.127 0.349 0.205 0.565 0.205 0.129 0 0.251-0.028 0.361-0.077 1.204-0.538 4.374-1.998 6.734-3.228 5.24-2.78 5.82-3.26 5.82-3.7 0-0.69-2-1.4-3.43-0.74z"></path><path d="M0 13h16v1h-16v-1z"></path></g>
<g id="vaadin:flip-h"><path d="M0 15l6-5-6-4.9z"></path><path d="M9 10.1l6 4.9v-10l-6 5.1zM14 12.9l-3.4-2.8 3.4-3v5.8z"></path><path d="M7 5h1v1h-1v-1z"></path><path d="M7 3h1v1h-1v-1z"></path><path d="M7 7h1v1h-1v-1z"></path><path d="M7 9h1v1h-1v-1z"></path><path d="M7 11h1v1h-1v-1z"></path><path d="M7 13h1v1h-1v-1z"></path><path d="M7 15h1v1h-1v-1z"></path><path d="M7.5 1v0c1.3 0 2.6 0.7 3.6 1.9l-1.1 1.1h3v-3l-1.2 1.2c-1.2-1.4-2.7-2.2-4.3-2.2 0 0 0 0 0 0-1.9 0-3.6 1-4.9 2.9l0.8 0.6c1.1-1.6 2.5-2.5 4.1-2.5z"></path></g>
<g id="vaadin:flip-v"><path d="M1 1l5 6 4.94-6h-9.94z"></path><path d="M5.94 10l-4.94 6h10zM3.12 15l2.83-3.44 3 3.44h-5.83z"></path><path d="M10 8h1v1h-1v-1z"></path><path d="M12 8h1v1h-1v-1z"></path><path d="M8 8h1v1h-1v-1z"></path><path d="M6 8h1v1h-1v-1z"></path><path d="M4 8h1v1h-1v-1z"></path><path d="M2 8h1v1h-1v-1z"></path><path d="M0 8h1v1h-1v-1z"></path><path d="M15 8.47v0c-0.059 1.485-0.782 2.789-1.879 3.632l-1.121-1.102v3h3l-1.18-1.18c1.293-1.031 2.128-2.588 2.18-4.342l0-0.008c-0.092-2.083-1.223-3.883-2.884-4.905l-0.596 0.805c1.423 0.857 2.383 2.357 2.479 4.087z"></path></g>
<g id="vaadin:folder-add"><path d="M14 6v-2h-7l-1-2h-4l-1 2h-1v11h14v-1h-13v-9h0.62l1-2h2.57l1.19 2h6.62v1h1z"></path><path d="M14 7h-2v2h-2v2h2v2h2v-2h2v-2h-2v-2z"></path></g>
<g id="vaadin:folder-o"><path d="M7 4l-1-2h-4l-1 2h-1v11h16v-11h-9zM15 14h-14v-9h0.6l1-2h2.6l1.2 2h8.6v9z"></path></g>
<g id="vaadin:folder-open-o"><path d="M14 6v-2h-7l-1-2h-4l-1 2h-1v11h14l2-9h-2zM14.9 7l-1.6 7-11.9-0.1 2.3-6.9h11.2zM1 5h0.6l1-2h2.6l1.2 2h6.6v1h-10l-2 5.9v-6.9z"></path></g>
<g id="vaadin:folder-open"><path d="M14 6v-2h-7l-1-2h-4l-1 2h-1v9.5l3-7.5z"></path><path d="M3.7 7l-3.2 8h12.8l2.5-8z"></path></g>
<g id="vaadin:folder-remove"><path d="M13 12.41v1.59h-12v-9h0.62l1-2h2.57l1.19 2h6.62v2.59l1-1v-2.59h-7l-1-2h-4l-1 2h-1v11h14v-1.59l-1-1z"></path><path d="M16 8l-1-1-2 2-2-2-1 1 2 2-2 2 1 1 2-2 2 2 1-1-2-2 2-2z"></path></g>
<g id="vaadin:folder-search"><path d="M13 13.47v0.53h-12v-9h0.62l1-2h2.57l1.19 2h6.62v0.91c0.385 0.179 0.716 0.407 1.001 0.681l-0.001-2.591h-7l-1-2h-4l-1 2h-1v11h14v-0.53z"></path><path d="M15.78 12.72l-1.92-1.92c-0.089-0.085-0.201-0.148-0.325-0.179 0.292-0.458 0.468-1.018 0.468-1.618 0-1.657-1.343-3-3-3s-3 1.343-3 3c0 1.657 1.343 3 3 3 0.6 0 1.16-0.176 1.629-0.48 0.020 0.136 0.083 0.248 0.169 0.337l1.92 1.92c0.134 0.125 0.313 0.201 0.511 0.201 0.414 0 0.75-0.336 0.75-0.75 0-0.198-0.077-0.378-0.202-0.512zM11 11c-1.105 0-2-0.895-2-2s0.895-2 2-2c1.105 0 2 0.895 2 2s-0.895 2-2 2z"></path></g>
<g id="vaadin:folder"><path d="M16 15h-16v-11h1l1-2h4l1 2h9z"></path></g>
<g id="vaadin:font"><path d="M12 16h3l-6-16h-2l-6 16h3l1.9-5h4.2l1.9 5zM6.7 9l1.3-3.6 1.3 3.6h-2.6z"></path></g>
<g id="vaadin:form"><path d="M15 2v2h-9v-2h9zM16 1h-11v4h11v-4z"></path><path d="M0 1h4v4h-4v-4z"></path><path d="M15 7v2h-9v-2h9zM16 6h-11v4h11v-4z"></path><path d="M0 6h4v4h-4v-4z"></path><path d="M15 12v2h-9v-2h9zM16 11h-11v4h11v-4z"></path><path d="M0 11h4v4h-4v-4z"></path></g>
<g id="vaadin:forward"><path d="M0 1v14l8-7z"></path><path d="M8 1v14l8-7z"></path></g>
<g id="vaadin:frown-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M7 6c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M11 6c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M11.3 12.3c-0.7-1.1-2-1.8-3.3-1.8s-2.6 0.7-3.3 1.8l-0.8-0.6c0.9-1.4 2.4-2.2 4.1-2.2s3.2 0.8 4.1 2.2l-0.8 0.6z"></path></g>
<g id="vaadin:function"><path d="M10 0c0 0-2.1 0-2.7 3l-0.4 2h-1.9l-0.5 1h2.2l-1.4 7c-0.4 2-1.9 2-1.9 2h-1l-0.4 1h3c0 0 2.1 0 2.7-3l1.4-7h2.4l0.5-1h-2.7l0.4-2c0.4-2 1.8-2 1.8-2h1l0.5-1h-3z"></path></g>
<g id="vaadin:funnel"><path d="M6 11h4v4h-4v-4z"></path><path d="M13.6 5l2.4-4h-16l2.4 4h11.2z"></path><path d="M3 6l2.4 4h5.2l2.4-4h-10z"></path></g>
<g id="vaadin:gamepad"><path d="M12.16 2c-1.215 0.603-2.641 0.968-4.149 1-1.53-0.032-2.956-0.397-4.229-1.026-2.611 0.026-3.781 1.196-3.781 3.866v6c0.017 1.197 0.991 2.16 2.19 2.16 0 0 0 0 0 0h0.23c0 0 0.001 0 0.002 0 0.963 0 1.78-0.621 2.074-1.485 0.305-0.915 1.145-2.515 2.085-2.515h2.84c0.94 0 1.78 1.6 2.080 2.5 0.298 0.879 1.116 1.5 2.078 1.5 0.001 0 0.001 0 0.002 0h0.23c1.21 0 2.19-0.98 2.19-2.19v-6c0-2.64-1.17-3.81-3.84-3.81zM5 7h-1v1h-1v-1h-1v-1h1v-1h1v1h1v1zM10.060 8.11c-0.585 0-1.060-0.475-1.060-1.060s0.475-1.060 1.060-1.060c0.585 0 1.060 0.475 1.060 1.060s-0.475 1.060-1.060 1.060zM13 8c-0.552 0-1-0.448-1-1s0.448-1 1-1c0.552 0 1 0.448 1 1s-0.448 1-1 1z"></path></g>
<g id="vaadin:gavel"><path d="M6.4 4.1v0c-0.4-0.4-0.4-0.9-0.1-1.2l2.6-2.6c0.3-0.3 0.8-0.3 1.2 0l0.1 0.1c0.3 0.3 0.3 0.8 0 1.2l-2.6 2.5c-0.3 0.3-0.9 0.3-1.2 0z"></path><path d="M12 9.7v0c-0.4-0.4-0.4-0.9-0.1-1.3l2.6-2.6c0.3-0.3 0.8-0.3 1.2 0l0.1 0.1c0.3 0.3 0.3 0.8 0 1.2l-2.6 2.6c-0.4 0.3-0.9 0.3-1.2 0z"></path><path d="M10 7.7l-1.7-1.7c-0.4-0.4-0.4-1 0-1.4l2.3-2.3c0.4-0.4 1-0.4 1.4 0l1.7 1.7c0.4 0.4 0.4 1 0 1.4l-2.3 2.3c-0.4 0.4-1 0.4-1.4 0z"></path><path d="M4 14.2c0.6-0.6 4-5.6 4.5-5.3 0.4 0.2 1-0.5 1-0.5l-1.9-1.9c0 0-0.7 0.6-0.5 1 0.3 0.5-4.7 3.9-5.3 4.5 0 0-2.8 2.2-1.4 3.6s3.6-1.4 3.6-1.4z"></path></g>
<g id="vaadin:gift"><path d="M10.1 5c2-0.3 3.9-1.1 2.2-3.6-0.7-1-1.4-1.4-2-1.4-1 0-1.7 1.1-2.3 2.2-0.6-1.1-1.3-2.2-2.3-2.2-0.6 0-1.3 0.4-2 1.4-1.8 2.5 0.2 3.3 2.2 3.6h-5.9v3h16v-3h-5.9zM10.3 1c0.1 0 0.5 0.1 1.2 1 0.5 0.7 0.6 1.1 0.5 1.3-0.2 0.3-1.3 0.7-3.3 0.8 0-0.2-0.1-0.4-0.2-0.6 0.6-1.4 1.3-2.5 1.8-2.5zM4 3.3c-0.1-0.2 0-0.6 0.5-1.3 0.7-0.9 1.1-1 1.2-1 0.5 0 1.2 1.1 1.8 2.5-0.1 0.2-0.2 0.4-0.2 0.6-2-0.1-3.1-0.5-3.3-0.8zM7 7v-2h2v2h-2z"></path><path d="M9 15h-2v-6h-6v7h14v-7h-6z"></path></g>
<g id="vaadin:glass"><path d="M11 15h-2v-8l6-7h-15l6 7v8h-2c-2 0-2 1-2 1h11c0 0 0-1-2-1zM12.9 1l-1.8 2h-7.2l-1.7-2h10.7zM7 15v-8h1v8h-1z"></path></g>
<g id="vaadin:glasses"><path d="M15.5 7h-0.5c-0.1 0-0.1 0-0.2 0-0.4-1.2-1.5-2-2.8-2s-2.4 0.9-2.8 2.1c-0.3-0.4-0.7-0.6-1.2-0.6s-0.9 0.2-1.2 0.6c-0.4-1.2-1.5-2.1-2.8-2.1s-2.4 0.9-2.8 2c-0.1 0-0.1 0-0.2 0h-0.5c-0.3 0-0.5 0.2-0.5 0.5s0.2 0.5 0.5 0.5h0.5c0 1.7 1.3 3 3 3 1.5 0 2.7-1.1 3-2.5 0 0 0 0 0 0 0.3 0 0.5-0.2 0.5-0.5s0.2-0.5 0.5-0.5 0.5 0.2 0.5 0.5c0 0.3 0.2 0.5 0.5 0.5 0 0 0 0 0 0 0.2 1.4 1.5 2.5 3 2.5 1.7 0 3-1.3 3-3h0.5c0.3 0 0.5-0.2 0.5-0.5s-0.2-0.5-0.5-0.5zM4 10c-1.1 0-2-0.9-2-2s0.9-2 2-2 2 0.9 2 2-0.9 2-2 2zM12 10c-1.1 0-2-0.9-2-2s0.9-2 2-2 2 0.9 2 2-0.9 2-2 2z"></path></g>
<g id="vaadin:globe-wire"><path d="M8 0c-4.418 0-8 3.582-8 8s3.582 8 8 8c4.418 0 8-3.582 8-8s-3.582-8-8-8zM14.8 9.5c0 0.5-0.7 0.66-2 1 0.124-0.589 0.206-1.277 0.229-1.98l2.001-0.020c0 0.36-0.080 0.5-0.16 1v0zM1.2 9.5v0c-0.1-0.5-0.15-0.64-0.2-1h2c0.024 0.723 0.106 1.411 0.244 2.079-1.344-0.419-2.044-0.579-2.044-1.079zM1.2 6.5c0-0.5 0.7-0.66 2-1-0.115 0.594-0.187 1.284-0.2 1.989l-2 0.011c0-0.36 0.080-0.5 0.16-1v0zM8.5 5c1.13 0.013 2.226 0.107 3.298 0.277 0.047 0.643 0.165 1.41 0.201 2.199l-3.499 0.025v-2.5zM8.5 4v-2.94c1.17 0.27 2.2 1.47 2.84 3.15-0.836-0.116-1.819-0.192-2.817-0.21zM7.5 1.060v2.94c-1.017 0.015-2.001 0.087-2.968 0.214 0.768-1.684 1.798-2.884 2.968-3.154zM7.5 5v2.5h-3.5c0.031-0.806 0.142-1.571 0.326-2.307 0.932-0.080 2.035-0.177 3.158-0.193zM4 8.5h3.5v2.5c-1.13-0.013-2.226-0.107-3.298-0.277-0.047-0.643-0.165-1.41-0.201-2.199zM7.5 12v2.94c-1.17-0.27-2.2-1.47-2.84-3.15 0.836 0.116 1.819 0.192 2.817 0.21zM8.5 14.94v-2.94c1.017-0.015 2.001-0.087 2.968-0.214-0.768 1.684-1.798 2.884-2.968 3.154zM8.5 11v-2.5h3.5c-0.031 0.806-0.142 1.571-0.326 2.307-0.932 0.080-2.035 0.177-3.158 0.193zM15 7.5h-2c-0.024-0.723-0.106-1.411-0.244-2.079 1.354 0.399 2.014 0.559 2.014 1.079v0c0.13 0.5 0.18 0.64 0.23 1zM14.3 4.91c-0.506-0.204-1.106-0.38-1.726-0.5-0.361-1.019-0.809-1.898-1.389-2.672 1.355 0.726 2.413 1.811 3.067 3.131zM4.84 1.76c-0.568 0.752-1.019 1.631-1.305 2.581-0.699 0.189-1.299 0.365-1.874 0.593 0.751-1.39 1.823-2.475 3.139-3.156zM1.73 11.090c0.506 0.204 1.106 0.38 1.726 0.5 0.361 1.019 0.809 1.898 1.389 2.672-1.367-0.722-2.436-1.807-3.097-3.131zM11.17 14.24c0.564-0.753 1.012-1.631 1.295-2.581 0.699-0.189 1.299-0.365 1.874-0.593-0.751 1.39-1.823 2.475-3.139 3.156z"></path></g>
<g id="vaadin:globe"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM13.2 5.3c0.4 0 0.7 0.3 1.1 0.3-0.3 0.4-1.6 0.4-2-0.1 0.3-0.1 0.5-0.2 0.9-0.2zM1 8c0-0.4 0-0.8 0.1-1.3 0.1 0 0.2 0.1 0.3 0.1 0 0 0.1 0.1 0.1 0.2 0 0.3 0.3 0.5 0.5 0.5 0.8 0.1 1.1 0.8 1.8 1 0.2 0.1 0.1 0.3 0 0.5-0.6 0.8-0.1 1.4 0.4 1.9 0.5 0.4 0.5 0.8 0.6 1.4 0 0.7 0.1 1.5 0.4 2.2-2.5-1.2-4.2-3.6-4.2-6.5zM8 15c-0.7 0-1.5-0.1-2.1-0.3-0.1-0.2-0.1-0.4 0-0.6 0.4-0.8 0.8-1.5 1.3-2.2 0.2-0.2 0.4-0.4 0.4-0.7 0-0.2 0.1-0.5 0.2-0.7 0.3-0.5 0.2-0.8-0.2-0.9-0.8-0.2-1.2-0.9-1.8-1.2s-1.2-0.5-1.7-0.2c-0.2 0.1-0.5 0.2-0.5-0.1 0-0.4-0.5-0.7-0.4-1.1-0.1 0-0.2 0-0.3 0.1s-0.2 0.2-0.4 0.1c-0.2-0.2-0.1-0.4-0.1-0.6 0.1-0.2 0.2-0.3 0.4-0.4 0.4-0.1 0.8-0.1 1 0.4 0.3-0.9 0.9-1.4 1.5-1.8 0 0 0.8-0.7 0.9-0.7s0.2 0.2 0.4 0.3c0.2 0 0.3 0 0.3-0.2 0.1-0.5-0.2-1.1-0.6-1.2 0-0.1 0.1-0.1 0.1-0.1 0.3-0.1 0.7-0.3 0.6-0.6 0-0.4-0.4-0.6-0.8-0.6-0.2 0-0.4 0-0.6 0.1-0.4 0.2-0.9 0.4-1.5 0.4 1.1-0.8 2.5-1.2 3.9-1.2 0.3 0 0.5 0 0.8 0-0.6 0.1-1.2 0.3-1.6 0.5 0.6 0.1 0.7 0.4 0.5 0.9-0.1 0.2 0 0.4 0.2 0.5s0.4 0.1 0.5-0.1c0.2-0.3 0.6-0.4 0.9-0.5 0.4-0.1 0.7-0.3 1-0.7 0-0.1 0.1-0.1 0.2-0.2 0.6 0.2 1.2 0.6 1.8 1-0.1 0-0.1 0.1-0.2 0.1-0.2 0.2-0.5 0.3-0.2 0.7 0.1 0.2 0 0.3-0.1 0.4-0.2 0.1-0.3 0-0.4-0.1s-0.1-0.3-0.4-0.3c-0.1 0.2-0.4 0.3-0.4 0.6 0.5 0 0.4 0.4 0.5 0.7-0.6 0.1-0.8 0.4-0.5 0.9 0.1 0.2-0.1 0.3-0.2 0.4-0.4 0.6-0.8 1-0.8 1.7s0.5 1.4 1.3 1.3c0.9-0.1 0.9-0.1 1.2 0.7 0 0.1 0.1 0.2 0.1 0.3 0.1 0.2 0.2 0.4 0.1 0.6-0.3 0.8 0.1 1.4 0.4 2 0.1 0.2 0.2 0.3 0.3 0.4-1.3 1.4-3 2.2-5 2.2z"></path></g>
<g id="vaadin:golf"><path d="M7 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M9.8 1.8c-0.2-0.5-1.7-0.1-2 0.5-0.2 0.3-0.2 1.2-1.2 1.9-0.8 0.5-1.6 0.5-1.6 0.5-0.3 0.6-0.1 1.1 0.2 1.6 0.5 0.9 0.6 1.8 0.7 2.8 0.1 1.3-0.5 2.4-2.3 3.2-0.8 0.3-1.3 0.9-1 1.9 0 0 2-0.3 3.1-1.2 1.5-1.2 1.8-2.3 1.8-2.3s0.1 0.7 0 1.9c-0.1 1-0.2 1.5-0.4 2.2s0.3 1.2 0.9 1.2 1-0.4 1-1l0.3-1.9c0.3-2.1 0-4.3-0.8-6.3 0-0.1-0.1-0.1-0.1-0.2-0.6-1.6 0.2-2.6 0.6-3 0.3-0.4 1.2-1.2 0.8-1.8z"></path><path d="M12 0v10h1v-6l3-2z"></path><path d="M16 10c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M1 8.4l3.7-3.7-0.7-0.3-3.8 3.6c0 0-0.4 0.7 0.1 1.7s1.6 0.3 1.6 0.3c0.4-0.2 0.2-0.4 0-0.6s-0.9-1-0.9-1z"></path></g>
<g id="vaadin:google-plus-square"><path d="M5 3.4c-0.8 0-1.3 0.8-1.2 1.8 0.1 1.1 0.9 1.9 1.7 2 0.8 0 1.3-0.8 1.2-1.9-0.1-1-0.9-1.9-1.7-1.9z"></path><path d="M5.4 9.3c-1.2 0-2.3 0.7-2.3 1.6s0.9 1.7 2.1 1.7c1.7 0 2.3-0.7 2.3-1.6 0-0.1 0-0.2 0-0.3-0.1-0.5-0.6-0.8-1.3-1.2-0.2-0.2-0.5-0.2-0.8-0.2z"></path><path d="M0 0v16h16v-16h-16zM7.9 5.3c0 0.7-0.4 1.2-0.9 1.6s-0.6 0.6-0.6 0.9c0 0.3 0.5 0.8 0.8 1 0.8 0.6 1.1 1.1 1.1 2 0 1.1-1.1 2.3-3.1 2.3-1.7 0-3.2-0.7-3.2-1.8 0-1.2 1.3-2.3 3.1-2.3 0.2 0 0.4 0 0.5 0-0.2-0.3-0.4-0.6-0.4-0.9 0-0.2 0.1-0.4 0.2-0.6-0.1 0-0.2 0-0.3 0-1.4 0-2.4-1-2.4-2.3 0-1.2 1.3-2.3 2.7-2.3 0.8 0 3.1 0 3.1 0l-0.7 0.6h-1c0.7 0.2 1.1 1 1.1 1.8zM14 5.5h-2.1v2h-0.5v-2h-2v-0.5h2v-2h0.5v2h2.1v0.5z"></path></g>
<g id="vaadin:google-plus"><path d="M16 3.9h-2.8v-2.6h-0.6v2.6h-2.7v0.8h2.7v2.6h0.6v-2.6h2.8z"></path><path d="M6.9 9c-0.4-0.2-1.1-0.9-1.1-1.3s0.1-0.7 0.8-1.2c0.7-0.5 1.2-1.2 1.2-2.1 0-1.1-0.5-2.1-1.3-2.4h1.3l0.9-0.7c0 0-3.1 0-4.2 0-1.9 0-3.6 1.4-3.6 3.1s1.3 3 3.2 3c0.1 0 0.3 0 0.4 0-0.2 0.2-0.2 0.4-0.2 0.7 0 0.5 0.3 0.8 0.6 1.2-0.2 0-0.5 0-0.7 0-2.3 0-4.1 1.5-4.1 3s2 2.5 4.3 2.5c2.6 0 4.1-1.5 4.1-3-0.1-1.3-0.5-2-1.6-2.8zM4.7 6.9c-1.1 0-2.1-1.2-2.3-2.6s0.5-2.5 1.6-2.5c1.1 0 2.1 1.2 2.3 2.6s-0.5 2.6-1.6 2.5zM4.3 14.1c-1.6 0-2.8-1-2.8-2.2s1.4-2.2 3-2.2c0.4 0 0.7 0.1 1 0.2 0.9 0.6 1.5 0.9 1.7 1.6 0 0.1 0.1 0.3 0.1 0.4 0 1.2-0.8 2.2-3 2.2z"></path></g>
<g id="vaadin:grab"><path d="M12.6 4c-0.2 0-0.4 0-0.6 0 0-0.2-0.2-0.6-0.4-0.8s-0.5-0.4-1.1-0.4c-0.2 0-0.4 0-0.6 0.1-0.1-0.2-0.2-0.3-0.3-0.5-0.2-0.2-0.5-0.4-1.1-0.4-0.8 0-1.2 0.5-1.4 1-0.1 0-0.3-0.1-0.5-0.1-0.5 0-0.8 0.2-1.1 0.4-0.5 0.6-0.5 1.4-0.5 1.5v0.4c-0.6 0-1.1 0.2-1.4 0.5-0.6 0.7-0.6 1.6-0.6 2.8 0 0.2 0 0.5 0 0.7 0 1.4 0.7 2.1 1.4 2.8l0.3 0.4c1.3 1.2 2.5 1.6 5.1 1.6 2.9 0 4.2-1.6 4.2-5.1v-2.5c0-0.7-0.2-2.1-1.4-2.4zM10.5 3.8c0.4 0 0.5 0.4 0.5 0.6v0.8c0 0.3 0.2 0.5 0.4 0.5 0.3 0 0.5-0.1 0.5-0.4 0 0 0-0.4 0.4-0.3 0.6 0.2 0.7 1.1 0.7 1.3 0 0 0 0 0 0v2.6c0 3.4-1.3 4.1-3.2 4.1-2.4 0-3.3-0.3-4.3-1.3-0.1-0.1-0.2-0.2-0.4-0.4-0.7-0.7-1.1-1.1-1.1-2.1 0-0.2 0-0.3 0-0.6 0-1 0-1.8 0.3-2.1 0.1-0.2 0.4-0.3 0.7-0.3v0.8l-0.3 1.2c0 0.1 0 0.1 0.1 0.1 0.1 0.1 0.2 0 0.2 0l1-1.2c0 0 0-0.1 0-0.1v-2c0-0.1 0-0.6 0.2-0.8 0.1-0.1 0.2-0.2 0.4-0.2 0.3 0 0.4 0.2 0.4 0.4v0.4c0 0.2 0.2 0.5 0.5 0.5s0.5-0.3 0.5-0.5v-1.3c0-0.1 0-0.5 0.5-0.5 0.3 0 0.5 0.2 0.5 0.5v1.2c0 0.3 0.2 0.6 0.5 0.6s0.5-0.3 0.5-0.5v-0.5c0-0.3 0.2-0.5 0.5-0.5z"></path></g>
<g id="vaadin:grid-bevel"><path d="M14 2v-1h-13v13h1v1h13v-13h-1zM5 13h-3v-3h3v3zM5 9h-3v-3h3v3zM5 5h-3v-3h3v3zM9 13h-3v-3h3v3zM9 9h-3v-3h3v3zM9 5h-3v-3h3v3zM13 13h-3v-3h3v3zM13 9h-3v-3h3v3zM13 5h-3v-3h3v3z"></path></g>
<g id="vaadin:grid-big-o"><path d="M0 7h7v-7h-7v7zM1 1h5v5h-5v-5z"></path><path d="M9 0v7h7v-7h-7zM15 6h-5v-5h5v5z"></path><path d="M0 16h7v-7h-7v7zM1 10h5v5h-5v-5z"></path><path d="M9 16h7v-7h-7v7zM10 10h5v5h-5v-5z"></path></g>
<g id="vaadin:grid-big"><path d="M0 0h7v7h-7v-7z"></path><path d="M9 0h7v7h-7v-7z"></path><path d="M0 9h7v7h-7v-7z"></path><path d="M9 9h7v7h-7v-7z"></path></g>
<g id="vaadin:grid-h"><path d="M0 0v16h16v-16h-16zM5 15h-4v-14h4v14zM10 15h-4v-14h4v14zM15 15h-4v-14h4v14z"></path></g>
<g id="vaadin:grid-small-o"><path d="M0 4h4v-4h-4v4zM1 1h2v2h-2v-2z"></path><path d="M0 10h4v-4h-4v4zM1 7h2v2h-2v-2z"></path><path d="M0 16h4v-4h-4v4zM1 13h2v2h-2v-2z"></path><path d="M6 4h4v-4h-4v4zM7 1h2v2h-2v-2z"></path><path d="M6 10h4v-4h-4v4zM7 7h2v2h-2v-2z"></path><path d="M6 16h4v-4h-4v4zM7 13h2v2h-2v-2z"></path><path d="M12 0v4h4v-4h-4zM15 3h-2v-2h2v2z"></path><path d="M12 10h4v-4h-4v4zM13 7h2v2h-2v-2z"></path><path d="M12 16h4v-4h-4v4zM13 13h2v2h-2v-2z"></path></g>
<g id="vaadin:grid-small"><path d="M0 0h4v4h-4v-4z"></path><path d="M0 6h4v4h-4v-4z"></path><path d="M0 12h4v4h-4v-4z"></path><path d="M6 0h4v4h-4v-4z"></path><path d="M6 6h4v4h-4v-4z"></path><path d="M6 12h4v4h-4v-4z"></path><path d="M12 0h4v4h-4v-4z"></path><path d="M12 6h4v4h-4v-4z"></path><path d="M12 12h4v4h-4v-4z"></path></g>
<g id="vaadin:grid-v"><path d="M16 0h-16v16h16v-16zM1 5v-4h14v4h-14zM1 10v-4h14v4h-14zM1 15v-4h14v4h-14z"></path></g>
<g id="vaadin:grid"><path d="M0 0v16h16v-16h-16zM5 15h-4v-4h4v4zM5 10h-4v-4h4v4zM5 5h-4v-4h4v4zM10 15h-4v-4h4v4zM10 10h-4v-4h4v4zM10 5h-4v-4h4v4zM15 15h-4v-4h4v4zM15 10h-4v-4h4v4zM15 5h-4v-4h4v4z"></path></g>
<g id="vaadin:group"><path d="M5 16v-5.3c-0.6-0.3-1-1-1-1.7v-4c0-0.7 0.4-1.3 1-1.7 0-0.1 0-0.2 0-0.3 0-1.1-0.9-2-2-2s-2 0.9-2 2c0 1.1 0.9 2 2 2h-2c-0.5 0-1 0.5-1 1v4c0 0.5 0.5 1 1 1v5h4z"></path><path d="M15 5h-2c1.1 0 2-0.9 2-2s-0.9-2-2-2-2 0.9-2 2c0 0.1 0 0.2 0 0.3 0.6 0.4 1 1 1 1.7v4c0 0.7-0.4 1.4-1 1.7v5.3h4v-5c0.5 0 1-0.5 1-1v-4c0-0.5-0.5-1-1-1z"></path><path d="M10 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M10 4h-4c-0.5 0-1 0.5-1 1v4c0 0.5 0.5 1 1 1v6h4v-6c0.5 0 1-0.5 1-1v-4c0-0.5-0.5-1-1-1z"></path></g>
<g id="vaadin:hammer"><path d="M6 2l7 7 3-3-4.48-4.48s-2.97 1.030-4.52-0.52z"></path><path d="M8.8 5.79l-8.53 8.52c-0.165 0.178-0.267 0.417-0.267 0.68s0.101 0.502 0.267 0.681c0.181 0.183 0.433 0.297 0.711 0.297 0.253 0 0.484-0.094 0.66-0.248l8.569-8.519z"></path></g>
<g id="vaadin:hand"><path d="M13.5 2.4c-0.4-0.4-1-0.5-1.5-0.3 0-0.3-0.1-0.6-0.4-0.9-0.2-0.2-0.6-0.4-1.1-0.4-0.3 0-0.5 0.1-0.7 0.1 0-0.2-0.1-0.3-0.2-0.5-0.5-0.6-1.5-0.6-2 0-0.2 0.2-0.4 0.4-0.4 0.6-0.2 0-0.4-0.1-0.6-0.1-0.5 0-0.8 0.2-1.1 0.5-0.5 0.5-0.5 1.3-0.5 1.3v3.8c-0.3-0.3-0.8-0.8-1.5-0.8-0.2 0-0.5 0.1-0.7 0.2-0.4 0.2-0.6 0.5-0.7 0.9-0.3 1 0.6 2.4 0.6 2.5 0.1 0.1 1.2 2.7 2.2 3.8 1 1.2 2.1 1.9 4.9 1.9 2.9 0 4.2-1.6 4.2-5.1v-5.5c0-0.1 0.1-1.3-0.5-2zM8 2c0-0.3-0.1-1 0.5-1 0.5 0 0.5 0.5 0.5 1v4c0 0.3 0.2 0.5 0.5 0.5s0.5-0.2 0.5-0.5v-3.8c0 0 0-0.4 0.5-0.4 0.6 0 0.5 0.9 0.5 0.9v3.3c0 0.3 0.2 0.5 0.5 0.5s0.5-0.2 0.5-0.5v-2.4c0-0.1 0-0.6 0.5-0.6s0.5 1 0.5 1v5.9c0 3.4-1.3 4.1-3.2 4.1-2.4 0-3.3-0.5-4.1-1.6-0.9-1-2.1-3.6-2.1-3.7-0.3-0.3-0.7-1.2-0.6-1.6 0-0.1 0.1-0.2 0.2-0.3 0.1 0 0.2-0.1 0.2-0.1 0.4 0 0.8 0.5 0.9 0.7l0.6 0.9c0.1 0.2 0.4 0.3 0.6 0.2 0.4 0 0.5-0.2 0.5-0.4v-5.2c0-0.4 0-1 0.5-1 0.4 0 0.5 0.3 0.5 0.8v3.3c0 0.3 0.2 0.5 0.5 0.5s0.5-0.2 0.5-0.5z"></path></g>
<g id="vaadin:handle-corner"><path d="M6.7 16l9.3-9.3v-1.4l-10.7 10.7z"></path><path d="M9.7 16l6.3-6.3v-1.4l-7.7 7.7z"></path><path d="M12.7 16l3.3-3.3v-1.4l-4.7 4.7z"></path><path d="M15.7 16l0.3-0.3v-1.4l-1.7 1.7z"></path></g>
<g id="vaadin:hands-up"><path d="M10 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M6 16h1.5v-5h1v5h1.5v-9c-0-0.016-0.001-0.034-0.001-0.052 0-0.521 0.194-0.997 0.513-1.36l3.278-3.318c0.216-0.129 0.358-0.362 0.358-0.628 0-0.403-0.327-0.73-0.73-0.73-0.266 0-0.499 0.142-0.626 0.355l-2.362 2.383c-0.212 0.216-0.508 0.35-0.835 0.35-0.002 0-0.004 0-0.006-0h-3.18c-0.002 0-0.004 0-0.005 0-0.327 0-0.622-0.134-0.834-0.35l-2.32-2.39c-0.129-0.216-0.362-0.358-0.628-0.358-0.403 0-0.73 0.327-0.73 0.73 0 0.266 0.142 0.499 0.355 0.626l3.243 3.332c0.317 0.361 0.511 0.836 0.511 1.358 0 0.018-0 0.037-0.001 0.055l0 8.997z"></path></g>
<g id="vaadin:handshake"><path d="M13 3c-0.538 0.515-1.185 0.92-1.902 1.178-0.748 0.132-2.818-0.828-3.838 0.152-0.17 0.17-0.38 0.34-0.6 0.51-0.48-0.21-1.22-0.53-1.76-0.84s-1.9-1-1.9-1l-3 3.5s0.74 1 1.2 1.66c0.3 0.44 0.67 1.11 0.91 1.56l-0.34 0.4c-0.058 0.115-0.093 0.25-0.093 0.393 0 0.235 0.092 0.449 0.243 0.607 0.138 0.103 0.311 0.165 0.5 0.165s0.362-0.062 0.502-0.167c-0.094 0.109-0.149 0.249-0.149 0.402 0 0.193 0.088 0.365 0.226 0.479 0.144 0.085 0.317 0.135 0.501 0.135s0.357-0.050 0.505-0.137c-0.112 0.139-0.177 0.313-0.177 0.503s0.065 0.364 0.174 0.502c0.099 0.035 0.214 0.056 0.334 0.056 0.207 0 0.399-0.063 0.558-0.17-0.043 0.095-0.065 0.203-0.065 0.317 0 0.234 0.096 0.445 0.252 0.595 0.13 0.059 0.283 0.093 0.443 0.093 0.226 0 0.437-0.068 0.611-0.185l0.516-0.467c0.472 0.47 1.123 0.761 1.842 0.761 0.020 0 0.041-0 0.061-0.001 0.494-0.042 0.908-0.356 1.094-0.791 0.146 0.056 0.312 0.094 0.488 0.094 0.236 0 0.455-0.068 0.64-0.185 0.585-0.387 0.445-0.687 0.445-0.687 0.125 0.055 0.27 0.087 0.423 0.087 0.321 0 0.61-0.142 0.806-0.366 0.176-0.181 0.283-0.427 0.283-0.697 0-0.19-0.053-0.367-0.145-0.518 0.008 0.005 0.015 0.005 0.021 0.005 0.421 0 0.787-0.232 0.978-0.574 0.068-0.171 0.105-0.363 0.105-0.563 0-0.342-0.11-0.659-0.296-0.917l0.003 0.005c0.82-0.16 0.79-0.57 1.19-1.17 0.384-0.494 0.852-0.902 1.387-1.208zM12.95 10.060c-0.44 0.44-0.78 0.25-1.53-0.32s-2.24-1.64-2.24-1.64c0.061 0.305 0.202 0.57 0.401 0.781 0.319 0.359 1.269 1.179 1.719 1.599 0.28 0.26 1 0.78 0.58 1.18s-0.75 0-1.44-0.56-2.23-1.94-2.23-1.94c-0.001 0.018-0.002 0.038-0.002 0.059 0 0.258 0.104 0.491 0.272 0.661 0.17 0.2 1.12 1.12 1.52 1.54s0.75 0.67 0.41 1-1.030-0.19-1.41-0.58c-0.59-0.57-1.76-1.63-1.76-1.63-0.001 0.016-0.001 0.034-0.001 0.053 0 0.284 0.098 0.544 0.263 0.75 0.288 0.378 0.848 0.868 1.188 1.248s0.54 0.7 0 1-1.34-0.44-1.69-0.8c0-0.001 0-0.001 0-0.002 0-0.103-0.038-0.197-0.1-0.269-0.159-0.147-0.374-0.238-0.609-0.238-0.104 0-0.204 0.018-0.297 0.050 0.128-0.114 0.204-0.274 0.204-0.452s-0.076-0.338-0.198-0.45c-0.126-0.095-0.284-0.152-0.455-0.152s-0.33 0.057-0.457 0.153c0.117-0.113 0.189-0.268 0.189-0.441 0-0.213-0.109-0.4-0.274-0.509-0.153-0.097-0.336-0.153-0.532-0.153-0.244 0-0.468 0.088-0.642 0.233 0.095-0.114 0.151-0.26 0.151-0.42 0-0.195-0.085-0.37-0.219-0.491-0.178-0.165-0.417-0.266-0.679-0.266-0.185 0-0.358 0.050-0.507 0.138l-0.665-1.123c-0.46-0.73-1-1.49-1-1.49l2.28-2.77s0.81 0.5 1.48 0.88c0.33 0.19 0.9 0.44 1.33 0.64-0.68 0.51-1.25 1-1.080 1.34 0.297 0.214 0.668 0.343 1.069 0.343 0.376 0 0.726-0.113 1.018-0.307 0.373-0.251 0.84-0.403 1.343-0.403 0.347 0 0.677 0.072 0.976 0.203 0.554 0.374 1.574 1.294 2.504 1.874v0c1.17 0.85 1.4 1.4 1.12 1.68z"></path></g>
<g id="vaadin:harddrive-o"><path d="M2 12h1v1h-1v-1z"></path><path d="M4 12h3v1h-3v-1z"></path><path d="M13 1h-10l-3 9v5h16v-5l-3-9zM3.7 2h8.6l2.7 8h-13.9l2.6-8zM1 14v-3h14v3h-14z"></path></g>
<g id="vaadin:harddrive"><path d="M13 1h-10l-2.7 8h15.4z"></path><path d="M0 10v5h16v-5h-16zM3 13h-1v-1h1v1zM7 13h-3v-1h3v1z"></path></g>
<g id="vaadin:hash"><path d="M15 6v-2h-2.6l0.6-2.8-2-0.4-0.7 3.2h-3l0.7-2.8-2-0.4-0.7 3.2h-3.3v2h2.9l-0.9 4h-3v2h2.6l-0.6 2.8 2 0.4 0.7-3.2h3l-0.7 2.8 2 0.4 0.7-3.2h3.3v-2h-2.9l0.9-4h3zM9 10h-3l1-4h3l-1 4z"></path></g>
<g id="vaadin:header"><path d="M11 0v7h-6v-7h-3v16h3v-7h6v7h3v-16z"></path></g>
<g id="vaadin:headphones"><path d="M14 8.3v-2.3c0-3.3-2.7-6-6-6s-6 2.7-6 6v2.3c-1.2 0.5-2 1.7-2 3.1v1.2c0 1.8 1.3 3.2 3 3.4h2v-8h-1v-2c0-2.2 1.8-4 4-4s4 1.8 4 4v2h-1v8h2c1.7-0.2 3-1.7 3-3.4v-1.2c0-1.4-0.8-2.6-2-3.1zM4 15h-1v-6h1v6zM13 15h-1v-6h1v6z"></path></g>
<g id="vaadin:headset"><path d="M14.82 8c-0.309-0.851-0.969-1.511-1.799-1.813l-0.021-1.687c0-2.5-2.47-4.5-5.5-4.5s-5.5 2-5.5 4.5v1.68c-1.173 0.423-1.996 1.525-2 2.82v1c0 1.657 1.343 3 3 3h1v-7h-1v-1.5c0-1.93 2-3.5 4.5-3.5s4.5 1.57 4.5 3.5v1.5h-1v7h1c1.657 0 3-1.343 3-3v1.73c0 1.806-1.464 3.27-3.27 3.27h-1.73c0-0.552-0.448-1-1-1h-1c-0.552 0-1 0.448-1 1s0.448 1 1 1h3.73c2.358 0 4.27-1.912 4.27-4.27v-3.73h-1.18z"></path></g>
<g id="vaadin:health-card"><path d="M15 3v10h-14v-10h14zM16 2h-16v12h16v-12z"></path><path d="M9 5h5v1h-5v-1z"></path><path d="M9 7h5v1h-5v-1z"></path><path d="M9 9h2v1h-2v-1z"></path><path d="M6.5 5c0 0 0 0 0 0-0.6 0-1.1 0.6-1.5 1-0.4-0.4-0.9-1-1.5-1 0 0 0 0 0 0-1.5 0-2.1 1.9-1 2.9l2.5 2.1 2.5-2.1c1.1-1 0.5-2.9-1-2.9z"></path></g>
<g id="vaadin:heart-o"><path d="M11.7 2c-0.9 0-2.7 0.5-3.7 2.1-1-1.6-2.8-2.1-3.8-2.1-2.3 0-4.2 1.9-4.2 4.2 0 4 7.4 8.5 7.7 8.7l0.3 0.2 0.3-0.2c0.3-0.2 7.7-4.8 7.7-8.7 0-2.3-1.9-4.2-4.3-4.2zM8 13.9c-2.2-1.4-7-5-7-7.7 0-1.8 1.5-3.2 3.2-3.2 0.1 0 2.5 0.1 3.3 2.4l0.5 1.4 0.5-1.4c0.8-2.3 3.2-2.4 3.3-2.4 1.7 0 3.2 1.4 3.2 3.2 0 2.7-4.8 6.3-7 7.7z"></path></g>
<g id="vaadin:heart"><path d="M12 2c0 0-3 0-4 3-1-3-4-3-4-3-2.2 0-4 1.8-4 4 0 4.1 8 9 8 9s8-5 8-9c0-2.2-1.8-4-4-4z"></path></g>
<g id="vaadin:home-o"><path d="M16 6.6l-8-5.2-2 1.3v-1.7h-2v3l-4 2.6 1.9 2.7 0.1-0.1v5.8h5v-4h2v4h5v-5.8l0.1 0.1 1.9-2.7zM1.4 6.9l6.6-4.3 6.6 4.3-0.7 1-5.9-3.9-5.9 3.9-0.7-1zM13 14h-3v-4h-4v4h-3v-5.4l5-3.3 5 3.3v5.4z"></path></g>
<g id="vaadin:home"><path d="M8 1.4l-2 1.3v-1.7h-2v3l-4 2.6 0.6 0.8 7.4-4.8 7.4 4.8 0.6-0.8z"></path><path d="M8 4l-6 4v7h5v-3h2v3h5v-7z"></path></g>
<g id="vaadin:hospital"><path d="M15 4v-4h-7v4h-8v12h6v-3h4v3h6v-12h-1zM4 11h-2v-2h2v2zM4 8h-2v-2h2v2zM7 11h-2v-2h2v2zM7 8h-2v-2h2v2zM10 3v-1h1v-1h1v1h1v1h-1v1h-1v-1h-1zM11 11h-2v-2h2v2zM11 8h-2v-2h2v2zM14 11h-2v-2h2v2zM14 8h-2v-2h2v2z"></path></g>
<g id="vaadin:hourglass-empty"><path d="M11.18 6.060c1.107-0.808 1.819-2.101 1.82-3.56v-0.5h1v-2h-12v2h1v0.5c0.001 1.459 0.713 2.752 1.808 3.551 0.672 0.43 1.121 1.13 1.192 1.939-0.093 0.848-0.551 1.564-1.209 2.003-1.081 0.814-1.772 2.078-1.79 3.503l-0 0.503h-1v2h12v-2h-1v-0.5c-0.018-1.429-0.709-2.692-1.769-3.492-0.68-0.454-1.138-1.169-1.23-1.996 0.071-0.831 0.52-1.532 1.169-1.946zM9 8c0.072 1.142 0.655 2.136 1.519 2.763 0.877 0.623 1.445 1.61 1.481 2.732l0 0.505h-8v-0.5c0.036-1.127 0.604-2.114 1.459-2.723 0.886-0.642 1.468-1.635 1.54-2.766-0.063-1.124-0.641-2.091-1.498-2.683-0.914-0.633-1.499-1.662-1.502-2.827v-0.5h8v0.5c-0.003 1.166-0.587 2.195-1.479 2.813-0.88 0.607-1.458 1.574-1.521 2.678z"></path></g>
<g id="vaadin:hourglass-end"><path d="M11.18 6.060c1.107-0.808 1.819-2.101 1.82-3.56v-0.5h1v-2h-12v2h1v0.5c0.001 1.459 0.713 2.752 1.808 3.551 0.672 0.43 1.121 1.13 1.192 1.939-0.093 0.848-0.551 1.564-1.209 2.003-1.081 0.814-1.772 2.078-1.79 3.503l-0 0.503h-1v2h12v-2h-1v-0.5c-0.018-1.429-0.709-2.692-1.769-3.492-0.68-0.454-1.138-1.169-1.23-1.996 0.071-0.831 0.52-1.532 1.169-1.946zM9 8c0.072 1.142 0.655 2.136 1.519 2.763 0.877 0.623 1.445 1.61 1.481 2.732l0 0.505h-1s-1.62-3.5-3-3.5-3 3.5-3 3.5h-1v-0.5c0.036-1.127 0.604-2.114 1.459-2.723 0.886-0.642 1.468-1.635 1.54-2.766-0.063-1.124-0.641-2.091-1.498-2.683-0.914-0.633-1.499-1.662-1.502-2.827v-0.5h8v0.5c-0.003 1.166-0.587 2.195-1.479 2.813-0.88 0.607-1.458 1.574-1.521 2.678z"></path></g>
<g id="vaadin:hourglass-start"><path d="M6.16 4.6c1.114 0.734 1.84 1.979 1.84 3.394 0 0.002 0 0.004 0 0.006v-0c0-0.002 0-0.004 0-0.006 0-1.415 0.726-2.66 1.825-3.384 0.573-0.385 0.984-0.939 1.17-1.589l-5.995-0.020c0.191 0.67 0.603 1.225 1.15 1.594z"></path><path d="M11.18 6.060c1.107-0.808 1.819-2.101 1.82-3.56v-0.5h1v-2h-12v2h1v0.5c0.001 1.459 0.713 2.752 1.808 3.551 0.672 0.43 1.121 1.13 1.192 1.939-0.093 0.848-0.551 1.564-1.209 2.003-1.081 0.814-1.772 2.078-1.79 3.503l-0 0.503h-1v2h12v-2h-1v-0.5c-0.018-1.429-0.709-2.692-1.769-3.492-0.68-0.454-1.138-1.169-1.23-1.996 0.071-0.831 0.52-1.532 1.169-1.946zM9 8c0.072 1.142 0.655 2.136 1.519 2.763 0.877 0.623 1.445 1.61 1.481 2.732l0 0.505h-8v-0.5c0.036-1.127 0.604-2.114 1.459-2.723 0.886-0.642 1.468-1.635 1.54-2.766-0.063-1.124-0.641-2.091-1.498-2.683-0.914-0.633-1.499-1.662-1.502-2.827v-0.5h8v0.5c-0.003 1.166-0.587 2.195-1.479 2.813-0.88 0.607-1.458 1.574-1.521 2.678z"></path></g>
<g id="vaadin:hourglass"><path d="M6.16 4.6c1.114 0.734 1.84 1.979 1.84 3.394 0 0.002 0 0.004 0 0.006v-0c0-0.002 0-0.004 0-0.006 0-1.415 0.726-2.66 1.825-3.384 0.23-0.199 0.426-0.395 0.609-0.602l-4.874-0.007c0.19 0.214 0.386 0.41 0.593 0.594z"></path><path d="M11.18 6.060c1.107-0.808 1.819-2.101 1.82-3.56v-0.5h1v-2h-12v2h1v0.5c0.001 1.459 0.713 2.752 1.808 3.551 0.672 0.43 1.121 1.13 1.192 1.939-0.093 0.848-0.551 1.564-1.209 2.003-1.081 0.814-1.772 2.078-1.79 3.503l-0 0.503h-1v2h12v-2h-1v-0.5c-0.018-1.429-0.709-2.692-1.769-3.492-0.68-0.454-1.138-1.169-1.23-1.996 0.071-0.831 0.52-1.532 1.169-1.946zM9 8c0.072 1.142 0.655 2.136 1.519 2.763 0.877 0.623 1.445 1.61 1.481 2.732l0 0.505h-1.77c-0.7-0.87-1.71-2-2.23-2s-1.53 1.13-2.23 2h-1.77v-0.5c0.036-1.127 0.604-2.114 1.459-2.723 0.886-0.642 1.468-1.635 1.54-2.766-0.063-1.124-0.641-2.091-1.498-2.683-0.914-0.633-1.499-1.662-1.502-2.827v-0.5h8v0.5c-0.003 1.166-0.587 2.195-1.479 2.813-0.88 0.607-1.458 1.574-1.521 2.678z"></path></g>
<g id="vaadin:inbox"><path d="M10 6v-6h-4v6h-2l4 5 4-5z"></path><path d="M13 1h-2v1h1.3l2.6 8h-3.9v2h-6v-2h-3.9l2.6-8h1.3v-1h-2l-3 9v5h16v-5z"></path></g>
<g id="vaadin:indent"><path d="M0 0h16v3h-16v-3z"></path><path d="M6 4h10v3h-10v-3z"></path><path d="M6 8h10v3h-10v-3z"></path><path d="M0 12h16v3h-16v-3z"></path><path d="M0 4.5v6l4-3z"></path></g>
<g id="vaadin:info-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M7 6h2v7h-2v-7z"></path><path d="M7 3h2v2h-2v-2z"></path></g>
<g id="vaadin:info-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM9 13h-2v-7h2v7zM9 5h-2v-2h2v2z"></path></g>
<g id="vaadin:info"><path d="M6 5h4v11h-4v-11z"></path><path d="M10 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:input"><path d="M16 5c0-0.6-0.4-1-1-1h-14c-0.6 0-1 0.4-1 1v6c0 0.6 0.4 1 1 1h14c0.6 0 1-0.4 1-1v-6zM15 11h-14v-6h14v6z"></path><path d="M2 6h1v4h-1v-4z"></path></g>
<g id="vaadin:insert"><path d="M14 16v-11l-1 1v9h-12v-12h9l1-1h-11v14z"></path><path d="M16 1.4l-1.4-1.4-6.8 6.8-1.8-1.8v5h5l-1.8-1.8z"></path></g>
<g id="vaadin:institution"><path d="M8 0l-8 3v2h16v-2z"></path><path d="M0 14h16v2h-16v-2z"></path><path d="M16 7v-1h-16v1h1v5h-1v1h16v-1h-1v-5h1zM4 12h-1v-5h1v5zM7 12h-1v-5h1v5zM10 12h-1v-5h1v5zM13 12h-1v-5h1v5z"></path></g>
<g id="vaadin:invoice"><path d="M4.4 10.2c-0.6 0.1-1.4-0.3-1.7-0.4l-0.5 0.9c0 0 0.9 0.4 1.7 0.5v0.8h1v-0.9c0.9-0.3 1.4-1.1 1.5-1.8 0-0.8-0.6-1.4-1.9-1.9-0.4-0.2-1.1-0.5-1.1-0.9 0-0.5 0.4-0.8 1-0.8 0.7 0 1.4 0.3 1.4 0.3l0.4-0.9c0 0-0.5-0.2-1.2-0.4v-0.7h-1v0.7c-0.9 0.2-1.5 0.8-1.6 1.7 0 1.2 1.3 1.7 1.8 1.9 0.6 0.2 1.3 0.6 1.3 0.9 0 0.4-0.4 0.9-1.1 1z"></path><path d="M0 2v12h16v-12h-16zM15 13h-14v-10h14v10z"></path><path d="M8 5h6v1h-6v-1z"></path><path d="M8 7h6v1h-6v-1z"></path><path d="M8 9h3v1h-3v-1z"></path></g>
<g id="vaadin:italic"><path d="M8 0h3l-3 16h-3z"></path></g>
<g id="vaadin:key-o"><path d="M13 0l-7 6.1c-0.3-0.1-0.6-0.1-1-0.1-2.8 0-5 2.2-5 5s2.3 5 5 5 5-2.2 5-5c0-0.3 0-0.6-0.1-0.9l1.1-1.1v-2h2v-2h2l1-1v-4h-3zM12 6h-1.7l1.7-1.4v1.4zM15 3.6l-0.4 0.4h-1.9l2.3-2v1.6zM7.3 7.6l0.7 0.4 2-1.7v2.3l-0.8 0.8-0.3 0.4 0.1 0.5c0 0.2 0.1 0.5 0.1 0.7 0 2.2-1.8 4-4 4s-4-1.8-4-4 1.8-4 4-4c0.3 0 0.5 0 0.8 0.1l0.5 0.1 0.4-0.3 6.6-5.9h1.6l-7.7 6.6z"></path><path d="M6 11.5c0 0.828-0.672 1.5-1.5 1.5s-1.5-0.672-1.5-1.5c0-0.828 0.672-1.5 1.5-1.5s1.5 0.672 1.5 1.5z"></path></g>
<g id="vaadin:key"><path d="M8.1 7c-0.2-0.1-0.4-0.2-0.6-0.3l7.5-6.7h-2l-7 6.1c-0.3-0.1-0.6-0.1-1-0.1-2.8 0-5 2.2-5 5s2.3 5 5 5 5-2.2 5-5c0-0.6-0.1-1.2-0.3-1.7l1.3-1.3v-2h2v-2h2l1-1v-3l-7.9 7zM4 13.2c-0.7 0-1.2-0.6-1.2-1.2s0.6-1.2 1.2-1.2 1.2 0.6 1.2 1.2-0.5 1.2-1.2 1.2z"></path></g>
<g id="vaadin:keyboard-o"><path d="M15 5v7h-14v-7h14zM16 4h-16v9h16v-9z"></path><path d="M4 10h8v1h-8v-1z"></path><path d="M2 10h1v1h-1v-1z"></path><path d="M13 10h1v1h-1v-1z"></path><path d="M11 8h1v1h-1v-1z"></path><path d="M9 8h1v1h-1v-1z"></path><path d="M7 8h1v1h-1v-1z"></path><path d="M5 8h1v1h-1v-1z"></path><path d="M3 8h1v1h-1v-1z"></path><path d="M10 6h1v1h-1v-1z"></path><path d="M12 6v1h1v2h1v-3z"></path><path d="M8 6h1v1h-1v-1z"></path><path d="M6 6h1v1h-1v-1z"></path><path d="M4 6h1v1h-1v-1z"></path><path d="M2 6h1v1h-1v-1z"></path></g>
<g id="vaadin:keyboard"><path d="M0 4v9h16v-9h-16zM10 6h1v1h-1v-1zM8 6h1v1h-1v-1zM10 8v1h-1v-1h1zM6 6h1v1h-1v-1zM8 8v1h-1v-1h1zM4 6h1v1h-1v-1zM6 8v1h-1v-1h1zM2 6h1v1h-1v-1zM3 11h-1v-1h1v1zM3 8h1v1h-1v-1zM12 11h-8v-1h8v1zM12 9h-1v-1h1v1zM14 11h-1v-1h1v1zM14 9h-1v-2h-1v-1h2v3z"></path></g>
<g id="vaadin:laptop"><path d="M14 11v-9h-12v9h-2v2h16v-2h-2zM10 12h-4v-1h4v1zM13 10h-10v-7h10v7z"></path></g>
<g id="vaadin:layout"><path d="M0 0v16h16v-16h-16zM1 3h4v12h-4v-12zM15 15h-9v-12h9v12z"></path></g>
<g id="vaadin:level-down-bold"><path d="M9 16l4-7h-3v-9h-7l2 3h2v6h-3z"></path></g>
<g id="vaadin:level-down"><path d="M5 1h6v11h2l-3 3-3-3h2v-9h-6z"></path></g>
<g id="vaadin:level-left-bold"><path d="M0 7l7-4v3h9v7l-3-2v-2h-6v3z"></path></g>
<g id="vaadin:level-left"><path d="M15 12v-6h-11v-2l-3 3 3 3v-2h9v6z"></path></g>
<g id="vaadin:level-right-bold"><path d="M16 7l-7-4v3h-9v7l3-2v-2h6v3z"></path></g>
<g id="vaadin:level-right"><path d="M1 12v-6h11v-2l3 3-3 3v-2h-9v6z"></path></g>
<g id="vaadin:level-up-bold"><path d="M9 0l4 7h-3v9h-7l2-3h2v-6h-3z"></path></g>
<g id="vaadin:level-up"><path d="M11 15h-6v-11h-2l3-3 3 3h-2v9h6z"></path></g>
<g id="vaadin:lifebuoy"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM4 8c0-2.2 1.8-4 4-4s4 1.8 4 4c0 2.2-1.8 4-4 4s-4-1.8-4-4zM12.6 9.8c0.3-0.5 0.4-1.2 0.4-1.8s-0.1-1.3-0.4-1.8l1.5-1.5c0.6 1 0.9 2.1 0.9 3.3s-0.3 2.3-0.8 3.3l-1.6-1.5zM11.3 1.8l-1.5 1.6c-0.5-0.3-1.2-0.4-1.8-0.4s-1.3 0.1-1.8 0.4l-1.5-1.6c1-0.5 2.1-0.8 3.3-0.8s2.3 0.3 3.3 0.8zM1.8 4.7l1.5 1.5c-0.2 0.5-0.3 1.2-0.3 1.8s0.1 1.3 0.4 1.8l-1.5 1.5c-0.6-1-0.9-2.1-0.9-3.3s0.3-2.3 0.8-3.3zM4.7 14.2l1.5-1.5c0.5 0.2 1.2 0.3 1.8 0.3s1.3-0.1 1.8-0.4l1.5 1.5c-1 0.6-2.1 0.9-3.3 0.9s-2.3-0.3-3.3-0.8z"></path></g>
<g id="vaadin:lightbulb"><path d="M8 0c-2.761 0-5 2.239-5 5 0.013 1.672 0.878 3.138 2.182 3.989l0.818 2.011c-0.276 0-0.5 0.224-0.5 0.5s0.224 0.5 0.5 0.5c-0.276 0-0.5 0.224-0.5 0.5s0.224 0.5 0.5 0.5c-0.276 0-0.5 0.224-0.5 0.5s0.224 0.5 0.5 0.5c-0.276 0-0.5 0.224-0.5 0.5s0.224 0.5 0.5 0.5h0.41c0.342 0.55 0.915 0.929 1.581 0.999 0.684-0.071 1.258-0.449 1.594-0.99l0.415-0.009c0.276 0 0.5-0.224 0.5-0.5s-0.224-0.5-0.5-0.5c0.276 0 0.5-0.224 0.5-0.5s-0.224-0.5-0.5-0.5c0.276 0 0.5-0.224 0.5-0.5s-0.224-0.5-0.5-0.5c0.276 0 0.5-0.224 0.5-0.5s-0.224-0.5-0.5-0.5l0.8-2c1.322-0.862 2.187-2.328 2.2-3.998 0-2.763-2.239-5.002-5-5.002zM10.25 8.21l-0.25 0.17-0.11 0.29-0.89 2.14c-0.042 0.111-0.147 0.189-0.27 0.19h-1.51c-0.103-0.020-0.186-0.093-0.219-0.188l-0.871-2.142-0.13-0.29-0.25-0.18c-1.045-0.7-1.729-1.868-1.75-3.197-0-2.212 1.791-4.003 4-4.003s4 1.791 4 4c-0.017 1.336-0.702 2.509-1.736 3.201z"></path><path d="M10.29 3c-0.574-0.612-1.387-0.995-2.289-1l-0.001 1c0.585 0.002 1.115 0.238 1.5 0.62 0.278 0.386 0.459 0.858 0.499 1.37l1.001 0.009c-0.045-0.756-0.305-1.443-0.718-2.011z"></path></g>
<g id="vaadin:line-bar-chart"><path d="M5 11h3v5h-3v-5z"></path><path d="M1 14h3v2h-3v-2z"></path><path d="M13 12h3v4h-3v-4z"></path><path d="M9 9h3v7h-3v-7z"></path><path d="M16 0.070l-5.68 4.97-5.47-1.7-4.85 3.76v1.9l5.15-4 5.53 1.72 5.32-4.66v-1.99z"></path></g>
<g id="vaadin:line-chart"><path d="M1 15v-15h-1v16h16v-1h-15z"></path><path d="M9 8l-3-3-4 4v2l4-4 3 3 7-7v-2z"></path></g>
<g id="vaadin:line-h"><path d="M0 7h16v1h-16v-1z"></path></g>
<g id="vaadin:line-v"><path d="M8 0h1v16h-1v-16z"></path></g>
<g id="vaadin:lines-list"><path d="M0 1h3v2h-3v-2z"></path><path d="M0 5h3v2h-3v-2z"></path><path d="M0 9h3v2h-3v-2z"></path><path d="M0 13h3v2h-3v-2z"></path><path d="M4 1h12v2h-12v-2z"></path><path d="M4 5h12v2h-12v-2z"></path><path d="M4 9h12v2h-12v-2z"></path><path d="M4 13h12v2h-12v-2z"></path></g>
<g id="vaadin:lines"><path d="M0 1h16v2h-16v-2z"></path><path d="M0 5h16v2h-16v-2z"></path><path d="M0 9h16v2h-16v-2z"></path><path d="M0 13h16v2h-16v-2z"></path></g>
<g id="vaadin:link"><path d="M14.9 1.1c-1.4-1.4-3.7-1.4-5.1 0l-4.4 4.3c-1.4 1.5-1.4 3.7 0 5.2 0.1 0.1 0.3 0.2 0.4 0.3l1.5-1.5c-0.1-0.1-0.3-0.2-0.4-0.3-0.6-0.6-0.6-1.6 0-2.2l4.4-4.4c0.6-0.6 1.6-0.6 2.2 0s0.6 1.6 0 2.2l-1.3 1.3c0.4 0.8 0.5 1.7 0.4 2.5l2.3-2.3c1.5-1.4 1.5-3.7 0-5.1z"></path><path d="M10.2 5.1l-1.5 1.5c0 0 0.3 0.2 0.4 0.3 0.6 0.6 0.6 1.6 0 2.2l-4.4 4.4c-0.6 0.6-1.6 0.6-2.2 0s-0.6-1.6 0-2.2l1.3-1.3c-0.4-0.8-0.1-1.3-0.4-2.5l-2.3 2.3c-1.4 1.4-1.4 3.7 0 5.1s3.7 1.4 5.1 0l4.4-4.4c1.4-1.4 1.4-3.7 0-5.1-0.2-0.1-0.4-0.3-0.4-0.3z"></path></g>
<g id="vaadin:list-ol"><path d="M4 0h12v4h-12v-4z"></path><path d="M4 6h12v4h-12v-4z"></path><path d="M4 12h12v4h-12v-4z"></path><path d="M1 0l-0.9 0.5 0.2 0.7 0.7-0.3v3.1h1v-4z"></path><path d="M2.2 13.9c0.3-0.2 0.5-0.5 0.5-0.8 0-0.5-0.4-1-1.3-1-0.5 0-1 0.1-1.2 0.3h-0.1l0.2 0.8 0.1-0.1c0.1-0.1 0.4-0.2 0.7-0.2s0.4 0.1 0.4 0.3c0 0.4-0.5 0.4-0.6 0.4h-0.4v0.7h0.4c0.3 0 0.6 0.1 0.6 0.4 0 0.2-0.2 0.4-0.6 0.4s-0.7-0.2-0.8-0.2l-0.1-0.1v0.9h0.1c0.2 0.2 0.6 0.3 1.1 0.3 1 0 1.6-0.5 1.6-1.2 0-0.4-0.2-0.8-0.6-0.9z"></path><path d="M0.1 6.4l0.3 1c0 0 0.7-0.6 1.2-0.3 1.1 0.8-1.6 2.4-1.6 2.4v0.5h3v-1h-1.2c0.6-0.5 1.2-1.2 1-1.9-0.5-1.9-2.7-0.7-2.7-0.7z"></path></g>
<g id="vaadin:list-select"><path d="M1 0h12v2h-12v-2z"></path><path d="M1 8h13v2h-13v-2z"></path><path d="M1 11h11v2h-11v-2z"></path><path d="M1 14h14v2h-14v-2z"></path><path d="M0 3v4h16v-4h-16zM11 6h-10v-2h10v2z"></path></g>
<g id="vaadin:list-ul"><path d="M0 1h3v3h-3v-3z"></path><path d="M0 6h3v3h-3v-3z"></path><path d="M0 11h3v3h-3v-3z"></path><path d="M5 1h11v3h-11v-3z"></path><path d="M5 6h11v3h-11v-3z"></path><path d="M5 11h11v3h-11v-3z"></path></g>
<g id="vaadin:list"><path d="M0 0h4v3h-4v-3z"></path><path d="M0 4h4v3h-4v-3z"></path><path d="M0 12h4v3h-4v-3z"></path><path d="M0 8h4v3h-4v-3z"></path><path d="M5 0h11v3h-11v-3z"></path><path d="M5 4h11v3h-11v-3z"></path><path d="M5 12h11v3h-11v-3z"></path><path d="M5 8h11v3h-11v-3z"></path></g>
<g id="vaadin:location-arrow-circle-o"><path d="M1 8c0-3.9 3.1-7 7-7s7 3.1 7 7-3.1 7-7 7-7-3.1-7-7zM0 8c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8-8 3.6-8 8v0z"></path><path d="M2 9l10-5-5 10v-5z"></path></g>
<g id="vaadin:location-arrow-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM7 14v-5h-5l10-5-5 10z"></path></g>
<g id="vaadin:location-arrow"><path d="M0 9l16-9-9 16v-7z"></path></g>
<g id="vaadin:lock"><path d="M12 8v-3.1c0-2.2-1.6-3.9-3.8-3.9h-0.3c-2.1 0-3.9 1.7-3.9 3.9v3.1h-1l0.1 5c0 0-0.1 3 4.9 3s5-3 5-3v-5h-1zM9 14h-1v-2c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1v3zM10 8h-4v-3.1c0-1.1 0.9-1.9 1.9-1.9h0.3c1 0 1.8 0.8 1.8 1.9v3.1z"></path></g>
<g id="vaadin:magic"><path d="M0 5h3v1h-3v-1z"></path><path d="M5 0h1v3h-1v-3z"></path><path d="M6 11h-1v-2.5l1 1z"></path><path d="M11 6h-1.5l-1-1h2.5z"></path><path d="M3.131 7.161l0.707 0.707-2.97 2.97-0.707-0.707 2.97-2.97z"></path><path d="M10.131 0.161l0.707 0.707-2.97 2.97-0.707-0.707 2.97-2.97z"></path><path d="M0.836 0.199l3.465 3.465-0.707 0.707-3.465-3.465 0.707-0.707z"></path><path d="M6.1 4.1l-2.1 2 9.8 9.9 2.2-2.1-9.9-9.8zM6.1 5.5l2.4 2.5-0.6 0.6-2.5-2.5 0.7-0.6z"></path></g>
<g id="vaadin:magnet"><path d="M11 0h5v4h-5v-4z"></path><path d="M11 5v3c0 1.6-1.4 3-3 3s-3-1.4-3-3v-3h-5v3c0 4.4 3.6 8 8 8s8-3.6 8-8v-3h-5z"></path><path d="M0 0h5v4h-5v-4z"></path></g>
<g id="vaadin:mailbox"><path d="M13 1h-10l-3 9v5h16v-5l-3-9zM11 10v2h-6v-2h-3.9l2.7-8h8.6l2.7 8h-4.1z"></path></g>
<g id="vaadin:male"><path d="M10 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M12.79 7.32l-2.6-2.63c-0.421-0.426-1.004-0.69-1.65-0.69h-1.070c-0 0-0 0-0.001 0-0.648 0-1.235 0.264-1.659 0.69l-2.6 2.63c-0.216 0.129-0.358 0.362-0.358 0.628 0 0.403 0.327 0.73 0.73 0.73 0.266 0 0.499-0.142 0.626-0.355l1.792-1.793v9.47h1.5v-5h1v5h1.5v-9.47l1.75 1.8c0.135 0.175 0.344 0.287 0.58 0.287 0.403 0 0.73-0.327 0.73-0.73 0-0.228-0.105-0.432-0.269-0.566z"></path></g>
<g id="vaadin:map-marker"><path d="M8 0c-2.8 0-5 2.2-5 5s4 11 5 11c1 0 5-8.2 5-11s-2.2-5-5-5zM8 8c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3z"></path></g>
<g id="vaadin:margin-bottom"><path d="M0 0v14h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v-13h-16zM15 12h-14v-11h14v11z"></path><path d="M0 15h1v1h-1v-1z"></path><path d="M1 14h1v1h-1v-1z"></path><path d="M2 15h1v1h-1v-1z"></path><path d="M3 14h1v1h-1v-1z"></path><path d="M4 15h1v1h-1v-1z"></path><path d="M5 14h1v1h-1v-1z"></path><path d="M6 15h1v1h-1v-1z"></path><path d="M7 14h1v1h-1v-1z"></path><path d="M8 15h1v1h-1v-1z"></path><path d="M9 14h1v1h-1v-1z"></path><path d="M10 15h1v1h-1v-1z"></path><path d="M11 14h1v1h-1v-1z"></path><path d="M12 15h1v1h-1v-1z"></path><path d="M13 14h1v1h-1v-1z"></path><path d="M14 15h1v1h-1v-1z"></path><path d="M15 14h1v1h-1v-1z"></path></g>
<g id="vaadin:margin-left"><path d="M2 0v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h13v-16h-14zM15 15h-11v-14h11v14z"></path><path d="M0 0h1v1h-1v-1z"></path><path d="M1 1h1v1h-1v-1z"></path><path d="M0 2h1v1h-1v-1z"></path><path d="M1 3h1v1h-1v-1z"></path><path d="M0 4h1v1h-1v-1z"></path><path d="M1 5h1v1h-1v-1z"></path><path d="M0 6h1v1h-1v-1z"></path><path d="M1 7h1v1h-1v-1z"></path><path d="M0 8h1v1h-1v-1z"></path><path d="M1 9h1v1h-1v-1z"></path><path d="M0 10h1v1h-1v-1z"></path><path d="M1 11h1v1h-1v-1z"></path><path d="M0 12h1v1h-1v-1z"></path><path d="M1 13h1v1h-1v-1z"></path><path d="M0 14h1v1h-1v-1z"></path><path d="M1 15h1v1h-1v-1z"></path></g>
<g id="vaadin:margin-right"><path d="M14 2v-1h-1v-1h-13v16h14v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1zM12 15h-11v-14h11v14z"></path><path d="M15 15h1v1h-1v-1z"></path><path d="M14 14h1v1h-1v-1z"></path><path d="M15 13h1v1h-1v-1z"></path><path d="M14 12h1v1h-1v-1z"></path><path d="M15 11h1v1h-1v-1z"></path><path d="M14 10h1v1h-1v-1z"></path><path d="M15 9h1v1h-1v-1z"></path><path d="M14 8h1v1h-1v-1z"></path><path d="M15 7h1v1h-1v-1z"></path><path d="M14 6h1v1h-1v-1z"></path><path d="M15 5h1v1h-1v-1z"></path><path d="M14 4h1v1h-1v-1z"></path><path d="M15 3h1v1h-1v-1z"></path><path d="M14 2h1v1h-1v-1z"></path><path d="M15 1h1v1h-1v-1z"></path><path d="M14 0h1v1h-1v-1z"></path></g>
<g id="vaadin:margin-top"><path d="M15 2v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v13h16v-14h-1zM15 15h-14v-11h14v11z"></path><path d="M15 0h1v1h-1v-1z"></path><path d="M14 1h1v1h-1v-1z"></path><path d="M13 0h1v1h-1v-1z"></path><path d="M12 1h1v1h-1v-1z"></path><path d="M11 0h1v1h-1v-1z"></path><path d="M10 1h1v1h-1v-1z"></path><path d="M9 0h1v1h-1v-1z"></path><path d="M8 1h1v1h-1v-1z"></path><path d="M7 0h1v1h-1v-1z"></path><path d="M6 1h1v1h-1v-1z"></path><path d="M5 0h1v1h-1v-1z"></path><path d="M4 1h1v1h-1v-1z"></path><path d="M3 0h1v1h-1v-1z"></path><path d="M2 1h1v1h-1v-1z"></path><path d="M1 0h1v1h-1v-1z"></path><path d="M0 1h1v1h-1v-1z"></path></g>
<g id="vaadin:margin"><path d="M0 0h1v1h-1v-1z"></path><path d="M2 0h1v1h-1v-1z"></path><path d="M1 1h1v1h-1v-1z"></path><path d="M0 2h1v1h-1v-1z"></path><path d="M2 2h1v1h-1v-1z"></path><path d="M1 3h1v1h-1v-1z"></path><path d="M0 4h1v1h-1v-1z"></path><path d="M1 5h1v1h-1v-1z"></path><path d="M0 6h1v1h-1v-1z"></path><path d="M1 7h1v1h-1v-1z"></path><path d="M0 8h1v1h-1v-1z"></path><path d="M1 9h1v1h-1v-1z"></path><path d="M0 10h1v1h-1v-1z"></path><path d="M1 11h1v1h-1v-1z"></path><path d="M0 12h1v1h-1v-1z"></path><path d="M1 13h1v1h-1v-1z"></path><path d="M0 14h1v1h-1v-1z"></path><path d="M2 14h1v1h-1v-1z"></path><path d="M1 15h1v1h-1v-1z"></path><path d="M3 15h1v1h-1v-1z"></path><path d="M5 15h1v1h-1v-1z"></path><path d="M4 0h1v1h-1v-1z"></path><path d="M3 1h1v1h-1v-1z"></path><path d="M5 1h1v1h-1v-1z"></path><path d="M4 14h1v1h-1v-1z"></path><path d="M6 0h1v1h-1v-1z"></path><path d="M8 0h1v1h-1v-1z"></path><path d="M7 1h1v1h-1v-1z"></path><path d="M6 14h1v1h-1v-1z"></path><path d="M8 14h1v1h-1v-1z"></path><path d="M7 15h1v1h-1v-1z"></path><path d="M9 15h1v1h-1v-1z"></path><path d="M11 15h1v1h-1v-1z"></path><path d="M10 0h1v1h-1v-1z"></path><path d="M9 1h1v1h-1v-1z"></path><path d="M11 1h1v1h-1v-1z"></path><path d="M10 14h1v1h-1v-1z"></path><path d="M12 0h1v1h-1v-1z"></path><path d="M14 0h1v1h-1v-1z"></path><path d="M13 1h1v1h-1v-1z"></path><path d="M13 2h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1zM12 12h-8v-8h8v8z"></path><path d="M14 2h1v1h-1v-1z"></path><path d="M14 4h1v1h-1v-1z"></path><path d="M14 6h1v1h-1v-1z"></path><path d="M14 8h1v1h-1v-1z"></path><path d="M14 10h1v1h-1v-1z"></path><path d="M14 12h1v1h-1v-1z"></path><path d="M13 13h1v1h-1v-1z"></path><path d="M12 14h1v1h-1v-1z"></path><path d="M14 14h1v1h-1v-1z"></path><path d="M13 15h1v1h-1v-1z"></path><path d="M15 15h1v1h-1v-1z"></path><path d="M15 1h1v1h-1v-1z"></path><path d="M15 3h1v1h-1v-1z"></path><path d="M15 5h1v1h-1v-1z"></path><path d="M15 7h1v1h-1v-1z"></path><path d="M15 9h1v1h-1v-1z"></path><path d="M15 11h1v1h-1v-1z"></path><path d="M15 13h1v1h-1v-1z"></path></g>
<g id="vaadin:medal"><path d="M10 12.2c-0.3 0-0.5-0.1-0.8-0.2l-1.2-0.5-1.2 0.5c-0.2 0.1-0.5 0.2-0.8 0.2-0.2 0-0.3 0-0.5-0.1l-0.5 3.9 3-2 3 2-0.6-3.9c-0.1 0.1-0.3 0.1-0.4 0.1z"></path><path d="M12.9 5.9c-0.1-0.2-0.1-0.5 0-0.7l0.6-1.2c0.2-0.4 0-0.9-0.5-1.1l-1.3-0.5c-0.2-0.1-0.4-0.3-0.5-0.5l-0.5-1.3c-0.1-0.4-0.4-0.6-0.7-0.6-0.1 0-0.3 0-0.4 0.1l-1.3 0.6c-0.1 0-0.2 0-0.3 0s-0.2 0-0.3-0.1l-1.3-0.5c-0.1-0.1-0.3-0.1-0.4-0.1-0.3 0-0.6 0.2-0.8 0.5l-0.5 1.4c0 0.2-0.2 0.4-0.4 0.5l-1.4 0.5c-0.4 0.1-0.6 0.6-0.4 1.1l0.6 1.3c0.1 0.2 0.1 0.5 0 0.7l-0.6 1.2c-0.2 0.4 0 0.9 0.5 1.1l1.3 0.5c0.2 0.1 0.4 0.3 0.5 0.5l0.5 1.3c0.1 0.4 0.4 0.6 0.7 0.6 0.1 0 0.2 0 0.3-0.1l1.3-0.6c0.1 0 0.2-0.1 0.3-0.1s0.2 0 0.3 0.1l1.3 0.6c0.1 0.1 0.2 0.1 0.3 0.1 0.3 0 0.6-0.2 0.8-0.5l0.5-1.3c0.1-0.2 0.3-0.4 0.5-0.5l1.3-0.5c0.4-0.2 0.7-0.7 0.5-1.1l-0.5-1.4zM8 9.6c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4c0 2.2-1.8 4-4 4z"></path><path d="M11 5.6c0 1.657-1.343 3-3 3s-3-1.343-3-3c0-1.657 1.343-3 3-3s3 1.343 3 3z"></path></g>
<g id="vaadin:megaphone"><path d="M15.5 5.4l-0.5-0.4v-4c0-0.6-0.4-1-1-1s-1 0.4-1 1v0.5c-2 0.9-5 2.5-8 2.5h-2.5c-1.4 0-2.5 1.2-2.5 2.5 0 0.9 0.5 1.7 1.2 2.1l1.1 5.9c0 0.3 0.3 0.5 0.7 0.5 0.1 0 0.1 0 0.2 0l3.6-0.7c0.4-0.1 0.6-0.4 0.5-0.7-0.3-0.6-0.8-1.5-1.2-1.8-0.2-0.1-0.5-0.9-0.7-1.8h0.6v-0.9c2.7 0.3 6 1.6 7 2.4v0.5c0 0.6 0.4 1 1 1s1-0.4 1-1v-4l0.4-0.3c0.4-0.3 0.6-0.7 0.6-1.1v-0.2c0-0.4-0.2-0.7-0.5-1zM2 5h3v1h-3v-1zM5.6 12.6c0.1 0 0.3 0.3 0.5 0.7l-2.8 0.7-1-5h1.9c0.2 1.3 0.6 3.2 1.4 3.6zM13 10.3c-1.6-0.8-4.4-2-7-2.3v-3c2.6-0.3 5.4-1.4 7-2.3v7.6z"></path></g>
<g id="vaadin:meh-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M7 6c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M11 6c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M4 10h8v1h-8v-1z"></path></g>
<g id="vaadin:menu"><path d="M0 1h16v3h-16v-3z"></path><path d="M0 6h16v3h-16v-3z"></path><path d="M0 11h16v3h-16v-3z"></path></g>
<g id="vaadin:microphone"><path d="M8 10v0c-1.7 0-3-1.3-3-3v-4c0-1.6 1.3-3 3-3v0c1.6 0 3 1.3 3 3v4c0 1.6-1.4 3-3 3z"></path><path d="M12 5v2.5c0 1.9-1.8 3.5-3.8 3.5h-0.4c-2 0-3.8-1.6-3.8-3.5v-2.5c-0.6 0-1 0.4-1 1v1.5c0 2.2 1.8 4.1 4 4.4v2.1c-3 0-2.5 2-2.5 2h7c0 0 0.5-2-2.5-2v-2.1c2.2-0.4 4-2.2 4-4.4v-1.5c0-0.6-0.4-1-1-1z"></path></g>
<g id="vaadin:minus-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M3 7h10v2h-10v-2z"></path></g>
<g id="vaadin:minus-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM13 9h-10v-2h10v2z"></path></g>
<g id="vaadin:minus-square-o"><path d="M4 7h8v2h-8v-2z"></path><path d="M15 1h-14v14h14v-14zM14 14h-12v-12h12v12z"></path></g>
<g id="vaadin:minus"><path d="M2 7h12v2h-12v-2z"></path></g>
<g id="vaadin:mobile-browser"><path d="M16 0h-13v5h-3v11h7v-3h9v-13zM6 1h9v1h-9v-1zM4 1h1v1h-1v-1zM4 15h-1v-1h1v1zM6 13h-5v-7h5v7zM15 12h-8v-7h-3v-2h11v9z"></path></g>
<g id="vaadin:mobile-retro"><path d="M11 0h-1v2h-6v14h7v-16zM6 14h-1v-1h1v1zM6 12h-1v-1h1v1zM6 10h-1v-1h1v1zM8 14h-1v-1h1v1zM8 12h-1v-1h1v1zM8 10h-1v-1h1v1zM10 14h-1v-1h1v1zM10 12h-1v-1h1v1zM10 10h-1v-1h1v1zM10 8h-5v-4h5v4z"></path></g>
<g id="vaadin:mobile"><path d="M4 1v14h8v-14h-8zM9 14h-2v-1h2v1zM11 12h-6v-9h6v9z"></path></g>
<g id="vaadin:modal-list"><path d="M3 6h2v1h-2v-1z"></path><path d="M6 6h7v1h-7v-1z"></path><path d="M3 8h2v1h-2v-1z"></path><path d="M6 8h7v1h-7v-1z"></path><path d="M3 10h2v1h-2v-1z"></path><path d="M6 10h7v1h-7v-1z"></path><path d="M0 1v14h16v-14h-16zM15 14h-14v-10h14v10zM15 3h-1v-1h1v1z"></path></g>
<g id="vaadin:modal"><path d="M0 1v14h16v-14h-16zM15 14h-14v-10h14v10zM15 3h-1v-1h1v1z"></path></g>
<g id="vaadin:money-deposit"><path d="M8 16l-2-3h1v-2h2v2h1l-2 3z"></path><path d="M15 1v8h-14v-8h14zM16 0h-16v10h16v-10z"></path><path d="M8 2c1.657 0 3 1.343 3 3s-1.343 3-3 3h5v-1h1v-4h-1v-1h-5z"></path><path d="M5 5c0-1.657 1.343-3 3-3h-5v1h-1v4h1v1h5c-1.657 0-3-1.343-3-3z"></path></g>
<g id="vaadin:money-exchange"><path d="M16 14l-3 2v-1h-4.75l2-2h2.75v-1l3 2z"></path><path d="M0 2l3-2v1h4.75l-2 2h-2.75v1l-3-2z"></path><path d="M9.74 0l-9.74 9.74 6.26 6.26 9.74-9.74zM1.39 9.74l8.35-8.35 4.87 4.87-8.35 8.35z"></path><path d="M4.17 9.74l-0.7 0.7 2.090 2.090 0.7-0.7 0.74 0.69 2.74-2.78c-0.445 0.445-1.060 0.721-1.74 0.721-1.359 0-2.461-1.102-2.461-2.461 0-0.68 0.275-1.295 0.721-1.74l-2.78 2.74z"></path><path d="M12.52 5.57l-2.090-2.090-0.7 0.7-0.73-0.7-2.74 2.78c0.445-0.445 1.060-0.721 1.74-0.721 1.359 0 2.461 1.102 2.461 2.461 0 0.68-0.275 1.295-0.721 1.74l2.78-2.74-0.7-0.7z"></path></g>
<g id="vaadin:money-withdraw"><path d="M8 0l2 3h-1v2h-2v-2h-1l2-3z"></path><path d="M15 7v8h-14v-8h14zM16 6h-16v10h16v-10z"></path><path d="M8 8c1.657 0 3 1.343 3 3s-1.343 3-3 3h5v-1h1v-4h-1v-1h-5z"></path><path d="M5 11c0-1.657 1.343-3 3-3h-5v1h-1v4h1v1h5c-1.657 0-3-1.343-3-3z"></path></g>
<g id="vaadin:money"><path d="M15 4v8h-14v-8h14zM16 3h-16v10h16v-10z"></path><path d="M8 5c1.7 0 3 1.3 3 3s-1.3 3-3 3h5v-1h1v-4h-1v-1h-5z"></path><path d="M5 8c0-1.7 1.3-3 3-3h-5v1h-1v4h1v1h5c-1.7 0-3-1.3-3-3z"></path></g>
<g id="vaadin:moon-o"><path d="M13.2 11.9c-4.5 0-8.1-3.6-8.1-8.1 0-1.4 0.3-2.7 0.9-3.8-3.4 0.9-6 4.1-6 7.9 0 4.5 3.6 8.1 8.1 8.1 3.1 0 5.8-1.8 7.2-4.4-0.6 0.2-1.3 0.3-2.1 0.3zM8.1 15c-3.9 0-7.1-3.2-7.1-7.1 0-2.5 1.3-4.7 3.3-6-0.2 0.6-0.2 1.2-0.2 1.9 0 5 4.1 9.1 9.1 9.2-1.4 1.2-3.2 2-5.1 2z"></path></g>
<g id="vaadin:moon"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM8 15c-3.9 0-7-3.1-7-7 0-2.4 1.2-4.6 3.2-5.9-0.1 0.6-0.2 1.3-0.2 1.9 0 4.9 4 8.9 8.9 9-1.3 1.3-3 2-4.9 2z"></path></g>
<g id="vaadin:morning"><path d="M14 10l-1.58-1.18 0.78-1.82-2-0.23-0.2-1.97-1.82 0.78-1.18-1.58-1.18 1.58-1.82-0.78-0.23 2-1.97 0.2 0.78 1.82-1.58 1.18h-2v1h16v-1h-2zM4 10c0.075-2.178 1.822-3.925 3.993-4 2.185 0.075 3.932 1.821 4.007 3.993l-8 0.007z"></path></g>
<g id="vaadin:movie"><path d="M12 7v-3h-12v9h12v-3l4 2v-7l-4 2zM9 11h-7v-5h7v5z"></path><path d="M5 8.4c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M8 8.4c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:music"><path d="M4 3v9.4c-0.4-0.2-0.9-0.4-1.5-0.4-1.4 0-2.5 0.9-2.5 2s1.1 2 2.5 2 2.5-0.9 2.5-2v-7.3l7-2.3v5.1c-0.4-0.3-0.9-0.5-1.5-0.5-1.4 0-2.5 0.9-2.5 2s1.1 2 2.5 2 2.5-0.9 2.5-2v-11l-9 3z"></path></g>
<g id="vaadin:mute"><path d="M15.2 0l-4.2 4.2v-1.2c0-1.7-1.3-3-3-3s-3 1.3-3 3v4c0 0.9 0.4 1.7 1 2.2l-0.8 0.8c-0.7-0.6-1.2-1.5-1.2-2.5v-2.5c-0.6 0-1 0.4-1 1v1.5c0 1.3 0.6 2.4 1.5 3.2l-4.5 4.6v0.7h0.7l15.3-15.4v-0.6h-0.8z"></path><path d="M12.5 5.1l-0.5 0.5v1.9c0 1.9-1.8 3.5-3.8 3.5h-0.4c-0.3 0-0.6-0.1-0.9-0.1l-0.9 0.7c0.3 0.1 0.6 0.2 1 0.3v2.1c-3 0-2.5 2-2.5 2h7c0 0 0.5-2-2.5-2v-2.1c2.2-0.4 4-2.2 4-4.4v-1.5c0-0.4-0.2-0.7-0.5-0.9z"></path><path d="M11 7v-0.4l-3.3 3.4c0.1 0 0.2 0 0.3 0 1.7 0 3-1.4 3-3z"></path></g>
<g id="vaadin:native-button"><path d="M15 12h-14c-0.6 0-1-0.4-1-1v-6c0-0.6 0.4-1 1-1h14c0.6 0 1 0.4 1 1v6c0 0.6-0.4 1-1 1z"></path></g>
<g id="vaadin:newspaper"><path d="M2 4h11v4h-11v-4z"></path><path d="M2 2h11v1h-11v-1z"></path><path d="M8 13h3v1h-3v-1z"></path><path d="M8 11h5v1h-5v-1z"></path><path d="M8 9h5v1h-5v-1z"></path><path d="M2 13h5v1h-5v-1z"></path><path d="M2 11h5v1h-5v-1z"></path><path d="M2 9h5v1h-5v-1z"></path><path d="M15 2v-2h-15v14.5c0 0.828 0.672 1.5 1.5 1.5h13c0.828 0 1.5-0.672 1.5-1.5v-12.5h-1zM1.5 15c-0.276 0-0.5-0.224-0.5-0.5v-13.5h13v12.5c0 1.5 1 1.5 1 1.5h-13.5z"></path></g>
<g id="vaadin:notebook"><path d="M2 0v1h-0.52c-0.265 0-0.48 0.215-0.48 0.48v0c-0.001 0.012-0.002 0.026-0.002 0.040 0 0.265 0.215 0.48 0.48 0.48 0.001 0 0.001 0 0.002 0h0.52v1h-0.52c-0.265 0-0.48 0.215-0.48 0.48v0c-0.001 0.012-0.002 0.026-0.002 0.040 0 0.265 0.215 0.48 0.48 0.48 0.001 0 0.001 0 0.002 0h0.52v1h-0.52c-0.265 0-0.48 0.215-0.48 0.48 0 0 0 0 0 0v0c-0.001 0.012-0.002 0.026-0.002 0.040 0 0.265 0.215 0.48 0.48 0.48 0.001 0 0.001 0 0.002 0h0.52v1h-0.52c-0.265 0-0.48 0.215-0.48 0.48 0 0 0 0 0 0v0c-0.001 0.012-0.002 0.026-0.002 0.040 0 0.265 0.215 0.48 0.48 0.48 0.001 0 0.001 0 0.002 0h0.52v1h-0.52c-0.265 0-0.48 0.215-0.48 0.48 0 0 0 0 0 0v0c0 0.265 0.215 0.48 0.48 0.48 0 0 0 0 0 0h0.52v1h-0.52c-0.265 0-0.48 0.215-0.48 0.48 0 0 0 0 0 0v0c0 0.265 0.215 0.48 0.48 0.48 0 0 0 0 0 0h0.52v1h-0.52c-0.265 0-0.48 0.215-0.48 0.48 0 0 0 0 0 0v0c0 0.265 0.215 0.48 0.48 0.48 0 0 0 0 0 0h0.52v2h12v-15.88h-12zM3.5 14c-0.276 0-0.5-0.224-0.5-0.5s0.224-0.5 0.5-0.5c0.276 0 0.5 0.224 0.5 0.5s-0.224 0.5-0.5 0.5zM3.5 12c-0.276 0-0.5-0.224-0.5-0.5s0.224-0.5 0.5-0.5c0.276 0 0.5 0.224 0.5 0.5s-0.224 0.5-0.5 0.5zM3.5 10c-0.276 0-0.5-0.224-0.5-0.5s0.224-0.5 0.5-0.5c0.276 0 0.5 0.224 0.5 0.5s-0.224 0.5-0.5 0.5zM3.5 8c-0.276 0-0.5-0.224-0.5-0.5s0.224-0.5 0.5-0.5c0.276 0 0.5 0.224 0.5 0.5s-0.224 0.5-0.5 0.5zM3.5 6c-0.276 0-0.5-0.224-0.5-0.5s0.224-0.5 0.5-0.5c0.276 0 0.5 0.224 0.5 0.5s-0.224 0.5-0.5 0.5zM3.5 4c-0.276 0-0.5-0.224-0.5-0.5s0.224-0.5 0.5-0.5c0.276 0 0.5 0.224 0.5 0.5s-0.224 0.5-0.5 0.5zM3.5 2c-0.276 0-0.5-0.224-0.5-0.5s0.224-0.5 0.5-0.5c0.276 0 0.5 0.224 0.5 0.5s-0.224 0.5-0.5 0.5zM12 6h-6v-3h6v3z"></path></g>
<g id="vaadin:nurse"><path d="M15.2 12c-0.658-1.414-2.067-2.376-3.701-2.376-0.077 0-0.154 0.002-0.23 0.006l-3.269 3.9-3.28-3.9c-0.049-0.002-0.106-0.003-0.163-0.003-1.648 0-3.072 0.958-3.746 2.348-0.422 0.9-0.707 1.917-0.808 2.988l1.997 0.037v1h12v-1h2c-0.104-1.107-0.388-2.124-0.824-3.057z"></path><path d="M6.57 8.73c-0.038 0.374-0.322 0.671-0.685 0.729l2.115 2.541 2.12-2.52c-0.368-0.059-0.652-0.356-0.69-0.727-0-0.613 0.8-0.413 1.43-1.453 0-0.030 2.88-7.3-2.86-7.3s-2.86 7.27-2.86 7.27c0.63 1.050 1.44 0.85 1.43 1.46z"></path></g>
<g id="vaadin:office"><path d="M14 15v-11h-3v-3h-9v14h-2v1h7v-3h2v3h7v-1h-2zM6 11h-2v-2h2v2zM6 8h-2v-2h2v2zM6 5h-2v-2h2v2zM9 11h-2v-2h2v2zM9 8h-2v-2h2v2zM9 5h-2v-2h2v2zM13 11h-2v-2h2v2zM13 8h-2v-2h2v2z"></path></g>
<g id="vaadin:open-book"><path d="M15 4.7v-0.7c-1.159-1.163-2.734-1.91-4.484-1.999-0.112-0.012-0.222-0.018-0.334-0.018-0.874 0-1.657 0.394-2.179 1.013-0.556-0.617-1.357-1.007-2.249-1.007-0.090 0-0.178 0.004-0.266 0.012-1.754 0.089-3.33 0.836-4.488 1.999l-0 0.7-1 0.3v10l6.7-1.4 0.3 0.4h2l0.3-0.4 6.7 1.4v-10zM5.48 11.31c-1.275 0.037-2.467 0.358-3.526 0.902l0.046-7.792c0.885-0.835 2.066-1.365 3.369-1.42 0.806 0.054 1.534 0.303 2.159 0.701l-0.019 7.869c-0.555-0.166-1.193-0.262-1.854-0.262-0.062 0-0.124 0.001-0.185 0.003zM14 12.19c-1.013-0.522-2.205-0.843-3.468-0.88-0.056-0.001-0.108-0.002-0.161-0.002-0.66 0-1.297 0.096-1.899 0.274l0.047-7.902c0.601-0.381 1.322-0.627 2.096-0.679 1.324 0.055 2.501 0.586 3.386 1.422l-0.003 7.768z"></path></g>
<g id="vaadin:option-a"><path d="M12.5 10h-1.5v-4h1.5c1.381 0 2.5-1.119 2.5-2.5s-1.119-2.5-2.5-2.5c-1.381 0-2.5 1.119-2.5 2.5v1.5h-4v-1.5c0-1.381-1.119-2.5-2.5-2.5s-2.5 1.119-2.5 2.5c0 1.381 1.119 2.5 2.5 2.5h1.5v4h-1.5c-1.381 0-2.5 1.119-2.5 2.5s1.119 2.5 2.5 2.5c1.381 0 2.5-1.119 2.5-2.5v-1.5h4v1.5c0 1.381 1.119 2.5 2.5 2.5s2.5-1.119 2.5-2.5c0-1.381-1.119-2.5-2.5-2.5zM11 3.5c0-0.828 0.672-1.5 1.5-1.5s1.5 0.672 1.5 1.5c0 0.828-0.672 1.5-1.5 1.5h-1.5v-1.5zM5 12.5c0 0.828-0.672 1.5-1.5 1.5s-1.5-0.672-1.5-1.5c0-0.828 0.672-1.5 1.5-1.5h1.5v1.5zM5 5h-1.5c-0.828 0-1.5-0.672-1.5-1.5s0.672-1.5 1.5-1.5c0.828 0 1.5 0.672 1.5 1.5v1.5zM10 10h-4v-4h4v4zM12.5 14c-0.828 0-1.5-0.672-1.5-1.5v-1.5h1.5c0.828 0 1.5 0.672 1.5 1.5s-0.672 1.5-1.5 1.5z"></path></g>
<g id="vaadin:option"><path d="M4 11c0 0.552 0.448 1 1 1s1-0.448 1-1v-1h-1c-0.552 0-1 0.448-1 1z"></path><path d="M0 0v16h16v-16h-16zM11 9c1.105 0 2 0.895 2 2s-0.895 2-2 2c-1.105 0-2-0.895-2-2v-1h-2v1c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2h1v-2h-1c-1.105 0-2-0.895-2-2s0.895-2 2-2c1.105 0 2 0.895 2 2v1h2v-1c0-1.105 0.895-2 2-2s2 0.895 2 2c0 1.105-0.895 2-2 2h-1v2h1z"></path><path d="M12 5c0-0.552-0.448-1-1-1s-1 0.448-1 1v1h1c0.552 0 1-0.448 1-1z"></path><path d="M5 4c-0.552 0-1 0.448-1 1s0.448 1 1 1h1v-1c0-0.552-0.448-1-1-1z"></path><path d="M7 7h2v2h-2v-2z"></path><path d="M10 11c0 0.552 0.448 1 1 1s1-0.448 1-1c0-0.552-0.448-1-1-1h-1v1z"></path></g>
<g id="vaadin:options"><path d="M5 3.5c0 0.828-0.672 1.5-1.5 1.5s-1.5-0.672-1.5-1.5c0-0.828 0.672-1.5 1.5-1.5s1.5 0.672 1.5 1.5z"></path><path d="M3.5 0c-1.9 0-3.5 1.6-3.5 3.5s1.6 3.5 3.5 3.5 3.5-1.6 3.5-3.5-1.6-3.5-3.5-3.5zM3.5 6c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5c0 1.4-1.1 2.5-2.5 2.5z"></path><path d="M3.5 8c-1.9 0-3.5 1.6-3.5 3.5s1.6 3.5 3.5 3.5 3.5-1.6 3.5-3.5c0-1.9-1.6-3.5-3.5-3.5zM3.5 14c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5c0 1.4-1.1 2.5-2.5 2.5z"></path><path d="M8 2h8v3h-8v-3z"></path><path d="M8 10h8v3h-8v-3z"></path></g>
<g id="vaadin:orientation"><path d="M11 2.1c2 0 3 1.3 3 2.9h-1l1.5 2 1.5-2h-1c0-2.2-2-3.9-4-3.9v-1.1l-2 1.5 2 1.5v-0.9z"></path><path d="M9 9h6v6h-7v-15h-8v16h16v-8h-7v1zM7 8h-1v1h1v6h-6v-14h6v7z"></path><path d="M2 8h1v1h-1v-1z"></path><path d="M4 8h1v1h-1v-1z"></path></g>
<g id="vaadin:out"><path d="M3.5 8c0.3 0 0.5 0.2 0.5 0.5v2c0 0.3-0.2 0.5-0.5 0.5s-0.5-0.2-0.5-0.5v-2c0-0.3 0.2-0.5 0.5-0.5v0zM3.5 7v0c-0.8 0-1.5 0.7-1.5 1.5v2c0 0.8 0.7 1.5 1.5 1.5v0c0.8 0 1.5-0.7 1.5-1.5v-2c0-0.8-0.7-1.5-1.5-1.5v0z"></path><path d="M8 7v3.5c0 0.3-0.2 0.5-0.5 0.5s-0.5-0.2-0.5-0.5v-3.5h-1v3.5c0 0.8 0.7 1.5 1.5 1.5v0c0.8 0 1.5-0.7 1.5-1.5v-3.5h-1z"></path><path d="M13 7h-3v1h1v4h1v-4h1z"></path><path d="M15 6v-1h-2.4l-3.7-3c0.1-0.2 0.1-0.3 0.1-0.5 0-0.8-0.7-1.5-1.5-1.5s-1.5 0.7-1.5 1.5c0 0.2 0 0.3 0.1 0.5l-3.7 3h-2.4v9h1v1h15v-9h-1zM6.7 2.8c0.3 0.1 0.5 0.2 0.8 0.2s0.5-0.1 0.8-0.2l2.7 2.2h-7l2.7-2.2zM14 13h-13v-7h13v7z"></path></g>
<g id="vaadin:outbox"><path d="M6 5v6h4v-6h2l-4-5-4 5z"></path><path d="M13 2h-2l0.9 1h0.4l2.6 8h-3.9v2h-6v-2h-3.9l2.6-8h0.4l0.9-1h-2l-3 9v5h16v-5z"></path></g>
<g id="vaadin:package"><path d="M8 0l-8 2v10l8 4 8-4v-10l-8-2zM8 1l2.1 0.5-5.9 1.9-2.3-0.8 6.1-1.6zM8 14.9l-7-3.5v-8.1l3 1v3.4l1 0.3v-3.3l3 1v9.2zM8.5 4.8l-2.7-0.9 6.2-1.9 2.4 0.6-5.9 2.2z"></path></g>
<g id="vaadin:padding-bottom"><path d="M16 16v-16h-16v16h16zM1 13h1v-1h-1v-11h14v12h-1v1h1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v-1z"></path><path d="M12 13h1v1h-1v-1z"></path><path d="M13 12h1v1h-1v-1z"></path><path d="M11 12h1v1h-1v-1z"></path><path d="M9 12h1v1h-1v-1z"></path><path d="M10 13h1v1h-1v-1z"></path><path d="M8 13h1v1h-1v-1z"></path><path d="M6 13h1v1h-1v-1z"></path><path d="M7 12h1v1h-1v-1z"></path><path d="M5 12h1v1h-1v-1z"></path><path d="M3 12h1v1h-1v-1z"></path><path d="M4 13h1v1h-1v-1z"></path><path d="M2 13h1v1h-1v-1z"></path></g>
<g id="vaadin:padding-left"><path d="M0 16h16v-16h-16v16zM3 1v1h1v-1h11v14h-12v-1h-1v1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h1z"></path><path d="M2 12h1v1h-1v-1z"></path><path d="M3 13h1v1h-1v-1z"></path><path d="M3 11h1v1h-1v-1z"></path><path d="M3 9h1v1h-1v-1z"></path><path d="M2 10h1v1h-1v-1z"></path><path d="M2 8h1v1h-1v-1z"></path><path d="M2 6h1v1h-1v-1z"></path><path d="M3 7h1v1h-1v-1z"></path><path d="M3 5h1v1h-1v-1z"></path><path d="M3 3h1v1h-1v-1z"></path><path d="M2 4h1v1h-1v-1z"></path><path d="M2 2h1v1h-1v-1z"></path></g>
<g id="vaadin:padding-right"><path d="M16 0h-16v16h16v-16zM13 15v-1h-1v1h-11v-14h12v1h1v-1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h-1z"></path><path d="M13 3h1v1h-1v-1z"></path><path d="M12 2h1v1h-1v-1z"></path><path d="M12 4h1v1h-1v-1z"></path><path d="M12 6h1v1h-1v-1z"></path><path d="M13 5h1v1h-1v-1z"></path><path d="M13 7h1v1h-1v-1z"></path><path d="M13 9h1v1h-1v-1z"></path><path d="M12 8h1v1h-1v-1z"></path><path d="M12 10h1v1h-1v-1z"></path><path d="M12 12h1v1h-1v-1z"></path><path d="M13 11h1v1h-1v-1z"></path><path d="M13 13h1v1h-1v-1z"></path></g>
<g id="vaadin:padding-top"><path d="M0 0v16h16v-16h-16zM15 3h-1v1h1v11h-14v-12h1v-1h-1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v1z"></path><path d="M3 2h1v1h-1v-1z"></path><path d="M2 3h1v1h-1v-1z"></path><path d="M4 3h1v1h-1v-1z"></path><path d="M6 3h1v1h-1v-1z"></path><path d="M5 2h1v1h-1v-1z"></path><path d="M7 2h1v1h-1v-1z"></path><path d="M9 2h1v1h-1v-1z"></path><path d="M8 3h1v1h-1v-1z"></path><path d="M10 3h1v1h-1v-1z"></path><path d="M12 3h1v1h-1v-1z"></path><path d="M11 2h1v1h-1v-1z"></path><path d="M13 2h1v1h-1v-1z"></path></g>
<g id="vaadin:padding"><path d="M0 0v16h16v-16h-16zM15 3h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v1z"></path><path d="M3 2h1v1h-1v-1z"></path><path d="M4 3h1v1h-1v-1z"></path><path d="M6 3h1v1h-1v-1z"></path><path d="M5 2h1v1h-1v-1z"></path><path d="M7 2h1v1h-1v-1z"></path><path d="M9 2h1v1h-1v-1z"></path><path d="M8 3h1v1h-1v-1z"></path><path d="M10 3h1v1h-1v-1z"></path><path d="M12 3h1v1h-1v-1z"></path><path d="M11 2h1v1h-1v-1z"></path><path d="M13 2h1v1h-1v-1z"></path><path d="M12 5h1v1h-1v-1z"></path><path d="M13 4h1v1h-1v-1z"></path><path d="M12 7h1v1h-1v-1z"></path><path d="M13 6h1v1h-1v-1z"></path><path d="M12 9h1v1h-1v-1z"></path><path d="M13 8h1v1h-1v-1z"></path><path d="M12 11h1v1h-1v-1z"></path><path d="M13 10h1v1h-1v-1z"></path><path d="M12 13h1v1h-1v-1z"></path><path d="M13 12h1v1h-1v-1z"></path><path d="M2 3h1v1h-1v-1z"></path><path d="M3 4h1v1h-1v-1z"></path><path d="M2 5h1v1h-1v-1z"></path><path d="M3 6h1v1h-1v-1z"></path><path d="M2 7h1v1h-1v-1z"></path><path d="M3 8h1v1h-1v-1z"></path><path d="M2 9h1v1h-1v-1z"></path><path d="M3 10h1v1h-1v-1z"></path><path d="M2 11h1v1h-1v-1z"></path><path d="M2 13h1v1h-1v-1z"></path><path d="M3 12h1v1h-1v-1z"></path><path d="M4 11h1v1h-1v-1z"></path><path d="M4 13h1v1h-1v-1z"></path><path d="M5 12h1v1h-1v-1z"></path><path d="M6 13h1v1h-1v-1z"></path><path d="M7 12h1v1h-1v-1z"></path><path d="M9 12h1v1h-1v-1z"></path><path d="M8 13h1v1h-1v-1z"></path><path d="M11 12h1v1h-1v-1z"></path><path d="M10 13h1v1h-1v-1z"></path></g>
<g id="vaadin:paint-roll"><path d="M16 6.9v-4.9h-2v-2h-13v1h-1v3h1v1h13v-2h1v3.1l-8 1v1.9h-1v0.9c0 0 0.5 0 0.5 0.9s-0.5 0.6-0.5 1.5v2.8c0 0 0 0.9 1.5 0.9s1.5-0.9 1.5-0.9v-2.8c0-0.9-0.5-0.7-0.5-1.5s0.5-0.9 0.5-0.9v-0.9h-1v-1.1l8-1z"></path></g>
<g id="vaadin:paintbrush"><path d="M5.6 11.6l-1.2-1.2c-0.8-0.2-2-0.1-2.7 1-0.8 1.1-0.3 2.8-1.7 4.6 0 0 3.5 0 4.8-1.3 1.2-1.2 1.2-2.2 1-3l-0.2-0.1z"></path><path d="M5.8 8.1c-0.2 0.3-0.5 0.7-0.7 1 0 0.2-0.1 0.3-0.2 0.4l1.5 1.5c0.1-0.1 0.3-0.2 0.4-0.3 0.3-0.2 0.7-0.4 1-0.7 0.4 0 0.6-0.2 0.8-0.4l-2.2-2.2c-0.2 0.2-0.4 0.4-0.6 0.7z"></path><path d="M15.8 0.2c-0.3-0.3-0.7-0.3-1-0.1 0 0-3 2.5-5.9 5.1-0.4 0.4-0.7 0.7-1.1 1-0.2 0.2-0.4 0.4-0.6 0.5l2.1 2.1c0.2-0.2 0.4-0.4 0.5-0.7 0.3-0.4 0.6-0.7 0.9-1.1 2.5-3 5.1-5.9 5.1-5.9 0.3-0.2 0.3-0.6 0-0.9z"></path></g>
<g id="vaadin:palette"><path d="M8.25 0c-6.38 0-9.11 7.38-8.010 9.92 0.82 1.89 2.62 0.080 3.34 1 1.88 2.46-2.11 3.81 0.090 4.68 2.59 1.060 12.33 0.4 12.33-8.53 0-2.69-1.34-7.070-7.75-7.070zM4.47 9c-0.815-0.017-1.47-0.682-1.47-1.5 0-0.828 0.672-1.5 1.5-1.5s1.5 0.671 1.5 1.5c0 0 0 0 0 0 0 0.828-0.672 1.5-1.5 1.5-0.011 0-0.021-0-0.032-0zM6 3.5c0-0.828 0.672-1.5 1.5-1.5s1.5 0.672 1.5 1.5-0.672 1.5-1.5 1.5c-0.011 0-0.021-0-0.032-0-0.814-0.017-1.468-0.682-1.468-1.5 0-0 0-0 0-0zM8.47 14c-0.815-0.017-1.47-0.682-1.47-1.5 0-0.828 0.672-1.5 1.5-1.5s1.5 0.671 1.5 1.5c0 0 0 0 0 0 0 0.828-0.672 1.5-1.5 1.5-0.011 0-0.021-0-0.032-0zM12.47 11c-0.815-0.017-1.47-0.682-1.47-1.5 0-0.828 0.672-1.5 1.5-1.5s1.5 0.671 1.5 1.5c0 0 0 0 0 0 0 0.828-0.672 1.5-1.5 1.5-0.011 0-0.021-0-0.032-0zM12.47 6c-0.815-0.017-1.47-0.682-1.47-1.5 0-0.828 0.672-1.5 1.5-1.5s1.5 0.671 1.5 1.5c0 0 0 0 0 0 0 0.828-0.672 1.5-1.5 1.5-0.011 0-0.021-0-0.032-0z"></path></g>
<g id="vaadin:panel"><path d="M0 0v16h16v-16h-16zM13 15h-12v-12h12v12zM15 15h-1v-1h1v1zM15 13h-1v-8h1v8zM15 4h-1v-1h1v1z"></path></g>
<g id="vaadin:paperclip"><path d="M2.7 15.3c-0.7 0-1.4-0.3-1.9-0.8-0.9-0.9-1.2-2.5 0-3.7l8.9-8.9c1.4-1.4 3.8-1.4 5.2 0s1.4 3.8 0 5.2l-7.4 7.4c-0.2 0.2-0.5 0.2-0.7 0s-0.2-0.5 0-0.7l7.4-7.4c1-1 1-2.7 0-3.7s-2.7-1-3.7 0l-8.9 8.9c-0.8 0.8-0.6 1.7 0 2.2 0.6 0.6 1.5 0.8 2.2 0l8.9-8.9c0.2-0.2 0.2-0.5 0-0.7s-0.5-0.2-0.7 0l-7.4 7.4c-0.2 0.2-0.5 0.2-0.7 0s-0.2-0.5 0-0.7l7.4-7.4c0.6-0.6 1.6-0.6 2.2 0s0.6 1.6 0 2.2l-8.9 8.9c-0.6 0.4-1.3 0.7-1.9 0.7z"></path></g>
<g id="vaadin:paperplane-o"><path d="M16 0l-16 8 4.7 1.6 0.3 5.4 2.5-2.8 2.5 3.8 6-16zM7.5 10.4l4.3-5.9-6.2 4.3-3-1 11.6-5.8-4.5 11.8-2.2-3.4z"></path></g>
<g id="vaadin:paperplane"><path d="M0 8l4.9 1.4h0.1v-0.1l7.1-5.3-1.1 1.2-6.2 6.6 0.2 3.2 2.9-3.2 2.1 4.2 6-16z"></path></g>
<g id="vaadin:paragraph"><path d="M5.5 0c-2.5 0-4.5 2-4.5 4.5s2 4.5 4.5 4.5h2.5v7h2v-14h1v14h2v-14h2v-2h-9.5z"></path></g>
<g id="vaadin:password"><path d="M16 5c0-0.6-0.4-1-1-1h-14c-0.6 0-1 0.4-1 1v6c0 0.6 0.4 1 1 1h14c0.6 0 1-0.4 1-1v-6zM15 11h-14v-6h14v6z"></path><path d="M6 8c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M9 8c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M12 8c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:paste"><path d="M13 4h-3v-4h-10v14h6v2h10v-9l-3-3zM3 1h4v1h-4v-1zM15 15h-8v-10h5v3h3v7zM13 7v-2l2 2h-2z"></path></g>
<g id="vaadin:pause"><path d="M0 1h7v14h-7v-14z"></path><path d="M9 1h7v14h-7v-14z"></path></g>
<g id="vaadin:pencil"><path d="M1 11.9l-1 4.1 4.1-1 9.2-9.2-3.1-3.1-9.2 9.2zM1.5 15l-0.4-0.5 0.4-2 2 2-2 0.5zM10.9 4.4l-8.1 8-0.6-0.6 8.1-8 0.6 0.6z"></path><path d="M15.3 0.7c-1.1-1.1-2.6-0.5-2.6-0.5l-1.5 1.5 3.1 3.1 1.5-1.5c0-0.1 0.6-1.5-0.5-2.6zM13.4 1.6l-0.5-0.5c0.6-0.6 1.1-0.1 1.1-0.1l-0.6 0.6z"></path></g>
<g id="vaadin:phone-landline"><path d="M15.88 3.86l-0.61-1.31c-0.155-0.326-0.443-0.568-0.792-0.658-1.938-0.528-4.161-0.851-6.453-0.891-2.342 0.041-4.565 0.363-6.687 0.934-0.165 0.048-0.453 0.29-0.605 0.609l-0.613 1.317c-0.075 0.152-0.119 0.331-0.12 0.52v0.87c-0.001 0.012-0.001 0.026-0.001 0.041 0 0.392 0.318 0.71 0.71 0.71 0.011 0 0.022-0 0.033-0.001l2.518 0c0.412-0.010 0.742-0.346 0.742-0.76 0-0.018-0.001-0.035-0.002-0.053l0-0.838c-0-0.004-0-0.008-0-0.012 0-0.229 0.119-0.43 0.298-0.546 0.947-0.508 2.069-0.806 3.26-0.806 0.156 0 0.31 0.005 0.464 0.015 0.122-0.011 0.288-0.017 0.456-0.017 1.178 0 2.287 0.291 3.261 0.805 0.143 0.099 0.262 0.3 0.262 0.529 0 0.004-0 0.009-0 0.013l0 0.859c-0.001 0.015-0.002 0.033-0.002 0.050 0 0.413 0.33 0.75 0.741 0.76l2.521 0c0.009 0 0.020 0.001 0.031 0.001 0.392 0 0.71-0.318 0.71-0.71 0-0.014-0-0.029-0.001-0.043l0-0.868c-0.001-0.189-0.045-0.368-0.123-0.527z"></path><path d="M12 8.3c-0.624-0.797-1.001-1.815-1.001-2.92 0-0.028 0-0.056 0.001-0.084l-0-0.296h-1v1h-4v-1h-1v0.33c0 0.024 0.001 0.052 0.001 0.080 0 1.105-0.377 2.122-1.009 2.93l-2.992 3.66v3h14v-3zM8 13c-1.657 0-3-1.343-3-3s1.343-3 3-3c1.657 0 3 1.343 3 3s-1.343 3-3 3z"></path><path d="M10 10c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:phone"><path d="M12.2 10c-1.1-0.1-1.7 1.4-2.5 1.8-1.3 0.7-3.7-1.8-3.7-1.8s-2.5-2.4-1.9-3.7c0.5-0.8 2-1.4 1.9-2.5-0.1-1-2.3-4.6-3.4-3.6-2.4 2.2-2.6 3.1-2.6 4.9-0.1 3.1 3.9 7 3.9 7 0.4 0.4 3.9 4 7 3.9 1.8 0 2.7-0.2 4.9-2.6 1-1.1-2.5-3.3-3.6-3.4z"></path></g>
<g id="vaadin:picture"><path d="M16 14h-16v-12h16v12zM1 13h14v-10h-14v10z"></path><path d="M2 10v2h12v-1c0 0 0.2-1.7-2-2-1.9-0.3-2.2 0.6-3.8 0.6-1.1 0-0.9-1.6-3.2-1.6-1.7 0-3 2-3 2z"></path><path d="M13 6c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:pie-bar-chart"><path d="M5 11h3v5h-3v-5z"></path><path d="M1 14h3v2h-3v-2z"></path><path d="M13 12h3v4h-3v-4z"></path><path d="M9 9h3v7h-3v-7z"></path><path d="M5 0c-2.761 0-5 2.239-5 5s2.239 5 5 5c2.761 0 5-2.239 5-5s-2.239-5-5-5zM5 9c-2.209 0-4-1.791-4-4s1.791-4 4-4v4h4c0 2.209-1.791 4-4 4z"></path></g>
<g id="vaadin:pie-chart"><path d="M9 1c3.2 0.2 5.7 2.8 6 6h-6v-6zM8.5 0c-0.2 0-0.3 0-0.5 0v8h8c0-0.2 0-0.3 0-0.5 0-4.1-3.4-7.5-7.5-7.5v0z"></path><path d="M7 9v-8c-3.9 0.3-7 3.5-7 7.5 0 4.1 3.4 7.5 7.5 7.5 4 0 7.2-3.1 7.5-7h-8z"></path></g>
<g id="vaadin:piggy-bank-coin"><path d="M15.93 7.75c-0.061-0.2-0.165-0.371-0.3-0.51-0.105-0.113-0.241-0.197-0.394-0.238 0.074 0.117 0.141 0.252 0.191 0.396 0.056 0.147 0.092 0.304 0.103 0.467 0.008 0.067 0.012 0.138 0.012 0.21s-0.004 0.143-0.012 0.214c-0.035-0.115-0.083-0.208-0.142-0.292-0.123-0.166-0.288-0.299-0.48-0.383-0.119-0.053-0.248-0.082-0.384-0.082-0.346 0-0.648 0.186-0.811 0.464-0.050 0.082-0.090 0.171-0.12 0.266-1.182-1.968-3.309-3.271-5.741-3.271-0.124 0-0.247 0.003-0.369 0.010-0.763 0.001-1.517 0.11-2.231 0.313-0.062-0.434-0.632-1.314-3.252-1.314l0.8 2.51c-0.507 0.411-0.927 0.905-1.247 1.465l-1.553 0.025s-0.17 4 1 4h0.54c0.379 0.638 0.868 1.171 1.445 1.589l0.015 2.411h1.080c1.31 0 1.92 0 1.92-0.75v-0.39c0.451 0.088 0.97 0.139 1.5 0.139s1.049-0.051 1.551-0.147l-0.051 0.398c0 0.75 0.62 0.75 1.94 0.75h1.060v-2.39c0.932-0.651 1.613-1.605 1.903-2.717 0.057-0.027 0.114-0.024 0.172-0.024s0.115-0.003 0.172-0.010c0.251-0.046 0.48-0.144 0.679-0.283 0.266-0.188 0.474-0.454 0.591-0.765 0.028-0.093 0.049-0.191 0.063-0.292l0.001-0.010c0.221-0.262 0.372-0.59 0.419-0.951 0.012-0.084 0.019-0.171 0.019-0.259 0-0.197-0.032-0.386-0.091-0.563zM3.51 7.75c0.414 0 0.75 0.336 0.75 0.75s-0.336 0.75-0.75 0.75c-0.414 0-0.75-0.336-0.75-0.75s0.336-0.75 0.75-0.75zM5.88 7c-0.046 0.015-0.099 0.024-0.154 0.024-0.194 0-0.362-0.11-0.445-0.271-0.013-0.038-0.019-0.078-0.019-0.12 0-0.19 0.136-0.348 0.315-0.383 0.571-0.141 1.224-0.221 1.896-0.221 0.038 0 0.075 0 0.113 0.001 0.026-0 0.064-0.001 0.101-0.001 0.672 0 1.324 0.080 1.949 0.232 0.126 0.024 0.262 0.182 0.262 0.372 0 0.042-0.007 0.082-0.019 0.119-0.070 0.129-0.197 0.223-0.346 0.247l-0.153 0c-0.512-0.127-1.101-0.2-1.706-0.2-0.016 0-0.031 0-0.047 0-0.011-0-0.026-0-0.042-0-0.605 0-1.193 0.073-1.756 0.211zM14.58 9.93c-0.13 0.095-0.285 0.165-0.453 0.199l-0.127 0.001s0-0.13 0-0.13 0-0.21 0-0.31c0.165 0.125 0.374 0.2 0.6 0.2 0.007 0 0.014-0 0.021-0zM14.66 9.25c-0.018 0.003-0.040 0.004-0.061 0.004-0.176 0-0.327-0.103-0.398-0.252-0.044-0.084-0.069-0.18-0.069-0.283s0.025-0.199 0.070-0.283c0.059-0.082 0.157-0.138 0.269-0.138 0.059 0 0.113 0.015 0.161 0.042 0.181 0.070 0.308 0.244 0.308 0.448 0 0 0 0.001 0 0.001 0.009 0.062 0.014 0.133 0.014 0.205s-0.005 0.143-0.015 0.213c-0.066 0.012-0.144 0.024-0.224 0.024-0.019 0-0.039-0.001-0.058-0.002z"></path><path d="M8 3h-1v-0.17h0.25v-1.090h-0.25l0.55-0.55h0.2v1.64h0.25v0.17z"></path><path d="M7.5 0.75c0.828 0 1.5 0.672 1.5 1.5s-0.672 1.5-1.5 1.5c-0.828 0-1.5-0.672-1.5-1.5s0.672-1.5 1.5-1.5zM7.5 0c-1.243 0-2.25 1.007-2.25 2.25s1.007 2.25 2.25 2.25c1.243 0 2.25-1.007 2.25-2.25s-1.007-2.25-2.25-2.25v0z"></path></g>
<g id="vaadin:piggy-bank"><path d="M15.93 5.75c-0.061-0.2-0.165-0.371-0.3-0.51-0.105-0.113-0.241-0.197-0.394-0.238 0.074 0.117 0.141 0.252 0.191 0.396 0.056 0.147 0.092 0.304 0.103 0.467 0.008 0.067 0.012 0.138 0.012 0.21s-0.004 0.143-0.012 0.214c-0.035-0.115-0.083-0.208-0.142-0.292-0.123-0.166-0.288-0.299-0.48-0.383-0.119-0.053-0.248-0.082-0.384-0.082-0.346 0-0.648 0.186-0.811 0.464-0.050 0.082-0.090 0.171-0.12 0.266-1.182-1.968-3.309-3.271-5.741-3.271-0.124 0-0.247 0.003-0.369 0.010-0.763 0.001-1.517 0.11-2.231 0.313-0.062-0.434-0.632-1.314-3.252-1.314l0.8 2.51c-0.507 0.411-0.927 0.905-1.247 1.465l-1.553 0.025s-0.17 4 1 4h0.54c0.379 0.638 0.868 1.171 1.445 1.589l0.015 2.41h1.080c1.31 0 1.92 0 1.92-0.75v-0.39c0.451 0.088 0.97 0.139 1.5 0.139s1.049-0.051 1.551-0.147l-0.051 0.398c0 0.75 0.62 0.75 1.94 0.75h1.060v-2.39c0.932-0.651 1.613-1.605 1.903-2.717 0.057-0.027 0.114-0.024 0.172-0.024s0.115-0.003 0.172-0.010c0.251-0.046 0.48-0.144 0.679-0.283 0.266-0.188 0.474-0.454 0.591-0.765 0.028-0.093 0.049-0.191 0.063-0.292l0.001-0.010c0.221-0.262 0.372-0.59 0.419-0.951 0.012-0.084 0.019-0.171 0.019-0.259 0-0.197-0.032-0.386-0.091-0.563zM3.51 5.75c0.414 0 0.75 0.336 0.75 0.75s-0.336 0.75-0.75 0.75c-0.414 0-0.75-0.336-0.75-0.75s0.336-0.75 0.75-0.75zM5.88 5c-0.046 0.015-0.099 0.024-0.154 0.024-0.194 0-0.362-0.11-0.445-0.271-0.013-0.038-0.019-0.078-0.019-0.12 0-0.19 0.136-0.348 0.315-0.383 0.571-0.141 1.224-0.221 1.896-0.221 0.038 0 0.075 0 0.113 0.001 0.026-0 0.064-0.001 0.101-0.001 0.672 0 1.324 0.080 1.949 0.232 0.126 0.024 0.262 0.182 0.262 0.372 0 0.042-0.007 0.082-0.019 0.119-0.070 0.129-0.197 0.223-0.346 0.247l-0.153 0c-0.512-0.127-1.101-0.2-1.706-0.2-0.016 0-0.031 0-0.047 0-0.011-0-0.026-0-0.042-0-0.605 0-1.193 0.073-1.756 0.211zM14.58 7.93c-0.13 0.095-0.285 0.165-0.453 0.199l-0.127 0.011s0-0.14 0-0.14 0-0.21 0-0.31c0.165 0.125 0.374 0.2 0.6 0.2 0.007 0 0.014-0 0.021-0zM14.66 7.25c-0.018 0.003-0.040 0.004-0.061 0.004-0.176 0-0.327-0.103-0.398-0.252-0.044-0.084-0.069-0.18-0.069-0.283s0.025-0.199 0.070-0.283c0.059-0.082 0.157-0.138 0.269-0.138 0.059 0 0.113 0.015 0.161 0.042 0.181 0.070 0.308 0.244 0.308 0.448 0 0 0 0.001 0 0.001 0.009 0.062 0.014 0.133 0.014 0.205s-0.005 0.143-0.015 0.213c-0.066 0.012-0.144 0.024-0.224 0.024-0.019 0-0.039-0.001-0.058-0.002z"></path></g>
<g id="vaadin:pill"><path d="M14.8 1.4l-0.2-0.2c-0.7-0.8-1.8-1.2-2.8-1.2s-2.1 0.4-2.9 1.2l-7.7 7.7c-1.6 1.6-1.6 4.1 0 5.7l0.2 0.2c0.7 0.8 1.8 1.2 2.8 1.2s2.1-0.4 2.9-1.2l7.8-7.8c1.5-1.5 1.5-4.1-0.1-5.6zM14.1 6.4l-3.9 3.9-3.5-3.6-3.8 3.8c-1.1 1.1-1.1 2.5-1 3.5v0c-1.2-1.2-1.2-3.1 0-4.3l7.8-7.8c0.5-0.6 1.3-0.9 2.1-0.9s1.6 0.3 2.2 0.9l0.2 0.2c0.5 0.5 0.8 1.3 0.8 2.1s-0.3 1.6-0.9 2.2z"></path></g>
<g id="vaadin:pills"><path d="M3.5 8l6.3-6.3c0.4-0.4 1-0.7 1.7-0.7s1.3 0.3 1.8 0.7c1 1 1 2.6 0 3.5l-2.8 2.8h1.4l2-2c1.4-1.4 1.4-3.6 0-4.9-0.7-0.7-1.6-1-2.5-1s-1.7 0.2-2.4 0.9l-6.3 6.4c-0.3 0.2-0.5 0.5-0.7 0.9 0.5-0.2 1-0.3 1.5-0.3z"></path><path d="M7.3 5.6l-2.4 2.4h4.7z"></path><path d="M12.5 9h-9c-1.9 0-3.5 1.6-3.5 3.5s1.6 3.5 3.5 3.5h9c1.9 0 3.5-1.6 3.5-3.5s-1.6-3.5-3.5-3.5zM12.5 15h-4.5v-4h-4.5c-1.1 0-2 0.6-2.5 1.2 0.2-1.2 1.2-2.2 2.5-2.2h9c1.4 0 2.5 1.1 2.5 2.5s-1.1 2.5-2.5 2.5z"></path></g>
<g id="vaadin:pin-post"><path d="M15 4v-1h-6c0-1.69 1-2 1-2v-1h-5v1s1 0.31 1 2h-6v12h2v1h14v-12h-1zM14 14h-13v-10h4v1h2v2h1v-2h2v-1h4v10z"></path></g>
<g id="vaadin:pin"><path d="M11 6.5v-5.5h1v-1h-8v1h1v5.5c0 0-2 1.5-2 3.5 0 0.5 1.9 0.7 4 0.7v2.2c0 0.7 0.2 1.4 0.5 2.1l0.5 1 0.5-1c0.3-0.6 0.5-1.3 0.5-2.1v-2.2c2.1 0 4-0.3 4-0.7 0-2-2-3.5-2-3.5zM7 6.6c0 0-0.5 0.3-1.6 1.4-1 1-1.5 1.9-1.5 1.9s0.1-1 0.8-1.9c0.9-1.1 1.3-1.4 1.3-1.4v-5.6h1v5.6z"></path></g>
<g id="vaadin:play-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M6 4v8l6-4z"></path></g>
<g id="vaadin:play-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM6 12v-8l6 4-6 4z"></path></g>
<g id="vaadin:play"><path d="M2 1v14l12-7z"></path></g>
<g id="vaadin:plug"><path d="M14.7 3.1c-0.4-0.4-1-0.4-1.4 0l-2.8 2.8-1.5-1.4 2.8-2.8c0.4-0.4 0.4-1 0-1.4s-1-0.4-1.4 0l-2.8 2.8-1.4-1.4-1.4 1.4 0.7 0.7-1.4 1.4c-1.4 1.4-1.5 3.5-0.5 5.1-1.7 1.5-2.6 3.8-2.6 5.7h2c0-1.3 0.4-3.2 2.1-4.4 1.5 0.8 3.4 0.5 4.6-0.7l1.4-1.4 0.7 0.7 1.4-1.4-1.4-1.4 2.8-2.8c0.5-0.5 0.5-1.1 0.1-1.5z"></path></g>
<g id="vaadin:plus-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M13 7h-4v-4h-2v4h-4v2h4v4h2v-4h4z"></path></g>
<g id="vaadin:plus-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM13 9h-4v4h-2v-4h-4v-2h4v-4h2v4h4v2z"></path></g>
<g id="vaadin:plus-minus"><path d="M10 7h6v2h-6v-2z"></path><path d="M4 5h-2v2h-2v2h2v2h2v-2h2v-2h-2z"></path><path d="M6 2l3 12h1l-3-12z"></path></g>
<g id="vaadin:plus-square-o"><path d="M12 7h-3v-3h-2v3h-3v2h3v3h2v-3h3z"></path><path d="M15 1h-14v14h14v-14zM14 14h-12v-12h12v12z"></path></g>
<g id="vaadin:plus"><path d="M14 7h-5v-5h-2v5h-5v2h5v5h2v-5h5v-2z"></path></g>
<g id="vaadin:pointer"><path d="M12.6 5c-0.2 0-0.5 0-0.6 0 0-0.2-0.2-0.6-0.4-0.8s-0.6-0.4-1.1-0.4c-0.2 0-0.4 0-0.6 0.1-0.1-0.2-0.2-0.3-0.3-0.5-0.2-0.2-0.5-0.4-1.1-0.4-0.2 0-0.4 0-0.5 0.1v-1.7c0-0.6-0.4-1.4-1.4-1.4-0.4 0-0.8 0.2-1.1 0.4-0.5 0.6-0.5 1.4-0.5 1.4v4.3c-0.6 0.1-1.1 0.3-1.4 0.6-0.6 0.7-0.6 1.6-0.6 2.8 0 0.2 0 0.5 0 0.7 0 1.4 0.7 2.1 1.4 2.8l0.3 0.4c1.3 1.2 2.4 1.6 5.1 1.6 2.9 0 4.2-1.6 4.2-5.1v-2.5c0-0.7-0.2-2.1-1.4-2.4zM13 7.4v2.6c0 3.4-1.3 4.1-3.2 4.1-2.4 0-3.3-0.3-4.3-1.3-0.1-0.1-0.2-0.2-0.4-0.4-0.7-0.8-1.1-1.2-1.1-2.2 0-0.2 0-0.5 0-0.7 0-1 0-1.7 0.3-2.1 0.1-0.1 0.4-0.2 0.7-0.2v0.5l-0.3 1.5c0 0.1 0 0.1 0.1 0.2s0.2 0 0.2 0l1-1.2c0-0.1 0-0.2 0-0.2v-6.2c0-0.1 0-0.5 0.2-0.7 0.1 0 0.2-0.1 0.4-0.1 0.3 0 0.4 0.3 0.4 0.4v3.1c0 0 0 0 0 0v1.2c0 0.3 0.2 0.6 0.5 0.6s0.5-0.3 0.5-0.5v-1.3c0 0 0 0 0 0 0-0.1 0.1-0.5 0.5-0.5 0.3 0 0.5 0.1 0.5 0.4v1.3c0 0.3 0.2 0.6 0.5 0.6s0.5-0.3 0.5-0.5v-0.7c0-0.1 0.1-0.3 0.5-0.3 0.2 0 0.3 0.1 0.3 0.1 0.2 0.1 0.2 0.4 0.2 0.4v0.8c0 0.3 0.2 0.5 0.4 0.5 0.3 0 0.5-0.1 0.5-0.4 0-0.1 0.1-0.2 0.2-0.3 0 0 0.1 0 0.2 0 0.6 0.2 0.7 1.2 0.7 1.5 0-0.1 0-0.1 0 0z"></path></g>
<g id="vaadin:power-off"><path d="M10 2.3v3.3c1.2 0.7 2 2 2 3.4 0 2.2-1.8 4-4 4s-4-1.8-4-4c0-1.5 0.8-2.8 2-3.4v-3.3c-2.9 0.9-5 3.5-5 6.7 0 3.9 3.1 7 7 7s7-3.1 7-7c0-3.2-2.1-5.8-5-6.7z"></path><path d="M7 1h2v7h-2v-7z"></path></g>
<g id="vaadin:presentation"><path d="M16 1h-7v-1h-2v1h-7v11h5l-2 4h2.2l2-4h1.5l2 4h2.3l-2-4h5v-11zM15 11h-14v-9h14v9z"></path><path d="M6 4v5l4-2.5z"></path></g>
<g id="vaadin:print"><path d="M0 10v4h2v2h12v-2h2v-4h-16zM13 15h-10v-3h10v3z"></path><path d="M12 6v-4l-2.7-2h-5.3v6h-4v3h16v-3h-4zM9 1l1.3 1h-1.3v-1zM11 7h-6v-6h3v2h3v4zM15 8h-1v-1h1v1z"></path></g>
<g id="vaadin:progressbar"><path d="M0 5v6h16v-6h-16zM15 10h-14v-4h14v4z"></path><path d="M2 7h7v2h-7v-2z"></path></g>
<g id="vaadin:puzzle-piece"><path d="M14.9 0.9c-1.1-1-2.5-1.3-3.1-0.4-0.7 1.1 0.5 1.7-0.3 2.5-0.5 0.6-2-0.8-2-0.8l-0.8-0.8-1.4 1.4c-0.6 0.7-2.1 1.5-2.6 1.1-0.7-0.6 0.1-1.8-0.5-2.6-0.7-1-2.1-0.8-3 0.3-1 1.1-1.4 2.4-0.5 3 1.1 0.7 1.9-0.3 2.7 0.5 0.4 0.4-0.2 1.7-0.5 2.1l-2.3 2.3 6.5 6.5 1.7-1.7c0.7-0.7 1.5-2 1.1-2.4-0.6-0.7-1.7 0.1-2.5-0.4-1-0.7-0.8-2 0.3-3s2.5-1.3 3.1-0.4c0.7 1.1-0.4 1.8 0.4 2.6 0.4 0.4 1.6-0.2 2-0.6l2.1-2.1-1.1-1.1c-0.6-0.6-1.9-2-1.4-2.5 0.6-0.7 1.7 0.2 2.5-0.4 0.9-0.8 0.6-2.1-0.4-3.1z"></path></g>
<g id="vaadin:pyramid-chart"><path d="M10.29 5l-2.29-4-2.29 4h4.58z"></path><path d="M2.29 11l-2.29 4h16l-2.29-4h-11.42z"></path><path d="M13.14 10l-2.28-4h-5.72l-2.28 4h10.28z"></path></g>
<g id="vaadin:qrcode"><path d="M6 0h-6v6h6v-6zM5 5h-4v-4h4v4z"></path><path d="M2 2h2v2h-2v-2z"></path><path d="M0 16h6v-6h-6v6zM1 11h4v4h-4v-4z"></path><path d="M2 12h2v2h-2v-2z"></path><path d="M10 0v6h6v-6h-6zM15 5h-4v-4h4v4z"></path><path d="M12 2h2v2h-2v-2z"></path><path d="M2 7h-2v2h3v-1h-1z"></path><path d="M7 9h2v2h-2v-2z"></path><path d="M3 7h2v1h-2v-1z"></path><path d="M9 12h-2v1h1v1h1v-1z"></path><path d="M6 7v1h-1v1h2v-2z"></path><path d="M8 4h1v2h-1v-2z"></path><path d="M9 8v1h2v-2h-3v1z"></path><path d="M7 6h1v1h-1v-1z"></path><path d="M9 14h2v2h-2v-2z"></path><path d="M7 14h1v2h-1v-2z"></path><path d="M9 11h1v1h-1v-1z"></path><path d="M9 3v-2h-1v-1h-1v4h1v-1z"></path><path d="M12 14h1v2h-1v-2z"></path><path d="M12 12h2v1h-2v-1z"></path><path d="M11 13h1v1h-1v-1z"></path><path d="M10 12h1v1h-1v-1z"></path><path d="M14 10v1h1v1h1v-2h-1z"></path><path d="M15 13h-1v3h2v-2h-1z"></path><path d="M10 10v1h3v-2h-2v1z"></path><path d="M12 7v1h2v1h2v-2h-2z"></path></g>
<g id="vaadin:question-circle-o"><path d="M9 10h-2c0-2 1.2-2.6 2-3 0.3-0.1 0.5-0.2 0.7-0.4 0.1-0.1 0.3-0.3 0.1-0.7-0.2-0.5-0.8-1-1.7-1-1.4 0-1.6 1.2-1.7 1.5l-2-0.3c0.1-1.1 1-3.2 3.6-3.2 1.6 0 3 0.9 3.6 2.2 0.4 1.1 0.2 2.2-0.6 3-0.4 0.4-0.8 0.6-1.2 0.7-0.6 0.4-0.8 0.2-0.8 1.2z"></path><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M6.9 11h2v2h-2v-2z"></path></g>
<g id="vaadin:question-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM8.9 13h-2v-2h2v2zM11 8.1c-0.4 0.4-0.8 0.6-1.2 0.7-0.6 0.4-0.8 0.2-0.8 1.2h-2c0-2 1.2-2.6 2-3 0.3-0.1 0.5-0.2 0.7-0.4 0.1-0.1 0.3-0.3 0.1-0.7-0.2-0.5-0.8-1-1.7-1-1.4 0-1.6 1.2-1.7 1.5l-2-0.3c0.1-1.1 1-3.2 3.6-3.2 1.6 0 3 0.9 3.6 2.2 0.4 1.1 0.2 2.2-0.6 3z"></path></g>
<g id="vaadin:question"><path d="M9 11h-3c0-3 1.6-4 2.7-4.6 0.4-0.2 0.7-0.4 0.9-0.6 0.5-0.5 0.3-1.2 0.2-1.4-0.3-0.7-1-1.4-2.3-1.4-2.1 0-2.5 1.9-2.5 2.3l-3-0.4c0.2-1.7 1.7-4.9 5.5-4.9 2.3 0 4.3 1.3 5.1 3.2 0.7 1.7 0.4 3.5-0.8 4.7-0.5 0.5-1.1 0.8-1.6 1.1-0.9 0.5-1.2 1-1.2 2z"></path><path d="M9.5 14c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:quote-left"><path d="M7 7v7h-7v-7.1c0-4.8 4.5-5.4 4.5-5.4l0.6 1.4c0 0-2 0.3-2.4 1.9-0.4 1.2 0.4 2.2 0.4 2.2h3.9z"></path><path d="M16 7v7h-7v-7.1c0-4.8 4.5-5.4 4.5-5.4l0.6 1.4c0 0-2 0.3-2.4 1.9-0.4 1.2 0.4 2.2 0.4 2.2h3.9z"></path></g>
<g id="vaadin:quote-right"><path d="M9 9v-7h7v7.1c0 4.8-4.5 5.4-4.5 5.4l-0.6-1.4c0 0 2-0.3 2.4-1.9 0.4-1.2-0.4-2.2-0.4-2.2h-3.9z"></path><path d="M0 9v-7h7v7.1c0 4.8-4.5 5.4-4.5 5.4l-0.6-1.4c0 0 2-0.3 2.4-1.9 0.4-1.2-0.4-2.2-0.4-2.2h-3.9z"></path></g>
<g id="vaadin:random"><path d="M13 12h-2c-1 0-1.7-1.2-2.4-2.7-0.3 0.7-0.6 1.5-1 2.3 0.8 1.4 1.8 2.4 3.4 2.4h2v2l3-3-3-3v2z"></path><path d="M5.4 6.6c0.3-0.7 0.6-1.5 1-2.2-0.8-1.4-1.9-2.4-3.4-2.4h-3v2h3c1 0 1.7 1.2 2.4 2.6z"></path><path d="M16 3l-3-3v2h-2c-2.7 0-3.9 3-5 5.7-0.8 2.1-1.7 4.3-3 4.3h-3v2h3c2.6 0 3.8-2.8 4.9-5.6 0.9-2.2 1.8-4.4 3.1-4.4h2v2l3-3z"></path></g>
<g id="vaadin:raster-lower-left"><path d="M15 7h1v1h-1v-1z"></path><path d="M13 7h1v1h-1v-1z"></path><path d="M11 7h1v1h-1v-1z"></path><path d="M9 7h1v1h-1v-1z"></path><path d="M14 6h1v1h-1v-1z"></path><path d="M12 6h1v1h-1v-1z"></path><path d="M10 6h1v1h-1v-1z"></path><path d="M15 5h1v1h-1v-1z"></path><path d="M13 5h1v1h-1v-1z"></path><path d="M11 5h1v1h-1v-1z"></path><path d="M14 4h1v1h-1v-1z"></path><path d="M12 4h1v1h-1v-1z"></path><path d="M15 3h1v1h-1v-1z"></path><path d="M13 3h1v1h-1v-1z"></path><path d="M14 2h1v1h-1v-1z"></path><path d="M15 1h1v1h-1v-1z"></path><path d="M7 15h1v1h-1v-1z"></path><path d="M5 15h1v1h-1v-1z"></path><path d="M3 15h1v1h-1v-1z"></path><path d="M1 15h1v1h-1v-1z"></path><path d="M6 14h1v1h-1v-1z"></path><path d="M4 14h1v1h-1v-1z"></path><path d="M2 14h1v1h-1v-1z"></path><path d="M7 13h1v1h-1v-1z"></path><path d="M5 13h1v1h-1v-1z"></path><path d="M3 13h1v1h-1v-1z"></path><path d="M6 12h1v1h-1v-1z"></path><path d="M4 12h1v1h-1v-1z"></path><path d="M7 11h1v1h-1v-1z"></path><path d="M5 11h1v1h-1v-1z"></path><path d="M6 10h1v1h-1v-1z"></path><path d="M7 9h1v1h-1v-1z"></path><path d="M15 15h1v1h-1v-1z"></path><path d="M13 15h1v1h-1v-1z"></path><path d="M11 15h1v1h-1v-1z"></path><path d="M9 15h1v1h-1v-1z"></path><path d="M14 14h1v1h-1v-1z"></path><path d="M12 14h1v1h-1v-1z"></path><path d="M10 14h1v1h-1v-1z"></path><path d="M8 14h1v1h-1v-1z"></path><path d="M15 13h1v1h-1v-1z"></path><path d="M13 13h1v1h-1v-1z"></path><path d="M11 13h1v1h-1v-1z"></path><path d="M9 13h1v1h-1v-1z"></path><path d="M14 12h1v1h-1v-1z"></path><path d="M12 12h1v1h-1v-1z"></path><path d="M10 12h1v1h-1v-1z"></path><path d="M8 12h1v1h-1v-1z"></path><path d="M15 11h1v1h-1v-1z"></path><path d="M13 11h1v1h-1v-1z"></path><path d="M11 11h1v1h-1v-1z"></path><path d="M9 11h1v1h-1v-1z"></path><path d="M14 10h1v1h-1v-1z"></path><path d="M12 10h1v1h-1v-1z"></path><path d="M10 10h1v1h-1v-1z"></path><path d="M8 10h1v1h-1v-1z"></path><path d="M15 9h1v1h-1v-1z"></path><path d="M13 9h1v1h-1v-1z"></path><path d="M11 9h1v1h-1v-1z"></path><path d="M9 9h1v1h-1v-1z"></path><path d="M14 8h1v1h-1v-1z"></path><path d="M12 8h1v1h-1v-1z"></path><path d="M10 8h1v1h-1v-1z"></path><path d="M8 8h1v1h-1v-1z"></path></g>
<g id="vaadin:raster"><path d="M7 7h1v1h-1v-1z"></path><path d="M5 7h1v1h-1v-1z"></path><path d="M3 7h1v1h-1v-1z"></path><path d="M1 7h1v1h-1v-1z"></path><path d="M6 6h1v1h-1v-1z"></path><path d="M4 6h1v1h-1v-1z"></path><path d="M2 6h1v1h-1v-1z"></path><path d="M0 6h1v1h-1v-1z"></path><path d="M7 5h1v1h-1v-1z"></path><path d="M5 5h1v1h-1v-1z"></path><path d="M3 5h1v1h-1v-1z"></path><path d="M1 5h1v1h-1v-1z"></path><path d="M6 4h1v1h-1v-1z"></path><path d="M4 4h1v1h-1v-1z"></path><path d="M2 4h1v1h-1v-1z"></path><path d="M0 4h1v1h-1v-1z"></path><path d="M7 3h1v1h-1v-1z"></path><path d="M5 3h1v1h-1v-1z"></path><path d="M3 3h1v1h-1v-1z"></path><path d="M1 3h1v1h-1v-1z"></path><path d="M6 2h1v1h-1v-1z"></path><path d="M4 2h1v1h-1v-1z"></path><path d="M2 2h1v1h-1v-1z"></path><path d="M0 2h1v1h-1v-1z"></path><path d="M7 1h1v1h-1v-1z"></path><path d="M5 1h1v1h-1v-1z"></path><path d="M3 1h1v1h-1v-1z"></path><path d="M1 1h1v1h-1v-1z"></path><path d="M6 0h1v1h-1v-1z"></path><path d="M4 0h1v1h-1v-1z"></path><path d="M2 0h1v1h-1v-1z"></path><path d="M0 0h1v1h-1v-1z"></path><path d="M15 7h1v1h-1v-1z"></path><path d="M13 7h1v1h-1v-1z"></path><path d="M11 7h1v1h-1v-1z"></path><path d="M9 7h1v1h-1v-1z"></path><path d="M14 6h1v1h-1v-1z"></path><path d="M12 6h1v1h-1v-1z"></path><path d="M10 6h1v1h-1v-1z"></path><path d="M8 6h1v1h-1v-1z"></path><path d="M15 5h1v1h-1v-1z"></path><path d="M13 5h1v1h-1v-1z"></path><path d="M11 5h1v1h-1v-1z"></path><path d="M9 5h1v1h-1v-1z"></path><path d="M14 4h1v1h-1v-1z"></path><path d="M12 4h1v1h-1v-1z"></path><path d="M10 4h1v1h-1v-1z"></path><path d="M8 4h1v1h-1v-1z"></path><path d="M15 3h1v1h-1v-1z"></path><path d="M13 3h1v1h-1v-1z"></path><path d="M11 3h1v1h-1v-1z"></path><path d="M9 3h1v1h-1v-1z"></path><path d="M14 2h1v1h-1v-1z"></path><path d="M12 2h1v1h-1v-1z"></path><path d="M10 2h1v1h-1v-1z"></path><path d="M8 2h1v1h-1v-1z"></path><path d="M15 1h1v1h-1v-1z"></path><path d="M13 1h1v1h-1v-1z"></path><path d="M11 1h1v1h-1v-1z"></path><path d="M9 1h1v1h-1v-1z"></path><path d="M14 0h1v1h-1v-1z"></path><path d="M12 0h1v1h-1v-1z"></path><path d="M10 0h1v1h-1v-1z"></path><path d="M8 0h1v1h-1v-1z"></path><path d="M7 15h1v1h-1v-1z"></path><path d="M5 15h1v1h-1v-1z"></path><path d="M3 15h1v1h-1v-1z"></path><path d="M1 15h1v1h-1v-1z"></path><path d="M6 14h1v1h-1v-1z"></path><path d="M4 14h1v1h-1v-1z"></path><path d="M2 14h1v1h-1v-1z"></path><path d="M0 14h1v1h-1v-1z"></path><path d="M7 13h1v1h-1v-1z"></path><path d="M5 13h1v1h-1v-1z"></path><path d="M3 13h1v1h-1v-1z"></path><path d="M1 13h1v1h-1v-1z"></path><path d="M6 12h1v1h-1v-1z"></path><path d="M4 12h1v1h-1v-1z"></path><path d="M2 12h1v1h-1v-1z"></path><path d="M0 12h1v1h-1v-1z"></path><path d="M7 11h1v1h-1v-1z"></path><path d="M5 11h1v1h-1v-1z"></path><path d="M3 11h1v1h-1v-1z"></path><path d="M1 11h1v1h-1v-1z"></path><path d="M6 10h1v1h-1v-1z"></path><path d="M4 10h1v1h-1v-1z"></path><path d="M2 10h1v1h-1v-1z"></path><path d="M0 10h1v1h-1v-1z"></path><path d="M7 9h1v1h-1v-1z"></path><path d="M5 9h1v1h-1v-1z"></path><path d="M3 9h1v1h-1v-1z"></path><path d="M1 9h1v1h-1v-1z"></path><path d="M6 8h1v1h-1v-1z"></path><path d="M4 8h1v1h-1v-1z"></path><path d="M2 8h1v1h-1v-1z"></path><path d="M0 8h1v1h-1v-1z"></path><path d="M15 15h1v1h-1v-1z"></path><path d="M13 15h1v1h-1v-1z"></path><path d="M11 15h1v1h-1v-1z"></path><path d="M9 15h1v1h-1v-1z"></path><path d="M14 14h1v1h-1v-1z"></path><path d="M12 14h1v1h-1v-1z"></path><path d="M10 14h1v1h-1v-1z"></path><path d="M8 14h1v1h-1v-1z"></path><path d="M15 13h1v1h-1v-1z"></path><path d="M13 13h1v1h-1v-1z"></path><path d="M11 13h1v1h-1v-1z"></path><path d="M9 13h1v1h-1v-1z"></path><path d="M14 12h1v1h-1v-1z"></path><path d="M12 12h1v1h-1v-1z"></path><path d="M10 12h1v1h-1v-1z"></path><path d="M8 12h1v1h-1v-1z"></path><path d="M15 11h1v1h-1v-1z"></path><path d="M13 11h1v1h-1v-1z"></path><path d="M11 11h1v1h-1v-1z"></path><path d="M9 11h1v1h-1v-1z"></path><path d="M14 10h1v1h-1v-1z"></path><path d="M12 10h1v1h-1v-1z"></path><path d="M10 10h1v1h-1v-1z"></path><path d="M8 10h1v1h-1v-1z"></path><path d="M15 9h1v1h-1v-1z"></path><path d="M13 9h1v1h-1v-1z"></path><path d="M11 9h1v1h-1v-1z"></path><path d="M9 9h1v1h-1v-1z"></path><path d="M14 8h1v1h-1v-1z"></path><path d="M12 8h1v1h-1v-1z"></path><path d="M10 8h1v1h-1v-1z"></path><path d="M8 8h1v1h-1v-1z"></path></g>
<g id="vaadin:records"><path d="M4 9h4v2h-4v-2z"></path><path d="M16 2h-1v-2h-10v2h-2v1.25l-0.6 0.75h-1.4v1.75l-1 1.25v9h12l4-5v-9zM2 5h8v2h-8v-2zM11 15h-10v-7h10v7zM12 7h-1v-3h-7v-1h8v4zM14 4.5l-1 1.25v-3.75h-7v-1h8v3.5z"></path></g>
<g id="vaadin:recycle"><path d="M8 3.1l1.4 2.2-1.6 1.1 1.3 0.3 2.8 0.6 0.6-2.7 0.4-1.4-1.8 1.1-2-3.3h-2.2l-2.6 4.3 1.7 1z"></path><path d="M16 12l-2.7-4.3-1.7 1 2 3.3h-2.6v-2l-3 3 3 3v-2h3.7z"></path><path d="M2.4 12v0l1.4-2.3 1.7 1.1-0.9-4.2-2.8 0.7-1.3 0.3 1.6 1-2.1 3.4 1.3 2h5.7v-2z"></path></g>
<g id="vaadin:refresh"><path d="M2.6 5.6c0.9-2.1 3-3.6 5.4-3.6 3 0 5.4 2.2 5.9 5h2c-0.5-3.9-3.8-7-7.9-7-3 0-5.6 1.6-6.9 4.1l-1.1-1.1v4h4l-1.4-1.4z"></path><path d="M16 9h-4.1l1.5 1.4c-0.9 2.1-3 3.6-5.5 3.6-2.9 0-5.4-2.2-5.9-5h-2c0.5 3.9 3.9 7 7.9 7 3 0 5.6-1.7 7-4.1l1.1 1.1v-4z"></path></g>
<g id="vaadin:reply-all"><path d="M16 8c0-5-4.9-5-4.9-5h-2.1v-3l-6 6 6 6v-3h2.2c3.5 0 1.8 7 1.8 7s3-4.1 3-8z"></path><path d="M0 6l6 6v-1.5l-4.5-4.5 4.5-4.5v-1.5z"></path></g>
<g id="vaadin:reply"><path d="M16 8c0-5-4.9-5-4.9-5h-5.1v-3l-6 6 6 6v-3h5.2c3.5 0 1.8 7 1.8 7s3-4.1 3-8z"></path></g>
<g id="vaadin:resize-h"><path d="M0 7h16v2h-16v-2z"></path><path d="M7 6h2v-3h2l-3-3-3 3h2z"></path><path d="M9 10h-2v3h-2l3 3 3-3h-2z"></path></g>
<g id="vaadin:resize-v"><path d="M7 0h2v16h-2v-16z"></path><path d="M3 5l-3 3 3 3v-2h3v-2h-3z"></path><path d="M16 8l-3-3v2h-3v2h3v2z"></path></g>
<g id="vaadin:retweet"><path d="M2 1h12v5h2l-3 3-3-3h2v-3h-8v2h-2z"></path><path d="M14 14h-12v-5h-2l3-3 3 3h-2v3h8v-2h2z"></path></g>
<g id="vaadin:rhombus"><path d="M8 0l-8 8 8 8 8-8-8-8zM2 8l6-6 6 6-6 6-6-6z"></path></g>
<g id="vaadin:road-branch"><path d="M16 4h-16v3h3.2l3.8 3.6c1.6 1.5 3.6 2.4 5.8 2.4h3.2v-3h-3.2c-1.4 0-2.7-0.5-3.7-1.5l-1.6-1.5h8.5v-3z"></path></g>
<g id="vaadin:road-branches"><path d="M16 4v-3h-16v3h1.7l7.7 9.5c1.3 1.6 3.1 2.5 5 2.5h1.6v-3h-1.5c-1 0-1.9-0.5-2.7-1.4l-1.3-1.6h5.5v-3h-8l-2.4-3h10.4z"></path></g>
<g id="vaadin:road-split"><path d="M14 13v-1c0-0.2 0-4.1-2.8-5.4-2.2-1-2.2-3.5-2.2-3.6v-3h-2v3c0 0.1 0 2.6-2.2 3.6-2.8 1.3-2.8 5.2-2.8 5.4v1h-2l3 3 3-3h-2v-1c0 0 0-2.8 1.7-3.6 1.1-0.5 1.8-1.3 2.3-2 0.5 0.8 1.2 1.5 2.3 2 1.7 0.8 1.7 3.6 1.7 3.6v1h-2l3 3 3-3h-2z"></path></g>
<g id="vaadin:road"><path d="M9 11v4h7l-4-14h-3v3h-2v-3h-3l-4 14h7v-4h2zM7 6h2v3h-2v-3z"></path></g>
<g id="vaadin:rocket"><path d="M16 0c0 0-3.5-0.4-6.7 2.8-1.6 1.5-2.9 3.5-3.9 5.3l-2.5-0.6-1.6 1.6 2.8 1.4c-0.3 0.6-0.4 1-0.4 1l0.8 0.8c0 0 0.4-0.2 1-0.4l1.4 2.8 1.6-1.6-0.5-2.5c1.7-1 3.8-2.3 5.3-3.8 3.1-3.2 2.7-6.8 2.7-6.8zM12.8 4.8c-0.4 0.4-1.1 0.4-1.6 0-0.4-0.4-0.4-1.1 0-1.6 0.4-0.4 1.1-0.4 1.6 0 0.4 0.4 0.4 1.1 0 1.6z"></path><path d="M4 14.2c-0.8 0.8-2.6 0.4-2.6 0.4s-0.4-1.8 0.4-2.6c0.8-0.8 1.5-0.9 1.5-0.9s-1.3-0.3-2.1 0.6c-1.6 1.6-1 4.2-1 4.2s2.6 0.6 4.2-1c0.9-0.9 0.6-2.2 0.6-2.2s-0.2 0.7-1 1.5z"></path></g>
<g id="vaadin:rotate-left"><path d="M8 0c-3 0-5.6 1.6-6.9 4.1l-1.1-1.1v4h4l-1.5-1.5c1-2 3.1-3.5 5.5-3.5 3.3 0 6 2.7 6 6s-2.7 6-6 6c-1.8 0-3.4-0.8-4.5-2.1l-1.5 1.3c1.4 1.7 3.6 2.8 6 2.8 4.4 0 8-3.6 8-8s-3.6-8-8-8z"></path></g>
<g id="vaadin:rotate-right"><path d="M16 7v-4l-1.1 1.1c-1.3-2.5-3.9-4.1-6.9-4.1-4.4 0-8 3.6-8 8s3.6 8 8 8c2.4 0 4.6-1.1 6-2.8l-1.5-1.3c-1.1 1.3-2.7 2.1-4.5 2.1-3.3 0-6-2.7-6-6s2.7-6 6-6c2.4 0 4.5 1.5 5.5 3.5l-1.5 1.5h4z"></path></g>
<g id="vaadin:rss-square"><path d="M0 0v16h16v-16h-16zM3.6 14c-0.9 0-1.6-0.7-1.6-1.6s0.7-1.6 1.6-1.6 1.6 0.7 1.6 1.6-0.6 1.6-1.6 1.6zM7.6 14c0-3.1-2.5-5.6-5.6-5.6v-2.4c4.4 0 8 3.6 8 8h-2.4zM11.6 14c0-5.3-4.3-9.6-9.6-9.6v-2.4c6.6 0 12 5.4 12 12h-2.4z"></path></g>
<g id="vaadin:rss"><path d="M4.4 13.8c0 1.215-0.985 2.2-2.2 2.2s-2.2-0.985-2.2-2.2c0-1.215 0.985-2.2 2.2-2.2s2.2 0.985 2.2 2.2z"></path><path d="M10.6 16h-3.1c0-4.1-3.4-7.5-7.5-7.5v0-3.1c5.9 0 10.6 4.7 10.6 10.6z"></path><path d="M12.8 16c0-7.1-5.7-12.8-12.8-12.8v-3.2c8.8 0 16 7.2 16 16h-3.2z"></path></g>
<g id="vaadin:safe-lock"><path d="M8 0c-4.418 0-8 3.582-8 8s3.582 8 8 8c4.418 0 8-3.582 8-8s-3.582-8-8-8zM11.13 14.25l-0.37-0.9-0.92 0.38 0.37 0.9c-0.659 0.23-1.419 0.363-2.21 0.363s-1.551-0.133-2.259-0.378l0.419-0.885-0.92-0.38-0.37 0.9c-1.355-0.69-2.43-1.765-3.102-3.080l0.882-0.41-0.38-0.93-0.9 0.37c-0.23-0.659-0.363-1.419-0.363-2.21s0.133-1.551 0.378-2.259l0.885 0.419 0.38-0.92-0.9-0.37c0.691-1.351 1.766-2.423 3.080-3.092l0.41 0.882 0.92-0.38-0.37-0.9c0.659-0.23 1.419-0.363 2.21-0.363s1.551 0.133 2.259 0.378l-0.419 0.885 0.92 0.38 0.37-0.9c1.355 0.69 2.43 1.765 3.102 3.080l-0.882 0.41 0.38 0.92 0.9-0.37c0.23 0.659 0.363 1.419 0.363 2.21s-0.133 1.551-0.378 2.259l-0.885-0.419-0.38 0.92 0.9 0.37c-0.69 1.355-1.765 2.43-3.080 3.102z"></path><path d="M10.36 3.62l-1.16 2.79c-0.329-0.253-0.746-0.407-1.199-0.41h0.279l1.15-2.77c-0.426-0.14-0.917-0.223-1.427-0.23-0.023-0-0.047-0-0.071-0-2.795 0-5.060 2.265-5.060 5.060s2.265 5.060 5.060 5.060c2.795 0 5.060-2.265 5.060-5.060 0-1.904-1.052-3.563-2.606-4.426z"></path></g>
<g id="vaadin:safe"><path d="M1 0v16h3v-1h8v1h3v-16h-14zM14 10h-1v-5h1v5zM14 3h-1v-1h-10v11h10v-1h1v2h-12v-13h12v2zM8.5 7.5c0 1.1-0.9 2-2 2s-2-0.9-2-2 0.9-2 2-2 2 0.9 2 2z"></path><path d="M7.5 7.5c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:scale-unbalance"><path d="M15.81 9l-2.47-4.93 0.83-0.15c0.239-0.044 0.418-0.251 0.418-0.5 0-0.281-0.227-0.508-0.508-0.508-0.032 0-0.063 0.003-0.093 0.009l-0.777 0.14c-0.993-0.755-2.25-1.21-3.613-1.21-0.21 0-0.418 0.011-0.623 0.032-0.036-0.5-0.457-0.882-0.967-0.882-0.003 0-0.005 0-0.008 0-0.552 0-1 0.448-1 1v0.2c-1.714 0.336-3.151 1.327-4.066 2.697l-0.754 0.153c-0.257 0.024-0.457 0.239-0.457 0.5 0 0.277 0.225 0.502 0.502 0.502 0.016 0 0.032-0.001 0.047-0.002l0.088 0 0.35-0.050-2.52 5h-0.19c0 1.1 1.34 2 3 2s3-0.9 3-2h-0.19l-2.56-5.12h0.1c0.172-0.031 0.311-0.144 0.379-0.297 0.021-0.093 0.701-1.583 3.271-2.363v10.78h-1v1h-2v1h8v-1h-2v-1h-1v-11.12c0.201-0.031 0.434-0.049 0.67-0.049 1.152 0 2.205 0.419 3.016 1.114l-0.006-0.005-2.49 5.060h-0.19c0 1.1 1.34 2 3 2s3-0.9 3-2h-0.19zM5 11h-4l2-3.94zM11 9l2-3.94 2 3.94h-4z"></path></g>
<g id="vaadin:scale"><path d="M15.81 10l-2.5-5h0.69c0.276 0 0.5-0.224 0.5-0.5s-0.224-0.5-0.5-0.5h-0.79c-1.056-1.145-2.541-1.881-4.198-1.95l-0.012-0.050c0-0.552-0.448-1-1-1s-1 0.448-1 1v0.050c-1.681 0.073-3.178 0.807-4.247 1.947l-0.753 0.003c-0.276 0-0.5 0.224-0.5 0.5s0.224 0.5 0.5 0.5h0.69l-2.5 5h-0.19c0 1.1 1.34 2 3 2s3-0.9 3-2h-0.19l-2.55-5.090c0.064-0.039 0.118-0.089 0.159-0.148 0.873-1.019 2.148-1.669 3.575-1.702l0.006 10.94h-1v1h-2v1h8v-1h-2v-1h-1v-10.94c1.418 0.030 2.679 0.682 3.524 1.693 0.053 0.084 0.117 0.145 0.193 0.186l-2.527 5.061h-0.19c0 1.1 1.34 2 3 2s3-0.9 3-2h-0.19zM5 10h-4l2-3.94zM11 10l2-3.94 2 3.94h-4z"></path></g>
<g id="vaadin:scatter-chart"><path d="M1 15v-15h-1v16h16v-1h-15z"></path><path d="M5 11c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M8 6c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M14 5c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M11 10c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:scissors"><path d="M16 3.1c0 0-2.1-1.1-3.5-1-0.3 0-0.5 0.1-0.7 0.2l-4.3 3.4-1.8-1.5c0.1-0.3 0.2-0.6 0.3-1 0.1-1.8-1.4-3.4-3.3-3.2-1.2 0.1-2.3 1-2.6 2.2-0.3 1.3 0.2 2.5 1.2 3.2l3.3 2.6-3.3 2.6c-1 0.7-1.5 1.9-1.2 3.2 0.3 1.2 1.4 2 2.6 2.2 1.9 0.2 3.4-1.4 3.2-3.2 0-0.3-0.1-0.7-0.3-1l1.8-1.5 4.3 3.4c0.2 0.1 0.4 0.2 0.7 0.2 1.4 0.1 3.5-1 3.5-1l-5.7-4.9 5.8-4.9zM2.8 4.6c-0.9-0.1-1.6-0.9-1.5-1.8s0.9-1.6 1.8-1.5c0.9 0.1 1.6 0.9 1.5 1.8 0 0.9-0.9 1.6-1.8 1.5zM3.1 14.7c-0.9 0.1-1.7-0.6-1.8-1.5s0.6-1.7 1.5-1.8c0.9-0.1 1.7 0.6 1.8 1.5s-0.6 1.7-1.5 1.8zM12.4 3.2c0 0 0.1 0 0.2 0 0.4 0 0.9 0.1 1.4 0.2l-6.8 5.7-0.9-1.1 6.1-4.8zM14 12.6c-0.5 0.2-1 0.3-1.4 0.2-0.1 0-0.2 0-0.2 0l-4-3.2 1-0.9 4.6 3.9z"></path></g>
<g id="vaadin:screwdriver"><path d="M8 10.8l0.9-0.8-0.9-0.9 5.7-5.7 1.2-0.4 1.1-2.2-0.7-0.7-2.3 1-0.5 1.2-5.6 5.7-0.9-0.9-0.8 0.9c0 0 0.8 0.6-0.1 1.5-0.5 0.5-1.3-0.1-2.8 1.4-0.5 0.5-2.1 2.1-2.1 2.1s-0.6 1 0.6 2.2 2.2 0.6 2.2 0.6 1.6-1.6 2.1-2.1c1.4-1.4 0.9-2.3 1.3-2.7 0.9-0.9 1.6-0.2 1.6-0.2zM4.9 10.4l0.7 0.7-3.8 3.8-0.7-0.7z"></path></g>
<g id="vaadin:search-minus"><path d="M15.7 14.3l-4.2-4.2c-0.2-0.2-0.5-0.3-0.8-0.3 0.8-1 1.3-2.4 1.3-3.8 0-3.3-2.7-6-6-6s-6 2.7-6 6 2.7 6 6 6c1.4 0 2.8-0.5 3.8-1.4 0 0.3 0 0.6 0.3 0.8l4.2 4.2c0.2 0.2 0.5 0.3 0.7 0.3s0.5-0.1 0.7-0.3c0.4-0.3 0.4-0.9 0-1.3zM6 10.5c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5 4.5 2 4.5 4.5-2 4.5-4.5 4.5z"></path><path d="M3 5h6v2h-6v-2z"></path></g>
<g id="vaadin:search-plus"><path d="M15.7 14.3l-4.2-4.2c-0.2-0.2-0.5-0.3-0.8-0.3 0.8-1 1.3-2.4 1.3-3.8 0-3.3-2.7-6-6-6s-6 2.7-6 6 2.7 6 6 6c1.4 0 2.8-0.5 3.8-1.4 0 0.3 0 0.6 0.3 0.8l4.2 4.2c0.2 0.2 0.5 0.3 0.7 0.3s0.5-0.1 0.7-0.3c0.4-0.3 0.4-0.9 0-1.3zM6 10.5c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5 4.5 2 4.5 4.5-2 4.5-4.5 4.5z"></path><path d="M7 3h-2v2h-2v2h2v2h2v-2h2v-2h-2z"></path></g>
<g id="vaadin:search"><path d="M15.7 14.3l-4.2-4.2c-0.2-0.2-0.5-0.3-0.8-0.3 0.8-1 1.3-2.4 1.3-3.8 0-3.3-2.7-6-6-6s-6 2.7-6 6 2.7 6 6 6c1.4 0 2.8-0.5 3.8-1.4 0 0.3 0 0.6 0.3 0.8l4.2 4.2c0.2 0.2 0.5 0.3 0.7 0.3s0.5-0.1 0.7-0.3c0.4-0.3 0.4-0.9 0-1.3zM6 10.5c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5 4.5 2 4.5 4.5-2 4.5-4.5 4.5z"></path></g>
<g id="vaadin:select"><path d="M15 4h-14c-0.6 0-1 0.4-1 1v6c0 0.6 0.4 1 1 1h14c0.6 0 1-0.4 1-1v-6c0-0.6-0.4-1-1-1zM12 9l-2-2h4l-2 2z"></path></g>
<g id="vaadin:server"><path d="M3 5v3h10v-3h-10zM7 7h-3v-1h3v1z"></path><path d="M3 4h10l-2-4h-6z"></path><path d="M3 12h10v-3h-10v3zM11 10h1v1h-1v-1zM9 10h1v1h-1v-1z"></path><path d="M3 16h10v-3h-10v3zM4 14h3v1h-3v-1z"></path></g>
<g id="vaadin:share-square"><path d="M11 3h-3.6c0 0-4.4-0.2-4.4 4.3 0 3.5 2 6.7 2 6.7s-0.4-7 2.3-7h3.7v3l5-5-5-5v3z"></path><path d="M14 9v6h-13v-13h9v-1h-10v15h15v-8z"></path></g>
<g id="vaadin:share"><path d="M10 3h-5.1c0 0-4.9 0-4.9 5 0 3.9 3 8 3 8s-1.7-7 1.8-7h5.2v3l6-6-6-6v3z"></path></g>
<g id="vaadin:shield"><path d="M1 0c0 0 0 3.2 0 7 0 5.6 7 9 7 9s7-3.4 7-9c0-3.8 0-7 0-7h-14zM14 7c0 4.2-4.6 7.1-6 7.9v-13.9h6v6z"></path></g>
<g id="vaadin:shift-arrow"><path d="M8 2l-7 7h4v5h6v-5h4zM10 8v5h-4v-5h-2.5l4.5-4.58 4.5 4.58h-2.5z"></path></g>
<g id="vaadin:shift"><path d="M0 2v12h16v-12h-16zM6 8v3h-2v-3h-2l3-3 3 3h-2z"></path></g>
<g id="vaadin:shop"><path d="M0 15h16v1h-16v-1z"></path><path d="M0 0v6c0.005 0.732 0.401 1.37 0.991 1.715l0.009 6.285h9v-5h3v5h2v-6.28c0.599-0.35 0.995-0.988 1-1.719v-6.001h-16zM4 2h2v4c0 0.552-0.448 1-1 1s-1-0.448-1-1v-4zM2 7c-0.552 0-1-0.448-1-1v-4h2v4c0 0.552-0.448 1-1 1zM8 12h-5v-3h5v3zM9 6c0 0.552-0.448 1-1 1s-1-0.448-1-1v-4h2v4zM12 6c0 0.552-0.448 1-1 1s-1-0.448-1-1v-4h2v4zM15 6c0 0.552-0.448 1-1 1s-1-0.448-1-1v-4h2v4z"></path></g>
<g id="vaadin:sign-in-alt"><path d="M0 0h2v16h-2v-16z"></path><path d="M3 10h8v3l5-5-5-5v3h-8z"></path></g>
<g id="vaadin:sign-in"><path d="M7 1v2l1 1v-2h7v12h-7v-2l-1 1v2h9v-14z"></path><path d="M10 8l-5-4v2h-5v4h5v2z"></path></g>
<g id="vaadin:sign-out-alt"><path d="M14 0h2v16h-2v-16z"></path><path d="M8 6h-8v4h8v3l5-5-5-5z"></path></g>
<g id="vaadin:sign-out"><path d="M9 4v-3h-9v14h9v-3h-1v2h-7v-12h7v2z"></path><path d="M16 8l-5-4v2h-5v4h5v2z"></path></g>
<g id="vaadin:signal"><path d="M6.9 13.2l1.1 1.1 1.1-1.1c-0.3-0.3-0.7-0.5-1.1-0.5s-0.9 0.2-1.1 0.5z"></path><path d="M8 4.6c2.7 0 5.1 1.1 6.9 2.8l1.1-1.1c-2-2-4.9-3.3-8-3.3s-6 1.3-8 3.3l1.1 1.1c1.8-1.7 4.2-2.8 6.9-2.8z"></path><path d="M2.3 8.6l1.1 1.1c1.2-1.1 2.8-1.8 4.6-1.8s3.4 0.7 4.6 1.9l1.1-1.1c-1.4-1.6-3.5-2.5-5.7-2.5s-4.3 0.9-5.7 2.4z"></path><path d="M4.6 10.9l1.1 1.1c0.6-0.6 1.4-0.9 2.3-0.9s1.7 0.4 2.3 0.9l1.1-1.1c-0.8-0.9-2.1-1.4-3.4-1.4s-2.6 0.5-3.4 1.4z"></path></g>
<g id="vaadin:sitemap"><path d="M14.5 12v-4.5h-6v-3.5h1.5v-4h-4v4h1.5v3.5h-6v4.5h-1.5v4h4v-4h-1.5v-3.5h5v3.5h-1.5v4h4v-4h-1.5v-3.5h5v3.5h-1.5v4h4v-4z"></path></g>
<g id="vaadin:slider"><path d="M16 6h-3.6c-0.7-1.2-2-2-3.4-2s-2.8 0.8-3.4 2h-5.6v4h5.6c0.7 1.2 2 2 3.4 2s2.8-0.8 3.4-2h3.6v-4zM1 9v-2h4.1c0 0.3-0.1 0.7-0.1 1s0.1 0.7 0.1 1h-4.1zM9 11c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3c0 1.7-1.3 3-3 3z"></path></g>
<g id="vaadin:sliders"><path d="M7 0h2v3h-2v-3z"></path><path d="M6 4v3h1v9h2v-9h1v-3z"></path><path d="M2 0h2v8h-2v-8z"></path><path d="M1 9v3h1v4h2v-4h1v-3z"></path><path d="M12 0h2v10h-2v-10z"></path><path d="M11 11v3h1v2h2v-2h1v-3z"></path></g>
<g id="vaadin:smiley-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M8 13.2c-2 0-3.8-1.2-4.6-3.1l0.9-0.4c0.6 1.5 2.1 2.4 3.7 2.4s3.1-1 3.7-2.4l0.9 0.4c-0.8 2-2.6 3.1-4.6 3.1z"></path><path d="M7 6c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M11 6c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:sort"><path d="M11 7h-6l3-4z"></path><path d="M5 9h6l-3 4z"></path></g>
<g id="vaadin:sound-disable"><path d="M4 5h-4v6h4l5 4v-14z"></path><path d="M15.9 5.6l-0.8-0.7-2.3 2.4-2.4-2.4-0.8 0.7 2.4 2.4-2.4 2.4 0.8 0.7 2.4-2.4 2.3 2.4 0.8-0.7-2.4-2.4z"></path></g>
<g id="vaadin:spark-line"><path d="M14 6c-1.105 0-2 0.895-2 2 0 0.060 0 0.11 0 0.16l-0.81 0.25-2.3-3.48-1.73 4.32-1.16-5.81-2.3 4.78-1.64-1.31-2.060 1.090v1.080l1.94-1 2.11 1.7 1.56-3.22 1.23 6.19 2.27-5.68 1.68 2.52 1.55-0.48c0.364 0.54 0.973 0.89 1.664 0.89 1.105 0 2-0.895 2-2s-0.895-2-2-2c-0.001 0-0.003 0-0.004 0zM14 9c-0.552 0-1-0.448-1-1s0.448-1 1-1c0.552 0 1 0.448 1 1s-0.448 1-1 1z"></path></g>
<g id="vaadin:specialist"><path d="M4.1 8c0.2 0.6 0.3 1.1 0.3 1.1 0.8 1.3 1.8 1.1 1.8 1.8 0 0.3-0.2 0.6-0.5 0.7l2.3 1.8 2.3-1.7c-0.3-0.2-0.5-0.4-0.5-0.7 0-0.8 1-0.5 1.8-1.8 0 0 0.2-0.4 0.3-1.1v0c0.3-1.1 0.6-3.1 0.5-4.1h-1.5c0-0.3 0.1-0.6 0.1-1h1.1c-0.3-1.4-1-2-2.2-2.3-0.5-0.4-1.2-0.7-1.9-0.7s-1.4 0.3-1.9 0.7c-1.2 0.3-1.8 0.9-2.2 2.3h1.1c0 0.4 0.1 0.7 0.2 1h-1.6c-0.1 1 0.2 3 0.5 4v0zM11.2 8.5c-0.1 0.1-0.2 0.2-0.3 0.3l-0.5 0.6c-0.4 0.5-0.8 0.8-1.4 0.9l-0.4 0.1c-0.4 0.1-0.9 0.1-1.4 0l-0.4-0.1c-0.6-0.2-1.1-0.5-1.5-1.1l-0.2-0.4c-0.1-0.1-0.2-0.2-0.3-0.3l-0.7-0.5 3.1-0.9c0.5-0.1 1-0.2 1.5 0l3.2 0.9-0.7 0.5zM6 3c0-1.1 0.9-2 2-2s2 0.9 2 2c0 1.1-0.9 2-2 2s-2-0.9-2-2z"></path><path d="M15.5 14.2c-1.3-2.4-2.6-2-3.9-2.2 0 0 0 0-0.1 0l-3.5 2.6-3.5-2.6c0 0 0 0-0.1 0-1.4 0.1-2.6-0.2-3.9 2.2-0.2 0.4-0.4 1.1-0.5 1.8h16c-0.1-0.7-0.3-1.4-0.5-1.8z"></path></g>
<g id="vaadin:spinner-arc"><path d="M15 8c0 3.9-3.1 7-7 7s-7-3-7-7h-1c0 4 3.6 8 8 8s8-3.6 8-8h-1z"></path></g>
<g id="vaadin:spinner-third"><path d="M12.9 3.1c1.3 1.2 2.1 3 2.1 4.9 0 3.9-3.1 7-7 7s-7-3.1-7-7c0-1.9 0.8-3.7 2.1-4.9l-0.8-0.8c-1.4 1.5-2.3 3.5-2.3 5.7 0 4.4 3.6 8 8 8s8-3.6 8-8c0-2.2-0.9-4.2-2.3-5.7l-0.8 0.8z"></path></g>
<g id="vaadin:spinner"><path d="M9.9 0.2l-0.2 1c3 0.8 5.3 3.5 5.3 6.8 0 3.9-3.1 7-7 7s-7-3.1-7-7c0-3.3 2.3-6 5.3-6.8l-0.2-1c-3.5 0.9-6.1 4.1-6.1 7.8 0 4.4 3.6 8 8 8s8-3.6 8-8c0-3.7-2.6-6.9-6.1-7.8z"></path></g>
<g id="vaadin:spline-area-chart"><path d="M1 15v-15h-1v16h16v-1h-15z"></path><path d="M10 7c-2 0-2.080-1-4-1-2.34 0-4 3-4 3v5h14v-12c-2 0-3.86 5-6 5z"></path></g>
<g id="vaadin:spline-chart"><path d="M1 15v-15h-1v16h16v-1h-15z"></path><path d="M12 5c-0.69 1-1.41 2-2 2-0.026 0.001-0.056 0.001-0.087 0.001-0.601 0-1.164-0.16-1.65-0.44-0.623-0.35-1.387-0.562-2.2-0.562-0.022 0-0.045 0-0.067 0-1.6 0.116-3.009 0.864-3.991 1.993l-0.006 2.347c0.77-1.12 2.32-2.84 4-2.84 0.014-0 0.031-0 0.048-0 0.579 0 1.121 0.156 1.587 0.428 0.643 0.358 1.429 0.573 2.264 0.573 0.035 0 0.071-0 0.106-0.001 1.395 0 2.335-1.32 3.245-2.6s1.75-2.4 2.75-2.4v-1.5c-1.81 0-3 1.61-4 3z"></path></g>
<g id="vaadin:split-h"><path d="M0 1v14h16v-14h-16zM1 4h6.5v10h-6.5v-10zM15 14h-6.5v-10h6.5v10zM15 3h-1v-1h1v1z"></path></g>
<g id="vaadin:split-v"><path d="M0 1v14h16v-14h-16zM14 2h1v1h-1v-1zM15 4v4.5h-14v-4.5h14zM1 14v-4.5h14v4.5h-14z"></path></g>
<g id="vaadin:split"><path d="M0 11h6v5h-6v-5z"></path><path d="M11 10v-2l-0.64 0.64c-0.851-0.81-1.38-1.952-1.38-3.217 0-0.149 0.007-0.296 0.022-0.441l1.999 0.018v-5h-6v5h2c0.013 0.127 0.020 0.274 0.020 0.423 0 1.265-0.529 2.407-1.378 3.216l-0.642-0.638v2h2l-0.65-0.65c1.028-0.991 1.667-2.38 1.667-3.919 0-0.152-0.006-0.302-0.018-0.45-0.010 0.149-0.016 0.299-0.016 0.45 0 1.539 0.639 2.928 1.665 3.917l-0.648 0.652h2z"></path><path d="M10 11h6v5h-6v-5z"></path></g>
<g id="vaadin:spoon"><path d="M10.5 4.8c0-1.8-0.9-4.8-3-4.8s-3 3-3 4.8c0 1.5 0.8 2.8 2.2 3.1-0.5 1.6-0.7 4.6-0.7 4.6v2c0 0.8 0.7 1.5 1.5 1.5s1.5-0.7 1.5-1.5v-2c0-0.6-0.2-3.2-0.7-4.6 1.4-0.3 2.2-1.6 2.2-3.1z"></path></g>
<g id="vaadin:square-shadow"><path d="M14 2v-2h-14v14h2v2h14v-14h-2zM13 13h-12v-12h12v12z"></path></g>
<g id="vaadin:star-half-left-o"><path d="M15.9 6.2l-5.5-0.8-2.4-5-2.4 5-5.5 0.8 3.9 3.8-0.9 5.4 4.9-2.5 4.9 2.6-0.9-5.5 3.9-3.8zM8 11.8v-9.1l1.8 3.6 4 0.6-2.9 2.8 0.7 4-3.6-1.9z"></path></g>
<g id="vaadin:star-half-left"><path d="M5.6 5.4l-5.5 0.8 3.9 3.8-0.9 5.5 4.9-2.6v-12.5z"></path></g>
<g id="vaadin:star-half-right-o"><path d="M15.9 6.2l-5.5-0.8-2.4-5-2.4 5-5.5 0.8 3.9 3.8-0.9 5.4 4.9-2.5 4.9 2.6-0.9-5.5 3.9-3.8zM4.4 13.7l0.7-4-2.9-2.8 4-0.6 1.8-3.6v9.1l-3.6 1.9z"></path></g>
<g id="vaadin:star-half-right"><path d="M10.5 5.4l5.5 0.8-4 3.8 0.9 5.5-4.9-2.6v-12.5z"></path></g>
<g id="vaadin:star-o"><path d="M15.9 6.2l-5.5-0.8-2.4-5-2.4 5-5.5 0.8 3.9 3.8-0.9 5.4 4.9-2.5 4.9 2.6-0.9-5.5 3.9-3.8zM8 11.8l-3.6 1.9 0.7-4-2.9-2.8 4-0.6 1.8-3.6 1.8 3.6 4 0.6-2.9 2.8 0.7 4-3.6-1.9z"></path></g>
<g id="vaadin:star"><path d="M12.9 15.4l-4.9-2.6-4.9 2.6 0.9-5.4-4-3.9 5.5-0.8 2.4-5 2.4 5 5.5 0.8-3.8 3.9 0.9 5.4z"></path></g>
<g id="vaadin:start-cog"><path d="M4 0v6h1.7l0.2 0.7 0.2 0.6c0 0 0.1 0 0.1 0l1.2-0.6 1.8 1.8-0.6 1.2c0 0 0 0.1 0 0.1l0.6 0.2 0.7 0.2v0.2l6.1-3.4-12-7z"></path><path d="M4.5 10.5c-0.2 0-0.4 0.1-0.5 0.2-0.3 0.2-0.5 0.5-0.5 0.8s0.2 0.7 0.5 0.8c0.1 0.1 0.3 0.2 0.5 0.2 0.6 0 1-0.4 1-1s-0.4-1-1-1z"></path><path d="M9 12v-1l-1.1-0.4c-0.1-0.3-0.2-0.6-0.4-0.9l0.5-1-0.7-0.7-1 0.5c-0.3-0.2-0.6-0.3-0.9-0.4l-0.4-1.1h-1l-0.4 1.1c-0.3 0.1-0.6 0.2-0.9 0.4l-1-0.5-0.7 0.7 0.5 1.1c-0.2 0.3-0.3 0.6-0.4 0.9l-1.1 0.3v1l1.1 0.4c0.1 0.3 0.2 0.6 0.4 0.9l-0.5 1 0.7 0.7 1.1-0.5c0.3 0.2 0.6 0.3 0.9 0.4l0.3 1.1h1l0.4-1.1c0.3-0.1 0.6-0.2 0.9-0.4l1 0.5 0.7-0.7-0.5-1.1c0.2-0.3 0.3-0.6 0.4-0.9l1.1-0.3zM4.5 13.5c-1.1 0-2-0.9-2-2s0.9-2 2-2 2 0.9 2 2c0 1.1-0.9 2-2 2z"></path></g>
<g id="vaadin:step-backward"><path d="M14 15v-14l-10 7z"></path><path d="M2 1h2v14h-2v-14z"></path></g>
<g id="vaadin:step-forward"><path d="M2 1v14l10-7z"></path><path d="M12 1h2v14h-2v-14z"></path></g>
<g id="vaadin:stethoscope"><path d="M5.7 15.2c0.3 0.3 1 0.8 1.8 0.8 2.7 0 3.3-2 3.4-3.6 0.2-2.3 0.8-2.2 1.1-2.2 0.7 0 0.9 0.4 0.9 1.1-0.6 0.4-1 1-1 1.7 0 1.1 0.9 2 2 2s2-0.9 2-2-0.9-2-2-2c-0.1 0-0.1 0-0.2 0-0.2-0.9-0.7-1.8-1.8-1.8-1.6 0-2 1.4-2.1 2.9-0.1 2.1-0.8 2.9-2.3 2.9-0.4 0-0.8-0.2-1-0.4-0.6-0.5-0.5-2.3-0.5-2.3 2 0 4-1.8 4.7-4.8l-0.2-0.1c0.3-1.2 0.5-2.6 0.5-3.6 0-1.1-0.3-1.9-1-2.5s-1.5-0.8-2.1-0.8c-0.2-0.3-0.5-0.5-0.9-0.5-0.5 0-1 0.4-1 1s0.4 1 1 1c0.4 0 0.7-0.2 0.8-0.5 0.5 0 1 0.2 1.5 0.6s0.7 0.9 0.7 1.7c0 0.9-0.2 2.2-0.5 3.5l-0.2-0.1c-0.3 1.1-1.3 3.6-3.3 3.6h-1c-2 0-3-2.5-3.3-3.6l-0.2 0.1c-0.3-1.3-0.5-2.6-0.5-3.5 0-0.8 0.2-1.3 0.7-1.7 0.4-0.4 1-0.5 1.5-0.6 0.1 0.3 0.4 0.5 0.8 0.5 0.6 0 1-0.4 1-1s-0.4-1-1-1c-0.4 0-0.7 0.2-0.9 0.5-0.6 0-1.4 0.2-2.1 0.8s-1 1.4-1 2.5c0 1 0.2 2.4 0.5 3.7l-0.2 0.1c0.7 2.9 2.7 4.7 4.7 4.7 0 0-0.1 2.2 0.7 2.9zM14 14c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1-0.5 1-1 1z"></path></g>
<g id="vaadin:stock"><path d="M12 6v-6h-8v6h-4v7h16v-7h-4zM7 12h-6v-5h2v1h2v-1h2v5zM5 6v-5h2v1h2v-1h2v5h-6zM15 12h-6v-5h2v1h2v-1h2v5z"></path><path d="M0 16h3v-1h10v1h3v-2h-16v2z"></path></g>
<g id="vaadin:stop-cog"><path d="M1 0v7.2l0.5-0.5 1.2 0.6c0 0 0.1 0 0.1 0l0.2-0.6 0.3-0.7h2.4l0.2 0.7 0.2 0.6c0 0 0.1 0 0.1 0l1.2-0.6 1.8 1.8-0.6 1.2c0 0 0 0.1 0 0.1l0.6 0.2 0.7 0.2v2.4l-0.7 0.2-0.6 0.2c0 0 0 0.1 0 0.1l0.6 1.2-0.4 0.7h7.2v-15h-15z"></path><path d="M5.5 11.5c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M7.9 12.4l1.1-0.4v-1l-1.1-0.4c-0.1-0.3-0.2-0.6-0.4-0.9l0.5-1-0.7-0.7-1 0.5c-0.3-0.2-0.6-0.3-0.9-0.4l-0.4-1.1h-1l-0.4 1.1c-0.3 0.1-0.6 0.2-0.9 0.4l-1-0.5-0.7 0.7 0.5 1.1c-0.2 0.3-0.3 0.6-0.4 0.9l-1.1 0.3v1l1.1 0.4c0.1 0.3 0.2 0.6 0.4 0.9l-0.5 1 0.7 0.7 1.1-0.5c0.3 0.2 0.6 0.3 0.9 0.4l0.3 1.1h1l0.4-1.1c0.3-0.1 0.6-0.2 0.9-0.4l1 0.5 0.7-0.7-0.5-1.1c0.2-0.2 0.3-0.5 0.4-0.8zM4.5 13.5c-1.1 0-2-0.9-2-2s0.9-2 2-2 2 0.9 2 2c0 1.1-0.9 2-2 2z"></path></g>
<g id="vaadin:stop"><path d="M1 1h14v14h-14v-14z"></path></g>
<g id="vaadin:stopwatch"><path d="M8.5 8.14v-3.64h-1v3.64c-0.301 0.176-0.5 0.498-0.5 0.866 0 0.552 0.448 1 1 1s1-0.448 1-1c0-0.368-0.199-0.69-0.495-0.863z"></path><path d="M8 2c-3.866 0-7 3.134-7 7s3.134 7 7 7c3.866 0 7-3.134 7-7s-3.134-7-7-7zM8 14.5c-3.038 0-5.5-2.462-5.5-5.5s2.462-5.5 5.5-5.5c3.038 0 5.5 2.462 5.5 5.5-0.006 3.035-2.465 5.494-5.499 5.5z"></path><path d="M6 0h4v1.5h-4v-1.5z"></path><path d="M0.005 4.438l2.713-2.939 1.102 1.017-2.713 2.939-1.102-1.017z"></path><path d="M12.186 2.519l1.102-1.017 2.713 2.939-1.102 1.017-2.713-2.939z"></path></g>
<g id="vaadin:storage"><path d="M16 4l-8.060-4-7.94 4v1h1v11h2v-9h10v9h2v-11h1v-1zM4 6v-1h2v1h-2zM7 6v-1h2v1h-2zM10 6v-1h2v1h-2z"></path><path d="M6 9h-1v-1h-1v3h3v-3h-1v1z"></path><path d="M6 13h-1v-1h-1v3h3v-3h-1v1z"></path><path d="M10 13h-1v-1h-1v3h3v-3h-1v1z"></path></g>
<g id="vaadin:strikethrough"><path d="M10.5 7c-0.5-0.3-1-0.5-1.4-0.7-2-0.9-2.1-1.1-2-1.9s0.4-1 0.6-1.2c0.9-0.5 2.8-0.1 3.5 0.2l1.1-2.8c-0.4-0.2-3.7-1.4-6.1 0-0.8 0.5-1.9 1.5-2.1 3.4-0.2 1.3 0.1 2.3 0.7 3h-4.8v1h16v-1h-5.5z"></path><path d="M7.7 9c0 0 0.1 0 0.1 0.1 2 0.9 2.4 1.2 2.2 2.5-0.2 0.9-0.5 1.1-0.8 1.3-1.1 0.6-3.3 0-4.4-0.5l-1.2 2.6c0.3 0.1 2.3 1 4.5 1 0.9 0 1.8-0.2 2.6-0.6 0.9-0.5 2-1.4 2.4-3.4 0.2-1.3 0-2.3-0.4-3.1h-5z"></path></g>
<g id="vaadin:subscript"><path d="M16 15v1h-4v-1c0 0 3.3-1.6 2.6-3.2-0.5-1.1-2-0.2-2-0.2l-0.5-0.9c0 0 1.9-1.4 3.1-0.2 2.4 2.3-1.4 4.5-1.4 4.5h2.2z"></path><path d="M12 3h-3.4l-2.6 3-2.6-3h-3.4l4.3 5-4.3 5h3.4l2.6-3 2.6 3h3.4l-4.3-5z"></path></g>
<g id="vaadin:suitcase"><path d="M11 3v-2h-6v2h-5v12h16v-12h-5zM4 14h-1v-10h1v10zM10 3h-4v-1h4v1zM13 14h-1v-10h1v10z"></path></g>
<g id="vaadin:sun-down"><path d="M10 3h-1v-2h-2v2h-1l2 3 2-3z"></path><path d="M14 13l-1.58-1.18 0.78-1.82-2-0.23-0.2-1.97-1.82 0.78-1.18-1.58-1.18 1.58-1.82-0.78-0.23 2-1.97 0.2 0.78 1.82-1.58 1.18h-2v1h16v-1h-2zM4 13c0.075-2.178 1.822-3.925 3.993-4 2.185 0.075 3.932 1.821 4.007 3.993l-8 0.007z"></path></g>
<g id="vaadin:sun-o"><path d="M16 8l-2.2-1.6 1.1-2.4-2.7-0.2-0.2-2.7-2.4 1.1-1.6-2.2-1.6 2.2-2.4-1.1-0.2 2.7-2.7 0.2 1.1 2.4-2.2 1.6 2.2 1.6-1.1 2.4 2.7 0.2 0.2 2.7 2.4-1.1 1.6 2.2 1.6-2.2 2.4 1.1 0.2-2.7 2.7-0.2-1.1-2.4 2.2-1.6zM8 13c-2.8 0-5-2.2-5-5s2.2-5 5-5 5 2.2 5 5-2.2 5-5 5z"></path></g>
<g id="vaadin:sun-rise"><path d="M6 4h1v2h2v-2h1l-2-3-2 3z"></path><path d="M12.42 11.82l0.78-1.82-2-0.23-0.2-1.97-1.82 0.78-1.18-1.58-1.18 1.58-1.82-0.78-0.23 2-1.97 0.2 0.78 1.82-1.58 1.18h-2v1h16v-1h-2zM4 13c0.075-2.178 1.822-3.925 3.993-4 2.185 0.075 3.932 1.821 4.007 3.993l-8 0.007z"></path></g>
<g id="vaadin:superscript"><path d="M16 5v1h-4v-1c0 0 3.3-1.6 2.6-3.2-0.5-1.1-2-0.2-2-0.2l-0.5-0.9c0 0 1.9-1.4 3.1-0.2 2.4 2.3-1.4 4.5-1.4 4.5h2.2z"></path><path d="M12 3h-3.4l-2.6 3-2.6-3h-3.4l4.3 5-4.3 5h3.4l2.6-3 2.6 3h3.4l-4.3-5z"></path></g>
<g id="vaadin:sword"><path d="M15.8 0.5l-0.1-0.2-0.2-0.1c-0.1 0-2.5-0.8-4.2 0.9l-6.7 6.6c-0.9-0.6-1.7-1.2-1.8-1l-0.4 0.3c-0.2 0.2 0.9 1.7 1.8 2.7l-2.5 3.4c-0.3-0.3-0.8-0.3-1.1 0l-0.3 0.3c-0.3 0.3-0.3 0.8 0 1.1l1 1c0.3 0.3 0.8 0.3 1.1 0l0.3-0.3c0.3-0.3 0.3-0.8 0-1.1v0l3.5-2.5c1 0.9 2.5 2 2.7 1.8l0.4-0.4c0.1-0.1-0.4-1-1.1-1.8l6.7-6.7c1.7-1.5 0.9-3.9 0.9-4zM7.7 10.5l-0.8-0.8 6.2-6.9-6.9 6.2-0.7-0.7 6.5-6.5c1-1 2.3-0.8 2.9-0.7 0.1 0.6 0.3 1.9-0.7 2.8l-6.5 6.6z"></path></g>
<g id="vaadin:tab-a"><path d="M9 10h-9v-4h9v-2l5 4-5 4v-2z"></path><path d="M14 4h2v8h-2v-8z"></path></g>
<g id="vaadin:tab"><path d="M0 2v12h16v-12h-16zM13 11h-1v-3l-3 3v-2h-6v-2h6v-2l3 3v-3h1v6z"></path></g>
<g id="vaadin:table"><path d="M0 1v15h16v-15h-16zM5 15h-4v-2h4v2zM5 12h-4v-2h4v2zM5 9h-4v-2h4v2zM5 6h-4v-2h4v2zM10 15h-4v-2h4v2zM10 12h-4v-2h4v2zM10 9h-4v-2h4v2zM10 6h-4v-2h4v2zM15 15h-4v-2h4v2zM15 12h-4v-2h4v2zM15 9h-4v-2h4v2zM15 6h-4v-2h4v2z"></path></g>
<g id="vaadin:tablet"><path d="M0 2v12h16v-12h-16zM13 13h-11v-10h11v10zM15 9h-1v-2h1v2z"></path></g>
<g id="vaadin:tabs"><path d="M14 4v-2h-14v12h16v-10h-2zM10 3h3v1h-3v-1zM6 3h3v1h-3v-1zM15 13h-14v-10h4v2h10v8z"></path></g>
<g id="vaadin:tag"><path d="M8 1h-7v7l7 7 7-7zM3.75 5c-0.69 0-1.25-0.56-1.25-1.25s0.56-1.25 1.25-1.25c0.69 0 1.25 0.56 1.25 1.25s-0.56 1.25-1.25 1.25z"></path></g>
<g id="vaadin:tags"><path d="M9 2h-1.5l7 7-5.3 5.2 0.8 0.8 6-6z"></path><path d="M6 2h-6v6l7 7 6-6-7-7zM2.8 6c-0.7 0-1.3-0.6-1.3-1.2s0.6-1.2 1.2-1.2 1.3 0.5 1.3 1.2-0.6 1.2-1.2 1.2z"></path></g>
<g id="vaadin:tasks"><path d="M6 0h10v4h-10v-4z"></path><path d="M6 6h10v4h-10v-4z"></path><path d="M6 12h10v4h-10v-4z"></path><path d="M3 1v2h-2v-2h2zM4 0h-4v4h4v-4z"></path><path d="M3 13v2h-2v-2h2zM4 12h-4v4h4v-4z"></path><path d="M5.3 5.9l-0.6-0.8-0.9 0.9h-3.8v4h4v-2.8l1.3-1.3zM2.7 7l-0.7 0.7-0.8-0.7h1.5zM1 8.2l0.9 0.8h-0.9v-0.8zM3 9h-0.9l0.9-0.9v0.9z"></path></g>
<g id="vaadin:taxi"><path d="M15 6.1l-1.4-2.9c-0.4-0.7-1.1-1.2-2-1.2h-0.6v-1.3c0-0.4-0.3-0.7-0.7-0.7h-4.6c-0.4 0-0.7 0.3-0.7 0.7v1.3h-0.7c-0.8 0-1.6 0.5-1.9 1.2l-1.4 2.9c-0.6 0.1-1 0.6-1 1.1v3.5c0 0.6 0 1.1 1 1.2v2c0 0.6 0.4 1.1 1 1.1h0.9c0.6 0 1.1-0.5 1.1-1.1v-1.9h8v1.9c0 0.6 0.4 1.1 1 1.1h0.9c0.6 0 1.1-0.5 1.1-1.1v-2c1-0.1 1-0.6 1-1.2v-3.5c0-0.5-0.4-1-1-1.1zM4 8.4c0 0.3-0.3 0.6-0.6 0.6h-1.8c-0.3 0-0.6-0.3-0.6-0.6v-0.8c0-0.3 0.3-0.6 0.6-0.6h1.8c0.3 0 0.6 0.3 0.6 0.6v0.8zM10 11h-4v-1h4v1zM2.1 6l1.2-2.4c0.2-0.4 0.6-0.6 1-0.6h7.4c0.4 0 0.8 0.2 1 0.6l1.2 2.4h-11.8zM15 8.4c0 0.3-0.3 0.6-0.6 0.6h-1.8c-0.3 0-0.6-0.3-0.6-0.6v-0.8c0-0.3 0.3-0.6 0.6-0.6h1.8c0.3 0 0.6 0.3 0.6 0.6v0.8z"></path></g>
<g id="vaadin:teeth"><path d="M4.6 7.6c-0.1 0.1-0.5 0.4-1.6 0.4 1.1 0 1.5 0.3 1.6 0.4 0.2-0.2 0.6-0.4 1.5-0.4-0.9 0-1.3-0.2-1.5-0.4z"></path><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8c4.4 0 8-3.6 8-8s-3.6-8-8-8zM13.1 11.6c-1 0-1.4-0.8-1.6-1.6-0.2 0.9-0.6 2-1.8 2-1.1 0-1.5-1.1-1.7-2-0.2 1-0.6 2-1.7 2s-1.6-1.1-1.8-2c-0.2 0.8-0.6 1.6-1.6 1.6-2 0-1.9-3-1.9-3s0.2-0.6 1.7-0.6c-1.5 0-1.7-0.5-1.7-0.5s-0.1-3 1.9-3c1 0 1.4 0.8 1.6 1.6 0.2-0.9 0.6-2 1.8-2 1.1-0.1 1.5 1 1.7 1.9 0.2-1 0.6-2 1.7-2s1.6 1.1 1.8 2c0.2-0.8 0.6-1.6 1.6-1.6 2 0 1.9 3 1.9 3s-0.3 0.6-1.8 0.6c-1.2 0-1.6-0.3-1.8-0.4-0.2 0.2-0.7 0.4-1.6 0.4-1.2 0-1.6-0.2-1.8-0.4-0.1 0.1-0.6 0.4-1.6 0.4 1 0 1.4 0.3 1.6 0.4 0.2-0.2 0.6-0.4 1.8-0.4 1 0 1.4 0.2 1.7 0.4 0-0.1 0.5-0.4 1.7-0.4 1.5 0 1.8 0.6 1.8 0.6s0.1 3-1.9 3z"></path></g>
<g id="vaadin:terminal"><path d="M6 12h9v1h-9v-1z"></path><path d="M1.1 13h1.2l3.7-5-3.7-5h-1.3l3.8 5z"></path></g>
<g id="vaadin:text-height"><path d="M15 3h1l-1.5-3-1.5 3h1v10h-1l1.5 3 1.5-3h-1z"></path><path d="M1 0v3h4v13h3v-13h4v-3z"></path></g>
<g id="vaadin:text-input"><path d="M2 2h1v4h-1v-4z"></path><path d="M1 0c-0.6 0-1 0.4-1 1v14c0 0.6 0.4 1 1 1h15v-16h-15zM13 15h-12v-14h12v14zM15 15v0h-1v-1h1v1zM15 13h-1v-10h1v10zM15 2h-1v-1h1v1z"></path></g>
<g id="vaadin:text-label"><path d="M12.5 4.9c-1.4 0-2.5 0.8-2.6 0.9l1.2 1.6c0 0 0.7-0.5 1.4-0.5 1.4 0 1.5 1.2 1.5 1.6-0.4-0.1-1.1-0.3-2-0.1-1.4 0.3-2.8 2-2.1 3.9 0.7 1.8 3.1 2.1 4.1 0.6v1h2v-5.3c0-2.7-1.9-3.7-3.5-3.7zM11.5 11.4c-0.1-1.9 1.5-1.9 2.5-1.8v1c0 1.2-2.3 2.3-2.5 0.8z"></path><path d="M6.9 14h2.1l-3.2-12h-2.7l-3.1 12h2.1l1-4h2.7l1.1 4zM3.6 8l0.8-3.2 0.9 3.2h-1.7z"></path></g>
<g id="vaadin:text-width"><path d="M15 14.5l-3-1.5v1h-9v-1l-3 1.5 3 1.5v-1h9v1z"></path><path d="M0 0v3h6v9h3v-9h6v-3z"></path></g>
<g id="vaadin:thin-square"><path d="M15 1h-14v14h14v-14zM14 14h-12v-12h12v12z"></path></g>
<g id="vaadin:thumbs-down-o"><path d="M15.6 7.3c0.1-0.3 0.3-0.7 0.2-1.2 0-0.6-0.3-1.1-0.5-1.3 0.1-0.3 0.1-0.6 0-1.1s-0.4-0.8-0.6-1c0.1-0.3 0.1-0.8-0.3-1.4-0.4-1-1.2-1.3-3.6-1.3-1.7 0-3.3 0.8-4.6 1.5-0.4 0.2-1 0.5-1.2 0.5v0h-5v9h5v-0.9l2.7 2.7 1 2.8c0.2 0.2 0.4 0.4 0.8 0.4h0.1c0 0 0 0 0 0 0.5 0 2-0.1 2.4-1.9 0.2-0.9-0.1-2.2-0.5-3.1h2.3c0.7-0.1 2.1-0.6 2.2-2.1 0-0.7-0.2-1.3-0.4-1.6zM2.5 7.5c0.6 0 1 0.4 1 1s-0.4 1-1 1-1-0.4-1-1c0-0.6 0.4-1 1-1zM13.8 10h-2.5c-0.3 0-0.5 0.1-0.7 0.4-0.2 0.2-0.2 0.5-0.1 0.8 0.5 1.2 0.7 2.2 0.6 2.8-0.2 0.9-0.9 1.1-1.4 1.1l-1-2.7c0-0.1-0.1-0.2-0.2-0.3l-2.9-2.9c-0.1-0.1-0.3-0.2-0.5-0.2h-0.1v-6c0.4 0 0.8-0.2 1.7-0.6 1.1-0.6 2.7-1.4 4.1-1.4 2.5 0 2.7 0.4 2.9 0.7 0.3 0.5 0.1 0.9 0.1 0.9l-0.2 0.4 0.4 0.3c0 0 0.4 0.2 0.5 0.7 0.1 0.4 0 0.7 0 0.7l-0.3 0.3 0.3 0.3c0 0 0.4 0.3 0.4 0.9 0 0.5-0.2 0.7-0.2 0.7l-0.4 0.3 0.4 0.4c0 0 0.4 0.4 0.3 1.2 0 1.1-1.1 1.2-1.2 1.2z"></path></g>
<g id="vaadin:thumbs-down"><path d="M15.6 7.8c0 0 0.5 0.5 0.4 1.6 0 1.5-1.6 1.6-1.6 1.6h-2.4c-0.2 0-0.3 0.2-0.3 0.4 0.3 0.7 0.8 2.1 0.6 3.1-0.3 1.4-1.5 1.5-1.9 1.5-0.1 0-0.2-0.1-0.2-0.2l-1-2.8c0 0 0-0.1-0.1-0.1l-2.6-2.8c-0.1-0.1-0.2-0.1-0.3-0.1h-0.2v-7h0.2c0.7 0 3.2-2 5.4-2s2.7 0.3 3.1 1c0.4 0.7 0.1 1.3 0.1 1.3s0.5 0.3 0.6 1c0.1 0.7-0.1 1.1-0.1 1.1s0.5 0.4 0.5 1.2c0.1 0.9-0.2 1.2-0.2 1.2z"></path><path d="M0 11h5v-8h-5v8zM2.5 7.5c0.6 0 1 0.4 1 1s-0.4 1-1 1-1-0.4-1-1c0-0.6 0.4-1 1-1z"></path></g>
<g id="vaadin:thumbs-up-o"><path d="M16 7.1c0-1.5-1.4-2.1-2.2-2.1h-2.2c0.4-1 0.7-2.2 0.5-3.1-0.5-1.8-2-1.9-2.5-1.9h-0.1c-0.4 0-0.6 0.2-0.8 0.5l-1 2.8-2.7 2.7h-5v9h5v-1c0.2 0 0.7 0.3 1.2 0.6 1.2 0.6 2.9 1.5 4.5 1.5 2.4 0 3.2-0.3 3.8-1.3 0.3-0.6 0.3-1.1 0.3-1.4 0.2-0.2 0.5-0.5 0.6-1s0.1-0.8 0-1.1c0.2-0.3 0.4-0.7 0.5-1.3 0-0.5-0.1-0.9-0.2-1.2 0.1-0.4 0.3-0.9 0.3-1.7zM2.5 13.5c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1c0 0.6-0.4 1-1 1zM14.7 9.1c0 0 0.2 0.2 0.2 0.7 0 0.6-0.4 0.9-0.4 0.9l-0.3 0.3 0.2 0.3c0 0 0.2 0.3 0 0.7-0.1 0.4-0.5 0.7-0.5 0.7l-0.3 0.3 0.2 0.4c0 0 0.2 0.4-0.1 0.9-0.2 0.4-0.4 0.7-2.9 0.7-1.4 0-3-0.8-4.1-1.4-0.8-0.4-1.3-0.6-1.7-0.6v0-6h0.1c0.2 0 0.4-0.1 0.6-0.2l2.8-2.8c0.1-0.1 0.1-0.2 0.2-0.3l1-2.7c0.5 0 1.2 0.2 1.4 1.1 0.1 0.6-0.1 1.6-0.6 2.8-0.1 0.3-0.1 0.5 0.1 0.8 0.1 0.2 0.4 0.3 0.7 0.3h2.5c0.1 0 1.2 0.2 1.2 1.1 0 0.8-0.3 1.2-0.3 1.2l-0.3 0.4 0.3 0.4z"></path></g>
<g id="vaadin:thumbs-up"><path d="M15.6 8.2c0 0 0.5-0.5 0.4-1.6 0-1.5-1.6-1.6-1.6-1.6h-2.4c-0.2 0-0.3-0.2-0.3-0.4 0.3-0.7 0.8-2.1 0.6-3.1-0.3-1.4-1.5-1.5-1.9-1.5-0.1 0-0.2 0.1-0.2 0.2l-1 2.8c0 0 0 0.1-0.1 0.1l-2.6 2.8c-0.1 0.1-0.2 0.1-0.3 0.1h-0.2v7h0.2c0.7 0 3.2 2 5.4 2s2.7-0.3 3.1-1c0.4-0.7 0.1-1.3 0.1-1.3s0.5-0.3 0.6-1c0.1-0.7-0.1-1.1-0.1-1.1s0.5-0.4 0.5-1.2c0.1-0.9-0.2-1.2-0.2-1.2z"></path><path d="M0 14h5v-8h-5v8zM2.5 10.5c0.6 0 1 0.4 1 1s-0.4 1-1 1-1-0.4-1-1c0-0.6 0.4-1 1-1z"></path></g>
<g id="vaadin:ticket"><path d="M14 3h-12c0 1.1-0.9 2-2 2v6c1.1 0 2 0.9 2 2h12c0-1.1 0.9-2 2-2v0-6c-1.1 0-2-0.9-2-2zM13 12h-10v-8h10v8z"></path><path d="M4 5h8v6h-8v-6z"></path></g>
<g id="vaadin:time-backward"><path d="M8 4h-1v5h4v-1h-3z"></path><path d="M8 0c-3 0-5.6 1.6-6.9 4.1l-1.1-1.1v4h4l-1.5-1.5c1-2 3.1-3.5 5.5-3.5 3.3 0 6 2.7 6 6s-2.7 6-6 6c-1.8 0-3.4-0.8-4.5-2.1l-1.5 1.3c1.4 1.7 3.6 2.8 6 2.8 4.4 0 8-3.6 8-8s-3.6-8-8-8z"></path></g>
<g id="vaadin:time-forward"><path d="M8 4h-1v5h4v-1h-3z"></path><path d="M16 7v-4l-1.1 1.1c-1.3-2.5-3.9-4.1-6.9-4.1-4.4 0-8 3.6-8 8s3.6 8 8 8c2.4 0 4.6-1.1 6-2.8l-1.5-1.3c-1.1 1.3-2.7 2.1-4.5 2.1-3.3 0-6-2.7-6-6s2.7-6 6-6c2.4 0 4.5 1.5 5.5 3.5l-1.5 1.5h4z"></path></g>
<g id="vaadin:timer"><path d="M9.060 9.060c0.271-0.271 0.439-0.646 0.439-1.060s-0.168-0.789-0.439-1.060c-0.59-0.59-6.72-4.6-6.72-4.6s4 6.13 4.59 6.72c0.272 0.274 0.649 0.444 1.065 0.444s0.793-0.17 1.065-0.444z"></path><path d="M8 0v3h1v-1.41c3.153 0.495 5.536 3.192 5.536 6.445 0 3.601-2.919 6.52-6.52 6.52s-6.52-2.919-6.52-6.52c0-1.256 0.355-2.428 0.97-3.423l-0.916-1.322c-0.958 1.303-1.533 2.939-1.533 4.71 0 4.418 3.582 8 8 8s8-3.582 8-8c0-4.418-3.582-8-8-8-0.006 0-0.012 0-0.017 0z"></path></g>
<g id="vaadin:toolbox"><path d="M0 8h6v2h4v-2h6v6h-16z"></path><path d="M7 7h2v2h-2v-2z"></path><path d="M11 4v-2h-6v2h-5v3h6v-1h4v1h6v-3h-5zM6 4v-1h4v1h-4z"></path></g>
<g id="vaadin:tools"><path d="M10.3 8.2l-0.9 0.9 0.9 0.9-1.2 1.2 4.3 4.3c0.6 0.6 1.5 0.6 2.1 0s0.6-1.5 0-2.1l-5.2-5.2zM14.2 15c-0.4 0-0.8-0.3-0.8-0.8 0-0.4 0.3-0.8 0.8-0.8s0.8 0.3 0.8 0.8c0 0.5-0.3 0.8-0.8 0.8z"></path><path d="M3.6 8l0.9-0.6 1.5-1.7 0.9 0.9 0.9-0.9-0.1-0.1c0.2-0.5 0.3-1 0.3-1.6 0-2.2-1.8-4-4-4-0.6 0-1.1 0.1-1.6 0.3l2.9 2.9-2.1 2.1-2.9-2.9c-0.2 0.5-0.3 1-0.3 1.6 0 2.1 1.6 3.7 3.6 4z"></path><path d="M8 10.8l0.9-0.8-0.9-0.9 5.7-5.7 1.2-0.4 1.1-2.2-0.7-0.7-2.3 1-0.5 1.2-5.6 5.7-0.9-0.9-0.8 0.9c0 0 0.8 0.6-0.1 1.5-0.5 0.5-1.3-0.1-2.8 1.4-0.5 0.5-2.1 2.1-2.1 2.1s-0.6 1 0.6 2.2 2.2 0.6 2.2 0.6 1.6-1.6 2.1-2.1c1.4-1.4 0.9-2.3 1.3-2.7 0.9-0.9 1.6-0.2 1.6-0.2zM4.9 10.4l0.7 0.7-3.8 3.8-0.7-0.7z"></path></g>
<g id="vaadin:tooth"><path d="M11.3 16c-1.2 0-1.7-3.9-1.7-4.1-0.1-1.3-1-2.1-1.6-2.2-0.6 0-1.4 0.9-1.6 2.2 0 0.2-0.5 4.1-1.7 4.1s-1.8-4.4-1.9-4.4c-0.2-1.4 0.1-3.4 0.2-4-0.4-1.2-1.8-5.6-0.5-7 0.5-0.4 1.1-0.6 1.9-0.6 0.6 0 1.3 0.1 2 0.3 0.6 0.1 1.1 0.2 1.6 0.2s1-0.1 1.6-0.2c0.7-0.2 1.4-0.3 2-0.3 0.8 0 1.4 0.2 1.8 0.7 1.3 1.4-0.1 5.8-0.5 7 0.1 0.5 0.4 2.5 0.2 3.9 0.1 0-0.5 4.4-1.8 4.4zM8 8.7c1.3 0.1 2.4 1.4 2.6 3.1 0.1 1.2 0.5 2.4 0.7 2.9 0.3-0.6 0.7-2.1 0.9-3.3 0.2-1.4-0.2-3.7-0.2-3.7v-0.2c0.7-2.1 1.4-5.3 0.8-6.1-0.3-0.3-0.7-0.4-1.2-0.4s-1.2 0.1-1.8 0.3c-0.6 0.1-1.2 0.2-1.8 0.2s-1.2-0.1-1.8-0.2c-0.6-0.2-1.3-0.3-1.8-0.3s-0.9 0.1-1.1 0.4c-0.7 0.7 0 4 0.8 6.1v0.2c0 0-0.4 2.3-0.2 3.7 0.2 1.2 0.6 2.7 0.9 3.3 0.2-0.6 0.6-1.7 0.7-2.9 0.1-1.6 1.2-3 2.5-3.1z"></path></g>
<g id="vaadin:touch"><path d="M12.62 6c-0.093-0.023-0.2-0.036-0.31-0.036s-0.217 0.013-0.319 0.038c-0.045-0.33-0.192-0.616-0.402-0.843-0.257-0.259-0.614-0.42-1.008-0.42-0.018 0-0.036 0-0.053 0.001-0-0-0.004-0-0.007-0-0.22 0-0.43 0.044-0.621 0.124-0.062-0.183-0.163-0.336-0.29-0.464-0.261-0.25-0.617-0.403-1.008-0.403-0.036 0-0.072 0.001-0.107 0.004l0.005-0c0.315-0.414 0.505-0.938 0.505-1.506 0-1.381-1.119-2.5-2.5-2.5s-2.5 1.119-2.5 2.5c0 0.813 0.388 1.535 0.989 1.992l0.006 2.664c-0.554 0.015-1.054 0.233-1.432 0.581-0.568 0.619-0.568 1.579-0.568 2.779 0 0.23 0 0.47 0 0.72 0.032 1.127 0.573 2.121 1.402 2.764l0.358 0.356c1.24 1.27 2.38 1.65 5.020 1.65 2.88 0 4.22-1.61 4.22-5.060v-2.51c0-0.77-0.22-2.12-1.38-2.43zM13 8.35v2.59c0 3.37-1.29 4.060-3.22 4.060-2.6 0-3.4-0.39-4.3-1.33l-0.36-0.37c-0.657-0.468-1.088-1.215-1.12-2.065-0-0.265-0-0.505-0-0.735-0.033-0.178-0.053-0.383-0.053-0.592 0-0.538 0.126-1.047 0.351-1.498 0.186-0.132 0.431-0.228 0.698-0.24l0.003 0.7v-0.22l-0.34 1.5c-0.010 0.022-0.016 0.048-0.016 0.075 0 0.103 0.083 0.186 0.186 0.186 0.075 0 0.14-0.045 0.17-0.11l1-1.211c0.003-0.014 0.005-0.029 0.005-0.045s-0.002-0.031-0.005-0.046l0-5.609c-0-0.012-0.001-0.026-0.001-0.039 0-0.256 0.083-0.492 0.223-0.684 0.091-0.096 0.223-0.158 0.369-0.158 0.010 0 0.020 0 0.030 0.001-0.001-0-0.001-0-0.001-0 0.21 0 0.38 0.17 0.38 0.38 0 0.004-0 0.007-0 0.011l0 3.869c0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5v-1.32c0.010-0.251 0.217-0.451 0.47-0.451 0.011 0 0.021 0 0.032 0.001 0.023-0.005 0.051-0.008 0.079-0.008 0.232 0 0.42 0.188 0.42 0.42 0 0.010-0 0.020-0.001 0.029l0 1.329c0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5v-0.64c0.034-0.218 0.22-0.383 0.445-0.383 0.019 0 0.038 0.001 0.057 0.004 0.013-0.002 0.030-0.003 0.047-0.003 0.112 0 0.214 0.043 0.291 0.113 0.1 0.129 0.16 0.294 0.16 0.473 0 0.006-0 0.012-0 0.017l0 0.819c0.003 0.252 0.193 0.459 0.438 0.49 0.021 0.003 0.043 0.004 0.066 0.004 0.241 0 0.442-0.166 0.496-0.39 0.026-0.112 0.082-0.204 0.16-0.273 0.033-0.015 0.071-0.024 0.111-0.024s0.078 0.009 0.112 0.024c0.38 0.249 0.628 0.674 0.628 1.157 0 0.057-0.003 0.113-0.010 0.169l0.001-0.007z"></path></g>
<g id="vaadin:train"><path d="M13 11.2v-7.4c0-1-0.8-1.8-1.8-1.8h-2.2v-1h2v-1h-6v1h2v1h-2.2c-1 0-1.8 0.8-1.8 1.8v7.4c0 1 0.8 1.8 1.8 1.8h0.2l-0.7 1h-1.3v1h0.7l-0.7 1h2l0.6-1h4.9l0.6 1h2l-0.7-1h0.6v-1h-1.3l-0.7-1h0.2c1 0 1.8-0.8 1.8-1.8zM4 3.9c0-0.5 0.4-0.9 0.9-0.9h6.1c0.6 0 1 0.4 1 0.9v2.1c0 0.6-0.4 1-0.9 1h-6.2c-0.5 0-0.9-0.4-0.9-0.9v-2.2zM4 11c0-0.6 0.4-1 1-1s1 0.4 1 1c0 0.6-0.4 1-1 1s-1-0.4-1-1zM9.9 14h-3.8l0.6-1h2.6l0.6 1zM10 11c0-0.6 0.4-1 1-1s1 0.4 1 1c0 0.6-0.4 1-1 1s-1-0.4-1-1z"></path></g>
<g id="vaadin:trash"><path d="M13 3s0-0.51-2-0.8v-0.7c-0.017-0.832-0.695-1.5-1.53-1.5-0 0-0 0-0 0h-3c-0.815 0.017-1.47 0.682-1.47 1.5 0 0 0 0 0 0v0.7c-0.765 0.068-1.452 0.359-2.007 0.806l-0.993-0.006v1h12v-1h-1zM6 1.5c0.005-0.274 0.226-0.495 0.499-0.5l3.001-0c0 0 0.001 0 0.001 0 0.282 0 0.513 0.22 0.529 0.499l0 0.561c-0.353-0.042-0.763-0.065-1.178-0.065-0.117 0-0.233 0.002-0.349 0.006-0.553-0-2.063-0-2.503 0.070v-0.57z"></path><path d="M2 5v1h1v9c1.234 0.631 2.692 1 4.236 1 0.002 0 0.003 0 0.005 0h1.52c0.001 0 0.003 0 0.004 0 1.544 0 3.002-0.369 4.289-1.025l-0.054-8.975h1v-1h-12zM6 13.92q-0.51-0.060-1-0.17v-6.75h1v6.92zM9 14h-2v-7h2v7zM11 13.72c-0.267 0.070-0.606 0.136-0.95 0.184l-0.050-6.904h1v6.72z"></path></g>
<g id="vaadin:tree-table"><path d="M6 10v-2h-2v-1h1v-2h-3v2h1v6h3v-2h-2v-1z"></path><path d="M0 0v16h16v-16h-16zM7 15h-6v-12h6v12zM11 15h-3v-12h3v12zM15 15h-3v-12h3v12z"></path></g>
<g id="vaadin:trending-down"><path d="M16 14h-4l1.29-1.29-4.29-4.3-3 3-6-6v-2.82l6 6 3-3 5.71 5.7 1.28-1.29 0.010 4z"></path></g>
<g id="vaadin:trending-up"><path d="M16 2h-4l1.29 1.29-4.29 4.3-3-3-6 6v2.82l6-6 3 3 5.71-5.7 1.28 1.29 0.010-4z"></path></g>
<g id="vaadin:trophy"><path d="M11.7 8c4.2-0.3 4.3-2.7 4.3-5h-3v-3h-10v3h-3c0 2.3 0.1 4.7 4.3 5 0.9 1.4 2.1 2 2.7 2v4c-3 0-3 2-3 2h8c0 0 0-2-3-2v-4c0.6 0 1.8-0.6 2.7-2zM13 4h2c-0.1 1.6-0.4 2.7-2.7 2.9 0.3-0.8 0.6-1.7 0.7-2.9zM1 4h2c0.1 1.2 0.4 2.1 0.7 2.9-2.2-0.2-2.6-1.3-2.7-2.9zM4.5 6.1c-0.5-1.7-0.5-3.1-0.5-3.1v-2h1v2c0 0 0 1.7 0.4 3.1 0.5 1.7 1.6 2.9 1.6 2.9s-1.8-0.2-2.5-2.9z"></path></g>
<g id="vaadin:truck"><path d="M6 3h10v7h-10v-7z"></path><path d="M15 14c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M13 11c1.3 0 2.4 0.8 2.8 2h0.2v-2h-3z"></path><path d="M5 5h-4l-1 4v4h1.2c0.4-1.2 1.5-2 2.8-2s2.4 0.8 2.8 2h3.4c0.4-1.2 1.5-2 2.8-2h-8v-6zM4 9h-3l0.8-3h2.2v3z"></path><path d="M6 14c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:twin-col-select"><path d="M0 2v12h16v-12h-16zM7 13h-6v-10h6v10zM15 13h-6v-10h6v10z"></path><path d="M10 4h4v1h-4v-1z"></path><path d="M2 4h4v1h-4v-1z"></path><path d="M2 6h4v1h-4v-1z"></path><path d="M2 8h4v1h-4v-1z"></path></g>
<g id="vaadin:twitter-square"><path d="M0 0v16h16v-16h-16zM12.8 5.6c0 0.1 0 0.2 0 0.3 0 3.3-2.5 7-7 7-1.4 0-2.7-0.4-3.8-1.1 0.2 0 0.4 0 0.6 0 1.2 0 2.2-0.4 3.1-1.1-1.1 0-2-0.7-2.3-1.7 0.2 0 0.3 0 0.5 0s0.4 0 0.6-0.1c-1.1-0.2-2-1.2-2-2.4 0 0 0 0 0 0 0.3 0.2 0.7 0.3 1.1 0.3-0.7-0.4-1.1-1.2-1.1-2 0-0.5 0.1-0.9 0.3-1.2 1.2 1.5 3.1 2.4 5.1 2.5 0-0.2-0.1-0.4-0.1-0.6 0-1.4 1.1-2.5 2.5-2.5 0.7 0 1.3 0.3 1.8 0.8 0.6-0.1 1.1-0.3 1.6-0.6-0.2 0.6-0.6 1.1-1.1 1.4 0.5-0.1 1-0.2 1.4-0.4-0.3 0.6-0.7 1-1.2 1.4z"></path></g>
<g id="vaadin:twitter"><path d="M16 3c-0.6 0.3-1.2 0.4-1.9 0.5 0.7-0.4 1.2-1 1.4-1.8-0.6 0.4-1.3 0.6-2.1 0.8-0.6-0.6-1.5-1-2.4-1-1.7 0-3.2 1.5-3.2 3.3 0 0.3 0 0.5 0.1 0.7-2.7-0.1-5.2-1.4-6.8-3.4-0.3 0.5-0.4 1-0.4 1.7 0 1.1 0.6 2.1 1.5 2.7-0.5 0-1-0.2-1.5-0.4 0 0 0 0 0 0 0 1.6 1.1 2.9 2.6 3.2-0.3 0.1-0.6 0.1-0.9 0.1-0.2 0-0.4 0-0.6-0.1 0.4 1.3 1.6 2.3 3.1 2.3-1.1 0.9-2.5 1.4-4.1 1.4-0.3 0-0.5 0-0.8 0 1.5 0.9 3.2 1.5 5 1.5 6 0 9.3-5 9.3-9.3 0-0.1 0-0.3 0-0.4 0.7-0.5 1.3-1.1 1.7-1.8z"></path></g>
<g id="vaadin:umbrella"><path d="M5.36 0.9l-0.27-0.57c-0.083-0.197-0.275-0.333-0.499-0.333-0.1 0-0.193 0.027-0.274 0.074-0.217 0.074-0.372 0.279-0.372 0.52 0 0.087 0.020 0.169 0.056 0.242l0.319 0.577c-6.2 3.49-3.9 10.59-3.9 10.59h0.060c0.25-0.12 0.8-1.64 2.050-2.25s2.78-0.090 3-0.21l0.12-0.060c0.477-0.742 0.998-1.387 1.58-1.97l3.37 7.070c0.246 0.619 0.729 1.098 1.334 1.335 0.168 0.053 0.343 0.080 0.524 0.080 0.254 0 0.495-0.053 0.713-0.149l0.359-0.176c0.263-0.145 0.462-0.38 0.558-0.662 0.117-0.276 0.183-0.586 0.183-0.913 0-0.401-0.1-0.778-0.277-1.108-0.102-0.189-0.311-0.324-0.551-0.324-0.076 0-0.149 0.014-0.217 0.038-0.182 0.089-0.308 0.277-0.308 0.495 0 0.093 0.023 0.18 0.064 0.257s0.529 1.067-0.101 1.337-1.19-0.73-1.19-0.73l-3.42-7.060c0.372-0.043 0.803-0.067 1.24-0.067s0.868 0.024 1.292 0.072l0.068-0.065c0.25-0.12 0.8-1.64 2.050-2.25s2.78-0.090 3-0.21h0.060s-3.98-6.41-10.62-3.58zM7.36 6.36c-1.034 0.399-1.834 1.209-2.211 2.224-0.55-1.082-0.909-2.375-1.007-3.74-0.142-2.244 0.608-2.924 0.608-2.924l0.77-0.32c1.084 0.101 2.052 0.534 2.816 1.195 0.976 0.895 1.747 2.009 2.233 3.265-0.339-0.021-0.752-0.067-1.175-0.067-0.724 0-1.417 0.134-2.054 0.379z"></path></g>
<g id="vaadin:underline"><path d="M2 15h12v1h-12v-1z"></path><path d="M11 0v8.4c0 1.5-1.1 2.6-2.6 2.6h-0.8c-1.5 0-2.6-1.1-2.6-2.6v-8.4h-3v8.4c0 3.1 2.5 5.6 5.6 5.6h0.9c3.1 0 5.6-2.5 5.6-5.6v-8.4h-3.1z"></path></g>
<g id="vaadin:unlink"><path d="M8 0h1v4h-1v-4z"></path><path d="M8 12h1v4h-1v-4z"></path><path d="M7 9h-4c-0.552 0-1-0.448-1-1s0.448-1 1-1h4v-2h-4c-1.657 0-3 1.343-3 3s1.343 3 3 3h4v-2z"></path><path d="M13 5h-4v2h4c0.552 0 1 0.448 1 1s-0.448 1-1 1h-4v2h4c1.657 0 3-1.343 3-3s-1.343-3-3-3z"></path><path d="M4.51 15.44l2.49-3.44h-1.23l-2.080 2.88 0.82 0.56z"></path><path d="M12.49 15.44l-2.49-3.44h1.23l2.080 2.88-0.82 0.56z"></path><path d="M12.49 0.99l-2.49 3.010h1.23l2.080-2.66-0.82-0.35z"></path><path d="M4.51 0.99l2.49 3.010h-1.23l-2.080-2.66 0.82-0.35z"></path></g>
<g id="vaadin:unlock"><path d="M8 8v-3.1c0-2.2-1.8-3.9-3.9-3.9h-0.3c-2.2 0-3.8 1.7-3.8 3.9v2.1h2v-2.1c0-1.1 0.7-1.9 1.8-1.9h0.3c1 0 1.9 0.8 1.9 1.9v3.1h-1l0.1 5c0 0-0.1 3 4.9 3s5-3 5-3v-5h-7zM11 14h-1v-1.8c-0.6 0-1-0.6-1-1.1 0-0.6 0.4-1.1 1-1.1s1 0.4 1 0.9v3.1z"></path></g>
<g id="vaadin:upload-alt"><path d="M0 14h16v2h-16v-2z"></path><path d="M8 0l-5 5h3v8h4v-8h3z"></path></g>
<g id="vaadin:upload"><path d="M11 10v2h-6v-2h-5v6h16v-6h-5zM4 14h-2v-2h2v2z"></path><path d="M13 5l-5-5-5 5h3v6h4v-6z"></path></g>
<g id="vaadin:user-card"><path d="M15 3v10h-14v-10h14zM16 2h-16v12h16v-12z"></path><path d="M8 5h6v1h-6v-1z"></path><path d="M8 7h6v1h-6v-1z"></path><path d="M8 9h3v1h-3v-1z"></path><path d="M5.4 7h-0.4v-0.1c0.6-0.2 1-0.8 1-1.4 0-0.8-0.7-1.5-1.5-1.5s-1.5 0.7-1.5 1.5c0 0.7 0.4 1.2 1 1.4v0.1h-0.4c-0.9 0-1.6 0.7-1.6 1.6v2.4h5v-2.4c0-0.9-0.7-1.6-1.6-1.6z"></path></g>
<g id="vaadin:user-check"><path d="M7.5 14.4c-0.8-0.8-0.8-2 0-2.8s2-0.8 2.8 0l0.6 0.6 1.9-2.1c-0.7-0.4-1.3-0.4-2-0.4-0.7-0.1-1.4-0.3-1.4-0.9s0.8-0.4 1.4-1.5c0 0 2.7-7.3-2.9-7.3-5.5 0-2.8 7.3-2.8 7.3 0.6 1 1.4 0.8 1.4 1.5s-0.7 0.7-1.4 0.8c-1.1 0.1-2.1-0.1-3.1 1.7-0.6 1.1-0.9 4.7-0.9 4.7h8l-1.6-1.6z"></path><path d="M12.8 16h2.1c0 0-0.1-0.9-0.2-2l-1.9 2z"></path><path d="M11 16c-0.3 0-0.5-0.1-0.7-0.3l-2-2c-0.4-0.4-0.4-1 0-1.4s1-0.4 1.4 0l1.3 1.3 3.3-3.6c0.4-0.4 1-0.4 1.4-0.1 0.4 0.4 0.4 1 0.1 1.4l-4 4.3c-0.3 0.3-0.5 0.4-0.8 0.4 0 0 0 0 0 0z"></path></g>
<g id="vaadin:user-clock"><path d="M14 13h-3v-3h1v2h2z"></path><path d="M16 12.5c0-2.5-2-4.5-4.5-4.5-0.7 0-1.4 0.2-2 0.5 0.2-0.3 0.8-0.3 1.4-1.2 0 0 2.7-7.3-2.9-7.3s-2.9 7.3-2.9 7.3c0.6 1 1.4 0.8 1.4 1.5s-0.7 0.7-1.4 0.8c-1.1 0.1-2.1-0.1-3.1 1.7-0.6 1.1-0.9 4.7-0.9 4.7h10.4c-1.9 0-3.5-1.6-3.5-3.5s1.6-3.5 3.5-3.5 3.5 1.6 3.5 3.5c0 1.9-1.6 3.5-3.5 3.5h3.4c0 0 0-0.2 0-0.5 0.6-0.8 1.1-1.8 1.1-3z"></path></g>
<g id="vaadin:user-heart"><path d="M14.2 16h0.6c0 0 0-0.2 0-0.6l-0.6 0.6z"></path><path d="M8.6 13.9c-0.7-0.7-1-1.8-0.8-2.8s0.8-1.8 1.7-2.1c0-0.1-0.1-0.2-0.1-0.2 0-0.6 0.8-0.4 1.4-1.5 0 0 2.7-7.3-2.9-7.3-5.5 0-2.8 7.3-2.8 7.3 0.6 1 1.4 0.8 1.4 1.5s-0.7 0.7-1.4 0.8c-1.1 0.1-2.1-0.1-3.1 1.7-0.6 1.1-0.9 4.7-0.9 4.7h9.6l-2.1-2.1z"></path><path d="M14.9 10.1c-0.2-0.1-0.5-0.1-0.7-0.1-0.7 0-1.3 0.6-1.7 1.1-0.4-0.5-1-1.1-1.7-1.1-0.3 0-0.5 0-0.7 0.1-1.2 0.4-1.4 2-0.5 2.9l3 2.9 3-2.9c0.8-0.9 0.5-2.5-0.7-2.9z"></path></g>
<g id="vaadin:user-star"><path d="M8.92 13.67l-1.61-1.53-1.5-1.42 2-0.29 2.25-0.32 0.29-0.57c-0.006 0-0.013 0-0.020 0-0.482 0-0.884-0.34-0.979-0.794-0.001-0.617 0.799-0.417 1.429-1.457 0.080-0.020 2.82-7.29-2.78-7.29s-2.86 7.27-2.86 7.27c0.63 1 1.44 0.85 1.43 1.45s-0.74 0.8-1.43 0.87c-1.14 0.13-2.14-0.13-3.14 1.76-0.6 1.090-0.85 4.65-0.85 4.65h7.36v-0.17z"></path><path d="M11.72 16h0.56l-0.28-0.14-0.28 0.14z"></path><path d="M12 14.73l2.47 1.27-0.47-2.69 2-1.9-2.76-0.39-1.24-2.45-1.24 2.45-2.76 0.39 2 1.9-0.47 2.69 2.47-1.27z"></path></g>
<g id="vaadin:user"><path d="M8 0c-5.6 0-2.9 7.3-2.9 7.3 0.6 1 1.4 0.8 1.4 1.5 0 0.6-0.7 0.8-1.4 0.9-1.1 0-2.1-0.2-3.1 1.6-0.6 1.1-0.9 4.7-0.9 4.7h13.7c0 0-0.3-3.6-0.8-4.7-1-1.9-2-1.6-3.1-1.7-0.7-0.1-1.4-0.3-1.4-0.9s0.8-0.4 1.4-1.5c0 0.1 2.7-7.2-2.9-7.2z"></path></g>
<g id="vaadin:users"><path d="M5.3 9.7c-0.4 0-0.9-0.2-0.9-0.6s0.5-0.3 0.9-1c0 0 1.8-4.9-1.8-4.9s-1.8 4.9-1.8 4.9c0.4 0.7 0.9 0.6 0.9 1s-0.5 0.6-0.9 0.6c-0.6 0.1-1.1 0-1.7 0.6v5.7h5c0.2-1.7 0.7-5.2 1.1-6.1 0 0 0.1-0.1 0.1-0.1-0.2-0.1-0.5-0.1-0.9-0.1z"></path><path d="M16 9.5c-0.7-0.8-1.3-0.7-2-0.8-0.5-0.1-1.1-0.2-1.1-0.7s0.6-0.3 1.1-1.2c0 0 2.1-5.9-2.2-5.9-4.4 0.1-2.3 6-2.3 6 0.5 0.8 1.1 0.7 1.1 1.1 0 0.5-0.6 0.6-1.1 0.7-0.9 0.1-1.7 0-2.5 1.5-0.4 0.9-1 5.8-1 5.8h10v-6.5z"></path></g>
<g id="vaadin:vaadin-h"><path d="M15.21 0.35c-0.436 0-0.79 0.354-0.79 0.79v0 0.46c0 0.5-0.32 0.85-1.070 0.85h-3.55c-1.61 0-1.73 1.19-1.8 1.83v0c-0.060-0.64-0.18-1.83-1.79-1.83h-3.57c-0.75 0-1.090-0.37-1.090-0.86v-0.45c0-0.006 0-0.013 0-0.020 0-0.425-0.345-0.77-0.77-0.77-0 0-0 0-0 0h0c-0 0-0 0-0 0-0.431 0-0.78 0.349-0.78 0.78 0 0.004 0 0.007 0 0.011v-0.001 1.32c0 1.54 0.7 2.31 2.34 2.31h3.66c1.090 0 1.19 0.46 1.19 0.9 0 0 0 0.090 0 0.13 0.048 0.428 0.408 0.758 0.845 0.758s0.797-0.33 0.845-0.754l0-0.004s0-0.080 0-0.13c0-0.44 0.1-0.9 1.19-0.9h3.61c1.61 0 2.32-0.77 2.32-2.31v-1.32c0-0.436-0.354-0.79-0.79-0.79v0z"></path><path d="M11.21 7.38c-0.012-0-0.026-0.001-0.040-0.001-0.453 0-0.835 0.301-0.958 0.714l-0.002 0.007-2.21 4.21-2.3-4.2c-0.122-0.425-0.507-0.731-0.963-0.731-0.013 0-0.026 0-0.039 0.001l0.002-0c-0.012-0-0.025-0.001-0.039-0.001-0.58 0-1.050 0.47-1.050 1.050 0 0.212 0.063 0.41 0.171 0.575l-0.002-0.004 3.29 6.1c0.15 0.333 0.478 0.561 0.86 0.561s0.71-0.228 0.858-0.555l0.002-0.006 3.34-6.1c0.090-0.152 0.144-0.335 0.144-0.53 0-0.58-0.47-1.050-1.050-1.050-0.005 0-0.010 0-0.014 0h0.001z"></path></g>
<g id="vaadin:vaadin-v"><path d="M5.8 7.16h-0.13c-0.44 0-0.9-0.1-0.9-1.19v-3.62c0-1.64-0.77-2.35-2.31-2.35h-1.32c-0.436 0-0.79 0.354-0.79 0.79v0c0 0.436 0.354 0.79 0.79 0.79v0h0.46c0.5 0 0.85 0.32 0.85 1.070v3.55c0 1.61 1.19 1.73 1.83 1.8v0c-0.64 0.060-1.83 0.18-1.83 1.79v3.55c0 0.75-0.37 1.090-0.86 1.090h-0.45c-0.006-0-0.013-0-0.020-0-0.425 0-0.77 0.345-0.77 0.77 0 0 0 0 0 0v-0c0 0 0 0 0 0 0 0.431 0.349 0.78 0.78 0.78 0.004 0 0.007-0 0.011-0h1.319c1.54 0 2.31-0.7 2.31-2.34v-3.59c0-1.090 0.46-1.19 0.9-1.19h0.13c0.428-0.048 0.758-0.408 0.758-0.845s-0.33-0.797-0.754-0.845l-0.004-0z"></path><path d="M15.1 7.19v0l-6.1-3.32c-0.152-0.090-0.335-0.144-0.53-0.144-0.58 0-1.050 0.47-1.050 1.050 0 0.005 0 0.010 0 0.014v-0.001c-0 0.012-0.001 0.026-0.001 0.040 0 0.453 0.301 0.835 0.714 0.958l0.007 0.002 4.21 2.26-4.24 2.25c-0.425 0.122-0.731 0.507-0.731 0.963 0 0.013 0 0.026 0.001 0.039l-0-0.002c-0 0.012-0.001 0.025-0.001 0.039 0 0.58 0.47 1.050 1.050 1.050 0.212 0 0.41-0.063 0.575-0.171l-0.004 0.002 6.1-3.29c0.333-0.15 0.561-0.478 0.561-0.86s-0.228-0.71-0.555-0.858l-0.006-0.002z"></path></g>
<g id="vaadin:viewport"><path d="M1 4h-1v-4h4v1h-3z"></path><path d="M12 1v-1h4v4h-1v-3z"></path><path d="M15 12h1v4h-4v-1h3z"></path><path d="M4 15v1h-4v-4h1v3z"></path><path d="M13 3v10h-10v-10h10zM14 2h-12v12h12v-12z"></path></g>
<g id="vaadin:vimeo-square"><path d="M0 0v16h16v-16h-16zM13.9 5.3c-0.7 3.8-4.4 7-5.5 7.7s-2.2-0.3-2.5-1.1c-0.4-0.9-1.7-5.7-2-6.1-0.4-0.3-1.4 0.5-1.4 0.5l-0.5-0.7c0 0 2-2.4 3.6-2.7s1.6 2.5 2 4.1c0.4 1.5 0.6 2.4 1 2.4 0.3 0 1-0.9 1.7-2.2s0-2.5-1.4-1.6c0.5-3.3 5.7-4.1 5-0.3z"></path></g>
<g id="vaadin:vimeo"><path d="M15.9 4.4c-0.9 5-5.9 9.3-7.4 10.3s-2.9-0.4-3.4-1.4c-0.5-1.3-2.2-7.6-2.7-8.2-0.4-0.5-1.8 0.6-1.8 0.6l-0.6-0.9c0 0 2.7-3.3 4.8-3.7 2.2-0.4 2.2 3.4 2.7 5.5 0.5 2 0.9 3.2 1.3 3.2s1.3-1.1 2.2-2.9c0.9-1.7 0-3.3-1.9-2.2 0.8-4.3 7.7-5.4 6.8-0.3z"></path></g>
<g id="vaadin:volume-down"><path d="M10.8 4.4l-0.5 1.1c0.5 0.9 0.8 1.9 0.8 3 0 1-0.3 2-0.7 2.9l0.7 0.9c0.6-1.1 1-2.4 1-3.7-0.1-1.6-0.5-3-1.3-4.2z"></path><path d="M4 5h-4v6h4l5 4v-14z"></path></g>
<g id="vaadin:volume-off"><path d="M4 5h-4v6h4l5 4v-14z"></path></g>
<g id="vaadin:volume-up"><path d="M15 8.5c0 2.3-0.8 4.5-2 6.2l0.7 0.8c1.5-1.9 2.4-4.4 2.4-7 0-3.1-1.2-5.9-3.2-8l-0.5 1c1.6 1.8 2.6 4.3 2.6 7z"></path><path d="M11.8 2.4l-0.5 1c1.1 1.4 1.7 3.2 1.7 5.1 0 1.7-0.5 3.2-1.3 4.6l0.7 0.8c1.1-1.5 1.7-3.4 1.7-5.4-0.1-2.3-0.9-4.4-2.3-6.1z"></path><path d="M10.8 4.4l-0.5 1.1c0.5 0.9 0.8 1.9 0.8 3 0 1-0.3 2-0.7 2.9l0.7 0.9c0.6-1.1 1-2.4 1-3.7-0.1-1.6-0.5-3-1.3-4.2z"></path><path d="M4 5h-4v6h4l5 4v-14z"></path></g>
<g id="vaadin:volume"><path d="M11.8 2.4l-0.5 1c1.1 1.4 1.7 3.2 1.7 5.1 0 1.7-0.5 3.2-1.3 4.6l0.7 0.8c1.1-1.5 1.7-3.4 1.7-5.4-0.1-2.3-0.9-4.4-2.3-6.1z"></path><path d="M10.8 4.4l-0.5 1.1c0.5 0.9 0.8 1.9 0.8 3 0 1-0.3 2-0.7 2.9l0.7 0.9c0.6-1.1 1-2.4 1-3.7-0.1-1.6-0.5-3-1.3-4.2z"></path><path d="M4 5h-4v6h4l5 4v-14z"></path></g>
<g id="vaadin:wallet"><path d="M14.5 4h-12.12c-0.057 0.012-0.123 0.018-0.19 0.018-0.552 0-1-0.448-1-1 0-0.006 0-0.013 0-0.019l12.81-0.499v-1.19c0.005-0.041 0.008-0.089 0.008-0.138 0-0.652-0.528-1.18-1.18-1.18-0.049 0-0.097 0.003-0.144 0.009l-11.374 1.849c-0.771 0.289-1.31 1.020-1.31 1.877 0 0.011 0 0.023 0 0.034l-0 10.728c-0 0.003-0 0.006-0 0.010 0 0.828 0.672 1.5 1.5 1.5 0 0 0 0 0 0h13c0 0 0 0 0 0 0.828 0 1.5-0.672 1.5-1.5 0-0.004-0-0.007-0-0.011v-8.999c0-0.012 0.001-0.027 0.001-0.041 0-0.801-0.649-1.45-1.45-1.45-0.018 0-0.036 0-0.053 0.001zM13 11c-0.828 0-1.5-0.672-1.5-1.5s0.672-1.5 1.5-1.5c0.828 0 1.5 0.672 1.5 1.5s-0.672 1.5-1.5 1.5z"></path></g>
<g id="vaadin:warning"><path d="M8 1l-8 14h16l-8-14zM8 13c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1c0 0.6-0.4 1-1 1zM7 10v-4h2v4h-2z"></path></g>
<g id="vaadin:workplace"><path d="M11,3 L11,0 L2,0 L2,14 L0,14 L0,15 L7,15 L7,10 L9,10 L9,8 L14,8 L14,3 L11,3 Z M6,10 L4,10 L4,8 L6,8 L6,10 Z M6,7 L4,7 L4,5 L6,5 L6,7 Z M6,4 L4,4 L4,2 L6,2 L6,4 Z M9,7 L7,7 L7,5 L9,5 L9,7 Z M9,4 L7,4 L7,2 L9,2 L9,4 Z M13,7 L11,7 L11,5 L13,5 L13,7 Z M14,11 L16,11 L16,16 L8,16 L8,11 L10,11 L10,9 L14,9 L14,11 Z" fill-rule="nonzero"></path></g>
<g id="vaadin:wrench"><path d="M15.5 13.4l-7.8-7.8c0.2-0.5 0.3-1 0.3-1.6 0-2.2-1.8-4-4-4-0.6 0-1.1 0.1-1.6 0.3l2.9 2.9-2.1 2.1-2.9-2.9c-0.2 0.5-0.3 1-0.3 1.6 0 2.2 1.8 4 4 4 0.6 0 1.1-0.1 1.6-0.3l7.8 7.8c0.6 0.6 1.5 0.6 2.1 0s0.6-1.5 0-2.1zM6.8 7.6l-1.4-1.4 0.9-0.9 1.4 1.4-0.9 0.9zM14.2 15c-0.4 0-0.8-0.3-0.8-0.8 0-0.4 0.3-0.8 0.8-0.8s0.8 0.3 0.8 0.8c0 0.5-0.3 0.8-0.8 0.8z"></path></g>
<g id="vaadin:youtube-square"><path d="M7.9 6c0.2 0 0.3-0.2 0.3-0.5v-1.4c0-0.3-0.1-0.5-0.3-0.5s-0.3 0.2-0.3 0.5v1.4c0 0.3 0.1 0.5 0.3 0.5z"></path><path d="M7.1 11.9c-0.1 0.2-0.3 0.3-0.4 0.3s-0.1 0-0.1-0.1c0 0 0-0.1 0-0.2v-2.5h-0.6v2.6c0 0.2 0 0.4 0.1 0.5 0.1 0.2 0.2 0.2 0.4 0.2s0.4-0.1 0.7-0.4v0.4h0.6v-3.3h-0.7v2.5z"></path><path d="M3.8 8.9h0.7v3.8h0.7v-3.8h0.7v-0.7h-2.1z"></path><path d="M9.4 9.3c-0.2 0-0.4 0.2-0.6 0.4v-1.5h-0.6v4.4h0.6v-0.3c0.2 0.2 0.4 0.4 0.6 0.4s0.4-0.1 0.5-0.4c0-0.1 0.1-0.4 0.1-0.7v-1.3c0-0.3 0-0.5-0.1-0.7-0.1-0.1-0.2-0.3-0.5-0.3zM9.4 11.7c0 0.3-0.1 0.4-0.3 0.4-0.1 0-0.2 0-0.3-0.1v-2c0.1-0.1 0.2-0.1 0.3-0.1 0.2 0 0.3 0.2 0.3 0.5v1.3z"></path><path d="M11.3 9.3c-0.3 0-0.5 0.1-0.7 0.3-0.1 0.2-0.2 0.4-0.2 0.8v1.2c0 0.4 0.1 0.6 0.2 0.8 0.2 0.2 0.4 0.3 0.7 0.3s0.6-0.1 0.7-0.4c0.1-0.1 0.1-0.2 0.1-0.4 0-0.1 0-0.2 0-0.4v-0.1h-0.6c0 0.2 0 0.4 0 0.4 0 0.2-0.1 0.2-0.3 0.2s-0.3-0.2-0.3-0.5v-0.6h1.2v-0.7c0-0.4-0.1-0.6-0.2-0.8 0 0.1-0.3-0.1-0.6-0.1zM11.6 10.6h-0.6v-0.3c0-0.3 0.1-0.5 0.3-0.5s0.3 0.2 0.3 0.5v0.3z"></path><path d="M0 0v16h16v-16h-16zM9.3 3.1h0.6v2.5c0 0.1 0 0.2 0 0.2 0 0.1 0 0.2 0.1 0.2s0.2-0.1 0.4-0.3v-2.6h0.6v3.3h-0.6v-0.3c-0.2 0.3-0.5 0.4-0.7 0.4s-0.3-0.1-0.4-0.2c0-0.1-0.1-0.3-0.1-0.5v-2.7zM7 4.2c0-0.3 0-0.6 0.2-0.8s0.4-0.3 0.7-0.3c0.3 0 0.5 0.1 0.7 0.3 0.1 0.2 0.2 0.4 0.2 0.8v1.2c0 0.4-0.1 0.6-0.2 0.8-0.2 0.2-0.4 0.3-0.7 0.3s-0.5-0.1-0.7-0.3c-0.2-0.2-0.2-0.4-0.2-0.8v-1.2zM5.3 2l0.5 1.8 0.5-1.8h0.7l-0.8 2.7v1.8h-0.7v-1.8c-0.1-0.4-0.2-0.8-0.4-1.5-0.2-0.4-0.3-0.8-0.5-1.2h0.7zM12.8 12.9c-0.1 0.5-0.6 0.9-1.1 1-1.2 0.1-2.5 0.1-3.7 0.1s-2.5 0-3.7-0.1c-0.5-0.1-1-0.4-1.1-1-0.2-0.8-0.2-1.6-0.2-2.4 0-0.7 0-1.5 0.2-2.3 0.1-0.5 0.6-0.9 1.1-1 1.2-0.1 2.5-0.1 3.7-0.1s2.5 0 3.7 0.1c0.5 0.1 1 0.4 1.1 1 0.2 0.8 0.2 1.6 0.2 2.3 0 0.8 0 1.6-0.2 2.4z"></path></g>
<g id="vaadin:youtube"><path d="M6.6 0h-0.9l-0.6 2.3-0.6-2.3h-1c0.2 0.6 0.4 1.1 0.6 1.7 0.3 0.8 0.5 1.5 0.5 1.9v2.4h0.9v-2.4l1.1-3.6zM9 4.5v-1.5c0-0.5-0.1-0.8-0.3-1.1s-0.5-0.4-0.9-0.4c-0.4 0-0.7 0.2-0.9 0.5-0.2 0.2-0.3 0.5-0.3 1v1.6c0 0.5 0.1 0.8 0.3 1 0.2 0.3 0.5 0.4 0.9 0.4s0.7-0.2 0.9-0.5c0.2-0.1 0.3-0.5 0.3-1zM8.2 4.7c0 0.4-0.1 0.6-0.4 0.6s-0.4-0.2-0.4-0.6v-1.9c0-0.4 0.1-0.6 0.4-0.6s0.4 0.2 0.4 0.6v1.9zM12 6v-4.5h-0.8v3.4c-0.2 0.3-0.3 0.4-0.5 0.4-0.1 0-0.2-0.1-0.2-0.2 0 0 0-0.1 0-0.3v-3.3h-0.8v3.5c0 0.3 0 0.5 0.1 0.7 0 0.2 0.2 0.3 0.5 0.3s0.6-0.2 0.9-0.5v0.5h0.8z"></path><path d="M12.4 10.5c-0.3 0-0.4 0.2-0.4 0.6v0.4h0.8v-0.4c0-0.4-0.1-0.6-0.4-0.6z"></path><path d="M9.5 10.5c-0.1 0-0.3 0.1-0.4 0.2v2.7c0.1 0.1 0.3 0.2 0.4 0.2 0.2 0 0.3-0.2 0.3-0.6v-1.9c0-0.4-0.1-0.6-0.3-0.6z"></path><path d="M14.4 8.3c-0.2-0.7-0.8-1.3-1.4-1.3-1.6-0.2-3.3-0.2-5-0.2s-3.3 0-5 0.2c-0.6 0-1.2 0.6-1.4 1.3-0.2 1-0.2 2.1-0.2 3.1s0 2.1 0.2 3.1c0.2 0.7 0.7 1.2 1.4 1.3 1.7 0.2 3.3 0.2 5 0.2s3.3 0 5-0.2c0.7-0.1 1.3-0.6 1.4-1.3 0.2-1 0.2-2.1 0.2-3.1s0-2.1-0.2-3.1zM5.2 9.2h-1v5.1h-0.9v-5.1h-0.9v-0.9h2.8v0.9zM7.6 14.3h-0.8v-0.5c-0.3 0.4-0.6 0.5-0.9 0.5s-0.4-0.1-0.5-0.3c0-0.1-0.1-0.3-0.1-0.7v-3.5h0.8v3.2c0 0.2 0 0.3 0 0.3 0 0.1 0.1 0.2 0.2 0.2 0.2 0 0.3-0.1 0.5-0.4v-3.3h0.8v4.5zM10.6 12.9c0 0.4 0 0.7-0.1 0.9-0.1 0.3-0.3 0.5-0.6 0.5s-0.6-0.2-0.8-0.5v0.4h-0.8v-5.9h0.8v1.9c0.3-0.3 0.5-0.5 0.8-0.5s0.5 0.2 0.6 0.5c0.1 0.2 0.1 0.5 0.1 0.9v1.8zM13.6 12.2h-1.6v0.8c0 0.4 0.1 0.6 0.4 0.6 0.2 0 0.3-0.1 0.4-0.3 0 0 0-0.2 0-0.5h0.8v0.1c0 0.3 0 0.4 0 0.5 0 0.2-0.1 0.3-0.2 0.5-0.2 0.3-0.5 0.5-1 0.5-0.4 0-0.7-0.2-1-0.5-0.2-0.2-0.3-0.6-0.3-1v-1.5c0-0.5 0.1-0.8 0.2-1 0.2-0.3 0.5-0.5 1-0.5 0.4 0 0.7 0.2 0.9 0.5 0.2 0.2 0.2 0.6 0.2 1v0.8z"></path></g>
</defs></svg>`;
Iconset$1.register("vaadin", 16, template$3);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MultiSelectListMixin = (superClass) => class VaadinMultiSelectListMixin extends ListMixin(superClass) {
  static get properties() {
    return {
      /**
       * Specifies that multiple options can be selected at once.
       */
      multiple: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_multipleChanged"
      },
      /**
       * Array of indexes of the items selected in the items array
       * Note: Not updated when used in single selection mode.
       * @type {number[] | null | undefined}
       */
      selectedValues: {
        type: Array,
        notify: true,
        value: () => []
      }
    };
  }
  static get observers() {
    return ["_enhanceMultipleItems(items, multiple, selected, disabled, selectedValues)"];
  }
  /** @protected */
  ready() {
    this.addEventListener("click", (e2) => this._onMultipleClick(e2));
    super.ready();
  }
  /** @private */
  _enhanceMultipleItems(items, multiple, _selected, _disabled, selectedValues) {
    if (!items || !multiple) {
      return;
    }
    if (selectedValues) {
      const selectedItems = selectedValues.map((selectedId) => items[selectedId]);
      items.forEach((item2) => {
        item2.selected = selectedItems.includes(item2);
      });
    }
    this._scrollToLastSelectedItem();
  }
  /** @private */
  _scrollToLastSelectedItem() {
    const lastSelectedItem = this.selectedValues.slice(-1)[0];
    if (lastSelectedItem && !lastSelectedItem.disabled) {
      this._scrollToItem(lastSelectedItem);
    }
  }
  /**
   * @param {!MouseEvent} event
   * @protected
   */
  _onMultipleClick(event) {
    const item2 = this._filterItems(event.composedPath())[0];
    const idx = item2 && !item2.disabled ? this.items.indexOf(item2) : -1;
    if (idx < 0 || !this.multiple) {
      return;
    }
    event.preventDefault();
    if (this.selectedValues.includes(idx)) {
      this.selectedValues = this.selectedValues.filter((v) => v !== idx);
    } else {
      this.selectedValues = this.selectedValues.concat(idx);
    }
  }
  /** @private */
  _multipleChanged(value, oldValue) {
    if (!value && oldValue) {
      this.selectedValues = [];
      this.items.forEach((item2) => {
        item2.selected = false;
      });
      this.removeAttribute("aria-multiselectable");
    }
    if (value && !oldValue) {
      this.setAttribute("aria-multiselectable", "true");
      if (this.selected !== void 0) {
        this.selectedValues = [...this.selectedValues, this.selected];
        this.selected = void 0;
      }
    }
  }
  /**
   * Fired when the selection is changed.
   * Not fired in single selection mode.
   *
   * @event selected-values-changed
   * @param {Object} detail
   * @param {Object} detail.value the array of indexes of the items selected in the items array.
   */
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ListBox extends ElementMixin(MultiSelectListMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='items'] {
          height: 100%;
          width: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }
      </style>
      <div part="items">
        <slot></slot>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-list-box";
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        readOnly: true
      }
    };
  }
  constructor() {
    super();
    this.focused;
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "listbox");
    setTimeout(this._checkImport.bind(this), 2e3);
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
  }
  /** @private */
  _checkImport() {
    const item2 = this.querySelector("vaadin-item");
    if (item2 && !(item2 instanceof PolymerElement)) {
      console.warn(`Make sure you have imported the vaadin-item element.`);
    }
  }
}
defineCustomElement(ListBox);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Item extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-item";
  }
  constructor() {
    super();
    this.value;
    this.label;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "option");
  }
}
defineCustomElement(Item);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-text-field", inputFieldShared$1, {
  moduleId: "lumo-text-field-styles"
});
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const InputFieldMixin = (superclass) => class InputFieldMixinClass extends InputControlMixin(superclass) {
  static get properties() {
    return {
      /**
       * Whether the value of the control can be automatically completed by the browser.
       * List of available options at:
       * https://developer.mozilla.org/en/docs/Web/HTML/Element/input#attr-autocomplete
       */
      autocomplete: {
        type: String
      },
      /**
       * This is a property supported by Safari that is used to control whether
       * autocorrection should be enabled when the user is entering/editing the text.
       * Possible values are:
       * on: Enable autocorrection.
       * off: Disable autocorrection.
       */
      autocorrect: {
        type: String
      },
      /**
       * This is a property supported by Safari and Chrome that is used to control whether
       * autocapitalization should be enabled when the user is entering/editing the text.
       * Possible values are:
       * characters: Characters capitalization.
       * words: Words capitalization.
       * sentences: Sentences capitalization.
       * none: No capitalization.
       */
      autocapitalize: {
        type: String,
        reflectToAttribute: true
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "autocapitalize", "autocomplete", "autocorrect"];
  }
  // Workaround for https://github.com/Polymer/polymer/issues/5259
  get __data() {
    return this.__dataValue || {};
  }
  set __data(value) {
    this.__dataValue = value;
  }
  /**
   * @param {HTMLElement} input
   * @protected
   * @override
   */
  _inputElementChanged(input) {
    super._inputElementChanged(input);
    if (input) {
      if (input.value && input.value !== this.value) {
        console.warn(`Please define value on the <${this.localName}> component!`);
        input.value = "";
      }
      if (this.value) {
        input.value = this.value;
      }
    }
  }
  /**
   * Override an event listener from `FocusMixin`.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
  /**
   * Override an event listener from `InputMixin`
   * to mark as valid after user started typing.
   * @param {Event} event
   * @protected
   * @override
   */
  _onInput(event) {
    super._onInput(event);
    if (this.invalid) {
      this._requestValidation();
    }
  }
  /**
   * Override an observer from `InputMixin` to validate the field
   * when a new value is set programmatically.
   *
   * @param {string | undefined} newValue
   * @param {string | undefined} oldValue
   * @protected
   * @override
   */
  _valueChanged(newValue, oldValue) {
    super._valueChanged(newValue, oldValue);
    if (oldValue === void 0) {
      return;
    }
    if (this.invalid) {
      this._requestValidation();
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const TextFieldMixin = (superClass) => class TextFieldMixinClass extends InputFieldMixin(superClass) {
  static get properties() {
    return {
      /**
       * Maximum number of characters (in Unicode code points) that the user can enter.
       */
      maxlength: {
        type: Number
      },
      /**
       * Minimum number of characters (in Unicode code points) that the user can enter.
       */
      minlength: {
        type: Number
      },
      /**
       * A regular expression that the value is checked against.
       * The pattern must match the entire value, not just some subset.
       */
      pattern: {
        type: String
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "maxlength", "minlength", "pattern"];
  }
  static get constraints() {
    return [...super.constraints, "maxlength", "minlength", "pattern"];
  }
  constructor() {
    super();
    this._setType("text");
  }
  /** @protected */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-text-field", inputFieldShared, { moduleId: "vaadin-text-field-styles" });
class TextField extends TextFieldMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-text-field";
  }
  static get template() {
    return html`
      <div class="vaadin-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <slot name="suffix" slot="suffix"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
      <slot name="tooltip"></slot>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this.addController(this._tooltipController);
  }
}
defineCustomElement(TextField);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const passwordFieldButton = css`
  :host {
    position: absolute;
    right: 0;
    top: 0;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    min-width: auto;
    background: transparent;
    outline: none;
  }
`;
registerStyles$1("vaadin-password-field-button", [button, passwordFieldButton], {
  moduleId: "lumo-password-field-button"
});
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const passwordField = css`
  [part='reveal-button']::before {
    content: var(--lumo-icons-eye);
  }

  :host([password-visible]) [part='reveal-button']::before {
    content: var(--lumo-icons-eye-disabled);
  }

  /* Make it easy to hide the button across the whole app */
  [part='reveal-button'] {
    position: relative;
    display: var(--lumo-password-field-reveal-button-display, block);
  }

  [part='reveal-button'][hidden] {
    display: none !important;
  }
`;
registerStyles$1("vaadin-password-field", [inputFieldShared$1, passwordField], { moduleId: "lumo-password-field" });
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-password-field-button", buttonStyles, { moduleId: "vaadin-password-field-button-styles" });
class PasswordFieldButton extends ButtonMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-password-field-button";
  }
  static get template() {
    return html``;
  }
}
defineCustomElement(PasswordFieldButton);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const PasswordFieldMixin = (superClass) => class PasswordFieldMixinClass extends SlotStylesMixin(DisabledMixin(FocusMixin(InputMixin(superClass)))) {
  static get properties() {
    return {
      /**
       * Set to true to hide the eye icon which toggles the password visibility.
       * @attr {boolean} reveal-button-hidden
       */
      revealButtonHidden: {
        type: Boolean,
        observer: "_revealButtonHiddenChanged",
        value: false
      },
      /**
       * True if the password is visible ([type=text]).
       * @attr {boolean} password-visible
       */
      passwordVisible: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_passwordVisibleChanged",
        readOnly: true
      },
      /**
       * An object with translated strings used for localization.
       * It has the following structure and default values:
       *
       * ```
       * {
       *   // Translation of the reveal icon button accessible label
       *   reveal: 'Show password'
       * }
       * ```
       */
      i18n: {
        type: Object,
        value: () => {
          return {
            reveal: "Show password"
          };
        }
      }
    };
  }
  static get observers() {
    return ["__i18nChanged(i18n)"];
  }
  constructor() {
    super();
    this._setType("password");
    this.__boundRevealButtonClick = this._onRevealButtonClick.bind(this);
    this.__boundRevealButtonMouseDown = this._onRevealButtonMouseDown.bind(this);
    this.__lastChange = "";
  }
  /** @protected */
  get slotStyles() {
    const tag = this.localName;
    return [
      ...super.slotStyles,
      `
          ${tag} [slot="input"]::-ms-reveal {
            display: none;
          }
        `
    ];
  }
  /** @protected */
  get _revealNode() {
    return this._revealButtonController && this._revealButtonController.node;
  }
  /** @protected */
  ready() {
    super.ready();
    this._revealPart = this.shadowRoot.querySelector('[part="reveal-button"]');
    this._revealButtonController = new SlotController(this, "reveal", "vaadin-password-field-button", {
      initializer: (btn) => {
        btn.disabled = this.disabled;
        btn.addEventListener("click", this.__boundRevealButtonClick);
        btn.addEventListener("mousedown", this.__boundRevealButtonMouseDown);
      }
    });
    this.addController(this._revealButtonController);
    this.__updateAriaLabel(this.i18n);
    this._updateToggleState(false);
    this._toggleRevealHidden(this.revealButtonHidden);
    if (this.inputElement) {
      this.inputElement.autocapitalize = "off";
    }
  }
  /**
   * Override an event listener inherited from `InputControlMixin`
   * to store the value at the moment of the native `change` event.
   * @param {Event} event
   * @protected
   * @override
   */
  _onChange(event) {
    super._onChange(event);
    this.__lastChange = this.inputElement.value;
  }
  /**
   * Override method inherited from `FocusMixin` to mark field as focused
   * when focus moves to the reveal button using Shift Tab.
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldSetFocus(event) {
    return event.target === this.inputElement || event.target === this._revealNode;
  }
  /**
   * Override method inherited from `FocusMixin` to not hide password
   * when focus moves to the reveal button or back to the input.
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldRemoveFocus(event) {
    return !(event.relatedTarget === this._revealNode || event.relatedTarget === this.inputElement && event.target === this._revealNode);
  }
  /**
   * Override method inherited from `FocusMixin` to toggle password visibility.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this._setPasswordVisible(false);
      if (this.__lastChange !== this.inputElement.value) {
        this.__lastChange = this.inputElement.value;
        this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
      }
    } else {
      const isButtonFocused = this.getRootNode().activeElement === this._revealNode;
      this.toggleAttribute("focus-ring", this._keyboardActive && !isButtonFocused);
    }
  }
  /** @private */
  __updateAriaLabel(i18n) {
    if (i18n && i18n.reveal && this._revealNode) {
      this._revealNode.setAttribute("aria-label", i18n.reveal);
    }
  }
  /** @private */
  __i18nChanged(i18n) {
    this.__updateAriaLabel(i18n);
  }
  /** @private */
  _revealButtonHiddenChanged(hidden) {
    this._toggleRevealHidden(hidden);
  }
  /** @private */
  _togglePasswordVisibility() {
    this._setPasswordVisible(!this.passwordVisible);
  }
  /** @private */
  _onRevealButtonClick() {
    this._togglePasswordVisibility();
  }
  /** @private */
  _onRevealButtonMouseDown(e2) {
    e2.preventDefault();
    this.inputElement.focus();
  }
  /** @private */
  _toggleRevealHidden(hidden) {
    if (this._revealNode) {
      if (hidden) {
        this._revealPart.setAttribute("hidden", "");
        this._revealNode.setAttribute("tabindex", "-1");
        this._revealNode.setAttribute("aria-hidden", "true");
      } else {
        this._revealPart.removeAttribute("hidden");
        this._revealNode.setAttribute("tabindex", "0");
        this._revealNode.removeAttribute("aria-hidden");
      }
    }
  }
  /** @private */
  _updateToggleState(passwordVisible) {
    if (this._revealNode) {
      this._revealNode.setAttribute("aria-pressed", passwordVisible ? "true" : "false");
    }
  }
  /** @private */
  _passwordVisibleChanged(passwordVisible) {
    this._setType(passwordVisible ? "text" : "password");
    this._updateToggleState(passwordVisible);
  }
  /**
   * Override method inherited from `DisabledMixin` to synchronize the reveal button
   * disabled state with the password field disabled state.
   * @param {boolean} disabled
   * @param {boolean} oldDisabled
   * @protected
   */
  _disabledChanged(disabled, oldDisabled) {
    super._disabledChanged(disabled, oldDisabled);
    if (this._revealNode) {
      this._revealNode.disabled = disabled;
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ownTemplate = html`
  <div part="reveal-button" slot="suffix">
    <slot name="reveal"></slot>
  </div>
`;
let memoizedTemplate$1;
class PasswordField extends PasswordFieldMixin(TextField) {
  static get is() {
    return "vaadin-password-field";
  }
  static get template() {
    if (!memoizedTemplate$1) {
      memoizedTemplate$1 = super.template.cloneNode(true);
      const revealButton = ownTemplate.content.querySelector('[part="reveal-button"]');
      const inputField2 = memoizedTemplate$1.content.querySelector('[part="input-field"]');
      inputField2.appendChild(revealButton);
    }
    return memoizedTemplate$1;
  }
}
defineCustomElement(PasswordField);
const loginFormWrapper$1 = css`
  :host {
    max-width: calc(var(--lumo-size-m) * 10);
    background: var(--lumo-base-color) linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
  }

  [part='form'] {
    padding: var(--lumo-space-l);
  }

  [part='form-title'] {
    margin-top: calc(var(--lumo-font-size-xxxl) - var(--lumo-font-size-xxl));
    color: var(--lumo-header-text-color);
    font-size: var(--lumo-font-size-xxl);
    font-weight: 600;
    line-height: var(--lumo-line-height-xs);
  }

  ::slotted([slot='submit']) {
    margin-top: var(--lumo-space-l);
    margin-bottom: var(--lumo-space-s);
  }

  ::slotted([slot='forgot-password']) {
    margin: var(--lumo-space-s) auto;
  }

  [part='error-message'] {
    background-color: var(--lumo-error-color-10pct);
    padding: var(--lumo-space-m);
    border-radius: var(--lumo-border-radius-m);
    margin-top: var(--lumo-space-m);
    margin-bottom: var(--lumo-space-s);
    color: var(--lumo-error-text-color);
  }

  :host(:not([dir='rtl'])) [part='error-message'] {
    padding-left: var(--lumo-size-m);
  }

  :host([dir='rtl']) [part='error-message'] {
    padding-right: var(--lumo-size-m);
  }

  [part='error-message']::before {
    content: var(--lumo-icons-error);
    font-family: lumo-icons;
    font-size: var(--lumo-icon-size-m);
    position: absolute;
    width: var(--lumo-size-m);
    height: 1em;
    line-height: 1;
    text-align: center;
  }

  :host(:not([dir='rtl'])) [part='error-message']::before {
    /* Visual centering */
    margin-left: calc(var(--lumo-size-m) * -0.95);
  }

  :host([dir='rtl']) [part='error-message']::before {
    /* Visual centering */
    margin-right: calc(var(--lumo-size-m) * -0.95);
  }

  [part='error-message-title'] {
    display: block;
    margin: 0 0 0.25em;
    color: inherit;
    line-height: var(--lumo-line-height-xs);
  }

  [part='error-message-description'] {
    font-size: var(--lumo-font-size-s);
    line-height: var(--lumo-line-height-s);
    margin: 0;
    opacity: 0.9;
  }

  [part='footer'] {
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-s);
    color: var(--lumo-secondary-text-color);
  }
`;
registerStyles$1("vaadin-login-form-wrapper", [color, typography, loginFormWrapper$1], {
  moduleId: "lumo-login-form-wrapper"
});
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const loginFormWrapperStyles = css`
  :host {
    overflow: hidden;
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='form'] {
    flex: 1;
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
  }

  [part='form-title'] {
    margin: 0;
  }

  [part='error-message'] {
    position: relative;
  }
`;
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-login-form-wrapper", loginFormWrapperStyles, {
  moduleId: "vaadin-login-form-wrapper-styles"
});
class LoginFormWrapper extends ThemableMixin(PolymerElement) {
  static get template() {
    return html`
      <section part="form">
        <div part="form-title" part="form-title" role="heading" aria-level="2">[[i18n.form.title]]</div>
        <div part="error-message" hidden$="[[!error]]">
          <strong part="error-message-title">[[i18n.errorMessage.title]]</strong>
          <p part="error-message-description">[[i18n.errorMessage.message]]</p>
        </div>

        <slot name="form"></slot>

        <slot name="custom-form-area"></slot>

        <slot name="submit"></slot>

        <slot name="forgot-password"></slot>

        <div part="footer">
          <slot name="footer"></slot>
          <p>[[i18n.additionalInformation]]</p>
        </div>
      </section>
    `;
  }
  static get is() {
    return "vaadin-login-form-wrapper";
  }
  static get properties() {
    return {
      /**
       * If set, the error message is shown. The message is hidden by default.
       * When set, it changes the disabled state of the submit button.
       * @type {boolean}
       */
      error: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * The object used to localize this component.
       */
      i18n: {
        type: Object
      }
    };
  }
}
defineCustomElement(LoginFormWrapper);
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const LoginMixin = (superClass) => class LoginMixin extends superClass {
  /**
   * Fired when user clicks on the "Forgot password" button.
   *
   * @event forgot-password
   */
  /**
   * Fired when an user submits the login.
   * The event contains `username` and `password` values in the `detail` property.
   *
   * @event login
   */
  static get properties() {
    return {
      /**
       * If set, a synchronous POST call will be fired to the path defined.
       * The `login` event is also dispatched, so `event.preventDefault()` can be called to prevent the POST call.
       * @type {string | null}
       */
      action: {
        type: String,
        value: null
      },
      /**
       * If set, disable the "Log in" button and prevent user from submitting login form.
       * It is re-enabled automatically, when error is set to true, allowing form resubmission
       * after user makes changes.
       * @type {boolean}
       */
      disabled: {
        type: Boolean,
        value: false,
        notify: true
      },
      /**
       * If set, the error message is shown. The message is hidden by default.
       * When set, it changes the disabled state of the submit button.
       * @type {boolean}
       */
      error: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        notify: true
      },
      /**
       * Whether to hide the forgot password button. The button is visible by default.
       * @type {boolean}
       * @attr {boolean} no-forgot-password
       */
      noForgotPassword: {
        type: Boolean,
        value: false
      },
      /**
       * If set, the user name field automatically receives focus when the component is attached to the document.
       * @type {boolean}
       * @attr {boolean} no-autofocus
       */
      noAutofocus: {
        type: Boolean,
        value: false
      },
      /**
       * The object used to localize this component.
       * For changing the default localization, change the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure (by default it doesn't include `additionalInformation`
       * and `header` sections, `header` can be added to override `title` and `description` properties
       * in `vaadin-login-overlay`):
       *
       * ```
       * {
       *   header: {
       *     title: 'App name',
       *     description: 'Inspiring application description'
       *   },
       *   form: {
       *     title: 'Log in',
       *     username: 'Username',
       *     password: 'Password',
       *     submit: 'Log in',
       *     forgotPassword: 'Forgot password'
       *   },
       *   errorMessage: {
       *     title: 'Incorrect username or password',
       *     message: 'Check that you have entered the correct username and password and try again.',
       *     username: 'Username is required',
       *     password: 'Password is required'
       *   },
       *   additionalInformation: 'In case you need to provide some additional info for the user.'
       * }
       * ```
       *
       * @type {!LoginI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value() {
          return {
            form: {
              title: "Log in",
              username: "Username",
              password: "Password",
              submit: "Log in",
              forgotPassword: "Forgot password"
            },
            errorMessage: {
              title: "Incorrect username or password",
              message: "Check that you have entered the correct username and password and try again.",
              username: "Username is required",
              password: "Password is required"
            }
          };
        }
      },
      /**
       * If set, prevents auto enabling the component when error property is set to true.
       * @private
       */
      _preventAutoEnable: {
        type: Boolean,
        value: false
      }
    };
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function isCheckbox(field) {
  return (field.inputElement || field).type === "checkbox";
}
const LoginFormMixin = (superClass) => class LoginFormMixin extends LoginMixin(superClass) {
  static get observers() {
    return ["_errorChanged(error)"];
  }
  get _customFields() {
    return [...this.$.vaadinLoginFormWrapper.children].filter((node) => {
      return node.getAttribute("slot") === "custom-form-area" && node.hasAttribute("name");
    });
  }
  /** @protected */
  async connectedCallback() {
    super.connectedCallback();
    if (!this.noAutofocus) {
      await new Promise(requestAnimationFrame);
      this.$.vaadinLoginUsername.focus();
    }
  }
  /** @private */
  _errorChanged() {
    if (this.error && !this._preventAutoEnable) {
      this.disabled = false;
    }
  }
  /**
   * Submits the form.
   */
  submit() {
    const userName = this.$.vaadinLoginUsername;
    const password = this.$.vaadinLoginPassword;
    userName.validate();
    password.validate();
    if (this.disabled || userName.invalid || password.invalid) {
      return;
    }
    this.error = false;
    this.disabled = true;
    const detail = {
      username: userName.value,
      password: password.value
    };
    const fields2 = this._customFields;
    if (fields2.length) {
      detail.custom = {};
      fields2.forEach((field) => {
        if (isCheckbox(field) && !field.checked) {
          return;
        }
        detail.custom[field.name] = field.value;
      });
    }
    const loginEventDetails = {
      bubbles: true,
      cancelable: true,
      detail
    };
    const firedEvent = this.dispatchEvent(new CustomEvent("login", loginEventDetails));
    if (this.action && firedEvent) {
      const csrfMetaName = document.querySelector("meta[name=_csrf_parameter]");
      const csrfMetaValue = document.querySelector("meta[name=_csrf]");
      if (csrfMetaName && csrfMetaValue) {
        this.$.csrf.name = csrfMetaName.content;
        this.$.csrf.value = csrfMetaValue.content;
      }
      this.querySelector("form").submit();
    }
  }
  /** @protected */
  _onFormData(event) {
    const { formData } = event;
    if (this._customFields.length) {
      this._customFields.forEach((field) => {
        if (isCheckbox(field) && !field.checked) {
          return;
        }
        formData.append(field.name, field.value);
      });
    }
  }
  /** @protected */
  _handleInputKeydown(e2) {
    if (e2.key === "Enter") {
      const { currentTarget: inputActive } = e2;
      const nextInput = inputActive.id === "vaadinLoginUsername" ? this.$.vaadinLoginPassword : this.$.vaadinLoginUsername;
      if (inputActive.validate()) {
        if (nextInput.checkValidity()) {
          this.submit();
        } else {
          nextInput.focus();
        }
      }
    }
  }
  /** @protected */
  _handleInputKeyup(e2) {
    const input = e2.currentTarget;
    if (e2.key === "Tab" && input instanceof HTMLInputElement) {
      input.select();
    }
  }
  /** @protected */
  _onForgotPasswordClick() {
    this.dispatchEvent(new CustomEvent("forgot-password"));
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class LoginForm extends LoginFormMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        vaadin-login-form-wrapper > form > * {
          width: 100%;
        }
      </style>
      <vaadin-login-form-wrapper id="vaadinLoginFormWrapper" theme$="[[_theme]]" error="[[error]]" i18n="[[i18n]]">
        <form method="POST" action$="[[action]]" on-formdata="_onFormData" slot="form">
          <input id="csrf" type="hidden" />
          <vaadin-text-field
            name="username"
            label="[[i18n.form.username]]"
            error-message="[[i18n.errorMessage.username]]"
            id="vaadinLoginUsername"
            required
            on-keydown="_handleInputKeydown"
            autocapitalize="none"
            autocorrect="off"
            spellcheck="false"
            autocomplete="username"
            manual-validation
          >
            <input type="text" slot="input" on-keyup="_handleInputKeyup" />
          </vaadin-text-field>

          <vaadin-password-field
            name="password"
            label="[[i18n.form.password]]"
            error-message="[[i18n.errorMessage.password]]"
            id="vaadinLoginPassword"
            required
            on-keydown="_handleInputKeydown"
            spellcheck="false"
            autocomplete="current-password"
            manual-validation
          >
            <input type="password" slot="input" on-keyup="_handleInputKeyup" />
          </vaadin-password-field>
        </form>

        <vaadin-button slot="submit" theme="primary contained submit" on-click="submit" disabled$="[[disabled]]">
          [[i18n.form.submit]]
        </vaadin-button>

        <vaadin-button
          slot="forgot-password"
          theme="tertiary small"
          on-click="_onForgotPasswordClick"
          hidden$="[[noForgotPassword]]"
        >
          [[i18n.form.forgotPassword]]
        </vaadin-button>
      </vaadin-login-form-wrapper>
    `;
  }
  static get is() {
    return "vaadin-login-form";
  }
  /**
   * @param {StampedTemplate} dom
   * @return {null}
   * @protected
   */
  _attachDom(dom) {
    this.appendChild(dom);
  }
}
defineCustomElement(LoginForm);
const loginOverlayWrapper = css`
  :host {
    inset: 0;
  }

  [part='backdrop'] {
    background: var(--lumo-base-color) linear-gradient(var(--lumo-shade-5pct), var(--lumo-shade-5pct));
  }

  [part='overlay'] {
    background: none;
    border-radius: 0;
    box-shadow: none;
    width: 100%;
    height: 100%;
  }

  [part='brand'] {
    padding: var(--lumo-space-l) var(--lumo-space-xl) var(--lumo-space-l) var(--lumo-space-l);
    background-color: var(--lumo-primary-color);
    color: var(--lumo-primary-contrast-color);
    min-height: calc(var(--lumo-size-m) * 5);
  }

  [part='description'] {
    line-height: var(--lumo-line-height-s);
    color: var(--lumo-tint-70pct);
    margin-bottom: 0;
  }

  [part='content'] {
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
  }

  [part='card'] {
    width: calc(var(--lumo-size-m) * 10);
    background: var(--lumo-base-color) linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
    border-radius: var(--lumo-border-radius-l);
    box-shadow: var(--lumo-box-shadow-s);
    margin: var(--lumo-space-s);
    height: auto;
  }

  /* Small screen */
  @media only screen and (max-width: 500px) {
    [part='overlay'],
    [part='content'] {
      height: 100%;
    }

    [part='content'] {
      min-height: 100%;
      background: var(--lumo-base-color);
      align-items: flex-start;
    }

    [part='card'],
    [part='overlay'] {
      width: 100%;
      border-radius: 0;
      box-shadow: none;
      margin: 0;
    }

    /* RTL styles */
    :host([dir='rtl']) [part='brand'] {
      padding: var(--lumo-space-l) var(--lumo-space-l) var(--lumo-space-l) var(--lumo-space-xl);
    }
  }

  /* Landscape small screen */
  @media only screen and (max-height: 600px) and (min-width: 600px) and (orientation: landscape) {
    [part='card'] {
      flex-direction: row;
      align-items: stretch;
      max-width: calc(var(--lumo-size-m) * 16);
      width: 100%;
    }

    [part='brand'],
    [part='form'] {
      flex: auto;
      flex-basis: 0;
      box-sizing: border-box;
    }

    [part='brand'] {
      justify-content: flex-start;
    }

    [part='form'] {
      padding: var(--lumo-space-l);
      overflow: auto;
    }
  }

  /* Landscape really small screen */
  @media only screen and (max-height: 500px) and (min-width: 600px) and (orientation: landscape),
    only screen and (max-width: 600px) and (min-width: 600px) and (orientation: landscape) {
    [part='content'] {
      height: 100vh;
    }

    [part='card'] {
      margin: 0;
      width: 100%;
      max-width: none;
      height: 100%;
      flex: auto;
      border-radius: 0;
      box-shadow: none;
    }

    [part='form'] {
      height: 100%;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
  }

  /* Handle iPhone X notch */
  @media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) {
    [part='card'] {
      padding-right: env(safe-area-inset-right);
      padding-left: env(safe-area-inset-left);
    }

    [part='brand'] {
      margin-left: calc(env(safe-area-inset-left) * -1);
      padding-left: calc(var(--lumo-space-l) + env(safe-area-inset-left));
    }

    /* RTL styles */
    :host([dir='rtl']) [part='card'] {
      padding-left: env(safe-area-inset-right);
      padding-right: env(safe-area-inset-left);
    }

    :host([dir='rtl']) [part='brand'] {
      margin-right: calc(env(safe-area-inset-left) * -1);
      padding-right: calc(var(--lumo-space-l) + env(safe-area-inset-left));
    }
  }
`;
registerStyles$1("vaadin-login-overlay-wrapper", [color, typography, overlay, loginOverlayWrapper], {
  moduleId: "lumo-login-overlay-wrapper"
});
const loginFormWrapper = css`
  :host([theme~='with-overlay']) {
    min-height: 100%;
    display: flex;
    justify-content: center;
    max-width: 100%;
  }

  /* Landscape small screen */
  @media only screen and (max-height: 600px) and (min-width: 600px) and (orientation: landscape) {
    :host([theme~='with-overlay']) [part='form'] {
      height: 100%;
      -webkit-overflow-scrolling: touch;
      flex: 1;
      padding: 2px;
    }
  }
`;
registerStyles$1("vaadin-login-form-wrapper", [loginFormWrapper], {
  moduleId: "lumo-login-overlay"
});
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const LoginOverlayWrapperMixin = (superClass) => class LoginOverlayWrapperMixin extends OverlayMixin(DirMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Title of the application.
       */
      title: {
        type: String,
        observer: "_titleChanged"
      },
      /**
       * Application description. Displayed under the title.
       */
      description: {
        type: String
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    const slot = this.shadowRoot.querySelector('slot[name="title"]');
    this._titleSlotObserver = new SlotObserver(slot, () => {
      const title = slot.assignedElements({ flatten: true })[0];
      if (!title) {
        return;
      }
      if (title.getAttribute("part") === "title") {
        this.setAttribute("aria-label", this.title);
        this.removeAttribute("aria-labelledby");
      } else {
        if (!title.id) {
          title.id = `login-overlay-title-${generateUniqueId()}`;
        }
        this.removeAttribute("aria-label");
        this.setAttribute("aria-labelledby", title.id);
      }
    });
  }
  /** @private */
  _titleChanged(title) {
    if (title && this.hasAttribute("aria-label")) {
      this.setAttribute("aria-label", title);
    }
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const loginOverlayWrapperStyles = css`
  [part='overlay'] {
    outline: none;
  }

  [part='card'] {
    max-width: 100%;
    box-sizing: border-box;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  [part='brand'] {
    box-sizing: border-box;
    overflow: hidden;
    flex-grow: 1;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
  }

  [part='brand'] h1 {
    color: inherit;
    margin: 0;
  }
`;
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-login-overlay-wrapper", [overlayStyles, loginOverlayWrapperStyles], {
  moduleId: "vaadin-login-overlay-wrapper-styles"
});
class LoginOverlayWrapper extends LoginOverlayWrapperMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-login-overlay-wrapper";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <section part="card">
            <div part="brand">
              <slot name="title">
                <h1 part="title">[[title]]</h1>
              </slot>
              <p part="description">[[description]]</p>
            </div>
            <div part="form">
              <slot></slot>
            </div>
          </section>
        </div>
      </div>
    `;
  }
}
defineCustomElement(LoginOverlayWrapper);
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const LoginOverlayMixin = (superClass) => class LoginOverlayMixin extends OverlayClassMixin(LoginMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Defines the application description
       * @type {string}
       */
      description: {
        type: String,
        value: "Application description",
        notify: true
      },
      /**
       * True if the overlay is currently displayed.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        observer: "_onOpenedChange"
      },
      /**
       * Defines the application title
       * @type {string}
       */
      title: {
        type: String,
        value: "App name"
      }
    };
  }
  static get observers() {
    return ["__i18nChanged(i18n)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this._overlayElement = this.$.vaadinLoginOverlayWrapper;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this.__restoreOpened) {
      this.opened = true;
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__restoreOpened = this.opened;
    this.opened = false;
  }
  /** @private */
  __i18nChanged(i18n) {
    const header = i18n && i18n.header;
    if (!header) {
      return;
    }
    this.title = header.title;
    this.description = header.description;
  }
  /** @protected */
  _preventClosingLogin(e2) {
    e2.preventDefault();
  }
  /**
   * @param {!Event} e
   * @protected
   */
  _retargetEvent(e2) {
    e2.stopPropagation();
    const { detail, composed, cancelable, bubbles } = e2;
    const firedEvent = this.dispatchEvent(new CustomEvent(e2.type, { bubbles, cancelable, composed, detail }));
    if (!firedEvent) {
      e2.preventDefault();
    }
  }
  /** @private */
  async _onOpenedChange() {
    const form = this.$.vaadinLoginForm;
    if (!form.$ && this.updateComplete) {
      await this.updateComplete;
    }
    if (!this.opened) {
      form.$.vaadinLoginUsername.value = "";
      form.$.vaadinLoginPassword.value = "";
      this.disabled = false;
      if (this._undoTitleTeleport) {
        this._undoTitleTeleport();
      }
      if (this._undoFieldsTeleport) {
        this._undoFieldsTeleport();
      }
      if (this._undoFooterTeleport) {
        this._undoFooterTeleport();
      }
    } else {
      this._undoTitleTeleport = this._teleport("title", this.$.vaadinLoginOverlayWrapper);
      this._undoFieldsTeleport = this._teleport(
        "custom-form-area",
        form.$.vaadinLoginFormWrapper,
        form.querySelector("vaadin-button")
      );
      this._undoFooterTeleport = this._teleport("footer", form.$.vaadinLoginFormWrapper);
      document.body.style.pointerEvents = this.$.vaadinLoginOverlayWrapper._previousDocumentPointerEvents;
    }
  }
  /** @private */
  _teleport(slot, target, refNode) {
    const teleported = [...this.querySelectorAll(`[slot="${slot}"]`)].map((el) => {
      if (refNode) {
        target.insertBefore(el, refNode);
      } else {
        target.appendChild(el);
      }
      return el;
    });
    return () => {
      this.append(...teleported);
    };
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class LoginOverlay extends LoginOverlayMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <vaadin-login-overlay-wrapper
        id="vaadinLoginOverlayWrapper"
        opened="{{opened}}"
        role="dialog"
        focus-trap
        with-backdrop
        title="[[title]]"
        description="[[description]]"
        theme$="[[_theme]]"
        on-vaadin-overlay-escape-press="_preventClosingLogin"
        on-vaadin-overlay-outside-click="_preventClosingLogin"
      >
        <vaadin-login-form
          theme="with-overlay"
          id="vaadinLoginForm"
          action="[[action]]"
          disabled="{{disabled}}"
          error="{{error}}"
          no-autofocus="[[noAutofocus]]"
          no-forgot-password="[[noForgotPassword]]"
          i18n="{{i18n}}"
          on-login="_retargetEvent"
          on-forgot-password="_retargetEvent"
        ></vaadin-login-form>
      </vaadin-login-overlay-wrapper>

      <div hidden>
        <slot name="custom-form-area"></slot>
        <slot name="footer"></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-login-overlay";
  }
}
defineCustomElement(LoginOverlay);
function initLazy(menubar, appId) {
  if (menubar.$connector) {
    return;
  }
  const observer2 = new MutationObserver((records) => {
    const hasChangedAttributes = records.some((entry) => {
      const oldValue = entry.oldValue;
      const newValue = entry.target.getAttribute(entry.attributeName);
      return oldValue !== newValue;
    });
    if (hasChangedAttributes) {
      menubar.$connector.generateItems();
    }
  });
  menubar.$connector = {
    /**
     * Generates and assigns the items to the menu bar.
     *
     * When the method is called without providing a node id,
     * the previously generated items tree will be used.
     * That can be useful if you only want to sync the disabled and hidden properties of root items.
     *
     * @param {number | undefined} nodeId
     */
    generateItems(nodeId) {
      if (!menubar.shadowRoot) {
        setTimeout(() => menubar.$connector.generateItems(nodeId));
        return;
      }
      if (!menubar._container) {
        queueMicrotask(() => menubar.$connector.generateItems(nodeId));
        return;
      }
      if (nodeId) {
        menubar.__generatedItems = window.Vaadin.Flow.contextMenuConnector.generateItemsTree(appId, nodeId);
      }
      let items = menubar.__generatedItems || [];
      items.forEach((item2) => {
        item2.disabled = item2.component.disabled;
        item2.component._rootItem = item2;
      });
      items.forEach((item2) => {
        observer2.observe(item2.component, {
          attributeFilter: ["hidden", "disabled"],
          attributeOldValue: true
        });
      });
      items = items.filter((item2) => !item2.component.hidden);
      menubar.items = items;
      menubar._buttons.forEach((button2) => {
        if (button2.item && button2.item.component) {
          button2.addEventListener("click", (e2) => {
            if (e2.composedPath().indexOf(button2.item.component) === -1) {
              button2.item.component.click();
              e2.stopPropagation();
            }
          });
        }
      });
    }
  };
}
function setClassName(component) {
  const item2 = component._rootItem || component._item;
  if (item2) {
    item2.className = component.className;
  }
}
window.Vaadin.Flow.menubarConnector = { initLazy, setClassName };
const menuBarButton = css`
  :host {
    margin: calc(var(--lumo-space-xs) / 2);
    margin-left: 0;
    border-radius: 0;
  }

  [part='label'] {
    width: 100%;
  }

  /* NOTE(web-padawan): avoid using shorthand padding property for IE11 */
  [part='label'] ::slotted(vaadin-menu-bar-item) {
    justify-content: center;
    background-color: transparent;
    height: var(--lumo-button-size);
    margin: 0 calc((var(--lumo-size-m) / 3 + var(--lumo-border-radius-m) / 2) * -1);
    padding-left: calc(var(--lumo-size-m) / 3 + var(--lumo-border-radius-m) / 2);
    padding-right: calc(var(--lumo-size-m) / 3 + var(--lumo-border-radius-m) / 2);
  }

  :host([theme~='small']) [part='label'] ::slotted(vaadin-menu-bar-item) {
    min-height: var(--lumo-size-s);
    margin: 0 calc((var(--lumo-size-s) / 3 + var(--lumo-border-radius-m) / 2) * -1);
    padding-left: calc(var(--lumo-size-s) / 3 + var(--lumo-border-radius-m) / 2);
    padding-right: calc(var(--lumo-size-s) / 3 + var(--lumo-border-radius-m) / 2);
  }

  :host([theme~='tertiary']) [part='label'] ::slotted(vaadin-menu-bar-item) {
    margin: 0 calc((var(--lumo-button-size) / 6) * -1);
    padding-left: calc(var(--lumo-button-size) / 6);
    padding-right: calc(var(--lumo-button-size) / 6);
  }

  :host([theme~='tertiary-inline']) {
    margin-top: calc(var(--lumo-space-xs) / 2);
    margin-bottom: calc(var(--lumo-space-xs) / 2);
    margin-right: calc(var(--lumo-space-xs) / 2);
  }

  :host([theme~='tertiary-inline']) [part='label'] ::slotted(vaadin-menu-bar-item) {
    margin: 0;
    padding: 0;
  }

  :host([first-visible]) {
    border-radius: var(--lumo-border-radius-m) 0 0 var(--lumo-border-radius-m);

    /* Needed to retain the focus-ring with border-radius */
    margin-left: calc(var(--lumo-space-xs) / 2);
  }

  :host([last-visible]),
  :host([slot='overflow']) {
    border-radius: 0 var(--lumo-border-radius-m) var(--lumo-border-radius-m) 0;
  }

  :host([theme~='tertiary']),
  :host([theme~='tertiary-inline']) {
    border-radius: var(--lumo-border-radius-m);
  }

  :host([slot='overflow']) {
    min-width: var(--lumo-button-size);
    padding-left: calc(var(--lumo-button-size) / 4);
    padding-right: calc(var(--lumo-button-size) / 4);
  }

  :host([slot='overflow']) ::slotted(*) {
    font-size: var(--lumo-font-size-xl);
  }

  :host([slot='overflow']) [part='prefix'],
  :host([slot='overflow']) [part='suffix'] {
    margin-left: 0;
    margin-right: 0;
  }

  :host([theme~='dropdown-indicators']:not([slot='overflow']):not([theme~='icon'])[aria-haspopup]) [part='suffix'] {
    margin-inline-start: 0;
    width: 1em;
    height: 1em;
    line-height: 1;
    font-size: var(--lumo-icon-size-s);
    position: relative;
    inset-inline-start: 0.15em;
  }

  /* prettier-ignore */
  :host([theme~='dropdown-indicators']:not([slot='overflow']):not([theme~='icon'])[aria-haspopup]) [part='suffix']::after {
    font-family: lumo-icons;
    content: var(--lumo-icons-dropdown);
  }

  /* prettier-ignore */
  :host([theme~='dropdown-indicators']:not([slot='overflow']):not([theme~='icon'])[theme~='tertiary'][aria-haspopup]) [part='suffix'] {
    inset-inline-start: 0.05em;
  }

  /* prettier-ignore */
  :host([theme~='dropdown-indicators']:not([slot='overflow']):not([theme~='icon'])[theme~='tertiary-inline'][aria-haspopup]) [part='suffix'] {
    inset-inline-start: 0;
  }

  /* RTL styles */
  :host([dir='rtl']) {
    margin-left: calc(var(--lumo-space-xs) / 2);
    margin-right: 0;
    border-radius: 0;
  }

  :host([dir='rtl'][first-visible]) {
    border-radius: 0 var(--lumo-border-radius-m) var(--lumo-border-radius-m) 0;
    margin-right: calc(var(--lumo-space-xs) / 2);
  }

  :host([dir='rtl'][last-visible]),
  :host([dir='rtl'][slot='overflow']) {
    border-radius: var(--lumo-border-radius-m) 0 0 var(--lumo-border-radius-m);
  }
`;
registerStyles$1("vaadin-menu-bar-button", [button, menuBarButton], {
  moduleId: "lumo-menu-bar-button"
});
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1(
  "vaadin-menu-bar-button",
  css`
    :host {
      flex-shrink: 0;
    }

    :host([slot='overflow']) {
      margin-inline-end: 0;
    }
  `,
  { moduleId: "vaadin-menu-bar-button-styles" }
);
class MenuBarButton extends Button {
  static get is() {
    return "vaadin-menu-bar-button";
  }
  /**
   * Override method inherited from `ButtonMixin`. Sets a flag based on whether the key is an active key. Unlike a mouse click, Enter and Space should also focus the first item. This flag is used in menu bar to identify the action that triggered the click.
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    this.__triggeredWithActiveKeys = this._activeKeys.includes(event.key);
    super._onKeyDown(event);
    this.__triggeredWithActiveKeys = null;
  }
}
defineCustomElement(MenuBarButton);
const menuBarItem = css`
  [part='content'] {
    display: flex;
    /* tweak to inherit centering from menu bar button */
    align-items: inherit;
    justify-content: inherit;
  }

  [part='content'] ::slotted(vaadin-icon) {
    display: inline-block;
    width: var(--lumo-icon-size-m);
    height: var(--lumo-icon-size-m);
  }

  [part='content'] ::slotted(vaadin-icon[icon^='vaadin:']) {
    padding: var(--lumo-space-xs);
    box-sizing: border-box !important;
  }
`;
registerStyles$1("vaadin-menu-bar-item", [item, contextMenuItem, menuBarItem], { moduleId: "lumo-menu-bar-item" });
registerStyles$1("vaadin-menu-bar-list-box", [listBox, contextMenuListBox], { moduleId: "lumo-menu-bar-list-box" });
const menuBarOverlay = css`
  :host(:first-of-type) {
    padding-top: var(--lumo-space-xs);
  }
`;
registerStyles$1("vaadin-menu-bar-overlay", [menuOverlay, contextMenuOverlay, menuBarOverlay], {
  moduleId: "lumo-menu-bar-overlay"
});
registerStyles$1(
  "vaadin-menu-bar",
  css`
    :host([has-single-button]) ::slotted(vaadin-menu-bar-button) {
      border-radius: var(--lumo-border-radius-m);
    }

    :host([theme~='end-aligned']) ::slotted(vaadin-menu-bar-button[first-visible]),
    :host([theme~='end-aligned'][has-single-button]) ::slotted(vaadin-menu-bar-button) {
      margin-inline-start: auto;
    }
  `,
  { moduleId: "lumo-menu-bar" }
);
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MenuBarItem extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-menu-bar-item";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "menuitem");
  }
}
defineCustomElement(MenuBarItem);
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MenuBarListBox extends ListMixin(ThemableMixin(DirMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-menu-bar-list-box";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='items'] {
          height: 100%;
          width: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }
      </style>
      <div part="items">
        <slot></slot>
      </div>
    `;
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        readOnly: true
      }
    };
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menu");
  }
}
defineCustomElement(MenuBarListBox);
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-menu-bar-overlay", [overlayStyles, styles], {
  moduleId: "vaadin-menu-bar-overlay-styles"
});
class MenuBarOverlay extends MenuOverlayMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-menu-bar-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
}
defineCustomElement(MenuBarOverlay);
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const SubMenuMixin = (superClass) => class SubMenuMixinClass extends ContextMenuMixin(OverlayClassMixin(superClass)) {
  constructor() {
    super();
    this.openOn = "opensubmenu";
  }
  /**
   * Tag name prefix used by overlay, list-box and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-menu-bar";
  }
  /**
   * Overriding the observer to not add global "contextmenu" listener.
   */
  _openedChanged(opened) {
    this._overlayElement.opened = opened;
  }
  /**
   * Overriding the public method to reset expanded button state.
   */
  close() {
    super.close();
    if (this.hasAttribute("is-root")) {
      this.getRootNode().host._close();
    }
  }
  /**
   * Override method from `ContextMenuMixin` to prevent closing
   * sub-menu on the same click event that was used to open it.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldCloseOnOutsideClick(event) {
    if (this.hasAttribute("is-root") && event.composedPath().includes(this.listenOn)) {
      return false;
    }
    return super._shouldCloseOnOutsideClick(event);
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MenuBarSubmenu extends SubMenuMixin(ControllerMixin(ThemePropertyMixin(PolymerElement))) {
  static get is() {
    return "vaadin-menu-bar-submenu";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>

      <slot id="slot"></slot>
    `;
  }
  /**
   * @param {DocumentFragment} dom
   * @return {ShadowRoot}
   * @protected
   * @override
   */
  _attachDom(dom) {
    const root2 = this.attachShadow({ mode: "open" });
    root2.appendChild(dom);
    root2.appendChild(this._overlayElement);
    return root2;
  }
}
defineCustomElement(MenuBarSubmenu);
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MenuBarMixin = (superClass) => class MenuBarMixinClass extends KeyboardDirectionMixin(
  ResizeMixin(FocusMixin(DisabledMixin(ControllerMixin(superClass))))
) {
  static get properties() {
    return {
      /**
       * @typedef MenuBarItem
       * @type {object}
       * @property {string} text - Text to be set as the menu button component's textContent.
       * @property {string} tooltip - Text to be set as the menu button's tooltip.
       * Requires a `<vaadin-tooltip slot="tooltip">` element to be added inside the `<vaadin-menu-bar>`.
       * @property {union: string | object} component - The component to represent the button content.
       * Either a tagName or an element instance. Defaults to "vaadin-menu-bar-item".
       * @property {boolean} disabled - If true, the button is disabled and cannot be activated.
       * @property {union: string | string[]} theme - Theme(s) to be set as the theme attribute of the button, overriding any theme set on the menu bar.
       * @property {SubMenuItem[]} children - Array of submenu items.
       */
      /**
       * @typedef SubMenuItem
       * @type {object}
       * @property {string} text - Text to be set as the menu item component's textContent.
       * @property {union: string | object} component - The component to represent the item.
       * Either a tagName or an element instance. Defaults to "vaadin-menu-bar-item".
       * @property {boolean} disabled - If true, the item is disabled and cannot be selected.
       * @property {boolean} checked - If true, the item shows a checkmark next to it.
       * @property {SubMenuItem[]} children - Array of child submenu items.
       */
      /**
       * Defines a hierarchical structure, where root level items represent menu bar buttons,
       * and `children` property configures a submenu with items to be opened below
       * the button on click, Enter, Space, Up and Down arrow keys.
       *
       * #### Example
       *
       * ```js
       * menubar.items = [
       *   {
       *     text: 'File',
       *     className: 'file',
       *     children: [
       *       {text: 'Open', className: 'file open'}
       *       {text: 'Auto Save', checked: true},
       *     ]
       *   },
       *   {component: 'hr'},
       *   {
       *     text: 'Edit',
       *     children: [
       *       {text: 'Undo', disabled: true},
       *       {text: 'Redo'}
       *     ]
       *   },
       *   {text: 'Help'}
       * ];
       * ```
       *
       * @type {!Array<!MenuBarItem>}
       */
      items: {
        type: Array,
        value: () => []
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * `i18n` object with a custom one.
       *
       * To update individual properties, extend the existing i18n object like so:
       * ```
       * menuBar.i18n = {
       *   ...menuBar.i18n,
       *   moreOptions: 'More options'
       * }
       * ```
       *
       * The object has the following JSON structure and default values:
       * ```
       * {
       *   moreOptions: 'More options'
       * }
       * ```
       *
       * @type {!MenuBarI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value: () => {
          return {
            moreOptions: "More options"
          };
        }
      },
      /**
       * A space-delimited list of CSS class names
       * to set on each sub-menu overlay element.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * If true, the submenu will open on hover (mouseover) instead of click.
       * @attr {boolean} open-on-hover
       */
      openOnHover: {
        type: Boolean
      },
      /**
       * If true, the buttons will be collapsed into the overflow menu
       * starting from the "start" end of the bar instead of the "end".
       * @attr {boolean} reverse-collapse
       */
      reverseCollapse: {
        type: Boolean
      },
      /**
       * If true, the top-level menu items is traversable by tab
       * instead of arrow keys (i.e. disabling roving tabindex)
       * @attr {boolean} tab-navigation
       */
      tabNavigation: {
        type: Boolean
      },
      /**
       * @type {boolean}
       * @protected
       */
      _hasOverflow: {
        type: Boolean,
        value: false,
        sync: true
      },
      /** @protected */
      _overflow: {
        type: Object
      },
      /** @protected */
      _container: {
        type: Object
      }
    };
  }
  static get observers() {
    return [
      "_themeChanged(_theme, _overflow, _container)",
      "__hasOverflowChanged(_hasOverflow, _overflow)",
      "__i18nChanged(i18n, _overflow)",
      "_menuItemsChanged(items, _overflow, _container)",
      "_reverseCollapseChanged(reverseCollapse, _overflow, _container)",
      "_tabNavigationChanged(tabNavigation, _overflow, _container)"
    ];
  }
  constructor() {
    super();
    this.__boundOnContextMenuKeydown = this.__onContextMenuKeydown.bind(this);
    this.__boundOnTooltipMouseLeave = this.__onTooltipOverlayMouseLeave.bind(this);
  }
  /**
   * Override getter from `KeyboardDirectionMixin`
   * to use expanded button for arrow navigation
   * when the sub-menu is opened and has focus.
   *
   * @return {Element | null}
   * @protected
   * @override
   */
  get focused() {
    return (this._getItems() || []).find(isElementFocused) || this._expandedButton;
  }
  /**
   * Override getter from `KeyboardDirectionMixin`.
   *
   * @return {boolean}
   * @protected
   * @override
   */
  get _vertical() {
    return false;
  }
  /**
   * Override getter from `ResizeMixin` to observe parent.
   *
   * @protected
   * @override
   */
  get _observeParent() {
    return true;
  }
  /**
   * @return {!Array<!HTMLElement>}
   * @protected
   */
  get _buttons() {
    return Array.from(this.querySelectorAll("vaadin-menu-bar-button"));
  }
  /** @private */
  get _subMenu() {
    return this.shadowRoot.querySelector("vaadin-menu-bar-submenu");
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menubar");
    this._overflowController = new SlotController(this, "overflow", "vaadin-menu-bar-button", {
      initializer: (btn) => {
        btn.setAttribute("hidden", "");
        const dots = document.createElement("div");
        dots.setAttribute("aria-hidden", "true");
        dots.innerHTML = "&centerdot;".repeat(3);
        btn.appendChild(dots);
        this._overflow = btn;
        this._initButtonAttrs(btn);
      }
    });
    this.addController(this._overflowController);
    this.addEventListener("mousedown", () => this._hideTooltip(true));
    this.addEventListener("mouseleave", () => this._hideTooltip());
    this._subMenu.addEventListener("item-selected", this.__onItemSelected.bind(this));
    this._subMenu.addEventListener("close-all-menus", this.__onEscapeClose.bind(this));
    const overlay2 = this._subMenu._overlayElement;
    overlay2.addEventListener("keydown", this.__boundOnContextMenuKeydown);
    const container = this.shadowRoot.querySelector('[part="container"]');
    container.addEventListener("click", this.__onButtonClick.bind(this));
    container.addEventListener("mouseover", (e2) => this._onMouseOver(e2));
    queueMicrotask(() => {
      this._container = container;
    });
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin`
   * to use the list of menu-bar buttons as items.
   *
   * @return {Element[]}
   * @protected
   * @override
   */
  _getItems() {
    return this._buttons;
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this._hideTooltip(true);
  }
  /**
   * Implement callback from `ResizeMixin` to update buttons
   * and detect whether to show or hide the overflow button.
   *
   * @protected
   * @override
   */
  _onResize() {
    this.__detectOverflow();
  }
  /**
   * Override method inherited from `DisabledMixin`
   * to update the `disabled` property for the buttons
   * whenever the property changes on the menu bar.
   *
   * @param {boolean} newValue the new disabled value
   * @param {boolean} oldValue the previous disabled value
   * @override
   * @protected
   */
  _disabledChanged(newValue, oldValue) {
    super._disabledChanged(newValue, oldValue);
    if (oldValue !== newValue) {
      this.__updateButtonsDisabled(newValue);
    }
  }
  /**
   * A callback for the `_theme` property observer.
   * It propagates the host theme to the buttons and the sub menu.
   *
   * @param {string | null} theme
   * @private
   */
  _themeChanged(theme, overflow, container) {
    if (overflow && container) {
      this._buttons.forEach((btn) => this._setButtonTheme(btn, theme));
      this.__detectOverflow();
    }
    if (theme) {
      this._subMenu.setAttribute("theme", theme);
    } else {
      this._subMenu.removeAttribute("theme");
    }
  }
  /**
   * A callback for the 'reverseCollapse' property observer.
   *
   * @param {boolean | null} _reverseCollapse
   * @private
   */
  _reverseCollapseChanged(_reverseCollapse, overflow, container) {
    if (overflow && container) {
      this.__detectOverflow();
    }
  }
  /** @private */
  _tabNavigationChanged(tabNavigation, overflow, container) {
    if (overflow && container) {
      const target = this.querySelector('[tabindex="0"]');
      this._buttons.forEach((btn) => {
        if (target) {
          this._setTabindex(btn, btn === target);
        } else {
          this._setTabindex(btn, false);
        }
        btn.setAttribute("role", tabNavigation ? "button" : "menuitem");
      });
    }
    this.setAttribute("role", tabNavigation ? "group" : "menubar");
  }
  /** @private */
  __hasOverflowChanged(hasOverflow, overflow) {
    if (overflow) {
      overflow.toggleAttribute("hidden", !hasOverflow);
    }
  }
  /** @private */
  _menuItemsChanged(items, overflow, container) {
    if (!overflow || !container) {
      return;
    }
    if (items !== this._oldItems) {
      this._oldItems = items;
      this.__renderButtons(items);
    }
    const subMenu = this._subMenu;
    if (subMenu && subMenu.opened) {
      subMenu.close();
    }
  }
  /** @private */
  __i18nChanged(i18n, overflow) {
    if (overflow && i18n && i18n.moreOptions !== void 0) {
      if (i18n.moreOptions) {
        overflow.setAttribute("aria-label", i18n.moreOptions);
      } else {
        overflow.removeAttribute("aria-label");
      }
    }
  }
  /** @private */
  __getOverflowCount(overflow) {
    return overflow.item && overflow.item.children && overflow.item.children.length || 0;
  }
  /** @private */
  __restoreButtons(buttons) {
    buttons.forEach((button2) => {
      button2.disabled = button2.item && button2.item.disabled || this.disabled;
      button2.style.visibility = "";
      button2.style.position = "";
      const item2 = button2.item && button2.item.component;
      if (item2 instanceof HTMLElement && item2.getAttribute("role") === "menuitem") {
        this.__restoreItem(button2, item2);
      }
    });
    this.__updateOverflow([]);
  }
  /** @private */
  __restoreItem(button2, item2) {
    button2.appendChild(item2);
    item2.removeAttribute("role");
    item2.removeAttribute("aria-expanded");
    item2.removeAttribute("aria-haspopup");
    item2.removeAttribute("tabindex");
  }
  /** @private */
  __updateButtonsDisabled(disabled) {
    this._buttons.forEach((btn) => {
      btn.disabled = disabled || btn.item && btn.item.disabled;
    });
  }
  /** @private */
  __updateOverflow(items) {
    this._overflow.item = { children: items };
    this._hasOverflow = items.length > 0;
  }
  /** @private */
  __setOverflowItems(buttons, overflow) {
    const container = this._container;
    if (container.offsetWidth < container.scrollWidth) {
      this._hasOverflow = true;
      const isRTL = this.__isRTL;
      const containerLeft = container.offsetLeft;
      const remaining = [...buttons];
      while (remaining.length) {
        const lastButton = remaining[remaining.length - 1];
        const btnLeft = lastButton.offsetLeft - containerLeft;
        if (!isRTL && btnLeft + lastButton.offsetWidth < container.offsetWidth - overflow.offsetWidth || isRTL && btnLeft >= overflow.offsetWidth) {
          break;
        }
        const btn = this.reverseCollapse ? remaining.shift() : remaining.pop();
        btn.style.width = getComputedStyle(btn).width;
        btn.disabled = true;
        btn.style.visibility = "hidden";
        btn.style.position = "absolute";
      }
      const items = buttons.filter((b2) => !remaining.includes(b2)).map((b2) => b2.item);
      this.__updateOverflow(items);
      if (remaining.length && !remaining.some((btn) => btn.getAttribute("tabindex") === "0")) {
        this._setTabindex(remaining[remaining.length - 1], true);
      }
    }
  }
  /** @private */
  __detectOverflow() {
    if (!this._container) {
      return;
    }
    const overflow = this._overflow;
    const buttons = this._buttons.filter((btn) => btn !== overflow);
    const oldOverflowCount = this.__getOverflowCount(overflow);
    this.__restoreButtons(buttons);
    this.__setOverflowItems(buttons, overflow);
    const newOverflowCount = this.__getOverflowCount(overflow);
    if (oldOverflowCount !== newOverflowCount && this._subMenu.opened) {
      this._subMenu.close();
    }
    const isSingleButton = newOverflowCount === buttons.length || newOverflowCount === 0 && buttons.length === 1;
    this.toggleAttribute("has-single-button", isSingleButton);
    buttons.filter((btn) => btn.style.visibility !== "hidden").forEach((btn, index, visibleButtons) => {
      btn.toggleAttribute("first-visible", index === 0);
      btn.toggleAttribute("last-visible", !this._hasOverflow && index === visibleButtons.length - 1);
    });
  }
  /** @protected */
  _removeButtons() {
    this._buttons.forEach((button2) => {
      if (button2 !== this._overflow) {
        this.removeChild(button2);
      }
    });
  }
  /** @protected */
  _initButton(item2) {
    const button2 = document.createElement("vaadin-menu-bar-button");
    const itemCopy = { ...item2 };
    button2.item = itemCopy;
    if (item2.component) {
      const component = this.__getComponent(itemCopy);
      itemCopy.component = component;
      component.item = itemCopy;
      button2.appendChild(component);
    } else if (item2.text) {
      button2.textContent = item2.text;
    }
    if (item2.className) {
      button2.className = item2.className;
    }
    return button2;
  }
  /** @protected */
  _initButtonAttrs(button2) {
    button2.setAttribute("role", this.tabNavigation ? "button" : "menuitem");
    if (button2 === this._overflow || button2.item && button2.item.children) {
      button2.setAttribute("aria-haspopup", "true");
      button2.setAttribute("aria-expanded", "false");
    }
  }
  /** @protected */
  _setButtonDisabled(button2, disabled) {
    button2.disabled = disabled;
    button2.setAttribute("tabindex", disabled ? "-1" : "0");
  }
  /** @protected */
  _setButtonTheme(btn, hostTheme) {
    let theme = hostTheme;
    const itemTheme = btn.item && btn.item.theme;
    if (itemTheme != null) {
      theme = Array.isArray(itemTheme) ? itemTheme.join(" ") : itemTheme;
    }
    if (theme) {
      btn.setAttribute("theme", theme);
    } else {
      btn.removeAttribute("theme");
    }
  }
  /** @private */
  __getComponent(item2) {
    const itemComponent = item2.component;
    let component;
    const isElement2 = itemComponent instanceof HTMLElement;
    if (isElement2 && itemComponent.localName === "vaadin-menu-bar-item") {
      component = itemComponent;
    } else {
      component = document.createElement("vaadin-menu-bar-item");
      component.appendChild(isElement2 ? itemComponent : document.createElement(itemComponent));
    }
    if (item2.text) {
      const node = component.firstChild || component;
      node.textContent = item2.text;
    }
    return component;
  }
  /** @private */
  __renderButtons(items = []) {
    this._removeButtons();
    if (items.length === 0) {
      return;
    }
    items.forEach((item2) => {
      const button2 = this._initButton(item2);
      this.insertBefore(button2, this._overflow);
      this._setButtonDisabled(button2, item2.disabled);
      this._initButtonAttrs(button2);
      this._setButtonTheme(button2, this._theme);
    });
    this.__detectOverflow();
  }
  /**
   * @param {HTMLElement} button
   * @protected
   */
  _showTooltip(button2, isHover) {
    const tooltip = this._tooltipController.node;
    if (tooltip && tooltip.isConnected) {
      if (tooltip.generator === void 0) {
        tooltip.generator = ({ item: item2 }) => item2 && item2.tooltip;
      }
      if (!tooltip._mouseLeaveListenerAdded) {
        tooltip._overlayElement.addEventListener("mouseleave", this.__boundOnTooltipMouseLeave);
        tooltip._mouseLeaveListenerAdded = true;
      }
      if (!this._subMenu.opened) {
        this._tooltipController.setTarget(button2);
        this._tooltipController.setContext({ item: button2.item });
        tooltip._stateController.open({
          hover: isHover,
          focus: !isHover
        });
      }
    }
  }
  /** @protected */
  _hideTooltip(immediate) {
    const tooltip = this._tooltipController && this._tooltipController.node;
    if (tooltip) {
      tooltip._stateController.close(immediate);
    }
  }
  /** @private */
  __onTooltipOverlayMouseLeave(event) {
    if (event.relatedTarget !== this._tooltipController.target) {
      this._hideTooltip();
    }
  }
  /** @protected */
  _setExpanded(button2, expanded) {
    button2.toggleAttribute("expanded", expanded);
    button2.toggleAttribute("active", expanded);
    button2.setAttribute("aria-expanded", expanded ? "true" : "false");
  }
  /** @protected */
  _setTabindex(button2, focused) {
    if (this.tabNavigation && !button2.disabled) {
      button2.setAttribute("tabindex", "0");
    } else {
      button2.setAttribute("tabindex", focused ? "0" : "-1");
    }
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin`
   * to close the submenu for the previously focused button
   * and open another one for the newly focused button.
   *
   * @param {Element} item
   * @param {boolean} navigating
   * @protected
   * @override
   */
  _focusItem(item2, navigating) {
    const wasExpanded = navigating && this.focused === this._expandedButton;
    if (wasExpanded) {
      this._close();
    }
    super._focusItem(item2, navigating);
    this._buttons.forEach((btn) => {
      this._setTabindex(btn, btn === item2);
    });
    if (wasExpanded && item2.item && item2.item.children) {
      this.__openSubMenu(item2, true, { keepFocus: true });
    } else if (item2 === this._overflow) {
      this._hideTooltip();
    } else {
      this._showTooltip(item2);
    }
  }
  /** @private */
  _getButtonFromEvent(e2) {
    return Array.from(e2.composedPath()).find((el) => el.localName === "vaadin-menu-bar-button");
  }
  /**
   * Override method inherited from `FocusMixin`
   *
   * @param {boolean} focused
   * @override
   * @protected
   */
  _setFocused(focused) {
    if (focused) {
      let target = this.querySelector('[tabindex="0"]');
      if (this.tabNavigation) {
        target = this.querySelector("[focused]");
        this.__switchSubMenu(target);
      }
      if (target) {
        this._buttons.forEach((btn) => {
          this._setTabindex(btn, btn === target);
          if (btn === target && btn !== this._overflow && isKeyboardActive()) {
            this._showTooltip(btn);
          }
        });
      }
    } else {
      this._hideTooltip();
    }
  }
  /**
   * @param {!KeyboardEvent} event
   * @private
   */
  _onArrowDown(event) {
    event.preventDefault();
    const button2 = this._getButtonFromEvent(event);
    if (button2 === this._expandedButton) {
      this._focusFirstItem();
    } else {
      this.__openSubMenu(button2, true);
    }
  }
  /**
   * @param {!KeyboardEvent} event
   * @private
   */
  _onArrowUp(event) {
    event.preventDefault();
    const button2 = this._getButtonFromEvent(event);
    if (button2 === this._expandedButton) {
      this._focusLastItem();
    } else {
      this.__openSubMenu(button2, true, { focusLast: true });
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`:
   * - to close the sub-menu for expanded button,
   * - to close a tooltip for collapsed button.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (event.composedPath().includes(this._expandedButton)) {
      this._close(true);
    }
    this._hideTooltip(true);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    switch (event.key) {
      case "ArrowDown":
        this._onArrowDown(event);
        break;
      case "ArrowUp":
        this._onArrowUp(event);
        break;
      default:
        super._onKeyDown(event);
        break;
    }
  }
  /**
   * @param {!MouseEvent} e
   * @protected
   */
  _onMouseOver(e2) {
    const button2 = this._getButtonFromEvent(e2);
    if (!button2) {
      this._hideTooltip();
    } else if (button2 !== this._expandedButton) {
      const isOpened = this._subMenu.opened;
      if (button2.item.children && (this.openOnHover || isOpened)) {
        this.__openSubMenu(button2, false);
      } else if (isOpened) {
        this._close();
      }
      if (button2 === this._overflow || this.openOnHover && button2.item.children) {
        this._hideTooltip();
      } else {
        this._showTooltip(button2, true);
      }
    }
  }
  /** @private */
  __onContextMenuKeydown(e2) {
    const item2 = Array.from(e2.composedPath()).find((el) => el._item);
    if (item2) {
      const list = item2.parentNode;
      if (e2.keyCode === 38 && item2 === list.items[0]) {
        this._close(true);
      }
      if (e2.keyCode === 37 || e2.keyCode === 39 && !item2._item.children) {
        e2.stopImmediatePropagation();
        this._onKeyDown(e2);
      } else if (e2.keyCode === 9 && this.tabNavigation) {
        const items = this._getItems() || [];
        const currentIdx = items.indexOf(this.focused);
        const increment = e2.shiftKey ? -1 : 1;
        let idx = currentIdx + increment;
        idx = this._getAvailableIndex(items, idx, increment, (item3) => !isElementHidden(item3));
        this.__switchSubMenu(items[idx]);
      }
    }
  }
  /** @private */
  __switchSubMenu(target) {
    const wasExpanded = this._expandedButton != null && this._expandedButton !== target;
    if (wasExpanded) {
      this._close();
      if (target.item && target.item.children) {
        this.__openSubMenu(target, true, { keepFocus: true });
      }
    }
  }
  /** @private */
  __fireItemSelected(value) {
    this.dispatchEvent(new CustomEvent("item-selected", { detail: { value } }));
  }
  /** @private */
  __onButtonClick(e2) {
    const button2 = this._getButtonFromEvent(e2);
    if (button2) {
      this.__openSubMenu(button2, button2.__triggeredWithActiveKeys);
    }
  }
  /** @private */
  __openSubMenu(button2, keydown, options = {}) {
    const subMenu = this._subMenu;
    const item2 = button2.item;
    if (subMenu.opened) {
      this._close();
      if (subMenu.listenOn === button2) {
        return;
      }
    }
    const items = item2 && item2.children;
    if (!items || items.length === 0) {
      this.__fireItemSelected(item2);
      return;
    }
    subMenu.items = items;
    subMenu.listenOn = button2;
    const overlay2 = subMenu._overlayElement;
    overlay2.noVerticalOverlap = true;
    this._expandedButton = button2;
    requestAnimationFrame(async () => {
      if (overlay2.positionTarget && !overlay2.positionTarget.isConnected) {
        overlay2.positionTarget = null;
      }
      button2.dispatchEvent(
        new CustomEvent("opensubmenu", {
          detail: {
            children: items
          }
        })
      );
      this._hideTooltip(true);
      this._setExpanded(button2, true);
      if (overlay2.updateComplete) {
        await overlay2.updateComplete;
      }
      overlay2.positionTarget = button2;
    });
    this.style.pointerEvents = "auto";
    overlay2.addEventListener(
      "vaadin-overlay-open",
      () => {
        if (options.focusLast) {
          this._focusLastItem();
        }
        if (options.keepFocus) {
          this._focusItem(this._expandedButton, false);
        }
        if (!keydown) {
          overlay2.$.overlay.focus();
        }
      },
      { once: true }
    );
  }
  /** @private */
  _focusFirstItem() {
    const list = this._subMenu._overlayElement.firstElementChild;
    list.focus();
  }
  /** @private */
  _focusLastItem() {
    const list = this._subMenu._overlayElement.firstElementChild;
    const item2 = list.items[list.items.length - 1];
    if (item2) {
      item2.focus();
    }
  }
  /** @private */
  __onItemSelected(e2) {
    e2.stopPropagation();
    this.__fireItemSelected(e2.detail.value);
  }
  /** @private */
  __onEscapeClose() {
    this.__deactivateButton(true);
  }
  /** @private */
  __deactivateButton(restoreFocus) {
    const button2 = this._expandedButton;
    if (button2 && button2.hasAttribute("expanded")) {
      this._setExpanded(button2, false);
      if (restoreFocus) {
        this._focusItem(button2, false);
      }
      this._expandedButton = null;
    }
  }
  /**
   * @param {boolean} restoreFocus
   * @protected
   */
  _close(restoreFocus = false) {
    this.style.pointerEvents = "";
    this.__deactivateButton(restoreFocus);
    if (this._subMenu.opened) {
      this._subMenu.close();
    }
  }
  /**
   * Closes the current submenu.
   */
  close() {
    this._close();
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MenuBar extends MenuBarMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='container'] {
          position: relative;
          display: flex;
          width: 100%;
          flex-wrap: nowrap;
          overflow: hidden;
        }
      </style>

      <div part="container">
        <slot></slot>
        <slot name="overflow"></slot>
      </div>
      <vaadin-menu-bar-submenu is-root overlay-class="[[overlayClass]]"></vaadin-menu-bar-submenu>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-menu-bar";
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setManual(true);
    this.addController(this._tooltipController);
  }
  /**
   * Fired when either a submenu item or menu bar button without nested children is clicked.
   *
   * @event item-selected
   * @param {Object} detail
   * @param {Object} detail.value the selected menu bar item
   */
}
defineCustomElement(MenuBar);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const textArea = css`
  [part='input-field'],
  [part='input-field'] ::slotted(textarea) {
    height: auto;
    box-sizing: border-box;
  }

  [part='input-field'] {
    /* Equal to the implicit padding in vaadin-text-field */
    padding-top: calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);
    padding-bottom: calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);
    transition: background-color 0.1s;
    line-height: var(--lumo-line-height-s);
  }

  :host(:not([readonly])) [part='input-field']::after {
    display: none;
  }

  :host([readonly]) [part='input-field'] {
    border: var(--vaadin-input-field-readonly-border, 1px dashed var(--lumo-contrast-30pct));
  }

  :host([readonly]) [part='input-field']::after {
    border: none;
  }

  :host(:hover:not([readonly]):not([focused]):not([invalid])) [part='input-field'] {
    background-color: var(--lumo-contrast-20pct);
  }

  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused]):not([invalid])) [part='input-field'] {
      background-color: var(--lumo-contrast-10pct);
    }

    :host(:active:not([readonly]):not([focused])) [part='input-field'] {
      background-color: var(--lumo-contrast-20pct);
    }
  }

  [part='input-field'] ::slotted(textarea) {
    line-height: inherit;
    --_lumo-text-field-overflow-mask-image: none;
  }

  /* Use sticky positioning to keep prefix/suffix/clear button visible when scrolling textarea container */
  [part='input-field'] ::slotted([slot$='fix']),
  [part='clear-button'] {
    position: sticky;
    top: 0;
    align-self: flex-start;
  }

  /* Vertically align icon prefix/suffix/clear button with the first line of text */
  [part='input-field'] ::slotted(vaadin-icon[slot$='fix']),
  [part='clear-button'] {
    top: calc((var(--lumo-icon-size-m) - 1em * var(--lumo-line-height-s)) / -2);
    margin-top: calc((var(--lumo-icon-size-m) - 1em * var(--lumo-line-height-s)) / -2);
  }
`;
registerStyles$1("vaadin-text-area", [inputFieldShared$1, textArea], {
  moduleId: "lumo-text-area"
});
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TextAreaController extends SlotController {
  constructor(host, callback) {
    super(host, "textarea", "textarea", {
      initializer: (node, host2) => {
        const value = host2.getAttribute("value");
        if (value) {
          node.value = value;
        }
        const name = host2.getAttribute("name");
        if (name) {
          node.setAttribute("name", name);
        }
        node.id = this.defaultId;
        if (typeof callback === "function") {
          callback(node);
        }
      },
      useUniqueId: true
    });
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const TextAreaMixin = (superClass) => class TextAreaMixinClass extends ResizeMixin(InputFieldMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Maximum number of characters (in Unicode code points) that the user can enter.
       */
      maxlength: {
        type: Number
      },
      /**
       * Minimum number of characters (in Unicode code points) that the user can enter.
       */
      minlength: {
        type: Number
      },
      /**
       * A regular expression that the value is checked against.
       * The pattern must match the entire value, not just some subset.
       */
      pattern: {
        type: String
      },
      /**
       * Minimum number of rows to show. Default is two rows, which is also the minimum value.
       *
       * When using a custom slotted textarea, the minimum number of rows are not applied for backwards compatibility.
       *
       * @attr {number} min-rows
       */
      minRows: {
        type: Number,
        value: 2,
        observer: "__minRowsChanged"
      },
      /**
       * Maximum number of rows to expand to before the text area starts scrolling. This effectively sets a max-height
       * on the `input-field` part. By default, it is not set, and the text area grows with the content without
       * constraints.
       * @attr {number} max-rows
       */
      maxRows: {
        type: Number
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "maxlength", "minlength", "pattern"];
  }
  static get constraints() {
    return [...super.constraints, "maxlength", "minlength", "pattern"];
  }
  static get observers() {
    return ["__updateMinHeight(minRows, inputElement)", "__updateMaxHeight(maxRows, inputElement, _inputField)"];
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this._updateHeight();
    this.__scrollPositionUpdated();
  }
  /** @protected */
  _onScroll() {
    this.__scrollPositionUpdated();
  }
  /** @protected */
  ready() {
    super.ready();
    this.__textAreaController = new TextAreaController(this, (input) => {
      this._setInputElement(input);
      this._setFocusElement(input);
      this.stateTarget = input;
      this.ariaTarget = input;
    });
    this.addController(this.__textAreaController);
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this.addEventListener("animationend", this._onAnimationEnd);
    this._inputField = this.shadowRoot.querySelector("[part=input-field]");
    this._inputField.addEventListener("wheel", (e2) => {
      const scrollTopBefore = this._inputField.scrollTop;
      this._inputField.scrollTop += e2.deltaY;
      if (scrollTopBefore !== this._inputField.scrollTop) {
        e2.preventDefault();
        this.__scrollPositionUpdated();
      }
    });
    this._updateHeight();
    this.__scrollPositionUpdated();
  }
  /** @private */
  __scrollPositionUpdated() {
    this._inputField.style.setProperty("--_text-area-vertical-scroll-position", "0px");
    this._inputField.style.setProperty("--_text-area-vertical-scroll-position", `${this._inputField.scrollTop}px`);
  }
  /** @private */
  _onAnimationEnd(e2) {
    if (e2.animationName.indexOf("vaadin-text-area-appear") === 0) {
      this._updateHeight();
    }
  }
  /**
   * @param {unknown} newVal
   * @param {unknown} oldVal
   * @protected
   * @override
   */
  _valueChanged(newVal, oldVal) {
    super._valueChanged(newVal, oldVal);
    this._updateHeight();
  }
  /** @private */
  _updateHeight() {
    const input = this.inputElement;
    const inputField2 = this._inputField;
    if (!input || !inputField2) {
      return;
    }
    const scrollTop = inputField2.scrollTop;
    const valueLength = this.value ? this.value.length : 0;
    if (this._oldValueLength >= valueLength) {
      const inputFieldHeight = getComputedStyle(inputField2).height;
      const inputWidth = getComputedStyle(input).width;
      inputField2.style.height = inputFieldHeight;
      input.style.maxWidth = inputWidth;
      input.style.alignSelf = "flex-start";
      input.style.height = "auto";
    }
    this._oldValueLength = valueLength;
    const inputHeight = input.scrollHeight;
    if (inputHeight > input.clientHeight) {
      input.style.height = `${inputHeight}px`;
    }
    input.style.removeProperty("max-width");
    input.style.removeProperty("align-self");
    inputField2.style.removeProperty("height");
    inputField2.scrollTop = scrollTop;
    this.__updateMaxHeight(this.maxRows);
  }
  /** @private */
  __updateMinHeight(minRows) {
    if (!this.inputElement) {
      return;
    }
    if (this.inputElement === this.__textAreaController.defaultNode) {
      this.inputElement.rows = Math.max(minRows, 2);
    }
  }
  /** @private */
  __updateMaxHeight(maxRows) {
    if (!this._inputField || !this.inputElement) {
      return;
    }
    if (maxRows) {
      const inputStyle = getComputedStyle(this.inputElement);
      const inputFieldStyle = getComputedStyle(this._inputField);
      const lineHeight = parseFloat(inputStyle.lineHeight);
      const contentHeight = lineHeight * maxRows;
      const marginsAndPaddings = parseFloat(inputStyle.paddingTop) + parseFloat(inputStyle.paddingBottom) + parseFloat(inputStyle.marginTop) + parseFloat(inputStyle.marginBottom) + parseFloat(inputFieldStyle.paddingTop) + parseFloat(inputFieldStyle.paddingBottom);
      const maxHeight = Math.ceil(contentHeight + marginsAndPaddings);
      this._inputField.style.setProperty("max-height", `${maxHeight}px`);
    } else {
      this._inputField.style.removeProperty("max-height");
    }
  }
  /**
   * @private
   */
  __minRowsChanged(minRows) {
    if (minRows < 2) {
      console.warn("<vaadin-text-area> minRows must be at least 2.");
    }
  }
  /**
   * Scrolls the textarea to the start if it has a vertical scrollbar.
   */
  scrollToStart() {
    this._inputField.scrollTop = 0;
  }
  /**
   * Scrolls the textarea to the end if it has a vertical scrollbar.
   */
  scrollToEnd() {
    this._inputField.scrollTop = this._inputField.scrollHeight;
  }
  /**
   * Returns true if the current textarea value satisfies all constraints (if any).
   * @return {boolean}
   * @override
   */
  checkValidity() {
    if (!super.checkValidity()) {
      return false;
    }
    if (!this.pattern || !this.inputElement.value) {
      return true;
    }
    try {
      const match2 = this.inputElement.value.match(this.pattern);
      return match2 ? match2[0] === match2.input : false;
    } catch (_) {
      return true;
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const textAreaStyles = css`
  :host {
    animation: 1ms vaadin-text-area-appear;
  }

  .vaadin-text-area-container {
    flex: auto;
  }

  /* The label, helper text and the error message should neither grow nor shrink. */
  [part='label'],
  [part='helper-text'],
  [part='error-message'] {
    flex: none;
  }

  [part='input-field'] {
    flex: auto;
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  ::slotted(textarea) {
    -webkit-appearance: none;
    -moz-appearance: none;
    flex: auto;
    overflow: hidden;
    width: 100%;
    height: 100%;
    outline: none;
    resize: none;
    margin: 0;
    padding: 0 0.25em;
    border: 0;
    border-radius: 0;
    min-width: 0;
    font: inherit;
    font-size: 1em;
    line-height: normal;
    color: inherit;
    background-color: transparent;
    /* Disable default invalid style in Firefox */
    box-shadow: none;
  }

  /* Override styles from <vaadin-input-container> */
  [part='input-field'] ::slotted(textarea) {
    align-self: stretch;
    white-space: pre-wrap;
    box-sizing: border-box;
  }

  [part='input-field'] ::slotted(:not(textarea)) {
    align-self: flex-start;
  }

  /* Workaround https://bugzilla.mozilla.org/show_bug.cgi?id=1739079 */
  :host([disabled]) ::slotted(textarea) {
    user-select: none;
  }

  @keyframes vaadin-text-area-appear {
    to {
      opacity: 1;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-text-area", [inputFieldShared, textAreaStyles], { moduleId: "vaadin-text-area-styles" });
class TextArea extends TextAreaMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-text-area";
  }
  static get template() {
    return html`
      <div class="vaadin-text-area-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
          on-scroll="_onScroll"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="textarea"></slot>
          <slot name="suffix" slot="suffix"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this.addController(this._tooltipController);
  }
}
defineCustomElement(TextArea);
registerStyles$1(
  "vaadin-message-input",
  css`
    :host {
      padding: var(--lumo-space-s) var(--lumo-space-m);
    }

    ::slotted([slot='textarea']) {
      margin-inline-end: var(--lumo-space-s);
    }
  `,
  { moduleId: "lumo-message-input" }
);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MessageInputMixin = (superClass) => class MessageInputMixinClass extends ControllerMixin(superClass) {
  static get properties() {
    return {
      /**
       * Current content of the text input field
       */
      value: {
        type: String,
        value: "",
        sync: true
      },
      /**
       * The object used to localize this component.
       * For changing the default localization, change the entire
       * `i18n` object.
       *
       * The object has the following JSON structure and default values:
       *
       * ```
       * {
       *   // Used as the button label
       *   send: 'Send',
       *
       *   // Used as the input field's placeholder and aria-label
       *   message: 'Message'
       * }
       * ```
       *
       * @type {!MessageInputI18n}
       * @default {English}
       */
      i18n: {
        type: Object,
        sync: true,
        value: () => ({
          send: "Send",
          message: "Message"
        })
      },
      /**
       * Set to true to disable this element.
       * @type {boolean}
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /** @private */
      _button: {
        type: Object,
        sync: true
      },
      /** @private */
      _textArea: {
        type: Object,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "__buttonPropsChanged(_button, disabled, i18n)",
      "__textAreaPropsChanged(_textArea, disabled, i18n, value)"
    ];
  }
  /** @protected */
  ready() {
    super.ready();
    this._buttonController = new SlotController(this, "button", "vaadin-button", {
      initializer: (btn) => {
        btn.setAttribute("theme", "primary contained");
        btn.addEventListener("click", () => {
          this.__submit();
        });
        this._button = btn;
      }
    });
    this.addController(this._buttonController);
    this._textAreaController = new SlotController(this, "textarea", "vaadin-text-area", {
      initializer: (textarea) => {
        textarea.addEventListener("value-changed", (event) => {
          this.value = event.detail.value;
        });
        textarea.addEventListener("keydown", (event) => {
          if (event.key === "Enter" && !event.shiftKey) {
            event.preventDefault();
            event.stopImmediatePropagation();
            this.__submit();
          }
        });
        if (textarea.performUpdate) {
          textarea.performUpdate();
          textarea.performUpdate();
        }
        const input = textarea.inputElement;
        input.setAttribute("rows", 1);
        input.style.minHeight = "0";
        this._textArea = textarea;
      }
    });
    this.addController(this._textAreaController);
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
  }
  focus() {
    if (this._textArea) {
      this._textArea.focus();
    }
  }
  /** @private */
  __buttonPropsChanged(button2, disabled, i18n) {
    if (button2) {
      button2.disabled = disabled;
      button2.textContent = i18n.send;
    }
  }
  /** @private */
  __textAreaPropsChanged(textArea2, disabled, i18n, value) {
    if (textArea2) {
      textArea2.disabled = disabled;
      textArea2.value = value;
      const message = i18n.message;
      textArea2.placeholder = message;
      textArea2.accessibleName = message;
    }
  }
  /**
   * Submits the current value as an custom event named 'submit'.
   * It also clears the text input and refocuses it for sending another message.
   * In UI, can be triggered by pressing the submit button or pressing enter key when field is focused.
   * It does not submit anything if text is empty.
   */
  __submit() {
    if (this.value !== "") {
      this.dispatchEvent(new CustomEvent("submit", { detail: { value: this.value } }));
      this.value = "";
    }
    this._textArea.focus();
  }
  /**
   * Fired when a new message is submitted with `<vaadin-message-input>`, either
   * by clicking the "send" button, or pressing the Enter key.
   * @event submit
   */
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MessageInput extends MessageInputMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          align-items: flex-start;
          box-sizing: border-box;
          display: flex;
          max-height: 50vh;
          overflow: hidden;
          flex-shrink: 0;
        }

        :host([hidden]) {
          display: none !important;
        }

        ::slotted([slot='button']) {
          flex-shrink: 0;
        }

        ::slotted([slot='textarea']) {
          align-self: stretch;
          flex-grow: 1;
        }
      </style>
      <slot name="textarea"></slot>

      <slot name="button"></slot>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-message-input";
  }
}
defineCustomElement(MessageInput);
window.Vaadin.Flow.messageListConnector = {
  setItems(list, items, locale2) {
    const formatter = new Intl.DateTimeFormat(locale2, {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "numeric",
      minute: "numeric"
    });
    list.items = items.map(
      (item2) => item2.time ? Object.assign(item2, {
        time: formatter.format(new Date(item2.time))
      }) : item2
    );
  }
};
registerStyles$1(
  "vaadin-message",
  css`
    :host {
      color: var(--lumo-body-text-color);
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      line-height: var(--lumo-line-height-m);
      padding: var(--lumo-space-s) var(--lumo-space-m);
      -moz-osx-font-smoothing: grayscale;
      -webkit-font-smoothing: antialiased;
      -webkit-text-size-adjust: 100%;
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
    }

    :host([focus-ring]) {
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }

    [part='header'] {
      min-height: calc(var(--lumo-font-size-m) * var(--lumo-line-height-m));
    }

    [part='name'] {
      margin-right: var(--lumo-space-s);
    }

    [part='name']:empty {
      margin-right: 0;
    }

    :host([dir='rtl']) [part='name'] {
      margin-left: var(--lumo-space-s);
      margin-right: 0;
    }

    :host([dir='rtl']) [part='name']:empty {
      margin-left: 0;
    }

    [part='time'] {
      color: var(--lumo-secondary-text-color);
      font-size: var(--lumo-font-size-s);
    }

    ::slotted([slot='avatar']) {
      --vaadin-avatar-size: var(--lumo-size-m);
      margin-top: calc(var(--lumo-space-s));
      margin-inline-end: calc(var(--lumo-space-m));
    }
  `,
  { moduleId: "lumo-message" }
);
registerStyles$1("vaadin-message-list", css``, { moduleId: "lumo-message-list" });
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MessageMixin = (superClass) => class MessageMixinClass extends FocusMixin(ControllerMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Time of sending the message. It is rendered as-is to the part='time' slot,
       * so the formatting is up to you.
       */
      time: {
        type: String
      },
      /**
       * The name of the user posting the message.
       * It will be placed in the name part to indicate who has sent the message.
       * It is also used as a tooltip for the avatar.
       * Example: `message.userName = "Jessica Jacobs";`
       * @attr {string} user-name
       */
      userName: {
        type: String
      },
      /**
       * The abbreviation of the user.
       * The abbreviation will be passed on to avatar of the message.
       * If the user does not have an avatar picture set with `userImg`, `userAbbr` will be shown in the avatar.
       * Example: `message.userAbbr = "JJ";`
       * @attr {string} user-abbr
       */
      userAbbr: {
        type: String
      },
      /**
       * An URL for a user image.
       * The image will be used in the avatar component to show who has sent the message.
       * Example: `message.userImg = "/static/img/avatar.jpg";`
       * @attr {string} user-img
       */
      userImg: {
        type: String
      },
      /**
       * A color index to be used to render the color of the avatar.
       * With no `userColorIndex` set, the basic avatar color will be used.
       * By setting a userColorIndex, the component will check if there exists a CSS variable defining the color, and uses it if there is one.
       * If now CSS variable is found for the color index, the property for the color will not be set.
       *
       * Example:
       * CSS:
       * ```css
       * html {
       *   --vaadin-user-color-1: red;
       * }
       * ```
       *
       * JavaScript:
       * ```js
       * message.userColorIndex = 1;
       * ```
       * @attr {number} user-color-index
       */
      userColorIndex: {
        type: Number
      },
      /** @private */
      _avatar: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["__avatarChanged(_avatar, userName, userAbbr, userImg, userColorIndex)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this._avatarController = new SlotController(this, "avatar", "vaadin-avatar", {
      initializer: (avatar) => {
        avatar.setAttribute("tabindex", "-1");
        avatar.setAttribute("aria-hidden", "true");
        this._avatar = avatar;
      }
    });
    this.addController(this._avatarController);
  }
  /** @private */
  __avatarChanged(avatar, userName, userAbbr, userImg, userColorIndex) {
    if (avatar) {
      avatar.setProperties({
        name: userName,
        abbr: userAbbr,
        img: userImg,
        colorIndex: userColorIndex
      });
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const messageStyles = css`
  :host {
    display: flex;
    flex-direction: row;
    outline: none;
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='content'] {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
  }

  [part='header'] {
    align-items: baseline;
    display: flex;
    flex-flow: row wrap;
  }

  [part='name'] {
    font-weight: 500;
  }

  [part='message'] {
    white-space: pre-wrap;
  }

  ::slotted([slot='avatar']) {
    --vaadin-avatar-outline-width: 0;
    flex-shrink: 0;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-message", messageStyles, { moduleId: "vaadin-message-styles" });
class Message extends MessageMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <slot name="avatar"></slot>
      <div part="content">
        <div part="header">
          <span part="name">[[userName]]</span>
          <span part="time">[[time]]</span>
        </div>
        <div part="message"><slot></slot></div>
      </div>
    `;
  }
  static get is() {
    return "vaadin-message";
  }
}
defineCustomElement(Message);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MessageListMixin = (superClass) => class MessageListMixinClass extends KeyboardDirectionMixin(superClass) {
  static get properties() {
    return {
      /**
       * An array of objects which will be rendered as messages.
       * The message objects can have the following properties:
       * ```js
       * Array<{
       *   text: string,
       *   time: string,
       *   userName: string,
       *   userAbbr: string,
       *   userImg: string,
       *   userColorIndex: number,
       *   className: string,
       *   theme: string
       * }>
       * ```
       */
      items: {
        type: Array,
        value: () => [],
        observer: "_itemsChanged",
        sync: true
      }
    };
  }
  /** @protected */
  get _messages() {
    return [...this.querySelectorAll("vaadin-message")];
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("aria-relevant", "additions");
    this.setAttribute("role", "log");
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin`
   * to use the list of message elements as items.
   *
   * @return {Element[]}
   * @protected
   * @override
   */
  _getItems() {
    return this._messages;
  }
  /** @private */
  _itemsChanged(newVal, oldVal) {
    const items = newVal || [];
    const oldItems = oldVal || [];
    if (items.length || oldItems.length) {
      const focusedIndex = this._getIndexOfFocusableElement();
      const closeToBottom = this.scrollHeight < this.clientHeight + this.scrollTop + 50;
      this._renderMessages(items);
      this._setTabIndexesByIndex(focusedIndex);
      requestAnimationFrame(() => {
        if (items.length > oldItems.length && closeToBottom) {
          this._scrollToLastMessage();
        }
      });
    }
  }
  /** @private */
  _renderMessages(items) {
    render(
      html$1`
          ${items.map(
        (item2) => html$1`
              <vaadin-message
                role="listitem"
                .time="${item2.time}"
                .userAbbr="${item2.userAbbr}"
                .userName="${item2.userName}"
                .userImg="${item2.userImg}"
                .userColorIndex="${item2.userColorIndex}"
                theme="${ifDefined(item2.theme)}"
                class="${ifDefined(item2.className)}"
                @focusin="${this._onMessageFocusIn}"
                >${item2.text}<vaadin-avatar slot="avatar"></vaadin-avatar
              ></vaadin-message>
            `
      )}
        `,
      this,
      { host: this }
    );
  }
  /** @private */
  _scrollToLastMessage() {
    if (this.items.length > 0) {
      this.scrollTop = this.scrollHeight - this.clientHeight;
    }
  }
  /** @private */
  _onMessageFocusIn(e2) {
    const target = e2.composedPath().find((node) => node instanceof customElements.get("vaadin-message"));
    this._setTabIndexesByMessage(target);
  }
  /**
   * @param {number} idx
   * @protected
   */
  _setTabIndexesByIndex(index) {
    const message = this._messages[index] || this._messages[0];
    this._setTabIndexesByMessage(message);
  }
  /** @private */
  _setTabIndexesByMessage(message) {
    this._messages.forEach((e2) => {
      e2.tabIndex = e2 === message ? 0 : -1;
    });
  }
  /** @private */
  _getIndexOfFocusableElement() {
    const index = this._messages.findIndex((e2) => e2.tabIndex === 0);
    return index !== -1 ? index : 0;
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MessageList extends MessageListMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-message-list";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          overflow: auto;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <div part="list" role="list">
        <slot></slot>
      </div>
    `;
  }
}
defineCustomElement(MessageList);
registerStyles$1(
  "vaadin-notification-card",
  css`
    :host {
      position: relative;
      margin: var(--lumo-space-s);
    }

    [part='overlay'] {
      background: var(--lumo-base-color) linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
      border-radius: var(--lumo-border-radius-l);
      box-shadow:
        0 0 0 1px var(--lumo-contrast-10pct),
        var(--lumo-box-shadow-l);
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      font-weight: 400;
      line-height: var(--lumo-line-height-s);
      letter-spacing: 0;
      text-transform: none;
      -webkit-text-size-adjust: 100%;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    [part='content'] {
      padding: var(--lumo-space-wide-l);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    [part='content'] ::slotted(vaadin-button) {
      flex: none;
      margin: 0 calc(var(--lumo-space-s) * -1) 0 var(--lumo-space-m);
    }

    :host([slot^='middle']) {
      max-width: 80vw;
      margin: var(--lumo-space-s) auto;
    }

    :host([slot$='stretch']) {
      margin: 0;
    }

    :host([slot$='stretch']) [part='overlay'] {
      border-radius: 0;
    }

    @media (min-width: 421px) {
      :host(:not([slot$='stretch'])) {
        display: flex;
      }

      :host([slot$='end']) {
        justify-content: flex-end;
      }

      :host([slot^='middle']),
      :host([slot$='center']) {
        display: flex;
        justify-content: center;
      }
    }

    @keyframes lumo-notification-exit-fade-out {
      100% {
        opacity: 0;
      }
    }

    @keyframes lumo-notification-enter-fade-in {
      0% {
        opacity: 0;
      }
    }

    @keyframes lumo-notification-enter-slide-down {
      0% {
        transform: translateY(-200%);
        opacity: 0;
      }
    }

    @keyframes lumo-notification-exit-slide-up {
      100% {
        transform: translateY(-200%);
        opacity: 0;
      }
    }

    @keyframes lumo-notification-enter-slide-up {
      0% {
        transform: translateY(200%);
        opacity: 0;
      }
    }

    @keyframes lumo-notification-exit-slide-down {
      100% {
        transform: translateY(200%);
        opacity: 0;
      }
    }

    :host([slot='middle'][opening]) {
      animation: lumo-notification-enter-fade-in 300ms;
    }

    :host([slot='middle'][closing]) {
      animation: lumo-notification-exit-fade-out 300ms;
    }

    :host([slot^='top'][opening]) {
      animation: lumo-notification-enter-slide-down 300ms;
    }

    :host([slot^='top'][closing]) {
      animation: lumo-notification-exit-slide-up 300ms;
    }

    :host([slot^='bottom'][opening]) {
      animation: lumo-notification-enter-slide-up 300ms;
    }

    :host([slot^='bottom'][closing]) {
      animation: lumo-notification-exit-slide-down 300ms;
    }

    :host([theme='success']) {
      --_focus-ring-gap-color: var(--lumo-success-color);
      --vaadin-focus-ring-color: var(--lumo-success-contrast-color);
    }

    :host([theme='warning']) {
      --_focus-ring-gap-color: var(--lumo-warning-color);
      --vaadin-focus-ring-color: var(--lumo-warning-contrast-color);
    }

    :host([theme='error']) {
      --_focus-ring-gap-color: var(--lumo-error-color);
      --vaadin-focus-ring-color: var(--lumo-error-contrast-color);
    }

    :host([theme='primary']) {
      --_focus-ring-gap-color: var(--lumo-primary-color);
      --vaadin-focus-ring-color: var(--lumo-primary-contrast-color);
    }

    :host([theme~='primary']) [part='overlay'] {
      background: var(--lumo-primary-color);
      color: var(--lumo-primary-contrast-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='primary']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-primary-contrast-color);
      --vaadin-button-primary-background: var(--lumo-primary-contrast-color);
      --vaadin-button-primary-text-color: var(--lumo-primary-text-color);
    }

    :host([theme~='contrast']) [part='overlay'] {
      background: var(--lumo-contrast);
      color: var(--lumo-base-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='contrast']) {
      --vaadin-button-background: var(--lumo-contrast-20pct);
      --vaadin-button-text-color: var(--lumo-base-color);
      --vaadin-button-primary-background: var(--lumo-base-color);
      --vaadin-button-primary-text-color: var(--lumo-contrast);
    }

    :host([theme~='success']) [part='overlay'] {
      background: var(--lumo-success-color);
      color: var(--lumo-success-contrast-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='success']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-success-contrast-color);
      --vaadin-button-primary-background: var(--lumo-success-contrast-color);
      --vaadin-button-primary-text-color: var(--lumo-success-text-color);
    }

    :host([theme~='error']) [part='overlay'] {
      background: var(--lumo-error-color);
      color: var(--lumo-error-contrast-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='error']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-error-contrast-color);
      --vaadin-button-primary-background: var(--lumo-error-contrast-color);
      --vaadin-button-primary-text-color: var(--lumo-error-text-color);
    }

    :host([theme~='warning']) [part='overlay'] {
      background: var(--lumo-warning-color);
      color: var(--lumo-warning-contrast-color);
      box-shadow:
        inset 0 0 0 1px var(--lumo-contrast-20pct),
        var(--lumo-box-shadow-l);
    }

    :host([theme~='warning']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-warning-contrast-color);
      --vaadin-button-primary-background: var(--lumo-shade-50pct);
      --vaadin-button-primary-text-color: var(--lumo-primary-contrast-color);
    }
  `,
  { moduleId: "lumo-notification-card" }
);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const NotificationContainerMixin = (superClass) => class extends OverlayStackMixin(superClass) {
  static get properties() {
    return {
      /**
       * True when the container is opened
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        sync: true,
        observer: "_openedChanged"
      }
    };
  }
  constructor() {
    super();
    this._boundVaadinOverlayClose = this._onVaadinOverlayClose.bind(this);
    if (isIOS) {
      this._boundIosResizeListener = () => this._detectIosNavbar();
    }
  }
  /** @private */
  _openedChanged(opened) {
    if (opened) {
      document.body.appendChild(this);
      document.addEventListener("vaadin-overlay-close", this._boundVaadinOverlayClose);
      if (this._boundIosResizeListener) {
        this._detectIosNavbar();
        window.addEventListener("resize", this._boundIosResizeListener);
      }
    } else {
      document.body.removeChild(this);
      document.removeEventListener("vaadin-overlay-close", this._boundVaadinOverlayClose);
      if (this._boundIosResizeListener) {
        window.removeEventListener("resize", this._boundIosResizeListener);
      }
    }
  }
  /** @private */
  _detectIosNavbar() {
    const innerHeight = window.innerHeight;
    const innerWidth = window.innerWidth;
    const landscape = innerWidth > innerHeight;
    const clientHeight = document.documentElement.clientHeight;
    if (landscape && clientHeight > innerHeight) {
      this.style.bottom = `${clientHeight - innerHeight}px`;
    } else {
      this.style.bottom = "0";
    }
  }
  /** @private */
  _onVaadinOverlayClose(event) {
    const sourceEvent = event.detail.sourceEvent;
    const isFromNotification = sourceEvent && sourceEvent.composedPath().indexOf(this) >= 0;
    if (isFromNotification) {
      event.preventDefault();
    }
  }
};
const NotificationMixin = (superClass) => class extends ThemePropertyMixin(OverlayClassMixin(superClass)) {
  static get properties() {
    return {
      /**
       * When true, the notification card has `aria-live` attribute set to
       * `assertive` instead of `polite`. This makes screen readers announce
       * the notification content immediately when it appears.
       */
      assertive: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * The duration in milliseconds to show the notification.
       * Set to `0` or a negative number to disable the notification auto-closing.
       * @type {number}
       */
      duration: {
        type: Number,
        value: 5e3,
        sync: true
      },
      /**
       * True if the notification is currently displayed.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        sync: true,
        observer: "_openedChanged"
      },
      /**
       * Alignment of the notification in the viewport
       * Valid values are `top-stretch|top-start|top-center|top-end|middle|bottom-start|bottom-center|bottom-end|bottom-stretch`
       * @type {!NotificationPosition}
       */
      position: {
        type: String,
        value: "bottom-start",
        observer: "_positionChanged",
        sync: true
      },
      /**
       * Custom function for rendering the content of the notification.
       * Receives two arguments:
       *
       * - `root` The `<vaadin-notification-card>` DOM element. Append
       *   your content to it.
       * - `notification` The reference to the `<vaadin-notification>` element.
       * @type {!NotificationRenderer | undefined}
       */
      renderer: {
        type: Function,
        sync: true
      }
    };
  }
  static get observers() {
    return ["_durationChanged(duration, opened)", "_rendererChanged(renderer, opened, _overlayElement)"];
  }
  /**
   * Shows a notification with the given content.
   * By default, positions the notification at `bottom-start` and uses a 5 second duration.
   * An options object can be passed to configure the notification.
   * The options object has the following structure:
   *
   * ```
   * {
   *   assertive?: boolean
   *   position?: string
   *   duration?: number
   *   theme?: string
   * }
   * ```
   *
   * See the individual documentation for:
   * - [`assertive`](#/elements/vaadin-notification#property-assertive)
   * - [`position`](#/elements/vaadin-notification#property-position)
   * - [`duration`](#/elements/vaadin-notification#property-duration)
   *
   * @param contents the contents to show, either as a string or a Lit template.
   * @param options optional options for customizing the notification.
   */
  static show(contents, options) {
    const Notification2 = customElements.get("vaadin-notification");
    if (isTemplateResult(contents)) {
      return Notification2._createAndShowNotification((root2) => {
        render(contents, root2);
      }, options);
    }
    return Notification2._createAndShowNotification((root2) => {
      root2.innerText = contents;
    }, options);
  }
  /** @private */
  static _createAndShowNotification(renderer, options) {
    const notification = document.createElement("vaadin-notification");
    if (options && Number.isFinite(options.duration)) {
      notification.duration = options.duration;
    }
    if (options && options.position) {
      notification.position = options.position;
    }
    if (options && options.assertive) {
      notification.assertive = options.assertive;
    }
    if (options && options.theme) {
      notification.setAttribute("theme", options.theme);
    }
    notification.renderer = renderer;
    document.body.appendChild(notification);
    notification.opened = true;
    notification.addEventListener("opened-changed", (e2) => {
      if (!e2.detail.value) {
        notification.remove();
      }
    });
    return notification;
  }
  /** @private */
  get _container() {
    const Notification2 = customElements.get("vaadin-notification");
    if (!Notification2._container) {
      Notification2._container = document.createElement("vaadin-notification-container");
      document.body.appendChild(Notification2._container);
    }
    return Notification2._container;
  }
  /** @protected */
  get _card() {
    return this._overlayElement;
  }
  /** @protected */
  ready() {
    super.ready();
    this._overlayElement = this.shadowRoot.querySelector("vaadin-notification-card");
    processTemplates(this);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    queueMicrotask(() => {
      if (!this.isConnected) {
        this.opened = false;
      }
    });
  }
  /**
   * Requests an update for the content of the notification.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this.renderer || !this._card) {
      return;
    }
    this.renderer(this._card, this);
  }
  /** @private */
  __computeAriaLive(assertive) {
    return assertive ? "assertive" : "polite";
  }
  /** @private */
  _rendererChanged(renderer, opened, card) {
    if (!card) {
      return;
    }
    const rendererChanged = this._oldRenderer !== renderer;
    this._oldRenderer = renderer;
    if (rendererChanged) {
      card.innerHTML = "";
      delete card._$litPart$;
    }
    if (opened) {
      if (!this._didAnimateNotificationAppend) {
        this._animatedAppendNotificationCard();
      }
      this.requestContentUpdate();
    }
  }
  /**
   * Opens the notification.
   */
  open() {
    this.opened = true;
  }
  /**
   * Closes the notification.
   */
  close() {
    this.opened = false;
  }
  /** @private */
  _openedChanged(opened) {
    if (opened) {
      this._container.opened = true;
      this._animatedAppendNotificationCard();
    } else if (this._card) {
      this._closeNotificationCard();
    }
  }
  /** @private */
  __cleanUpOpeningClosingState() {
    this._card.removeAttribute("opening");
    this._card.removeAttribute("closing");
    this._card.removeEventListener("animationend", this.__animationEndListener);
  }
  /** @private */
  _animatedAppendNotificationCard() {
    if (this._card) {
      this.__cleanUpOpeningClosingState();
      this._card.setAttribute("opening", "");
      this._appendNotificationCard();
      this.__animationEndListener = () => this.__cleanUpOpeningClosingState();
      this._card.addEventListener("animationend", this.__animationEndListener);
      this._didAnimateNotificationAppend = true;
    } else {
      this._didAnimateNotificationAppend = false;
    }
  }
  /** @private */
  _appendNotificationCard() {
    if (!this._card) {
      return;
    }
    if (this._container.performUpdate) {
      this._container.performUpdate();
    }
    if (!this._container.shadowRoot.querySelector(`slot[name="${this.position}"]`)) {
      console.warn(`Invalid alignment parameter provided: position=${this.position}`);
      return;
    }
    this._container.bringToFront();
    this._card.slot = this.position;
    if (this._container.firstElementChild && /top/u.test(this.position)) {
      this._container.insertBefore(this._card, this._container.firstElementChild);
    } else {
      this._container.appendChild(this._card);
    }
  }
  /** @private */
  _removeNotificationCard() {
    if (!this._card) {
      return;
    }
    if (this._card.parentNode) {
      this._card.parentNode.removeChild(this._card);
    }
    this._card.removeAttribute("closing");
    this._container.opened = Boolean(this._container.firstElementChild);
    this.dispatchEvent(new CustomEvent("closed"));
  }
  /** @private */
  _closeNotificationCard() {
    if (this._durationTimeoutId) {
      clearTimeout(this._durationTimeoutId);
    }
    this._animatedRemoveNotificationCard();
  }
  /** @private */
  _animatedRemoveNotificationCard() {
    this.__cleanUpOpeningClosingState();
    this._card.setAttribute("closing", "");
    const name = getComputedStyle(this._card).getPropertyValue("animation-name");
    if (name && name !== "none") {
      this.__animationEndListener = () => {
        this._removeNotificationCard();
        this.__cleanUpOpeningClosingState();
      };
      this._card.addEventListener("animationend", this.__animationEndListener);
    } else {
      this._removeNotificationCard();
    }
  }
  /** @private */
  _positionChanged() {
    if (this.opened) {
      this._animatedAppendNotificationCard();
    }
  }
  /** @private */
  _durationChanged(duration, opened) {
    if (opened) {
      clearTimeout(this._durationTimeoutId);
      if (duration > 0) {
        this._durationTimeoutId = setTimeout(() => this.close(), duration);
      }
    }
  }
  /**
   * Fired when the notification is closed.
   *
   * @event closed
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const notificationContainerStyles = css`
  :host {
    position: fixed;
    z-index: 1000;
    inset: 0;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    pointer-events: none;
  }

  [region-group] {
    flex: 1 1 0%;
    display: flex;
  }

  [region-group='top'] {
    align-items: flex-start;
  }

  [region-group='bottom'] {
    align-items: flex-end;
  }

  [region-group] > [region] {
    flex: 1 1 0%;
  }

  @media (max-width: 420px) {
    [region-group] {
      flex-direction: column;
      align-items: stretch;
    }

    [region-group='top'] {
      justify-content: flex-start;
    }

    [region-group='bottom'] {
      justify-content: flex-end;
    }

    [region-group] > [region] {
      flex: initial;
    }
  }
`;
const notificationCardStyles = css`
  :host {
    display: block;
  }

  [part='overlay'] {
    pointer-events: auto;
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 3px solid;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-notification-container", notificationContainerStyles, {
  moduleId: "vaadin-notification-container-styles"
});
registerStyles$1("vaadin-notification-card", notificationCardStyles, {
  moduleId: "vaadin-notification-card-styles"
});
class NotificationContainer extends NotificationContainerMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get template() {
    return html`
      <div region="top-stretch"><slot name="top-stretch"></slot></div>
      <div region-group="top">
        <div region="top-start"><slot name="top-start"></slot></div>
        <div region="top-center"><slot name="top-center"></slot></div>
        <div region="top-end"><slot name="top-end"></slot></div>
      </div>
      <div region="middle"><slot name="middle"></slot></div>
      <div region-group="bottom">
        <div region="bottom-start"><slot name="bottom-start"></slot></div>
        <div region="bottom-center"><slot name="bottom-center"></slot></div>
        <div region="bottom-end"><slot name="bottom-end"></slot></div>
      </div>
      <div region="bottom-stretch"><slot name="bottom-stretch"></slot></div>
    `;
  }
  static get is() {
    return "vaadin-notification-container";
  }
}
class NotificationCard extends ThemableMixin(PolymerElement) {
  static get template() {
    return html`
      <div part="overlay">
        <div part="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
  static get is() {
    return "vaadin-notification-card";
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "alert");
  }
}
class Notification extends NotificationMixin(ElementMixin(PolymerElement)) {
  static get template() {
    return html`
      <style>
        :host {
          display: none !important;
        }
      </style>
      <vaadin-notification-card
        theme$="[[_theme]]"
        aria-live$="[[__computeAriaLive(assertive)]]"
      ></vaadin-notification-card>
    `;
  }
  static get is() {
    return "vaadin-notification";
  }
}
defineCustomElement(NotificationContainer);
defineCustomElement(NotificationCard);
defineCustomElement(Notification);
const horizontalLayout = css`
  :host([theme~='margin']) {
    margin: var(--lumo-space-m);
  }

  :host([theme~='padding']) {
    padding: var(--lumo-space-m);
  }

  :host([theme~='spacing-xs']) {
    gap: var(--lumo-space-xs);
  }

  :host([theme~='spacing-s']) {
    gap: var(--lumo-space-s);
  }

  :host([theme~='spacing']) {
    gap: var(--lumo-space-m);
  }

  :host([theme~='spacing-l']) {
    gap: var(--lumo-space-l);
  }

  :host([theme~='spacing-xl']) {
    gap: var(--lumo-space-xl);
  }

  :host([theme~='wrap']) {
    flex-wrap: wrap;
  }
`;
registerStyles$1("vaadin-horizontal-layout", horizontalLayout, { moduleId: "lumo-horizontal-layout" });
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class HorizontalLayout extends ElementMixin(ThemableMixin(PolymerElement)) {
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
          box-sizing: border-box;
        }

        :host([hidden]) {
          display: none !important;
        }

        /* Theme variations */
        :host([theme~='margin']) {
          margin: 1em;
        }

        :host([theme~='padding']) {
          padding: 1em;
        }

        :host([theme~='spacing']) {
          gap: 1em;
        }
      </style>

      <slot></slot>
    `;
  }
  static get is() {
    return "vaadin-horizontal-layout";
  }
}
defineCustomElement(HorizontalLayout);
const scroller = css`
  :host {
    outline: none;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  :host([focus-ring]) {
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  /* Show dividers when content overflows */

  :host([theme~='overflow-indicators'])::before,
  :host([theme~='overflow-indicators'])::after {
    content: '';
    display: none;
    position: sticky;
    inset: 0;
    z-index: 9999;
    height: 1px;
    margin-bottom: -1px;
    background: var(--lumo-contrast-10pct);
  }

  :host([theme~='overflow-indicators'])::after {
    margin-bottom: 0;
    margin-top: -1px;
  }

  :host([theme~='overflow-indicators'][overflow~='top'])::before,
  :host([theme~='overflow-indicators'][overflow~='bottom'])::after {
    display: block;
  }
`;
registerStyles$1("vaadin-scroller", scroller, { moduleId: "lumo-scroller" });
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class OverflowController {
  constructor(host, scrollTarget) {
    this.host = host;
    this.scrollTarget = scrollTarget || host;
    this.__boundOnScroll = this.__onScroll.bind(this);
  }
  hostConnected() {
    if (!this.initialized) {
      this.initialized = true;
      this.observe();
    }
  }
  /**
   * Setup scroll listener and observers to update overflow.
   * Also performs one-time update synchronously when called.
   * @protected
   */
  observe() {
    const { host } = this;
    this.__resizeObserver = new ResizeObserver(() => {
      this.__debounceOverflow = Debouncer$1.debounce(this.__debounceOverflow, animationFrame, () => {
        this.__updateOverflow();
      });
    });
    this.__resizeObserver.observe(host);
    [...host.children].forEach((child) => {
      this.__resizeObserver.observe(child);
    });
    this.__childObserver = new MutationObserver((mutations) => {
      mutations.forEach(({ addedNodes, removedNodes }) => {
        addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            this.__resizeObserver.observe(node);
          }
        });
        removedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            this.__resizeObserver.unobserve(node);
          }
        });
      });
      this.__updateOverflow();
    });
    this.__childObserver.observe(host, { childList: true });
    this.scrollTarget.addEventListener("scroll", this.__boundOnScroll);
    this.__updateOverflow();
  }
  /** @private */
  __onScroll() {
    this.__updateOverflow();
  }
  /** @private */
  __updateOverflow() {
    const target = this.scrollTarget;
    let overflow = "";
    if (target.scrollTop > 0) {
      overflow += " top";
    }
    if (Math.ceil(target.scrollTop) < Math.ceil(target.scrollHeight - target.clientHeight)) {
      overflow += " bottom";
    }
    const scrollLeft = Math.abs(target.scrollLeft);
    if (scrollLeft > 0) {
      overflow += " start";
    }
    if (Math.ceil(scrollLeft) < Math.ceil(target.scrollWidth - target.clientWidth)) {
      overflow += " end";
    }
    overflow = overflow.trim();
    if (overflow.length > 0 && this.host.getAttribute("overflow") !== overflow) {
      this.host.setAttribute("overflow", overflow);
    } else if (overflow.length === 0 && this.host.hasAttribute("overflow")) {
      this.host.removeAttribute("overflow");
    }
  }
}
/**
 * @license
 * Copyright (c) 2020 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ScrollerMixin = (superClass) => class ScrollerMixinClass extends FocusMixin(superClass) {
  static get properties() {
    return {
      /**
       * This property indicates the scroll direction. Supported values are `vertical`, `horizontal`, `none`.
       * When `scrollDirection` is undefined scrollbars will be shown in both directions.
       * @attr {string} scroll-direction
       */
      scrollDirection: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       * @protected
       */
      tabindex: {
        type: Number,
        value: 0,
        reflectToAttribute: true
      }
    };
  }
  /**
   * Override method inherited from `FocusMixin` to mark the scroller as focused
   * only when the host is focused.
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldSetFocus(event) {
    return event.target === this;
  }
};
/**
 * @license
 * Copyright (c) 2020 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Scroller extends ScrollerMixin(ElementMixin(ControllerMixin(ThemableMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host([hidden]) {
          display: none !important;
        }

        :host {
          display: block;
          overflow: auto;
        }

        :host([scroll-direction='vertical']) {
          overflow-x: hidden;
        }

        :host([scroll-direction='horizontal']) {
          overflow-y: hidden;
        }

        :host([scroll-direction='none']) {
          overflow: hidden;
        }
      </style>

      <slot></slot>
    `;
  }
  static get is() {
    return "vaadin-scroller";
  }
  /** @protected */
  ready() {
    super.ready();
    this.__overflowController = new OverflowController(this);
    this.addController(this.__overflowController);
  }
}
defineCustomElement(Scroller);
const verticalLayout = css`
  :host([theme~='margin']) {
    margin: var(--lumo-space-m);
  }

  :host([theme~='padding']) {
    padding: var(--lumo-space-m);
  }

  :host([theme~='spacing-xs']) {
    gap: var(--lumo-space-xs);
  }

  :host([theme~='spacing-s']) {
    gap: var(--lumo-space-s);
  }

  :host([theme~='spacing']) {
    gap: var(--lumo-space-m);
  }

  :host([theme~='spacing-l']) {
    gap: var(--lumo-space-l);
  }

  :host([theme~='spacing-xl']) {
    gap: var(--lumo-space-xl);
  }

  :host([theme~='wrap']) {
    flex-wrap: wrap;
  }
`;
registerStyles$1("vaadin-vertical-layout", verticalLayout, { moduleId: "lumo-vertical-layout" });
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class VerticalLayout extends ElementMixin(ThemableMixin(PolymerElement)) {
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
          flex-direction: column;
          align-items: flex-start;
          box-sizing: border-box;
        }

        :host([hidden]) {
          display: none !important;
        }

        /* Theme variations */
        :host([theme~='margin']) {
          margin: 1em;
        }

        :host([theme~='padding']) {
          padding: 1em;
        }

        :host([theme~='spacing']) {
          gap: 1em;
        }
      </style>

      <slot></slot>
    `;
  }
  static get is() {
    return "vaadin-vertical-layout";
  }
}
defineCustomElement(VerticalLayout);
const popoverOverlay = css`
  :host {
    --vaadin-popover-offset-top: var(--_vaadin-popover-default-offset);
    --vaadin-popover-offset-bottom: var(--_vaadin-popover-default-offset);
    --vaadin-popover-offset-start: var(--_vaadin-popover-default-offset);
    --vaadin-popover-offset-end: var(--_vaadin-popover-default-offset);
    --vaadin-popover-arrow-size: 0.5rem;
    --_vaadin-popover-default-offset: var(--lumo-space-xs);
  }

  [part='overlay'] {
    outline: none;
  }

  [part='content'] {
    padding: var(--lumo-space-xs) var(--lumo-space-s);
  }

  :host([theme~='no-padding']) [part='content'] {
    padding: 0;
  }

  :host([theme~='arrow']) {
    --_vaadin-popover-default-offset: calc(var(--lumo-space-s) + var(--vaadin-popover-arrow-size) / 2);
  }

  /* top / bottom position */
  :host([theme~='arrow'][position^='top']) [part='arrow'],
  :host([theme~='arrow'][position^='bottom']) [part='arrow'] {
    border-left: var(--vaadin-popover-arrow-size) solid transparent;
    border-right: var(--vaadin-popover-arrow-size) solid transparent;
  }

  :host([theme~='arrow'][position^='bottom'][bottom-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='top'][bottom-aligned]) [part='arrow'] {
    bottom: calc(var(--vaadin-popover-arrow-size) * -1);
    border-top: var(--vaadin-popover-arrow-size) solid var(--lumo-base-color);
    filter: drop-shadow(0 2px 1px var(--lumo-shade-10pct));
  }

  :host([theme~='arrow'][position^='bottom'][top-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='top'][top-aligned]) [part='arrow'] {
    top: calc(var(--vaadin-popover-arrow-size) * -1);
    border-bottom: var(--vaadin-popover-arrow-size) solid var(--lumo-base-color);
    filter: drop-shadow(0 -2px 1px var(--lumo-shade-10pct));
  }

  :host([theme~='arrow'][position^='bottom'][start-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='top'][start-aligned]) [part='arrow'] {
    transform: translateX(-50%);
    inset-inline-start: 1.5rem;
  }

  :host([theme~='arrow'][position^='bottom'][end-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='top'][end-aligned]) [part='arrow'] {
    transform: translateX(50%);
    inset-inline-end: 1.5rem;
  }

  :host([theme~='arrow'][position^='bottom'][arrow-centered]) [part='arrow'],
  :host([theme~='arrow'][position^='top'][arrow-centered]) [part='arrow'] {
    transform: translateX(-50%);
    inset-inline-start: 50%;
  }

  /* start / end position */
  :host([theme~='arrow'][position^='start']) [part='arrow'],
  :host([theme~='arrow'][position^='end']) [part='arrow'] {
    border-top: var(--vaadin-popover-arrow-size) solid transparent;
    border-bottom: var(--vaadin-popover-arrow-size) solid transparent;
  }

  :host([theme~='arrow'][position^='start'][start-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='end'][start-aligned]) [part='arrow'] {
    inset-inline-start: calc(var(--vaadin-popover-arrow-size) * -1);
    border-right: var(--vaadin-popover-arrow-size) solid var(--lumo-base-color);
    filter: drop-shadow(-2px 0 1px var(--lumo-shade-10pct));
  }

  :host([theme~='arrow'][position^='start'][end-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='end'][end-aligned]) [part='arrow'] {
    inset-inline-end: calc(var(--vaadin-popover-arrow-size) * -1);
    border-left: var(--vaadin-popover-arrow-size) solid var(--lumo-base-color);
    filter: drop-shadow(2px 0 1px var(--lumo-shade-10pct));
  }

  :host([theme~='arrow'][position^='start'][top-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='end'][top-aligned]) [part='arrow'] {
    top: 0.5rem;
  }

  :host([theme~='arrow'][position='start'][top-aligned]) [part='arrow'],
  :host([theme~='arrow'][position='end'][top-aligned]) [part='arrow'] {
    top: 50%;
    transform: translateY(-50%);
  }

  :host([theme~='arrow'][position^='start'][bottom-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='end'][bottom-aligned]) [part='arrow'] {
    bottom: 0.5rem;
  }
`;
registerStyles$1("vaadin-popover-overlay", [overlay, popoverOverlay], { moduleId: "lumo-popover-overlay" });
const appliedClassMixins = /* @__PURE__ */ new WeakMap();
function wasMixinPreviouslyApplied(mixin, superClass) {
  let klass = superClass;
  while (klass) {
    if (appliedClassMixins.get(klass) === mixin) {
      return true;
    }
    klass = Object.getPrototypeOf(klass);
  }
  return false;
}
function dedupeMixin(mixin) {
  return (superClass) => {
    if (wasMixinPreviouslyApplied(mixin, superClass)) {
      return superClass;
    }
    const mixedClass = mixin(superClass);
    appliedClassMixins.set(mixedClass, mixin);
    return mixedClass;
  };
}
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const caseMap = {};
const CAMEL_TO_DASH = /([A-Z])/gu;
function camelToDash(camel) {
  if (!caseMap[camel]) {
    caseMap[camel] = camel.replace(CAMEL_TO_DASH, "-$1").toLowerCase();
  }
  return caseMap[camel];
}
function upper(name) {
  return name[0].toUpperCase() + name.substring(1);
}
function parseObserver(observerString) {
  const [method, rest] = observerString.split("(");
  const observerProps = rest.replace(")", "").split(",").map((prop) => prop.trim());
  return {
    method,
    observerProps
  };
}
function getOrCreateMap(obj, name) {
  if (!Object.prototype.hasOwnProperty.call(obj, name)) {
    obj[name] = new Map(obj[name]);
  }
  return obj[name];
}
const PolylitMixinImplementation = (superclass) => {
  class PolylitMixinClass extends superclass {
    static createProperty(name, options) {
      if ([String, Boolean, Number, Array].includes(options)) {
        options = {
          type: options
        };
      }
      if (options.reflectToAttribute) {
        options.reflect = true;
      }
      super.createProperty(name, options);
    }
    static getOrCreateMap(name) {
      return getOrCreateMap(this, name);
    }
    /**
     * @protected
     * @override
     */
    static finalize() {
      super.finalize();
      if (Array.isArray(this.observers)) {
        const complexObservers = this.getOrCreateMap("__complexObservers");
        this.observers.forEach((observer2) => {
          const { method, observerProps } = parseObserver(observer2);
          complexObservers.set(method, observerProps);
        });
      }
    }
    static addCheckedInitializer(initializer) {
      super.addInitializer((instance) => {
        if (instance instanceof this) {
          initializer(instance);
        }
      });
    }
    static getPropertyDescriptor(name, key, options) {
      const defaultDescriptor = super.getPropertyDescriptor(name, key, options);
      let result = defaultDescriptor;
      this.getOrCreateMap("__propKeys").set(name, key);
      if (options.sync) {
        result = {
          get: defaultDescriptor.get,
          set(value) {
            const oldValue = this[name];
            this[key] = value;
            this.requestUpdate(name, oldValue, options);
            if (this.hasUpdated) {
              this.performUpdate();
            }
          },
          configurable: true,
          enumerable: true
        };
      }
      if (options.readOnly) {
        const setter = defaultDescriptor.set;
        this.addCheckedInitializer((instance) => {
          instance[`_set${upper(name)}`] = function(value) {
            setter.call(instance, value);
            if (options.sync) {
              this.performUpdate();
            }
          };
        });
        result = {
          get: defaultDescriptor.get,
          set() {
          },
          configurable: true,
          enumerable: true
        };
      }
      if ("value" in options) {
        this.addCheckedInitializer((instance) => {
          const value = typeof options.value === "function" ? options.value.call(instance) : options.value;
          if (options.readOnly) {
            instance[`_set${upper(name)}`](value);
          } else {
            instance[name] = value;
          }
        });
      }
      if (options.observer) {
        const method = options.observer;
        this.getOrCreateMap("__observers").set(name, method);
        this.addCheckedInitializer((instance) => {
          if (!instance[method]) {
            console.warn(`observer method ${method} not defined`);
          }
        });
      }
      if (options.notify) {
        if (!this.__notifyProps) {
          this.__notifyProps = /* @__PURE__ */ new Set();
        } else if (!this.hasOwnProperty("__notifyProps")) {
          const notifyProps = this.__notifyProps;
          this.__notifyProps = new Set(notifyProps);
        }
        this.__notifyProps.add(name);
      }
      if (options.computed) {
        const assignComputedMethod = `__assignComputed${name}`;
        const observer2 = parseObserver(options.computed);
        this.prototype[assignComputedMethod] = function(...props) {
          this[name] = this[observer2.method](...props);
        };
        this.getOrCreateMap("__complexObservers").set(assignComputedMethod, observer2.observerProps);
      }
      if (!options.attribute) {
        options.attribute = camelToDash(name);
      }
      return result;
    }
    /** @protected */
    firstUpdated() {
      super.firstUpdated();
      if (!this.$) {
        this.$ = {};
      }
      this.renderRoot.querySelectorAll("[id]").forEach((node) => {
        this.$[node.id] = node;
      });
    }
    /** @protected */
    ready() {
    }
    /** @protected */
    updated(props) {
      const wasReadyInvoked = this.__isReadyInvoked;
      this.__isReadyInvoked = true;
      if (this.constructor.__observers) {
        this.__runObservers(props, this.constructor.__observers);
      }
      if (this.constructor.__complexObservers) {
        this.__runComplexObservers(props, this.constructor.__complexObservers);
      }
      if (this.__dynamicPropertyObservers) {
        this.__runDynamicObservers(props, this.__dynamicPropertyObservers);
      }
      if (this.__dynamicMethodObservers) {
        this.__runComplexObservers(props, this.__dynamicMethodObservers);
      }
      if (this.constructor.__notifyProps) {
        this.__runNotifyProps(props, this.constructor.__notifyProps);
      }
      if (!wasReadyInvoked) {
        this.ready();
      }
    }
    /**
     * Set several properties at once and perform synchronous update.
     * @protected
     */
    setProperties(props) {
      Object.entries(props).forEach(([name, value]) => {
        const key = this.constructor.__propKeys.get(name);
        const oldValue = this[key];
        this[key] = value;
        this.requestUpdate(name, oldValue);
      });
      if (this.hasUpdated) {
        this.performUpdate();
      }
    }
    /** @protected */
    _createMethodObserver(observer2) {
      const dynamicObservers = getOrCreateMap(this, "__dynamicMethodObservers");
      const { method, observerProps } = parseObserver(observer2);
      dynamicObservers.set(method, observerProps);
    }
    /** @protected */
    _createPropertyObserver(property, method) {
      const dynamicObservers = getOrCreateMap(this, "__dynamicPropertyObservers");
      dynamicObservers.set(method, property);
    }
    /** @private */
    __runComplexObservers(props, observers) {
      observers.forEach((observerProps, method) => {
        if (observerProps.some((prop) => props.has(prop))) {
          if (!this[method]) {
            console.warn(`observer method ${method} not defined`);
          } else {
            this[method](...observerProps.map((prop) => this[prop]));
          }
        }
      });
    }
    /** @private */
    __runDynamicObservers(props, observers) {
      observers.forEach((prop, method) => {
        if (props.has(prop) && this[method]) {
          this[method](this[prop], props.get(prop));
        }
      });
    }
    /** @private */
    __runObservers(props, observers) {
      props.forEach((v, k2) => {
        const observer2 = observers.get(k2);
        if (observer2 !== void 0 && this[observer2]) {
          this[observer2](this[k2], v);
        }
      });
    }
    /** @private */
    __runNotifyProps(props, notifyProps) {
      props.forEach((_, k2) => {
        if (notifyProps.has(k2)) {
          this.dispatchEvent(
            new CustomEvent(`${camelToDash(k2)}-changed`, {
              detail: {
                value: this[k2]
              }
            })
          );
        }
      });
    }
    /** @protected */
    _get(path, object) {
      return get$1(path, object);
    }
    /** @protected */
    _set(path, value, object) {
      set(path, value, object);
    }
  }
  return PolylitMixinClass;
};
const PolylitMixin = dedupeMixin(PolylitMixinImplementation);
/**
 * @license
 * Copyright (c) 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class PopoverOverlay extends PopoverOverlayMixin(DirMixin(ThemableMixin(PolylitMixin(LitElement)))) {
  static get is() {
    return "vaadin-popover-overlay";
  }
  static get styles() {
    return [
      overlayStyles,
      css`
        :host {
          --_vaadin-popover-content-width: auto;
          --_vaadin-popover-content-height: auto;
        }

        :host([modeless][with-backdrop]) [part='backdrop'] {
          pointer-events: none;
        }

        :host([position^='top'][top-aligned]) [part='overlay'],
        :host([position^='bottom'][top-aligned]) [part='overlay'] {
          margin-top: var(--vaadin-popover-offset-top, 0);
        }

        [part='overlay'] {
          position: relative;
          overflow: visible;
          max-height: 100%;
        }

        [part='content'] {
          overflow: auto;
          box-sizing: border-box;
          max-height: 100%;
          width: var(--_vaadin-popover-content-width);
          height: var(--_vaadin-popover-content-height);
        }

        /* Increase the area of the popover so the pointer can go from the target directly to it. */
        [part='overlay']::before {
          position: absolute;
          content: '';
          inset-block: calc(var(--vaadin-popover-offset-top, 0) * -1) calc(var(--vaadin-popover-offset-bottom, 0) * -1);
          inset-inline: calc(var(--vaadin-popover-offset-start, 0) * -1) calc(var(--vaadin-popover-offset-end, 0) * -1);
          z-index: -1;
          pointer-events: auto;
        }

        :host([position^='top'][bottom-aligned]) [part='overlay'],
        :host([position^='bottom'][bottom-aligned]) [part='overlay'] {
          margin-bottom: var(--vaadin-popover-offset-bottom, 0);
        }

        :host([position^='start'][start-aligned]) [part='overlay'],
        :host([position^='end'][start-aligned]) [part='overlay'] {
          margin-inline-start: var(--vaadin-popover-offset-start, 0);
        }

        :host([position^='start'][end-aligned]) [part='overlay'],
        :host([position^='end'][end-aligned]) [part='overlay'] {
          margin-inline-end: var(--vaadin-popover-offset-end, 0);
        }

        [part='arrow'] {
          display: none;
          position: absolute;
          height: 0;
          width: 0;
        }

        :host([theme~='arrow']) [part='arrow'] {
          display: block;
        }
      `
    ];
  }
  /** @protected */
  render() {
    return html$1`
      <div id="backdrop" part="backdrop" hidden ?hidden="${!this.withBackdrop}"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="arrow"></div>
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
  }
  /**
   * Override method inherited from `OverlayMixin` to not close
   * modal popover on outside click when opening on focus.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(event) {
    if (this.owner.__hasTrigger("focus") && isElementFocused(this)) {
      return false;
    }
    return super._shouldCloseOnOutsideClick(event);
  }
}
defineCustomElement(PopoverOverlay);
/**
 * @license
 * Copyright (c) 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DEFAULT_DELAY = 500;
let defaultFocusDelay$2 = DEFAULT_DELAY;
let defaultHoverDelay$2 = DEFAULT_DELAY;
let defaultHideDelay$2 = DEFAULT_DELAY;
class PopoverOpenedStateController {
  constructor(host) {
    this.host = host;
  }
  /**
   * Whether closing is currently in progress.
   * @return {boolean}
   */
  get isClosing() {
    return this.__closeTimeout != null;
  }
  /** @private */
  get __focusDelay() {
    const popover = this.host;
    return popover.focusDelay != null && popover.focusDelay >= 0 ? popover.focusDelay : defaultFocusDelay$2;
  }
  /** @private */
  get __hoverDelay() {
    const popover = this.host;
    return popover.hoverDelay != null && popover.hoverDelay >= 0 ? popover.hoverDelay : defaultHoverDelay$2;
  }
  /** @private */
  get __hideDelay() {
    const popover = this.host;
    return popover.hideDelay != null && popover.hideDelay >= 0 ? popover.hideDelay : defaultHideDelay$2;
  }
  /**
   * Schedule opening the popover.
   * @param {Object} options
   */
  open(options = { immediate: false }) {
    const { immediate, trigger } = options;
    const shouldDelayHover = trigger === "hover" && this.__hoverDelay > 0;
    const shouldDelayFocus = trigger === "focus" && this.__focusDelay > 0;
    if (!immediate && (shouldDelayHover || shouldDelayFocus) && !this.__closeTimeout) {
      this.__scheduleOpen(trigger);
    } else {
      this.__showPopover();
    }
  }
  /**
   * Schedule closing the popover.
   * @param {boolean} immediate
   */
  close(immediate) {
    if (!immediate && this.__hideDelay > 0) {
      this.__scheduleClose();
    } else {
      this.__abortClose();
      this.__setOpened(false);
    }
    this.__abortOpen();
  }
  /** @private */
  __setOpened(opened) {
    this.host.opened = opened;
  }
  /** @private */
  __showPopover() {
    this.__abortClose();
    this.__setOpened(true);
  }
  /** @private */
  __abortClose() {
    if (this.__closeTimeout) {
      clearTimeout(this.__closeTimeout);
      this.__closeTimeout = null;
    }
  }
  /** @private */
  __abortOpen() {
    if (this.__openTimeout) {
      clearTimeout(this.__openTimeout);
      this.__openTimeout = null;
    }
  }
  /** @private */
  __scheduleClose() {
    this.__closeTimeout = setTimeout(() => {
      this.__closeTimeout = null;
      this.__setOpened(false);
    }, this.__hideDelay);
  }
  /** @private */
  __scheduleOpen(trigger) {
    this.__abortOpen();
    const delay = trigger === "focus" ? this.__focusDelay : this.__hoverDelay;
    this.__openTimeout = setTimeout(() => {
      this.__openTimeout = null;
      this.__showPopover();
    }, delay);
  }
}
class Popover extends PopoverPositionMixin(
  PopoverTargetMixin(OverlayClassMixin(ThemePropertyMixin(ElementMixin(PolylitMixin(LitElement)))))
) {
  static get is() {
    return "vaadin-popover";
  }
  static get styles() {
    return css`
      :host {
        display: none !important;
      }
    `;
  }
  static get properties() {
    return {
      /**
       * String used to label the overlay to screen reader users.
       *
       * @attr {string} accessible-name
       */
      accessibleName: {
        type: String
      },
      /**
       * Id of the element used as label of the overlay to screen reader users.
       *
       * @attr {string} accessible-name-ref
       */
      accessibleNameRef: {
        type: String
      },
      /**
       * When true, the popover content automatically receives focus after
       * it is opened. Modal popovers use this behavior by default.
       */
      autofocus: {
        type: Boolean
      },
      /**
       * Height to be set on the overlay content.
       *
       * @attr {string} content-height
       */
      contentHeight: {
        type: String
      },
      /**
       * Width to be set on the overlay content.
       *
       * @attr {string} content-width
       */
      contentWidth: {
        type: String
      },
      /**
       * The delay in milliseconds before the popover is opened
       * on focus when the corresponding trigger is used.
       *
       * When not specified, the global default (500ms) is used.
       *
       * @attr {number} focus-delay
       */
      focusDelay: {
        type: Number
      },
      /**
       * The delay in milliseconds before the popover is closed
       * on losing hover, when the corresponding trigger is used.
       * On blur, the popover is closed immediately.
       *
       * When not specified, the global default (500ms) is used.
       *
       * @attr {number} hide-delay
       */
      hideDelay: {
        type: Number
      },
      /**
       * The delay in milliseconds before the popover is opened
       * on hover when the corresponding trigger is used.
       *
       * When not specified, the global default (500ms) is used.
       *
       * @attr {number} hover-delay
       */
      hoverDelay: {
        type: Number
      },
      /**
       * True if the popover overlay is opened, false otherwise.
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        observer: "__openedChanged"
      },
      /**
       * The `role` attribute value to be set on the overlay.
       *
       * @attr {string} overlay-role
       */
      overlayRole: {
        type: String,
        value: "dialog"
      },
      /**
       * Custom function for rendering the content of the overlay.
       * Receives two arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `popover` The reference to the `vaadin-popover` element (overlay host).
       */
      renderer: {
        type: Object
      },
      /**
       * When true, the popover prevents interacting with background elements
       * by setting `pointer-events` style on the document body to `none`.
       * This also enables trapping focus inside the overlay.
       */
      modal: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to disable closing popover overlay on outside click.
       *
       * @attr {boolean} no-close-on-outside-click
       */
      noCloseOnOutsideClick: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to disable closing popover overlay on Escape press.
       * When the popover is modal, pressing Escape anywhere in the
       * document closes the overlay. Otherwise, only Escape press
       * from the popover itself or its target closes the overlay.
       *
       * @attr {boolean} no-close-on-esc
       */
      noCloseOnEsc: {
        type: Boolean,
        value: false
      },
      /**
       * Popover trigger mode, used to configure how the overlay is opened or closed.
       * Could be set to multiple by providing an array, e.g. `trigger = ['hover', 'focus']`.
       *
       * Supported values:
       * - `click` (default) - opens and closes on target click.
       * - `hover` - opens on target mouseenter, closes on target mouseleave. Moving mouse
       * to the popover overlay content keeps the overlay opened.
       * - `focus` - opens on target focus, closes on target blur. Moving focus to the
       * popover overlay content keeps the overlay opened.
       *
       * In addition to the behavior specified by `trigger`, the popover can be closed by:
       * - pressing Escape key (unless `noCloseOnEsc` property is true)
       * - outside click (unless `noCloseOnOutsideClick` property is true)
       *
       * When setting `trigger` property to `null`, `undefined` or empty array, the popover
       * can be only opened or closed programmatically by changing `opened` property.
       */
      trigger: {
        type: Array,
        value: () => ["click"]
      },
      /**
       * When true, the overlay has a backdrop (modality curtain) on top of the
       * underlying page content, covering the whole viewport.
       *
       * @attr {boolean} with-backdrop
       */
      withBackdrop: {
        type: Boolean,
        value: false
      },
      /** @private */
      __shouldRestoreFocus: {
        type: Boolean,
        value: false,
        sync: true
      },
      /** @private */
      __overlayId: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "__updateContentHeight(contentHeight, _overlayElement)",
      "__updateContentWidth(contentWidth, _overlayElement)",
      "__openedOrTargetChanged(opened, target)",
      "__overlayRoleOrTargetChanged(overlayRole, target)"
    ];
  }
  /**
   * Sets the default focus delay to be used by all popover instances,
   * except for those that have focus delay configured using property.
   *
   * @param {number} focusDelay
   */
  static setDefaultFocusDelay(focusDelay) {
    defaultFocusDelay$2 = focusDelay != null && focusDelay >= 0 ? focusDelay : DEFAULT_DELAY;
  }
  /**
   * Sets the default hide delay to be used by all popover instances,
   * except for those that have hide delay configured using property.
   *
   * @param {number} hideDelay
   */
  static setDefaultHideDelay(hideDelay) {
    defaultHideDelay$2 = hideDelay != null && hideDelay >= 0 ? hideDelay : DEFAULT_DELAY;
  }
  /**
   * Sets the default hover delay to be used by all popover instances,
   * except for those that have hover delay configured using property.
   *
   * @param {number} hoverDelay
   */
  static setDefaultHoverDelay(hoverDelay) {
    defaultHoverDelay$2 = hoverDelay != null && hoverDelay >= 0 ? hoverDelay : DEFAULT_DELAY;
  }
  constructor() {
    super();
    this.__overlayId = `vaadin-popover-${generateUniqueId()}`;
    this.__onGlobalClick = this.__onGlobalClick.bind(this);
    this.__onGlobalKeyDown = this.__onGlobalKeyDown.bind(this);
    this.__onTargetClick = this.__onTargetClick.bind(this);
    this.__onTargetFocusIn = this.__onTargetFocusIn.bind(this);
    this.__onTargetFocusOut = this.__onTargetFocusOut.bind(this);
    this.__onTargetMouseEnter = this.__onTargetMouseEnter.bind(this);
    this.__onTargetMouseLeave = this.__onTargetMouseLeave.bind(this);
    this._openedStateController = new PopoverOpenedStateController(this);
  }
  /** @protected */
  render() {
    const effectivePosition = this.__effectivePosition;
    return html$1`
      <vaadin-popover-overlay
        id="${this.__overlayId}"
        role="${this.overlayRole}"
        aria-label="${ifDefined(this.accessibleName)}"
        aria-labelledby="${ifDefined(this.accessibleNameRef)}"
        .renderer="${this.renderer}"
        .owner="${this}"
        theme="${ifDefined(this._theme)}"
        .positionTarget="${this.target}"
        .position="${effectivePosition}"
        .opened="${this.opened}"
        .modeless="${!this.modal}"
        .focusTrap="${this.modal}"
        .withBackdrop="${this.withBackdrop}"
        ?no-horizontal-overlap="${this.__computeNoHorizontalOverlap(effectivePosition)}"
        ?no-vertical-overlap="${this.__computeNoVerticalOverlap(effectivePosition)}"
        .horizontalAlign="${this.__computeHorizontalAlign(effectivePosition)}"
        .verticalAlign="${this.__computeVerticalAlign(effectivePosition)}"
        @mousedown="${this.__onOverlayMouseDown}"
        @mouseenter="${this.__onOverlayMouseEnter}"
        @mouseleave="${this.__onOverlayMouseLeave}"
        @focusin="${this.__onOverlayFocusIn}"
        @focusout="${this.__onOverlayFocusOut}"
        @opened-changed="${this.__onOpenedChanged}"
        .restoreFocusOnClose="${this.__shouldRestoreFocus}"
        .restoreFocusNode="${this.target}"
        @vaadin-overlay-escape-press="${this.__onEscapePress}"
        @vaadin-overlay-outside-click="${this.__onOutsideClick}"
        @vaadin-overlay-open="${this.__onOverlayOpened}"
        @vaadin-overlay-closed="${this.__onOverlayClosed}"
      ></vaadin-popover-overlay>
    `;
  }
  /**
   * Requests an update for the content of the popover.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this.renderer || !this._overlayElement) {
      return;
    }
    this._overlayElement.requestContentUpdate();
  }
  /** @protected */
  ready() {
    super.ready();
    this._overlayElement = this.shadowRoot.querySelector("vaadin-popover-overlay");
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    document.documentElement.addEventListener("click", this.__onGlobalClick, true);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    document.documentElement.removeEventListener("click", this.__onGlobalClick, true);
    queueMicrotask(() => {
      if (!this.isConnected) {
        this._openedStateController.close(true);
      }
    });
  }
  /**
   * @param {HTMLElement} target
   * @protected
   * @override
   */
  _addTargetListeners(target) {
    target.addEventListener("click", this.__onTargetClick);
    target.addEventListener("mouseenter", this.__onTargetMouseEnter);
    target.addEventListener("mouseleave", this.__onTargetMouseLeave);
    target.addEventListener("focusin", this.__onTargetFocusIn);
    target.addEventListener("focusout", this.__onTargetFocusOut);
  }
  /**
   * @param {HTMLElement} target
   * @protected
   * @override
   */
  _removeTargetListeners(target) {
    target.removeEventListener("click", this.__onTargetClick);
    target.removeEventListener("mouseenter", this.__onTargetMouseEnter);
    target.removeEventListener("mouseleave", this.__onTargetMouseLeave);
    target.removeEventListener("focusin", this.__onTargetFocusIn);
    target.removeEventListener("focusout", this.__onTargetFocusOut);
  }
  /** @private */
  __openedChanged(opened, oldOpened) {
    if (opened) {
      document.addEventListener("keydown", this.__onGlobalKeyDown, true);
    } else if (oldOpened) {
      document.removeEventListener("keydown", this.__onGlobalKeyDown, true);
    }
  }
  /** @private */
  __openedOrTargetChanged(opened, target) {
    if (target) {
      target.setAttribute("aria-expanded", opened ? "true" : "false");
      if (opened) {
        target.setAttribute("aria-controls", this.__overlayId);
      } else {
        target.removeAttribute("aria-controls");
      }
    }
  }
  /** @private */
  __overlayRoleOrTargetChanged(overlayRole, target) {
    if (this.__oldTarget) {
      this.__oldTarget.removeAttribute("aria-haspopup");
    }
    if (target) {
      const isDialog = overlayRole === "dialog" || overlayRole === "alertdialog";
      target.setAttribute("aria-haspopup", isDialog ? "dialog" : "true");
      this.__oldTarget = target;
    }
  }
  /**
   * Overlay's global outside click listener doesn't work when
   * the overlay is modeless, so we use a separate listener.
   * @private
   */
  __onGlobalClick(event) {
    if (this.opened && !this.__isManual && !this.modal && !event.composedPath().some((el) => el === this._overlayElement || el === this.target) && !this.noCloseOnOutsideClick && isLastOverlay(this._overlayElement)) {
      this._openedStateController.close(true);
    }
  }
  /** @private */
  __onTargetClick() {
    if (this.__hasTrigger("click")) {
      if (!this.opened) {
        this.__shouldRestoreFocus = true;
      }
      if (this.opened) {
        this._openedStateController.close(true);
      } else {
        this._openedStateController.open({ immediate: true });
      }
    }
  }
  /**
   * Overlay's global Escape press listener doesn't work when
   * the overlay is modeless, so we use a separate listener.
   * @private
   */
  __onGlobalKeyDown(event) {
    if (this.modal) {
      return;
    }
    if (event.key === "Escape" && !this.noCloseOnEsc && this.opened && !this.__isManual && isLastOverlay(this._overlayElement)) {
      event.stopPropagation();
      this._openedStateController.close(true);
    }
    if (event.key === "Tab") {
      if (event.shiftKey) {
        this.__onGlobalShiftTab(event);
      } else {
        this.__onGlobalTab(event);
      }
    }
  }
  /** @private */
  __onGlobalTab(event) {
    const overlayPart = this._overlayElement.$.overlay;
    if (this.target && isElementFocused(this.target)) {
      event.preventDefault();
      overlayPart.focus();
      return;
    }
    const lastFocusable = this.__getLastFocusable(overlayPart);
    if (lastFocusable && isElementFocused(lastFocusable)) {
      const focusable = this.__getNextBodyFocusable(this.target);
      if (focusable && focusable !== overlayPart) {
        event.preventDefault();
        focusable.focus();
        return;
      }
    }
    const activeElement = getDeepActiveElement();
    const nextFocusable = this.__getNextBodyFocusable(activeElement);
    if (nextFocusable === overlayPart && lastFocusable) {
      lastFocusable.focus();
    }
  }
  /** @private */
  __onGlobalShiftTab(event) {
    const overlayPart = this._overlayElement.$.overlay;
    if (this.target && isElementFocused(this.target) && this.__shouldRestoreFocus) {
      this.__shouldRestoreFocus = false;
      return;
    }
    if (this.target && isElementFocused(overlayPart)) {
      event.preventDefault();
      this.target.focus();
      return;
    }
    const nextFocusable = this.__getNextBodyFocusable(this.target);
    if (nextFocusable && isElementFocused(nextFocusable)) {
      const lastFocusable = this.__getLastFocusable(overlayPart);
      if (lastFocusable) {
        event.preventDefault();
        lastFocusable.focus();
      }
    }
  }
  /** @private */
  __getNextBodyFocusable(target) {
    const focusables = getFocusableElements(document.body);
    const idx = focusables.findIndex((el) => el === target);
    return focusables[idx + 1];
  }
  /** @private */
  __getLastFocusable(container) {
    const focusables = getFocusableElements(container);
    return focusables.pop();
  }
  /** @private */
  __onTargetFocusIn() {
    this.__focusInside = true;
    if (this.__hasTrigger("focus")) {
      if (this.__hasTrigger("click") && !isKeyboardActive()) {
        return;
      }
      if (!this.__shouldRestoreFocus) {
        this.__shouldRestoreFocus = true;
        this._openedStateController.open({ trigger: "focus" });
      }
    }
  }
  /** @private */
  __onTargetFocusOut(event) {
    if (!isLastOverlay(this._overlayElement)) {
      return;
    }
    if (this.__hasTrigger("focus") && this.__mouseDownInside || this._overlayElement.contains(event.relatedTarget)) {
      return;
    }
    this.__handleFocusout();
  }
  /** @private */
  __onTargetMouseEnter() {
    this.__hoverInside = true;
    if (this.__hasTrigger("hover") && !this.opened) {
      if (this.modal) {
        this.target.style.pointerEvents = "auto";
      }
      this._openedStateController.open({ trigger: "hover" });
    }
  }
  /** @private */
  __onTargetMouseLeave(event) {
    if (this._overlayElement.opened && !isLastOverlay(this._overlayElement)) {
      return;
    }
    if (this._overlayElement.contains(event.relatedTarget)) {
      return;
    }
    this.__handleMouseLeave();
  }
  /** @private */
  __onOverlayFocusIn() {
    this.__focusInside = true;
    if (this.__hasTrigger("focus") || this.__hasTrigger("click")) {
      this.__shouldRestoreFocus = true;
    }
  }
  /** @private */
  __onOverlayFocusOut(event) {
    if (!isLastOverlay(this._overlayElement)) {
      return;
    }
    if (this.__hasTrigger("focus") && this.__mouseDownInside || event.relatedTarget === this.target || this._overlayElement.contains(event.relatedTarget)) {
      return;
    }
    this.__handleFocusout();
  }
  /** @private */
  __onOverlayMouseDown() {
    if (this.__hasTrigger("focus")) {
      this.__mouseDownInside = true;
      document.addEventListener(
        "mouseup",
        () => {
          this.__mouseDownInside = false;
        },
        { once: true }
      );
    }
  }
  /** @private */
  __onOverlayMouseEnter() {
    this.__hoverInside = true;
    if (this.__hasTrigger("hover") && this._openedStateController.isClosing) {
      this._openedStateController.open({ immediate: true });
    }
  }
  /** @private */
  __onOverlayMouseLeave(event) {
    if (!isLastOverlay(this._overlayElement)) {
      return;
    }
    if (event.relatedTarget === this.target) {
      return;
    }
    this.__handleMouseLeave();
  }
  /** @private */
  __handleFocusout() {
    this.__focusInside = false;
    if (this.__hasTrigger("hover") && this.__hoverInside) {
      return;
    }
    if (this.__hasTrigger("focus")) {
      this._openedStateController.close(true);
    }
  }
  /** @private */
  __handleMouseLeave() {
    this.__hoverInside = false;
    if (this.__hasTrigger("focus") && this.__focusInside) {
      return;
    }
    if (this.__hasTrigger("hover")) {
      this._openedStateController.close();
    }
  }
  /** @private */
  __onOpenedChanged(event) {
    this.opened = event.detail.value;
  }
  /** @private */
  __onOverlayOpened() {
    if (this.autofocus && !this.modal) {
      this._overlayElement.$.overlay.focus();
    }
  }
  /** @private */
  __onOverlayClosed() {
    if (this.__shouldRestoreFocus) {
      setTimeout(() => {
        this.__shouldRestoreFocus = false;
      });
    }
    if (this.modal && this.target.style.pointerEvents) {
      this.target.style.pointerEvents = "";
    }
    this.dispatchEvent(new CustomEvent("closed"));
  }
  /**
   * Close the popover if `noCloseOnEsc` isn't set to true.
   * @private
   */
  __onEscapePress(e2) {
    if (this.noCloseOnEsc || this.__isManual) {
      e2.preventDefault();
    }
  }
  /**
   * Close the popover if `noCloseOnOutsideClick` isn't set to true.
   * @private
   */
  __onOutsideClick(e2) {
    if (this.noCloseOnOutsideClick || this.__isManual) {
      e2.preventDefault();
    }
  }
  /** @private */
  __hasTrigger(trigger) {
    return Array.isArray(this.trigger) && this.trigger.includes(trigger);
  }
  /** @private */
  get __isManual() {
    return this.trigger == null || Array.isArray(this.trigger) && this.trigger.length === 0;
  }
  /** @private */
  __updateDimension(overlay2, dimension, value) {
    const prop = `--_vaadin-popover-content-${dimension}`;
    if (value) {
      overlay2.style.setProperty(prop, value);
    } else {
      overlay2.style.removeProperty(prop);
    }
  }
  /** @private */
  __updateContentHeight(height, overlay2) {
    if (overlay2) {
      this.__updateDimension(overlay2, "height", height);
    }
  }
  /** @private */
  __updateContentWidth(width, overlay2) {
    if (overlay2) {
      this.__updateDimension(overlay2, "width", width);
    }
  }
  /**
   * Fired when the popover is closed.
   *
   * @event closed
   */
}
defineCustomElement(Popover);
const _window$2 = window;
_window$2.Vaadin || (_window$2.Vaadin = {});
(_d = _window$2.Vaadin).Flow || (_d.Flow = {});
(_e = _window$2.Vaadin.Flow).popover || (_e.popover = {});
Object.assign(_window$2.Vaadin.Flow.popover, {
  setDefaultHideDelay: (hideDelay) => Popover.setDefaultHideDelay(hideDelay),
  setDefaultFocusDelay: (focusDelay) => Popover.setDefaultFocusDelay(focusDelay),
  setDefaultHoverDelay: (hoverDelay) => Popover.setDefaultHoverDelay(hoverDelay)
});
const { defaultHideDelay: defaultHideDelay$1, defaultFocusDelay: defaultFocusDelay$1, defaultHoverDelay: defaultHoverDelay$1 } = _window$2.Vaadin.Flow.popover;
if (defaultHideDelay$1) {
  Popover.setDefaultHideDelay(defaultHideDelay$1);
}
if (defaultFocusDelay$1) {
  Popover.setDefaultFocusDelay(defaultFocusDelay$1);
}
if (defaultHoverDelay$1) {
  Popover.setDefaultHoverDelay(defaultHoverDelay$1);
}
registerStyles$1(
  "vaadin-progress-bar",
  css`
    :host {
      height: calc(var(--lumo-size-l) / 10);
      margin: var(--lumo-space-s) 0;
    }

    [part='bar'] {
      border-radius: var(--lumo-border-radius-m);
      background-color: var(--lumo-contrast-10pct);
    }

    [part='value'] {
      border-radius: var(--lumo-border-radius-m);
      background-color: var(--lumo-primary-color);
      /* Use width instead of transform to preserve border radius */
      transform: none;
      width: calc(var(--vaadin-progress-value) * 100%);
      will-change: width;
      transition: 0.1s width linear;
    }

    /* Indeterminate mode */
    :host([indeterminate]) [part='value'] {
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to right,
        var(--lumo-primary-color-10pct) 10%,
        var(--lumo-primary-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to left,
        var(--lumo-primary-color-10pct) 10%,
        var(--lumo-primary-color)
      );
      width: 100%;
      background-color: transparent !important;
      background-image: var(--lumo-progress-indeterminate-progress-bar-background);
      opacity: 0.75;
      will-change: transform;
      animation: vaadin-progress-indeterminate 1.6s infinite cubic-bezier(0.645, 0.045, 0.355, 1);
    }

    @keyframes vaadin-progress-indeterminate {
      0% {
        transform: scaleX(0.015);
        transform-origin: 0% 0%;
      }

      25% {
        transform: scaleX(0.4);
      }

      50% {
        transform: scaleX(0.015);
        transform-origin: 100% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background);
      }

      50.1% {
        transform: scaleX(0.015);
        transform-origin: 100% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
      }

      75% {
        transform: scaleX(0.4);
      }

      100% {
        transform: scaleX(0.015);
        transform-origin: 0% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
      }
    }

    :host(:not([aria-valuenow])) [part='value']::before,
    :host([indeterminate]) [part='value']::before {
      content: '';
      display: block;
      width: 100%;
      height: 100%;
      border-radius: inherit;
      background-color: var(--lumo-primary-color);
      will-change: opacity;
      animation: vaadin-progress-pulse3 1.6s infinite cubic-bezier(0.645, 0.045, 0.355, 1);
    }

    @keyframes vaadin-progress-pulse3 {
      0% {
        opacity: 1;
      }

      10% {
        opacity: 0;
      }

      40% {
        opacity: 0;
      }

      50% {
        opacity: 1;
      }

      50.1% {
        opacity: 1;
      }

      60% {
        opacity: 0;
      }

      90% {
        opacity: 0;
      }

      100% {
        opacity: 1;
      }
    }

    /* Contrast color */
    :host([theme~='contrast']) [part='value'],
    :host([theme~='contrast']) [part='value']::before {
      background-color: var(--lumo-contrast-80pct);
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to right,
        var(--lumo-contrast-5pct) 10%,
        var(--lumo-contrast-80pct)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to left,
        var(--lumo-contrast-5pct) 10%,
        var(--lumo-contrast-60pct)
      );
    }

    /* Error color */
    :host([theme~='error']) [part='value'],
    :host([theme~='error']) [part='value']::before {
      background-color: var(--lumo-error-color);
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to right,
        var(--lumo-error-color-10pct) 10%,
        var(--lumo-error-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to left,
        var(--lumo-error-color-10pct) 10%,
        var(--lumo-error-color)
      );
    }

    /* Primary color */
    :host([theme~='success']) [part='value'],
    :host([theme~='success']) [part='value']::before {
      background-color: var(--lumo-success-color);
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to right,
        var(--lumo-success-color-10pct) 10%,
        var(--lumo-success-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to left,
        var(--lumo-success-color-10pct) 10%,
        var(--lumo-success-color)
      );
    }

    /* RTL specific styles */
    :host([indeterminate][dir='rtl']) [part='value'] {
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to left,
        var(--lumo-primary-color-10pct) 10%,
        var(--lumo-primary-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to right,
        var(--lumo-primary-color-10pct) 10%,
        var(--lumo-primary-color)
      );
      animation: vaadin-progress-indeterminate-rtl 1.6s infinite cubic-bezier(0.355, 0.045, 0.645, 1);
    }

    :host(:not([aria-valuenow])[dir='rtl']) [part='value']::before,
    :host([indeterminate][dir='rtl']) [part='value']::before {
      animation: vaadin-progress-pulse3 1.6s infinite cubic-bezier(0.355, 0.045, 0.645, 1);
    }

    @keyframes vaadin-progress-indeterminate-rtl {
      0% {
        transform: scaleX(0.015);
        transform-origin: 100% 0%;
      }

      25% {
        transform: scaleX(0.4);
      }

      50% {
        transform: scaleX(0.015);
        transform-origin: 0% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background);
      }

      50.1% {
        transform: scaleX(0.015);
        transform-origin: 0% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
      }

      75% {
        transform: scaleX(0.4);
      }

      100% {
        transform: scaleX(0.015);
        transform-origin: 100% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
      }
    }

    /* Contrast color */
    :host([theme~='contrast'][dir='rtl']) [part='value'],
    :host([theme~='contrast'][dir='rtl']) [part='value']::before {
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to left,
        var(--lumo-contrast-5pct) 10%,
        var(--lumo-contrast-80pct)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to right,
        var(--lumo-contrast-5pct) 10%,
        var(--lumo-contrast-60pct)
      );
    }

    /* Error color */
    :host([theme~='error'][dir='rtl']) [part='value'],
    :host([theme~='error'][dir='rtl']) [part='value']::before {
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to left,
        var(--lumo-error-color-10pct) 10%,
        var(--lumo-error-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to right,
        var(--lumo-error-color-10pct) 10%,
        var(--lumo-error-color)
      );
    }

    /* Primary color */
    :host([theme~='success'][dir='rtl']) [part='value'],
    :host([theme~='success'][dir='rtl']) [part='value']::before {
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to left,
        var(--lumo-success-color-10pct) 10%,
        var(--lumo-success-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to right,
        var(--lumo-success-color-10pct) 10%,
        var(--lumo-success-color)
      );
    }
  `,
  { moduleId: "lumo-progress-bar" }
);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const progressBarStyles = css`
  :host {
    display: block;
    width: 100%; /* prevent collapsing inside non-stretching column flex */
    height: 8px;
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='bar'] {
    height: 100%;
  }

  [part='value'] {
    height: 100%;
    transform-origin: 0 50%;
    transform: scaleX(var(--vaadin-progress-value));
  }

  :host([dir='rtl']) [part='value'] {
    transform-origin: 100% 50%;
  }

  @media (forced-colors: active) {
    [part='bar'] {
      outline: 1px solid;
    }

    [part='value'] {
      background-color: AccentColor !important;
      forced-color-adjust: none;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ProgressMixin = (superClass) => class VaadinProgressMixin extends superClass {
  static get properties() {
    return {
      /**
       * Current progress value.
       */
      value: {
        type: Number,
        observer: "_valueChanged"
      },
      /**
       * Minimum bound of the progress bar.
       * @type {number}
       */
      min: {
        type: Number,
        value: 0,
        observer: "_minChanged"
      },
      /**
       * Maximum bound of the progress bar.
       * @type {number}
       */
      max: {
        type: Number,
        value: 1,
        observer: "_maxChanged"
      },
      /**
       * Indeterminate state of the progress bar.
       * This property takes precedence over other state properties (min, max, value).
       * @type {boolean}
       */
      indeterminate: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return ["_normalizedValueChanged(value, min, max)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "progressbar");
  }
  /** @private */
  _normalizedValueChanged(value, min, max) {
    const newNormalizedValue = this._normalizeValue(value, min, max);
    this.style.setProperty("--vaadin-progress-value", newNormalizedValue);
  }
  /** @private */
  _valueChanged(newV) {
    this.setAttribute("aria-valuenow", newV);
  }
  /** @private */
  _minChanged(newV) {
    this.setAttribute("aria-valuemin", newV);
  }
  /** @private */
  _maxChanged(newV) {
    this.setAttribute("aria-valuemax", newV);
  }
  /**
   * Percent of current progress relative to whole progress bar (max - min)
   * @private
   */
  _normalizeValue(value, min, max) {
    let nV;
    if (!value && value !== 0) {
      nV = 0;
    } else if (min >= max) {
      nV = 1;
    } else {
      nV = (value - min) / (max - min);
      nV = Math.min(Math.max(nV, 0), 1);
    }
    return nV;
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-progress-bar", progressBarStyles, { moduleId: "vaadin-progress-bar-styles" });
class ProgressBar extends ElementMixin(ThemableMixin(ProgressMixin(PolymerElement))) {
  static get is() {
    return "vaadin-progress-bar";
  }
  static get template() {
    return html`
      <div part="bar">
        <div part="value"></div>
      </div>
    `;
  }
}
defineCustomElement(ProgressBar);
registerStyles$1(
  "vaadin-radio-button",
  css`
    :host {
      color: var(--vaadin-radio-button-label-color, var(--lumo-body-text-color));
      font-size: var(--vaadin-radio-button-label-font-size, var(--lumo-font-size-m));
      font-family: var(--lumo-font-family);
      line-height: var(--lumo-line-height-s);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
      cursor: default;
      outline: none;
      --_radio-button-size: var(--vaadin-radio-button-size, calc(var(--lumo-size-m) / 2));
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      --_selection-color: var(--vaadin-selection-color, var(--lumo-primary-color));
    }

    :host([has-label]) ::slotted(label) {
      padding: var(
        --vaadin-radio-button-label-padding,
        var(--lumo-space-xs) var(--lumo-space-s) var(--lumo-space-xs) var(--lumo-space-xs)
      );
    }

    [part='radio'] {
      width: var(--_radio-button-size);
      height: var(--_radio-button-size);
      margin: var(--lumo-space-xs);
      position: relative;
      border-radius: 50%;
      background: var(--vaadin-radio-button-background, var(--lumo-contrast-20pct));
      transition:
        transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2),
        background-color 0.15s;
      will-change: transform;
      cursor: var(--lumo-clickable-cursor);
      /* Default field border color */
      --_input-border-color: var(--vaadin-input-field-border-color, var(--lumo-contrast-50pct));
    }

    /* Used for activation "halo" */
    [part='radio']::before {
      pointer-events: none;
      color: transparent;
      width: 100%;
      height: 100%;
      line-height: var(--_radio-button-size);
      border-radius: inherit;
      background-color: inherit;
      transform: scale(1.4);
      opacity: 0;
      transition:
        transform 0.1s,
        opacity 0.8s;
      will-change: transform, opacity;
    }

    /* Used for the dot */
    [part='radio']::after {
      content: '';
      pointer-events: none;
      width: 0;
      height: 0;
      border: var(--vaadin-radio-button-dot-size, 3px) solid
        var(--vaadin-radio-button-dot-color, var(--lumo-primary-contrast-color));
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      transition: 0.25s transform;
      will-change: transform;
      background-clip: content-box;
    }

    :host([checked]) {
      --vaadin-input-field-border-color: transparent;
    }

    :host([checked]) [part='radio'] {
      background-color: var(--_selection-color);
    }

    :host([checked]) [part='radio']::after {
      transform: translate(-50%, -50%) scale(1);
    }

    :host(:not([checked]):not([disabled]):hover) [part='radio'] {
      background: var(--vaadin-radio-button-background-hover, var(--lumo-contrast-30pct));
    }

    :host([active]) [part='radio'] {
      transform: scale(0.9);
      transition-duration: 0.05s;
    }

    :host([active][checked]) [part='radio'] {
      transform: scale(1.1);
    }

    :host([active]:not([checked])) [part='radio']::before {
      transition-duration: 0.01s, 0.01s;
      transform: scale(0);
      opacity: 0.4;
    }

    :host([focus-ring]) [part='radio'] {
      box-shadow:
        0 0 0 1px var(--lumo-base-color),
        0 0 0 calc(var(--_focus-ring-width) + 1px) var(--_focus-ring-color),
        inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
    }

    :host([disabled]) {
      pointer-events: none;
      color: var(--lumo-disabled-text-color);
      --vaadin-input-field-border-color: var(--lumo-contrast-20pct);
    }

    :host([disabled]) ::slotted(label) {
      color: inherit;
    }

    :host([disabled]) [part='radio'] {
      background-color: var(--vaadin-radio-button-disabled-background, var(--lumo-contrast-10pct));
    }

    :host([disabled]) [part='radio']::after {
      border-color: var(--vaadin-radio-button-disabled-dot-color, var(--lumo-contrast-30pct));
    }

    /* RTL specific styles */
    :host([dir='rtl'][has-label]) ::slotted(label) {
      padding: var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-s);
    }
  `,
  { moduleId: "lumo-radio-button" }
);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const RadioButtonMixin = (superclass) => class RadioButtonMixinClass extends LabelMixin(CheckedMixin(DelegateFocusMixin(ActiveMixin(superclass)))) {
  static get properties() {
    return {
      /**
       * The name of the radio button.
       *
       * @type {string}
       */
      name: {
        type: String,
        value: ""
      },
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       *
       * @override
       * @protected
       */
      tabindex: {
        type: Number,
        value: 0,
        reflectToAttribute: true
      }
    };
  }
  /** @override */
  static get delegateAttrs() {
    return [...super.delegateAttrs, "name"];
  }
  constructor() {
    super();
    this._setType("radio");
    this.value = "on";
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const radioButtonStyles = css`
  :host {
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([disabled]) {
    -webkit-tap-highlight-color: transparent;
  }

  .vaadin-radio-button-container {
    display: grid;
    grid-template-columns: auto 1fr;
    align-items: baseline;
  }

  [part='radio'],
  ::slotted(input),
  ::slotted(label) {
    grid-row: 1;
  }

  [part='radio'],
  ::slotted(input) {
    grid-column: 1;
  }

  [part='radio'] {
    width: var(--vaadin-radio-button-size, 1em);
    height: var(--vaadin-radio-button-size, 1em);
    --_input-border-width: var(--vaadin-input-field-border-width, 0);
    --_input-border-color: var(--vaadin-input-field-border-color, transparent);
    box-shadow: inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
  }

  [part='radio']::before {
    display: block;
    content: '\\202F';
    line-height: var(--vaadin-radio-button-size, 1em);
    contain: paint;
  }

  /* visually hidden */
  ::slotted(input) {
    opacity: 0;
    cursor: inherit;
    margin: 0;
    align-self: stretch;
    -webkit-appearance: none;
    width: initial;
    height: initial;
  }

  @media (forced-colors: active) {
    [part='radio'] {
      outline: 1px solid;
      outline-offset: -1px;
    }

    :host([focused]) [part='radio'] {
      outline-width: 2px;
    }

    :host([disabled]) [part='radio'] {
      outline-color: GrayText;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-radio-button", radioButtonStyles, { moduleId: "vaadin-radio-button-styles" });
class RadioButton extends RadioButtonMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-radio-button";
  }
  static get template() {
    return html`
      <div class="vaadin-radio-button-container">
        <div part="radio" aria-hidden="true"></div>
        <slot name="input"></slot>
        <slot name="label"></slot>
      </div>
    `;
  }
}
defineCustomElement(RadioButton);
const radioGroup = css`
  :host {
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-m);
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: var(--lumo-space-xs) 0;
  }

  :host::before {
    /* Effective height of vaadin-radio-button */
    height: var(--lumo-size-s);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  :host([theme~='vertical']) [part='group-field'] {
    flex-direction: column;
  }

  :host([disabled]) [part='label'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([focused]:not([readonly])) [part='label'] {
    color: var(--lumo-primary-text-color);
  }

  :host(:hover:not([readonly]):not([focused])) [part='label'],
  :host(:hover:not([readonly])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused])) [part='label'] {
      color: var(--lumo-secondary-text-color);
    }
  }
`;
registerStyles$1("vaadin-radio-group", [requiredField, helper, radioGroup], { moduleId: "lumo-radio-group" });
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const RadioGroupMixin = (superclass) => class RadioGroupMixinClass extends FieldMixin(FocusMixin(DisabledMixin(KeyboardMixin(superclass)))) {
  static get properties() {
    return {
      /**
       * The name of the control, which is submitted with the form data.
       */
      name: {
        type: String,
        observer: "__nameChanged",
        sync: true
      },
      /**
       * The value of the radio group.
       *
       * @type {string}
       */
      value: {
        type: String,
        notify: true,
        value: "",
        sync: true,
        observer: "__valueChanged"
      },
      /**
       * When present, the user cannot modify the value of the radio group.
       * The property works similarly to the `disabled` property.
       * While the `disabled` property disables all radio buttons inside the group,
       * the `readonly` property disables only unchecked ones.
       *
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true,
        observer: "__readonlyChanged"
      },
      /**
       * @type {string}
       * @private
       */
      _fieldName: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.__registerRadioButton = this.__registerRadioButton.bind(this);
    this.__unregisterRadioButton = this.__unregisterRadioButton.bind(this);
    this.__onRadioButtonCheckedChange = this.__onRadioButtonCheckedChange.bind(this);
    this._tooltipController = new TooltipController(this);
    this._tooltipController.addEventListener("tooltip-changed", (event) => {
      const tooltip = event.detail.node;
      if (tooltip && tooltip.isConnected) {
        const inputs = this.__radioButtons.map((radio) => radio.inputElement);
        this._tooltipController.setAriaTarget(inputs);
      } else {
        this._tooltipController.setAriaTarget([]);
      }
    });
  }
  /**
   * A collection of the group's radio buttons.
   *
   * @return {!Array<!RadioButton>}
   * @private
   */
  get __radioButtons() {
    return this.__filterRadioButtons([...this.children]);
  }
  /**
   * A currently selected radio button.
   *
   * @return {!RadioButton | undefined}
   * @private
   */
  get __selectedRadioButton() {
    return this.__radioButtons.find((radioButton) => radioButton.checked);
  }
  /**
   * @return {boolean}
   * @private
   */
  get isHorizontalRTL() {
    return this.__isRTL && this._theme !== "vertical";
  }
  /** @protected */
  ready() {
    super.ready();
    this.ariaTarget = this;
    this.setAttribute("role", "radiogroup");
    this._fieldName = `${this.localName}-${generateUniqueId()}`;
    const slot = this.shadowRoot.querySelector("slot:not([name])");
    this._observer = new SlotObserver(slot, ({ addedNodes, removedNodes }) => {
      this.__filterRadioButtons(addedNodes).reverse().forEach(this.__registerRadioButton);
      this.__filterRadioButtons(removedNodes).forEach(this.__unregisterRadioButton);
      const inputs = this.__radioButtons.map((radio) => radio.inputElement);
      this._tooltipController.setAriaTarget(inputs);
    });
    this.addController(this._tooltipController);
  }
  /**
   * @param {!Array<!Node>} nodes
   * @return {!Array<!RadioButton>}
   * @private
   */
  __filterRadioButtons(nodes) {
    return nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE && node.localName === "vaadin-radio-button");
  }
  /**
   * Override method inherited from `KeyboardMixin`
   * to implement the custom keyboard navigation as a replacement for the native one
   * in order for the navigation to work the same way across different browsers.
   *
   * @param {!KeyboardEvent} event
   * @override
   * @protected
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    const radioButton = event.composedPath().find((node) => node.nodeType === Node.ELEMENT_NODE && node.localName === "vaadin-radio-button");
    if (["ArrowLeft", "ArrowUp"].includes(event.key)) {
      event.preventDefault();
      this.__selectNextRadioButton(radioButton);
    }
    if (["ArrowRight", "ArrowDown"].includes(event.key)) {
      event.preventDefault();
      this.__selectPrevRadioButton(radioButton);
    }
  }
  /**
   * Override an observer from `FieldMixin`.
   *
   * @param {boolean} invalid
   * @protected
   * @override
   */
  _invalidChanged(invalid) {
    super._invalidChanged(invalid);
    if (invalid) {
      this.setAttribute("aria-invalid", "true");
    } else {
      this.removeAttribute("aria-invalid");
    }
  }
  /** @private */
  __nameChanged(name) {
    this.__radioButtons.forEach((radioButton) => {
      radioButton.name = name || this._fieldName;
    });
  }
  /**
   * @param {number} index
   * @private
   */
  __selectNextRadioButton(radioButton) {
    const index = this.__radioButtons.indexOf(radioButton);
    this.__selectIncRadioButton(index, this.isHorizontalRTL ? 1 : -1);
  }
  /**
   * @param {number} index
   * @private
   */
  __selectPrevRadioButton(radioButton) {
    const index = this.__radioButtons.indexOf(radioButton);
    this.__selectIncRadioButton(index, this.isHorizontalRTL ? -1 : 1);
  }
  /**
   * @param {number} index
   * @param {number} step
   * @private
   */
  __selectIncRadioButton(index, step) {
    const newIndex = (this.__radioButtons.length + index + step) % this.__radioButtons.length;
    const newRadioButton = this.__radioButtons[newIndex];
    if (newRadioButton.disabled) {
      this.__selectIncRadioButton(newIndex, step);
    } else {
      newRadioButton.focusElement.focus();
      newRadioButton.focusElement.click();
    }
  }
  /**
   * Registers the radio button after adding it to the group.
   *
   * @param {!RadioButton} radioButton
   * @private
   */
  __registerRadioButton(radioButton) {
    radioButton.name = this.name || this._fieldName;
    radioButton.addEventListener("checked-changed", this.__onRadioButtonCheckedChange);
    if (this.disabled || this.readonly) {
      radioButton.disabled = true;
    }
    if (radioButton.checked) {
      this.__selectRadioButton(radioButton);
    }
  }
  /**
   * Unregisters the radio button before removing it from the group.
   *
   * @param {!RadioButton} radioButton
   * @private
   */
  __unregisterRadioButton(radioButton) {
    radioButton.removeEventListener("checked-changed", this.__onRadioButtonCheckedChange);
    if (radioButton.value === this.value) {
      this.__selectRadioButton(null);
    }
  }
  /**
   * @param {!CustomEvent} event
   * @private
   */
  __onRadioButtonCheckedChange(event) {
    if (event.target.checked) {
      this.__selectRadioButton(event.target);
    }
  }
  /**
   * Whenever the user sets a non-empty value,
   * the method tries to select the radio button with that value
   * showing a warning if no radio button was found with the given value.
   * If the new value is empty, the method deselects the currently selected radio button.
   * At last, the method toggles the `has-value` attribute considering the new value.
   *
   * @param {string | null | undefined} newValue
   * @param {string | null | undefined} oldValue
   * @private
   */
  __valueChanged(newValue, oldValue) {
    if (oldValue === void 0 && newValue === "") {
      return;
    }
    if (newValue) {
      const newSelectedRadioButton = this.__radioButtons.find((radioButton) => {
        return radioButton.value === newValue;
      });
      if (newSelectedRadioButton) {
        this.__selectRadioButton(newSelectedRadioButton);
        this.toggleAttribute("has-value", true);
      } else {
        console.warn(`The radio button with the value "${newValue}" was not found.`);
      }
    } else {
      this.__selectRadioButton(null);
      this.removeAttribute("has-value");
    }
    if (oldValue !== void 0) {
      this._requestValidation();
    }
  }
  /**
   * Whenever `readonly` property changes on the group element,
   * the method updates the `disabled` property for the radio buttons.
   *
   * @param {boolean} newValue
   * @param {boolean} oldValue
   * @private
   */
  __readonlyChanged(newValue, oldValue) {
    if (!newValue && oldValue === void 0) {
      return;
    }
    if (oldValue !== newValue) {
      this.__updateRadioButtonsDisabledProperty();
    }
  }
  /**
   * Override method inherited from `DisabledMixin`
   * to update the `disabled` property for the radio buttons
   * whenever the property changes on the group element.
   *
   * @param {boolean} newValue
   * @param {boolean} oldValue
   * @override
   * @protected
   */
  _disabledChanged(newValue, oldValue) {
    super._disabledChanged(newValue, oldValue);
    if (!newValue && oldValue === void 0) {
      return;
    }
    if (oldValue !== newValue) {
      this.__updateRadioButtonsDisabledProperty();
    }
  }
  /**
   * Override method inherited from `FocusMixin`
   * to prevent removing the `focused` attribute
   * when focus moves between radio buttons inside the group.
   *
   * @param {!FocusEvent} event
   * @return {boolean}
   * @protected
   */
  _shouldRemoveFocus(event) {
    return !this.contains(event.relatedTarget);
  }
  /**
   * Override method inherited from `FocusMixin`
   * to run validation when the group loses focus.
   *
   * @param {boolean} focused
   * @override
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
  /**
   * @param {RadioButton} radioButton
   * @private
   */
  __selectRadioButton(radioButton) {
    if (radioButton) {
      this.value = radioButton.value;
    } else {
      this.value = "";
    }
    this.__radioButtons.forEach((button2) => {
      button2.checked = button2 === radioButton;
    });
    if (this.readonly) {
      this.__updateRadioButtonsDisabledProperty();
    }
  }
  /**
   * If the group is read-only, the method disables the unchecked radio buttons.
   * Otherwise, the method propagates the group's `disabled` property to the radio buttons.
   *
   * @private
   */
  __updateRadioButtonsDisabledProperty() {
    this.__radioButtons.forEach((button2) => {
      if (this.readonly) {
        button2.disabled = button2 !== this.__selectedRadioButton;
      } else {
        button2.disabled = this.disabled;
      }
    });
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const radioGroupStyles = css`
  :host {
    display: inline-flex;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  .vaadin-group-field-container {
    display: flex;
    flex-direction: column;
    width: 100%;
  }

  [part='group-field'] {
    display: flex;
    flex-wrap: wrap;
  }

  :host(:not([has-label])) [part='label'] {
    display: none;
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-radio-group", radioGroupStyles, { moduleId: "vaadin-radio-group-styles" });
class RadioGroup extends RadioGroupMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-radio-group";
  }
  static get template() {
    return html`
      <div class="vaadin-group-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div part="group-field">
          <slot></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
}
defineCustomElement(RadioGroup);
function stateReducer(state, action) {
  switch (action.type) {
    case "stateKeyChanged":
      const { value } = action;
      return {
        ...state,
        key: value
      };
    default:
      return state;
  }
}
const emptyAction = () => {
};
class ReactAdapterElement extends HTMLElement {
  constructor() {
    super();
    __privateAdd(this, _ReactAdapterElement_instances);
    __privateAdd(this, _root);
    __privateAdd(this, _rootRendered, false);
    __privateAdd(this, _rendering);
    __privateAdd(this, _state, /* @__PURE__ */ Object.create(null));
    __privateAdd(this, _stateSetters, /* @__PURE__ */ new Map());
    __privateAdd(this, _customEvents, /* @__PURE__ */ new Map());
    __privateAdd(this, _dispatchFlowState, emptyAction);
    __privateAdd(this, _readyCallback, /* @__PURE__ */ new Map());
    __privateAdd(this, _renderHooks);
    __privateAdd(this, _Wrapper);
    __privateAdd(this, _unmounting);
    __privateSet(this, _renderHooks, {
      useState: this.useState.bind(this),
      useCustomEvent: this.useCustomEvent.bind(this),
      useContent: this.useContent.bind(this)
    });
    __privateSet(this, _Wrapper, __privateMethod(this, _ReactAdapterElement_instances, renderWrapper_fn).bind(this));
    __privateMethod(this, _ReactAdapterElement_instances, markAsUsed_fn).call(this);
  }
  async connectedCallback() {
    __privateSet(this, _rendering, /* @__PURE__ */ reactExports.createElement(__privateGet(this, _Wrapper)));
    const createNewRoot = this.dispatchEvent(
      new CustomEvent("flow-portal-add", {
        bubbles: true,
        cancelable: true,
        composed: true,
        detail: {
          children: __privateGet(this, _rendering),
          domNode: this
        }
      })
    );
    if (!createNewRoot || __privateGet(this, _root)) {
      return;
    }
    await __privateGet(this, _unmounting);
    __privateSet(this, _root, clientExports.createRoot(this));
    __privateMethod(this, _ReactAdapterElement_instances, maybeRenderRoot_fn).call(this);
    __privateGet(this, _root).render(__privateGet(this, _rendering));
  }
  /**
   * Add a callback for specified element identifier to be called when
   * react element is ready.
   * <p>
   * For internal use only. May be renamed or removed in a future release.
   *
   * @param id element identifier that callback is for
   * @param readyCallback callback method to be informed on element ready state
   * @internal
   */
  addReadyCallback(id, readyCallback) {
    __privateGet(this, _readyCallback).set(id, readyCallback);
  }
  async disconnectedCallback() {
    if (!__privateGet(this, _root)) {
      this.dispatchEvent(
        new CustomEvent("flow-portal-remove", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: {
            children: __privateGet(this, _rendering),
            domNode: this
          }
        })
      );
    } else {
      __privateSet(this, _unmounting, Promise.resolve());
      await __privateGet(this, _unmounting);
      __privateGet(this, _root).unmount();
      __privateSet(this, _root, void 0);
    }
    __privateSet(this, _rootRendered, false);
    __privateSet(this, _rendering, void 0);
  }
  /**
   * A hook API for using stateful JS properties of the Web Component from
   * the React `render()`.
   *
   * @typeParam T - Type of the state value
   *
   * @param key - Web Component property name, which is used for two-way
   * value propagation from the server and back.
   * @param initialValue - Fallback initial value (optional). Only applies if
   * the Java component constructor does not invoke `setState`.
   * @returns A tuple with two values:
   * 1. The current state.
   * 2. The `set` function for changing the state and triggering render
   * @protected
   */
  useState(key, initialValue) {
    if (__privateGet(this, _stateSetters).has(key)) {
      return [__privateGet(this, _state)[key], __privateGet(this, _stateSetters).get(key)];
    }
    const value = this[key] ?? initialValue;
    __privateGet(this, _state)[key] = value;
    Object.defineProperty(this, key, {
      enumerable: true,
      get() {
        return __privateGet(this, _state)[key];
      },
      set(nextValue) {
        __privateGet(this, _state)[key] = nextValue;
        __privateGet(this, _dispatchFlowState).call(this, { type: "stateKeyChanged", key, value });
      }
    });
    const dispatchChangedEvent = this.useCustomEvent(`${key}-changed`, { detail: { value } });
    const setValue = (value2) => {
      __privateGet(this, _state)[key] = value2;
      dispatchChangedEvent({ value: value2 });
      __privateGet(this, _dispatchFlowState).call(this, { type: "stateKeyChanged", key, value: value2 });
    };
    __privateGet(this, _stateSetters).set(key, setValue);
    return [value, setValue];
  }
  /**
   * A hook helper to simplify dispatching a `CustomEvent` on the Web
   * Component from React.
   *
   * @typeParam T - The type for `event.detail` value (optional).
   *
   * @param type - The `CustomEvent` type string.
   * @param options - The settings for the `CustomEvent`.
   * @returns The `dispatch` function. The function parameters change
   * depending on the `T` generic type:
   * - For `undefined` type (default), has no parameters.
   * - For other types, has one parameter for the `event.detail` value of that type.
   * @protected
   */
  useCustomEvent(type, options = {}) {
    if (!__privateGet(this, _customEvents).has(type)) {
      const dispatch = (detail) => {
        const eventInitDict = detail === void 0 ? options : {
          ...options,
          detail
        };
        const event = new CustomEvent(type, eventInitDict);
        return this.dispatchEvent(event);
      };
      __privateGet(this, _customEvents).set(type, dispatch);
      return dispatch;
    }
    return __privateGet(this, _customEvents).get(type);
  }
  /**
   * Prepare content container for Flow to bind server Element to.
   *
   * @param name container name attribute matching server name attribute
   * @protected
   */
  useContent(name) {
    reactExports.useEffect(() => {
      var _a2;
      (_a2 = __privateGet(this, _readyCallback).get(name)) == null ? void 0 : _a2();
    }, []);
    return /* @__PURE__ */ reactExports.createElement("flow-content-container", { name, style: { display: "contents" } });
  }
}
_root = new WeakMap();
_rootRendered = new WeakMap();
_rendering = new WeakMap();
_state = new WeakMap();
_stateSetters = new WeakMap();
_customEvents = new WeakMap();
_dispatchFlowState = new WeakMap();
_readyCallback = new WeakMap();
_renderHooks = new WeakMap();
_Wrapper = new WeakMap();
_unmounting = new WeakMap();
_ReactAdapterElement_instances = new WeakSet();
maybeRenderRoot_fn = function() {
  if (__privateGet(this, _rootRendered) || !__privateGet(this, _root)) {
    return;
  }
  __privateGet(this, _root).render(/* @__PURE__ */ reactExports.createElement(__privateGet(this, _Wrapper)));
  __privateSet(this, _rootRendered, true);
};
renderWrapper_fn = function() {
  const [state, dispatchFlowState] = reactExports.useReducer(stateReducer, __privateGet(this, _state));
  __privateSet(this, _state, state);
  __privateSet(this, _dispatchFlowState, dispatchFlowState);
  return this.render(__privateGet(this, _renderHooks));
};
markAsUsed_fn = function() {
  let vaadinObject = window.Vaadin || {};
  if (vaadinObject.developmentMode) {
    vaadinObject.registrations = vaadinObject.registrations || [];
    vaadinObject.registrations.push({
      is: "ReactAdapterElement",
      version: "24.6.3"
    });
  }
};
var _jsxFileName = "F:\\Dev\\java\\jmix\\ProjectManager\\.jmix\\screen-designer\\frontend\\generated\\jar-resources\\ReactRouterOutletElement.tsx";
class ReactRouterOutletElement extends ReactAdapterElement {
  render() {
    return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Outlet, {}, void 0, false, { fileName: _jsxFileName, lineNumber: 7, columnNumber: 12 }, this);
  }
}
customElements.define("react-router-outlet", ReactRouterOutletElement);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-select-item", item, { moduleId: "lumo-select-item" });
registerStyles$1("vaadin-select-list-box", listBox, { moduleId: "lumo-select-list-box" });
const select = css`
  :host(:not([theme*='align'])) ::slotted([slot='value']) {
    text-align: start;
  }

  [part='input-field'] {
    cursor: var(--lumo-clickable-cursor);
  }

  [part='input-field'] ::slotted([slot='value']) {
    font-weight: var(--vaadin-input-field-value-font-weight, 500);
  }

  [part='input-field'] ::slotted([slot='value']:not([placeholder])) {
    color: var(--vaadin-input-field-value-color, var(--lumo-body-text-color));
  }

  :host([readonly]) [part='input-field'] ::slotted([slot='value']:not([placeholder])) {
    color: var(--lumo-secondary-text-color);
  }

  /* placeholder styles */
  [part='input-field'] ::slotted([slot='value'][placeholder]) {
    color: var(--vaadin-input-field-placeholder-color, var(--lumo-secondary-text-color));
  }

  :host(:is([readonly], [disabled])) ::slotted([slot='value'][placeholder]) {
    opacity: 0;
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
  }

  /* Highlight the toggle button when hovering over the entire component */
  :host(:hover:not([readonly]):not([disabled])) [part='toggle-button'] {
    color: var(--lumo-contrast-80pct);
  }

  :host([theme~='small']) [part='input-field'] ::slotted([slot='value']) {
    --_lumo-selected-item-height: var(--lumo-size-s);
    --_lumo-selected-item-padding: 0;
  }
`;
registerStyles$1("vaadin-select", [inputFieldShared$1, select], { moduleId: "lumo-select" });
registerStyles$1(
  "vaadin-select-value-button",
  css`
    :host {
      font-family: var(--lumo-font-family);
      font-size: var(--vaadin-input-field-value-font-size, var(--lumo-font-size-m));
      padding: 0 0.25em;
      --_lumo-selected-item-height: var(--lumo-size-m);
      --_lumo-selected-item-padding: 0.5em;
    }

    ::slotted(*) {
      min-height: var(--_lumo-selected-item-height);
      padding-top: var(--_lumo-selected-item-padding);
      padding-bottom: var(--_lumo-selected-item-padding);
      font-size: inherit;
    }

    ::slotted(*:hover) {
      background-color: transparent;
    }
  `,
  { moduleId: "lumo-select-value-button" }
);
const selectOverlay = css`
  :host {
    --_lumo-item-selected-icon-display: block;
  }

  /* Small viewport adjustment */
  :host([phone]) {
    /* stylelint-disable declaration-block-no-redundant-longhand-properties */
    top: 0 !important;
    right: 0 !important;
    bottom: var(--vaadin-overlay-viewport-bottom, 0) !important;
    left: 0 !important;
    /* stylelint-enable declaration-block-no-redundant-longhand-properties */
    align-items: stretch;
    justify-content: flex-end;
  }

  :host([no-vertical-overlap][top-aligned]) [part='overlay'] {
    margin-block-start: var(--lumo-space-xs);
  }

  :host([no-vertical-overlap][bottom-aligned]) [part='overlay'] {
    margin-block-end: var(--lumo-space-xs);
  }

  :host([theme~='align-left']) {
    text-align: left;
  }

  :host([theme~='align-right']) {
    text-align: right;
  }

  :host([theme~='align-center']) {
    text-align: center;
  }
`;
registerStyles$1("vaadin-select-overlay", [menuOverlay, selectOverlay], { moduleId: "lumo-select-overlay" });
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SelectItem extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-select-item";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "option");
  }
}
defineCustomElement(SelectItem);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SelectListBox extends ListMixin(ThemableMixin(DirMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-select-list-box";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='items'] {
          height: 100%;
          width: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }
      </style>
      <div part="items">
        <slot></slot>
      </div>
    `;
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        readOnly: true
      }
    };
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "listbox");
  }
}
defineCustomElement(SelectListBox);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const SelectOverlayMixin = (superClass) => class SelectOverlayMixin extends PositionMixin(OverlayMixin(DirMixin(superClass))) {
  static get observers() {
    return ["_updateOverlayWidth(opened, owner)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.restoreFocusOnClose = true;
  }
  /** @protected */
  _getMenuElement() {
    return Array.from(this.children).find((el) => el.localName !== "style");
  }
  /** @private */
  _updateOverlayWidth(opened, owner) {
    if (opened && owner) {
      const widthProperty = "--vaadin-select-overlay-width";
      const customWidth = getComputedStyle(owner).getPropertyValue(widthProperty);
      if (customWidth === "") {
        this.style.removeProperty(widthProperty);
      } else {
        this.style.setProperty(widthProperty, customWidth);
      }
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const selectOverlayStyles = css`
  :host {
    align-items: flex-start;
    justify-content: flex-start;
  }

  :host(:not([phone])) [part='overlay'] {
    min-width: var(--vaadin-select-overlay-width, var(--vaadin-select-text-field-width));
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 3px solid;
    }
  }
`;
registerStyles$1("vaadin-select-overlay", [overlayStyles, selectOverlayStyles], {
  moduleId: "vaadin-select-overlay-styles"
});
class SelectOverlay extends SelectOverlayMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-select-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.owner = this.__dataHost;
    this.owner._overlayElement = this;
  }
  requestContentUpdate() {
    super.requestContentUpdate();
    if (this.owner) {
      const menuElement = this._getMenuElement();
      this.owner._assignMenuElement(menuElement);
    }
  }
}
defineCustomElement(SelectOverlay);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const valueButton = css`
  :host {
    display: inline-block;
    position: relative;
    outline: none;
    white-space: nowrap;
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    min-width: 0;
    width: 0;
  }

  ::slotted(*) {
    padding-left: 0;
    padding-right: 0;
    flex: auto;
  }

  /* placeholder styles */
  ::slotted(*:not([selected])) {
    line-height: 1;
  }

  .vaadin-button-container {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-align: inherit;
    width: 100%;
    height: 100%;
    min-height: inherit;
    text-shadow: inherit;
  }

  [part='label'] {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 100%;
    line-height: inherit;
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-select-value-button", valueButton, { moduleId: "vaadin-select-value-button-styles" });
class SelectValueButton extends ButtonMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-select-value-button";
  }
  static get template() {
    return html`
      <div class="vaadin-button-container">
        <span part="label">
          <slot></slot>
        </span>
      </div>
    `;
  }
}
defineCustomElement(SelectValueButton);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd..
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const screenReaderOnly = css`
  .sr-only {
    border: 0 !important;
    clip: rect(1px, 1px, 1px, 1px) !important;
    -webkit-clip-path: inset(50%) !important;
    clip-path: inset(50%) !important;
    height: 1px !important;
    margin: -1px !important;
    overflow: hidden !important;
    padding: 0 !important;
    position: absolute !important;
    width: 1px !important;
    white-space: nowrap !important;
  }
`;
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ButtonController extends SlotController {
  constructor(host) {
    super(host, "value", "vaadin-select-value-button", {
      initializer: (button2, host2) => {
        host2._setFocusElement(button2);
        host2.ariaTarget = button2;
        host2.stateTarget = button2;
        button2.setAttribute("aria-haspopup", "listbox");
      }
    });
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const SelectBaseMixin = (superClass) => class SelectBaseMixin extends OverlayClassMixin(
  DelegateFocusMixin(DelegateStateMixin(KeyboardMixin(FieldMixin(superClass))))
) {
  static get properties() {
    return {
      /**
       * An array containing items that will be rendered as the options of the select.
       *
       * #### Example
       * ```js
       * select.items = [
       *   { label: 'Most recent first', value: 'recent' },
       *   { component: 'hr' },
       *   { label: 'Rating: low to high', value: 'rating-asc', className: 'asc' },
       *   { label: 'Rating: high to low', value: 'rating-desc', className: 'desc' },
       *   { component: 'hr' },
       *   { label: 'Price: low to high', value: 'price-asc', disabled: true },
       *   { label: 'Price: high to low', value: 'price-desc', disabled: true }
       * ];
       * ```
       *
       * Note: each item is rendered by default as the internal `<vaadin-select-item>` that is an extension of `<vaadin-item>`.
       * To render the item with a custom component, provide a tag name by the `component` property.
       *
       * @type {!Array<!SelectItem>}
       */
      items: {
        type: Array,
        observer: "__itemsChanged"
      },
      /**
       * Set when the select is open
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Custom function for rendering the content of the `<vaadin-select>`.
       * Receives two arguments:
       *
       * - `root` The `<vaadin-select-overlay>` internal container
       *   DOM element. Append your content to it.
       * - `select` The reference to the `<vaadin-select>` element.
       * @type {!SelectRenderer | undefined}
       */
      renderer: {
        type: Object
      },
      /**
       * The `value` property of the selected item, or an empty string
       * if no item is selected.
       * On change or initialization, the component finds the item which matches the
       * value and displays it.
       * If no value is provided to the component, it selects the first item without
       * value or empty value.
       * Hint: If you do not want to select any item by default, you can either set all
       * the values of inner vaadin-items, or set the vaadin-select value to
       * an inexistent value in the items list.
       * @type {string}
       */
      value: {
        type: String,
        value: "",
        notify: true,
        observer: "_valueChanged"
      },
      /**
       * The name of this element.
       */
      name: {
        type: String
      },
      /**
       * A hint to the user of what can be entered in the control.
       * The placeholder will be displayed in the case that there
       * is no item selected, or the selected item has an empty
       * string label, or the selected item has no label and it's
       * DOM content is empty.
       */
      placeholder: {
        type: String
      },
      /**
       * When present, it specifies that the element is read-only.
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Defines whether the overlay should overlap the target element
       * in the y-axis, or be positioned right above/below it.
       *
       * @attr {boolean} no-vertical-overlap
       */
      noVerticalOverlap: {
        type: Boolean,
        value: false
      },
      /** @private */
      _phone: Boolean,
      /** @private */
      _phoneMediaQuery: {
        value: "(max-width: 450px), (max-height: 450px)"
      },
      /** @private */
      _inputContainer: Object,
      /** @private */
      _items: Object
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "invalid"];
  }
  static get observers() {
    return [
      "_updateAriaExpanded(opened, focusElement)",
      "_updateSelectedItem(value, _items, placeholder)",
      "_openedChanged(opened, _overlayElement, _inputContainer)"
    ];
  }
  constructor() {
    super();
    this._itemId = `value-${this.localName}-${generateUniqueId()}`;
    this._srLabelController = new LabelController(this);
    this._srLabelController.slotName = "sr-label";
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.opened = false;
  }
  /** @protected */
  ready() {
    super.ready();
    this._inputContainer = this.shadowRoot.querySelector('[part~="input-field"]');
    this._valueButtonController = new ButtonController(this);
    this.addController(this._valueButtonController);
    this.addController(this._srLabelController);
    this.addController(
      new MediaQueryController(this._phoneMediaQuery, (matches2) => {
        this._phone = matches2;
      })
    );
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.focusElement);
    this.addController(this._tooltipController);
  }
  /**
   * Requests an update for the content of the select.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this._overlayElement) {
      return;
    }
    this._overlayElement.requestContentUpdate();
    if (this._menuElement && this._menuElement.items) {
      this._updateSelectedItem(this.value, this._menuElement.items);
    }
  }
  /**
   * Override an observer from `FieldMixin`
   * to validate when required is removed.
   *
   * @protected
   * @override
   */
  _requiredChanged(required) {
    super._requiredChanged(required);
    if (required === false) {
      this._requestValidation();
    }
  }
  /**
   * @param {SelectItem[] | undefined | null} newItems
   * @param {SelectItem[] | undefined | null} oldItems
   * @private
   */
  __itemsChanged(newItems, oldItems) {
    if (newItems || oldItems) {
      this.requestContentUpdate();
    }
  }
  /**
   * @param {HTMLElement} menuElement
   * @protected
   */
  _assignMenuElement(menuElement) {
    if (menuElement && menuElement !== this.__lastMenuElement) {
      this._menuElement = menuElement;
      this.__initMenuItems(menuElement);
      menuElement.addEventListener("items-changed", () => {
        this.__initMenuItems(menuElement);
      });
      menuElement.addEventListener("selected-changed", () => this.__updateValueButton());
      menuElement.addEventListener("keydown", (e2) => this._onKeyDownInside(e2), true);
      menuElement.addEventListener(
        "click",
        (e2) => {
          const item2 = e2.composedPath().find((el) => el._hasVaadinItemMixin);
          this.__dispatchChangePending = Boolean(item2 && item2.value !== void 0 && item2.value !== this.value);
          this.opened = false;
        },
        true
      );
      this.__lastMenuElement = menuElement;
    }
  }
  /** @private */
  __initMenuItems(menuElement) {
    if (menuElement.items) {
      this._items = menuElement.items;
    }
  }
  /** @private */
  _valueChanged(value, oldValue) {
    this.toggleAttribute("has-value", Boolean(value));
    if (oldValue !== void 0 && !this.__dispatchChangePending) {
      this._requestValidation();
    }
  }
  /**
   * Opens the overlay if the field is not read-only.
   *
   * @private
   */
  _onClick(event) {
    if (this.disabled) {
      return;
    }
    event.preventDefault();
    this.opened = !this.readonly;
  }
  /** @private */
  _onToggleMouseDown(event) {
    event.preventDefault();
  }
  /**
   * @param {!KeyboardEvent} e
   * @protected
   * @override
   */
  _onKeyDown(e2) {
    if (e2.target === this.focusElement && !this.readonly && !this.disabled && !this.opened) {
      if (/^(Enter|SpaceBar|\s|ArrowDown|Down|ArrowUp|Up)$/u.test(e2.key)) {
        e2.preventDefault();
        this.opened = true;
      } else if (/[\p{L}\p{Nd}]/u.test(e2.key) && e2.key.length === 1) {
        const selected = this._menuElement.selected;
        const currentIdx = selected !== void 0 ? selected : -1;
        const newIdx = this._menuElement._searchKey(currentIdx, e2.key);
        if (newIdx >= 0) {
          this.__dispatchChangePending = true;
          this._updateAriaLive(true);
          this._menuElement.selected = newIdx;
        }
      }
    }
  }
  /**
   * @param {!KeyboardEvent} e
   * @protected
   */
  _onKeyDownInside(e2) {
    if (/^(Tab)$/u.test(e2.key)) {
      this.opened = false;
    }
  }
  /** @private */
  _openedChanged(opened, overlayElement, inputContainer) {
    if (!overlayElement || !inputContainer) {
      return;
    }
    if (opened) {
      if (this.disabled || this.readonly) {
        this.opened = false;
        return;
      }
      this._updateAriaLive(false);
      overlayElement.style.setProperty("--vaadin-select-text-field-width", `${inputContainer.offsetWidth}px`);
      const hasFocusRing = this.hasAttribute("focus-ring");
      this._openedWithFocusRing = hasFocusRing;
      if (hasFocusRing) {
        this.removeAttribute("focus-ring");
      }
    } else if (this.__oldOpened) {
      if (this._openedWithFocusRing) {
        this.setAttribute("focus-ring", "");
      }
      if (!this.__dispatchChangePending && !this._keyboardActive) {
        this._requestValidation();
      }
    }
    this.__oldOpened = opened;
  }
  /** @private */
  _updateAriaExpanded(opened, focusElement) {
    if (focusElement) {
      focusElement.setAttribute("aria-expanded", opened ? "true" : "false");
    }
  }
  /** @private */
  _updateAriaLive(ariaLive) {
    if (this.focusElement) {
      if (ariaLive) {
        this.focusElement.setAttribute("aria-live", "polite");
      } else {
        this.focusElement.removeAttribute("aria-live");
      }
    }
  }
  /** @private */
  __attachSelectedItem(selected) {
    let labelItem;
    const label = selected.getAttribute("label");
    if (label) {
      labelItem = this.__createItemElement({ label });
    } else {
      labelItem = selected.cloneNode(true);
    }
    labelItem._sourceItem = selected;
    this.__appendValueItemElement(labelItem, this.focusElement);
    labelItem.selected = true;
  }
  /**
   * @param {!SelectItem} item
   * @private
   */
  __createItemElement(item2) {
    const itemElement = document.createElement(item2.component || "vaadin-select-item");
    if (item2.label) {
      itemElement.textContent = item2.label;
    }
    if (item2.value) {
      itemElement.value = item2.value;
    }
    if (item2.disabled) {
      itemElement.disabled = item2.disabled;
    }
    if (item2.className) {
      itemElement.className = item2.className;
    }
    return itemElement;
  }
  /**
   * @param {!HTMLElement} itemElement
   * @param {!HTMLElement} parent
   * @private
   */
  __appendValueItemElement(itemElement, parent) {
    parent.appendChild(itemElement);
    if (itemElement.performUpdate) {
      itemElement.performUpdate();
    }
    itemElement.removeAttribute("tabindex");
    itemElement.removeAttribute("aria-selected");
    itemElement.removeAttribute("role");
    itemElement.removeAttribute("focused");
    itemElement.removeAttribute("focus-ring");
    itemElement.removeAttribute("active");
    itemElement.setAttribute("id", this._itemId);
  }
  /**
   * @param {string} accessibleName
   * @protected
   */
  _accessibleNameChanged(accessibleName) {
    this._srLabelController.setLabel(accessibleName);
    this._setCustomAriaLabelledBy(accessibleName ? this._srLabelController.defaultId : null);
  }
  /**
   * @param {string} accessibleNameRef
   * @protected
   */
  _accessibleNameRefChanged(accessibleNameRef) {
    this._setCustomAriaLabelledBy(accessibleNameRef);
  }
  /**
   * @param {string} ariaLabelledby
   * @private
   */
  _setCustomAriaLabelledBy(ariaLabelledby) {
    const labelId = this._getLabelIdWithItemId(ariaLabelledby);
    this._fieldAriaController.setLabelId(labelId, true);
  }
  /**
   * @param {string | null} labelId
   * @returns string | null
   * @private
   */
  _getLabelIdWithItemId(labelId) {
    const selected = this._items ? this._items[this._menuElement.selected] : false;
    const itemId = selected || this.placeholder ? this._itemId : "";
    return labelId ? `${labelId} ${itemId}`.trim() : null;
  }
  /** @private */
  __updateValueButton() {
    const valueButton2 = this.focusElement;
    if (!valueButton2) {
      return;
    }
    valueButton2.innerHTML = "";
    const selected = this._items[this._menuElement.selected];
    valueButton2.removeAttribute("placeholder");
    if (this._hasContent(selected)) {
      this.__attachSelectedItem(selected);
    } else if (this.placeholder) {
      const item2 = this.__createItemElement({ label: this.placeholder });
      this.__appendValueItemElement(item2, valueButton2);
      valueButton2.setAttribute("placeholder", "");
    }
    if (!this._valueChanging && selected) {
      this._selectedChanging = true;
      this.value = selected.value || "";
      if (this.__dispatchChangePending) {
        this.__dispatchChange();
      }
      delete this._selectedChanging;
    }
    const labelledIdReferenceConfig = selected || this.placeholder ? { newId: this._itemId } : { oldId: this._itemId };
    setAriaIDReference(valueButton2, "aria-labelledby", labelledIdReferenceConfig);
    if (this.accessibleName || this.accessibleNameRef) {
      this._setCustomAriaLabelledBy(this.accessibleNameRef || this._srLabelController.defaultId);
    }
  }
  /** @private */
  _hasContent(item2) {
    if (!item2) {
      return false;
    }
    const hasText = Boolean(item2.hasAttribute("label") ? item2.getAttribute("label") : item2.textContent.trim());
    const hasChildren = item2.childElementCount > 0;
    return hasText || hasChildren;
  }
  /** @private */
  _updateSelectedItem(value, items) {
    if (items) {
      const valueAsString = value == null ? value : value.toString();
      this._menuElement.selected = items.reduce((prev, item2, idx) => {
        return prev === void 0 && item2.value === valueAsString ? idx : prev;
      }, void 0);
      if (!this._selectedChanging) {
        this._valueChanging = true;
        this.__updateValueButton();
        delete this._valueChanging;
      }
    }
  }
  /**
   * Override method inherited from `FocusMixin` to not remove focused
   * state when select is opened and focus moves to list-box.
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldRemoveFocus() {
    return !this.opened;
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
  /**
   * Returns true if the current value satisfies all constraints (if any)
   *
   * @return {boolean}
   */
  checkValidity() {
    return !this.required || this.readonly || !!this.value;
  }
  /**
   * Renders items when they are provided by the `items` property and clears the content otherwise.
   * @param {!HTMLElement} root
   * @param {!Select} _select
   * @private
   */
  __defaultRenderer(root2, _select) {
    if (!this.items || this.items.length === 0) {
      root2.textContent = "";
      return;
    }
    let listBox2 = root2.firstElementChild;
    if (!listBox2) {
      listBox2 = document.createElement("vaadin-select-list-box");
      root2.appendChild(listBox2);
    }
    listBox2.textContent = "";
    this.items.forEach((item2) => {
      listBox2.appendChild(this.__createItemElement(item2));
    });
  }
  /** @private */
  async __dispatchChange() {
    if (this.updateComplete) {
      await this.updateComplete;
    }
    this._requestValidation();
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
    this.__dispatchChangePending = false;
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-select", [fieldShared, inputFieldContainer, screenReaderOnly], {
  moduleId: "vaadin-select-styles"
});
class Select extends SelectBaseMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-select";
  }
  static get template() {
    return html`
      <style>
        :host {
          position: relative;
        }

        ::slotted([slot='value']) {
          flex-grow: 1;
        }
      </style>

      <div class="vaadin-select-container">
        <div part="label" on-click="_onClick">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
          on-click="_onClick"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="value"></slot>
          <div part="toggle-button" slot="suffix" aria-hidden="true" on-mousedown="_onToggleMouseDown"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-select-overlay
        position-target="[[_inputContainer]]"
        opened="{{opened}}"
        with-backdrop="[[_phone]]"
        phone$="[[_phone]]"
        theme$="[[_theme]]"
        no-vertical-overlap$="[[noVerticalOverlap]]"
        on-vaadin-overlay-open="_onOverlayOpen"
      ></vaadin-select-overlay>

      <slot name="tooltip"></slot>
      <div class="sr-only">
        <slot name="sr-label"></slot>
      </div>
    `;
  }
  static get observers() {
    return ["_rendererChanged(renderer, _overlayElement)"];
  }
  /** @protected */
  ready() {
    super.ready();
    processTemplates(this);
  }
  /**
   * @param {SelectRenderer | undefined | null} renderer
   * @param {SelectOverlay | undefined} overlay
   * @private
   */
  _rendererChanged(renderer, overlay2) {
    if (!overlay2) {
      return;
    }
    overlay2.renderer = renderer || this.__defaultRenderer;
    this.requestContentUpdate();
  }
  /** @private */
  _onOverlayOpen() {
    if (this._menuElement) {
      this._menuElement.focus();
    }
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
}
defineCustomElement(Select);
window.Vaadin.Flow.selectConnector = {};
window.Vaadin.Flow.selectConnector.initLazy = (select2) => {
  if (select2.$connector) {
    return;
  }
  select2.$connector = {};
  select2.renderer = (root2) => {
    const listBox2 = select2.querySelector("vaadin-select-list-box");
    if (listBox2) {
      if (root2.firstChild) {
        root2.removeChild(root2.firstChild);
      }
      root2.appendChild(listBox2);
    }
  };
};
const _window$1 = window;
_window$1.Vaadin || (_window$1.Vaadin = {});
(_f = _window$1.Vaadin).Flow || (_f.Flow = {});
(_g = _window$1.Vaadin.Flow).tooltip || (_g.tooltip = {});
Object.assign(_window$1.Vaadin.Flow.tooltip, {
  setDefaultHideDelay: (hideDelay) => Tooltip.setDefaultHideDelay(hideDelay),
  setDefaultFocusDelay: (focusDelay) => Tooltip.setDefaultFocusDelay(focusDelay),
  setDefaultHoverDelay: (hoverDelay) => Tooltip.setDefaultHoverDelay(hoverDelay)
});
const { defaultHideDelay, defaultFocusDelay, defaultHoverDelay } = _window$1.Vaadin.Flow.tooltip;
if (defaultHideDelay) {
  Tooltip.setDefaultHideDelay(defaultHideDelay);
}
if (defaultFocusDelay) {
  Tooltip.setDefaultFocusDelay(defaultFocusDelay);
}
if (defaultHoverDelay) {
  Tooltip.setDefaultHoverDelay(defaultHoverDelay);
}
document.addEventListener("click", (event) => {
  const target = event.composedPath().find((node) => node.disableOnClick);
  if (target) {
    target.disabled = true;
  }
});
const sideNavItemStyles = css`
  :host {
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  [part='link'] {
    width: 100%;
    gap: var(--lumo-space-xs);
    padding: var(--lumo-space-s);
    padding-inline-start: calc(var(--lumo-space-s) + var(--_child-indent, 0px));
    border-radius: var(--lumo-border-radius-m);
    transition:
      background-color 140ms,
      color 140ms;
    cursor: var(--lumo-clickable-cursor, default);
    min-height: var(--lumo-icon-size-m);
  }

  [part='link'][href] {
    cursor: pointer;
  }

  :host([disabled]) [part='link'] {
    color: var(--lumo-disabled-text-color);
  }

  [part='toggle-button'] {
    margin-inline-end: calc(var(--lumo-space-xs) * -1);
    width: var(--lumo-size-s);
    height: var(--lumo-size-s);
  }

  :host([has-children]) [part='content'] {
    padding-inline-end: var(--lumo-space-s);
  }

  @media (any-hover: hover) {
    [part='link']:hover {
      color: var(--lumo-header-text-color);
    }

    [part='toggle-button']:hover {
      color: var(--lumo-body-text-color);
    }
  }

  [part='link']:active:focus {
    background-color: var(--lumo-contrast-5pct);
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
    transform: rotate(-90deg);
    transition: transform 140ms;
  }

  :host([dir='rtl']) [part='toggle-button']::before {
    transform: rotate(90deg);
  }

  :host([expanded]) [part='toggle-button']::before {
    transform: none;
  }

  @supports selector(:focus-visible) {
    [part='link'],
    [part='toggle-button'] {
      outline: none;
    }

    [part='link']:focus-visible,
    [part='toggle-button']:focus-visible {
      border-radius: var(--lumo-border-radius-m);
      box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }
  }

  [part='link']:active {
    color: var(--lumo-header-text-color);
  }

  slot:not([name]) {
    margin: 0 var(--lumo-space-s);
  }

  slot[name='prefix']::slotted(:is(vaadin-icon, [class*='icon'])) {
    padding: 0.1em;
    flex-shrink: 0;
    color: var(--lumo-contrast-60pct);
  }

  :host([disabled]) slot[name='prefix']::slotted(:is(vaadin-icon, [class*='icon'])) {
    color: var(--lumo-disabled-text-color);
  }

  :host([current]) slot[name='prefix']::slotted(:is(vaadin-icon, [class*='icon'])) {
    color: inherit;
  }

  slot[name='children'] {
    --_child-indent: calc(var(--_child-indent-2, 0px) + var(--vaadin-side-nav-child-indent, var(--lumo-space-l)));
  }

  slot[name='children']::slotted(*) {
    --_child-indent-2: var(--_child-indent);
  }

  :host([current]) [part='content'] {
    background-color: var(--lumo-primary-color-10pct);
    color: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
    border-radius: var(--lumo-border-radius-m);
  }
`;
registerStyles$1("vaadin-side-nav-item", [fieldButton, sideNavItemStyles], { moduleId: "lumo-side-nav-item" });
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function containsQueryParams(actual, expected) {
  return [...expected.entries()].every(([key, value]) => {
    return actual.getAll(key).includes(value);
  });
}
function matchPaths(actual, expected, matchOptions = { matchNested: false }) {
  const base = document.baseURI;
  const actualUrl = new URL(actual, base);
  const expectedUrl = new URL(expected, base);
  const matchesOrigin = actualUrl.origin === expectedUrl.origin;
  const matchesPath = matchOptions.matchNested ? actualUrl.pathname === expectedUrl.pathname || actualUrl.pathname.startsWith(`${expectedUrl.pathname}/`) : actualUrl.pathname === expectedUrl.pathname;
  return matchesOrigin && matchesPath && containsQueryParams(actualUrl.searchParams, expectedUrl.searchParams);
}
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const location$1 = {
  get pathname() {
    return document.location.pathname;
  },
  get search() {
    return document.location.search;
  }
};
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const sideNavItemBaseStyles = css`
  :host {
    display: block;
  }

  :host([hidden]),
  [hidden] {
    display: none !important;
  }

  :host([disabled]) {
    pointer-events: none;
  }

  [part='content'] {
    display: flex;
    align-items: center;
  }

  [part='link'] {
    flex: auto;
    min-width: 0;
    display: flex;
    align-items: center;
    text-decoration: none;
    color: inherit;
    font: inherit;
  }

  button {
    -webkit-appearance: none;
    appearance: none;
    flex: none;
    position: relative;
    margin: 0;
    padding: 0;
    border: 0;
    background: transparent;
  }

  [part='children'] {
    padding: 0;
    margin: 0;
    list-style-type: none;
  }

  :host(:not([has-children])) button {
    display: none !important;
  }

  slot[name='prefix'],
  slot[name='suffix'] {
    flex: none;
  }

  slot:not([name]) {
    display: block;
    flex: auto;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
`;
const sideNavBaseStyles = css`
  :host {
    display: block;
  }

  :host([hidden]) {
    display: none !important;
  }

  button {
    display: flex;
    align-items: center;
    justify-content: inherit;
    width: 100%;
    margin: 0;
    padding: 0;
    background-color: initial;
    color: inherit;
    border: initial;
    outline: none;
    font: inherit;
    text-align: inherit;
  }

  [part='children'] {
    padding: 0;
    margin: 0;
    list-style-type: none;
  }
`;
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ChildrenController extends SlotController {
  constructor(host, slotName) {
    super(host, slotName, null, { observe: true, multiple: true });
  }
  /**
   * @protected
   * @override
   */
  initAddedNode() {
    this.host.requestUpdate();
  }
  /**
   * @protected
   * @override
   */
  teardownNode() {
    this.host.requestUpdate();
  }
}
const SideNavChildrenMixin = (superClass) => class SideNavChildrenMixin extends superClass {
  static get properties() {
    return {
      /**
       * The object used to localize this component.
       *
       * To change the default localization, replace the entire
       * `i18n` object with a custom one.
       *
       * The object has the following structure and default values:
       * ```
       * {
       *   toggle: 'Toggle child items'
       * }
       * ```
       *
       * @type {SideNavI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value: () => {
          return {
            toggle: "Toggle child items"
          };
        }
      },
      /**
       * Count of child items.
       * @protected
       */
      _itemsCount: {
        type: Number,
        value: 0
      }
    };
  }
  constructor() {
    super();
    this._childrenController = new ChildrenController(this, this._itemsSlotName);
  }
  /**
   * List of child items of this component.
   * @protected
   */
  get _items() {
    return this._childrenController.nodes;
  }
  /**
   * Name of the slot to be used for children.
   * @protected
   */
  get _itemsSlotName() {
    return "children";
  }
  /** @protected */
  firstUpdated() {
    super.firstUpdated();
    this.addController(this._childrenController);
  }
  /**
   * @protected
   * @override
   */
  willUpdate(props) {
    super.willUpdate(props);
    this._itemsCount = this._items.length;
  }
  /**
   * @protected
   * @override
   */
  updated(props) {
    super.updated(props);
    if (props.has("_itemsCount")) {
      this.toggleAttribute("has-children", this._itemsCount > 0);
    }
    if (props.has("_itemsCount") || props.has("i18n")) {
      this._items.forEach((item2) => {
        item2.i18n = this.i18n;
      });
    }
  }
};
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SideNavItem extends SideNavChildrenMixin(DisabledMixin(ElementMixin(ThemableMixin(PolylitMixin(LitElement))))) {
  static get is() {
    return "vaadin-side-nav-item";
  }
  static get properties() {
    return {
      /**
       * The path to navigate to
       */
      path: String,
      /**
       * The list of alternative paths matching this item
       *
       * @type {!Array<string>}
       */
      pathAliases: {
        type: Array,
        value: () => []
      },
      /**
       * Whether to show the child items or not
       *
       * @type {boolean}
       */
      expanded: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true
      },
      /**
       * Whether to also match nested paths / routes. `false` by default.
       *
       * When enabled, an item with the path `/path` is considered current when
       * the browser URL is `/path`, `/path/child`, `/path/child/grandchild`,
       * etc.
       *
       * Note that this only affects matching of the URLs path, not the base
       * origin or query parameters.
       *
       * @type {boolean}
       * @attr {boolean} match-nested
       */
      matchNested: {
        type: Boolean,
        value: false
      },
      /**
       * Whether the item's path matches the current browser URL.
       *
       * A match occurs when both share the same base origin (like https://example.com),
       * the same path (like /path/to/page), and the browser URL contains at least
       * all the query parameters with the same values from the item's path.
       *
       * See [`matchNested`](#/elements/vaadin-side-nav-item#property-matchNested) for how to change the path matching behavior.
       *
       * The state is updated when the item is added to the DOM or when the browser
       * navigates to a new page.
       *
       * @type {boolean}
       */
      current: {
        type: Boolean,
        value: false,
        readOnly: true,
        reflectToAttribute: true
      },
      /**
       * The target of the link. Works only when `path` is set.
       */
      target: String,
      /**
       * Whether to exclude the item from client-side routing. When enabled,
       * this causes the item to behave like a regular anchor, causing a full
       * page reload. This only works with supported routers, such as the one
       * provided in Vaadin apps, or when using the side nav `onNavigate` hook.
       *
       * @type {boolean}
       * @attr {boolean} router-ignore
       */
      routerIgnore: {
        type: Boolean,
        value: false
      }
    };
  }
  static get styles() {
    return [sideNavItemBaseStyles];
  }
  constructor() {
    super();
    this.__boundUpdateCurrent = this.__updateCurrent.bind(this);
  }
  /** @protected */
  get _button() {
    return this.shadowRoot.querySelector("button");
  }
  /**
   * @protected
   * @override
   */
  firstUpdated() {
    super.firstUpdated();
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", "listitem");
    }
  }
  /**
   * @protected
   * @override
   */
  updated(props) {
    super.updated(props);
    if (props.has("path") || props.has("pathAliases") || props.has("matchNested")) {
      this.__updateCurrent();
    }
    if (props.has("disabled") || props.has("_itemsCount")) {
      this._items.forEach((item2) => {
        item2.disabled = this.disabled;
      });
    }
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__updateCurrent();
    window.addEventListener("popstate", this.__boundUpdateCurrent);
    window.addEventListener("vaadin-navigated", this.__boundUpdateCurrent);
    window.addEventListener("side-nav-location-changed", this.__boundUpdateCurrent);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("popstate", this.__boundUpdateCurrent);
    window.removeEventListener("vaadin-navigated", this.__boundUpdateCurrent);
    window.removeEventListener("side-nav-location-changed", this.__boundUpdateCurrent);
  }
  /** @protected */
  render() {
    return html$1`
      <div part="content" @click="${this._onContentClick}">
        <a
          id="link"
          ?disabled="${this.disabled}"
          tabindex="${this.disabled || this.path == null ? "-1" : "0"}"
          href="${ifDefined(this.disabled ? null : this.path)}"
          target="${ifDefined(this.target)}"
          ?router-ignore="${this.routerIgnore}"
          part="link"
          aria-current="${this.current ? "page" : "false"}"
        >
          <slot name="prefix"></slot>
          <slot></slot>
          <slot name="suffix"></slot>
        </a>
        <button
          part="toggle-button"
          ?disabled="${this.disabled}"
          @click="${this._onButtonClick}"
          aria-controls="children"
          aria-expanded="${this.expanded}"
          aria-labelledby="link i18n"
        ></button>
      </div>
      <ul part="children" role="list" ?hidden="${!this.expanded}" aria-hidden="${this.expanded ? "false" : "true"}">
        <slot name="children"></slot>
      </ul>
      <div hidden id="i18n">${this.i18n.toggle}</div>
    `;
  }
  /** @private */
  _onButtonClick(event) {
    event.stopPropagation();
    this.__toggleExpanded();
  }
  /** @private */
  _onContentClick() {
    if (this.path == null && this.hasAttribute("has-children")) {
      this.__toggleExpanded();
    }
  }
  /** @private */
  __toggleExpanded() {
    this.expanded = !this.expanded;
  }
  /** @private */
  __updateCurrent() {
    this._setCurrent(this.__isCurrent());
    if (this.current) {
      this.__expandParentItems();
      this.expanded = this._items.length > 0;
    }
  }
  /** @private */
  __expandParentItems() {
    const parentItem = this.__getParentItem();
    if (parentItem) {
      parentItem.__expandParentItems();
    }
    this.expanded = true;
  }
  /** @private */
  __getParentItem() {
    return this.parentElement instanceof SideNavItem ? this.parentElement : null;
  }
  /** @private */
  __isCurrent() {
    if (this.path == null) {
      return false;
    }
    const browserPath = `${location$1.pathname}${location$1.search}`;
    const matchOptions = { matchNested: this.matchNested };
    return matchPaths(browserPath, this.path, matchOptions) || this.pathAliases.some((alias) => matchPaths(browserPath, alias, matchOptions));
  }
}
defineCustomElement(SideNavItem);
const sideNavStyles = css`
  :host {
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    font-weight: 500;
    line-height: var(--lumo-line-height-xs);
    color: var(--lumo-body-text-color);
    -webkit-tap-highlight-color: transparent;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  [part='label'] {
    display: flex;
    align-items: center;
    width: 100%;
    outline: none;
    box-sizing: border-box;
    border-radius: var(--lumo-border-radius-m);
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-s);
    font-weight: 500;
    line-height: var(--lumo-line-height-xs);
  }

  [part='label'] ::slotted([slot='label']) {
    color: var(--lumo-secondary-text-color);
    margin: var(--lumo-space-s);
  }

  :host([focus-ring]) [part='label'] {
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  [part='toggle-button'] {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--lumo-size-s);
    height: var(--lumo-size-s);
    margin-inline: auto var(--lumo-space-xs);
    font-size: var(--lumo-icon-size-m);
    line-height: 1;
    color: var(--lumo-contrast-60pct);
    font-family: 'lumo-icons';
    cursor: var(--lumo-clickable-cursor);
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-angle-right);
    transition: transform 140ms;
  }

  :host(:not([collapsible])) [part='toggle-button'] {
    display: none !important;
  }

  :host(:not([collapsed])) [part='toggle-button']::before {
    transform: rotate(90deg);
  }

  :host([collapsed][dir='rtl']) [part='toggle-button']::before {
    transform: rotate(180deg);
  }

  @media (any-hover: hover) {
    [part='label']:hover [part='toggle-button'] {
      color: var(--lumo-body-text-color);
    }
  }
`;
registerStyles$1("vaadin-side-nav", sideNavStyles, { moduleId: "lumo-side-nav" });
/**
 * @license
 * Copyright (c) 2023 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SideNav extends SideNavChildrenMixin(FocusMixin(ElementMixin(ThemableMixin(PolylitMixin(LitElement))))) {
  static get is() {
    return "vaadin-side-nav";
  }
  static get shadowRootOptions() {
    return { ...LitElement.shadowRootOptions, delegatesFocus: true };
  }
  static get properties() {
    return {
      /**
       * Whether the side nav is collapsible. When enabled, the toggle icon is shown.
       *
       * @type {boolean}
       */
      collapsible: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Whether the side nav is collapsed. When collapsed, the items are hidden.
       *
       * @type {boolean}
       */
      collapsed: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true
      },
      /**
       * Callback function for router integration.
       *
       * When a side nav item link is clicked, this function is called and the default click action is cancelled.
       * This delegates the responsibility of navigation to the function's logic.
       *
       * The click event action is not cancelled in the following cases:
       * - The click event has a modifier (e.g. `metaKey`, `shiftKey`)
       * - The click event is on an external link
       * - The click event is on a link with `target="_blank"`
       * - The function explicitly returns `false`
       *
       * The function receives an object with the properties of the clicked side-nav item:
       * - `path`: The path of the navigation item.
       * - `target`: The target of the navigation item.
       * - `current`: A boolean indicating whether the navigation item is currently selected.
       * - `expanded`: A boolean indicating whether the navigation item is expanded.
       * - `pathAliases`: An array of path aliases for the navigation item.
       * - `originalEvent`: The original DOM event that triggered the navigation.
       *
       * Also see the `location` property for updating the highlighted navigation item on route change.
       *
       * @type {function(Object): boolean | undefined}
       */
      onNavigate: {
        attribute: false
      },
      /**
       * A change to this property triggers an update of the highlighted item in the side navigation. While it typically
       * corresponds to the browser's URL, the specific value assigned to the property is irrelevant. The component has
       * its own internal logic for determining which item is highlighted.
       *
       * The main use case for this property is when the side navigation is used with a client-side router. In this case,
       * the component needs to be informed about route changes so it can update the highlighted item.
       *
       * @type {any}
       */
      location: {
        observer: "__locationChanged"
      }
    };
  }
  static get styles() {
    return sideNavBaseStyles;
  }
  constructor() {
    super();
    this._labelId = `side-nav-label-${generateUniqueId()}`;
    this.addEventListener("click", this.__onClick);
  }
  /**
   * Name of the slot to be used for children.
   * @protected
   * @override
   */
  get _itemsSlotName() {
    return "";
  }
  /** @protected */
  get focusElement() {
    return this.shadowRoot.querySelector("button");
  }
  /** @protected */
  firstUpdated() {
    super.firstUpdated();
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", "navigation");
    }
  }
  /** @protected */
  render() {
    return html$1`
      ${this.collapsible ? html$1`
            <button
              part="label"
              @click="${this._onLabelClick}"
              aria-expanded="${!this.collapsed}"
              aria-controls="children"
            >
              <slot name="label" @slotchange="${this._onLabelSlotChange}"></slot>
              <span part="toggle-button" aria-hidden="true"></span>
            </button>
          ` : html$1`
            <div part="label">
              <slot name="label" @slotchange="${this._onLabelSlotChange}"></slot>
            </div>
          `}
      <ul
        id="children"
        role="list"
        part="children"
        ?hidden="${this.collapsed}"
        aria-hidden="${this.collapsed ? "true" : "false"}"
      >
        <slot></slot>
      </ul>
    `;
  }
  /**
   * @param {Event} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldSetFocus(event) {
    return event.composedPath()[0] === this.focusElement;
  }
  /** @private */
  _onLabelClick() {
    if (this.collapsible) {
      this.__toggleCollapsed();
    }
  }
  /** @private */
  _onLabelSlotChange() {
    const label = this.querySelector('[slot="label"]');
    if (label) {
      if (!label.id) {
        label.id = this._labelId;
      }
      this.setAttribute("aria-labelledby", label.id);
    } else {
      this.removeAttribute("aria-labelledby");
    }
  }
  /** @private */
  __locationChanged() {
    window.dispatchEvent(new CustomEvent("side-nav-location-changed"));
  }
  /** @private */
  __toggleCollapsed() {
    this.collapsed = !this.collapsed;
  }
  /** @private */
  __onClick(e2) {
    if (!this.onNavigate) {
      return;
    }
    const hasModifier = e2.metaKey || e2.shiftKey;
    if (hasModifier) {
      return;
    }
    const composedPath = e2.composedPath();
    const item2 = composedPath.find((el) => el.localName && el.localName.includes("side-nav-item"));
    const anchor = composedPath.find((el) => el instanceof HTMLAnchorElement);
    if (!item2 || !item2.shadowRoot.contains(anchor)) {
      return;
    }
    const isRelative = anchor.href && anchor.href.startsWith(location.origin);
    if (!isRelative) {
      return;
    }
    if (item2.target === "_blank") {
      return;
    }
    if (item2.routerIgnore) {
      return;
    }
    const result = this.onNavigate({
      path: item2.path,
      target: item2.target,
      current: item2.current,
      expanded: item2.expanded,
      pathAliases: item2.pathAliases,
      originalEvent: e2
    });
    if (result !== false) {
      e2.preventDefault();
    }
  }
}
defineCustomElement(SideNav);
registerStyles$1(
  "vaadin-split-layout",
  css`
    [part='splitter'] {
      min-width: var(--lumo-space-s);
      min-height: var(--lumo-space-s);
      background-color: var(--lumo-contrast-5pct);
      transition: 0.1s background-color;
    }

    [part='handle'] {
      display: flex;
      align-items: center;
      justify-content: center;
      width: var(--lumo-size-m);
      height: var(--lumo-size-m);
    }

    [part='handle']::after {
      content: '';
      display: block;
      --_handle-size: 4px;
      width: var(--_handle-size);
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      border-radius: var(--lumo-border-radius-s);
      background-color: var(--lumo-contrast-30pct);
      transition:
        0.1s opacity,
        0.1s background-color;
    }

    :host([orientation='vertical']) [part='handle']::after {
      width: 100%;
      height: var(--_handle-size);
    }

    /* Hover style */
    @media (any-hover: hover) {
      [part='splitter']:hover [part='handle']::after {
        background-color: var(--lumo-contrast-40pct);
      }
    }

    /* Active style */
    [part='splitter']:active [part='handle']::after {
      background-color: var(--lumo-contrast-50pct);
    }

    /* Small/minimal */
    :host([theme~='small']) > [part='splitter'] {
      border-left: 1px solid var(--lumo-contrast-10pct);
      border-top: 1px solid var(--lumo-contrast-10pct);
    }

    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter'] {
      min-width: 0;
      min-height: 0;
      background-color: transparent;
    }

    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter']::after {
      content: '';
      position: absolute;
      inset: -4px;
    }

    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter'] > [part='handle'] {
      left: calc(50% - 0.5px);
      top: calc(50% - 0.5px);
    }

    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter'] > [part='handle']::after {
      opacity: 0;
      --_handle-size: 5px;
    }

    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter']:hover > [part='handle']::after,
    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter']:active > [part='handle']::after {
      opacity: 1;
    }
  `,
  { moduleId: "lumo-split-layout" }
);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const SplitLayoutMixin = (superClass) => class SplitLayoutMixin extends superClass {
  static get properties() {
    return {
      /**
       * The split layout's orientation. Possible values are: `horizontal|vertical`.
       * @type {string}
       */
      orientation: {
        type: String,
        reflectToAttribute: true,
        value: "horizontal"
      },
      /** @private */
      _previousPrimaryPointerEvents: String,
      /** @private */
      _previousSecondaryPointerEvents: String
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this._processChildren();
    this.__observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        this._cleanupNodes(mutation.removedNodes);
      });
      this._processChildren();
    });
    this.__observer.observe(this, { childList: true });
    const splitter = this.$.splitter;
    addListener(splitter, "track", this._onHandleTrack.bind(this));
    addListener(splitter, "down", this._setPointerEventsNone.bind(this));
    addListener(splitter, "up", this._restorePointerEvents.bind(this));
  }
  /** @private */
  _cleanupNodes(nodes) {
    nodes.forEach((node) => {
      if (node.nodeType === Node.ELEMENT_NODE && !(node.parentElement instanceof this.constructor)) {
        const slot = node.getAttribute("slot");
        if (slot) {
          this[`_${slot}Child`] = null;
          node.removeAttribute("slot");
        }
      }
    });
  }
  /** @private */
  _processChildren() {
    const children = [...this.children];
    children.filter((child) => child.hasAttribute("slot")).forEach((child) => this._processChildWithSlot(child));
    children.filter((child) => !child.hasAttribute("slot")).forEach((child, i2) => this._processChildWithoutSlot(child, i2));
  }
  /** @private */
  _processChildWithSlot(child) {
    const slot = child.getAttribute("slot");
    if (child.__autoSlotted) {
      this[`_${slot}Child`] = null;
      child.removeAttribute("slot");
    } else {
      this[`_${slot}Child`] = child;
    }
  }
  /** @private */
  _processChildWithoutSlot(child, idx) {
    let slotName;
    if (this._primaryChild || this._secondaryChild) {
      slotName = this._primaryChild ? "secondary" : "primary";
    } else {
      slotName = idx === 0 ? "primary" : "secondary";
    }
    this[`_${slotName}Child`] = child;
    child.setAttribute("slot", slotName);
    child.__autoSlotted = true;
  }
  /** @private */
  _setFlexBasis(element, flexBasis, containerSize) {
    flexBasis = Math.max(0, Math.min(flexBasis, containerSize));
    if (flexBasis === 0) {
      flexBasis = 1e-6;
    }
    element.style.flex = `1 1 ${flexBasis}px`;
  }
  /** @private */
  _setPointerEventsNone(event) {
    if (!this._primaryChild || !this._secondaryChild) {
      return;
    }
    this._previousPrimaryPointerEvents = this._primaryChild.style.pointerEvents;
    this._previousSecondaryPointerEvents = this._secondaryChild.style.pointerEvents;
    this._primaryChild.style.pointerEvents = "none";
    this._secondaryChild.style.pointerEvents = "none";
    event.preventDefault();
  }
  /** @private */
  _restorePointerEvents() {
    if (!this._primaryChild || !this._secondaryChild) {
      return;
    }
    this._primaryChild.style.pointerEvents = this._previousPrimaryPointerEvents;
    this._secondaryChild.style.pointerEvents = this._previousSecondaryPointerEvents;
  }
  /** @private */
  _onHandleTrack(event) {
    if (!this._primaryChild || !this._secondaryChild) {
      return;
    }
    const size = this.orientation === "vertical" ? "height" : "width";
    if (event.detail.state === "start") {
      this._startSize = {
        container: this.getBoundingClientRect()[size] - this.$.splitter.getBoundingClientRect()[size],
        primary: this._primaryChild.getBoundingClientRect()[size],
        secondary: this._secondaryChild.getBoundingClientRect()[size]
      };
      return;
    }
    const distance = this.orientation === "vertical" ? event.detail.dy : event.detail.dx;
    const isRtl = this.orientation !== "vertical" && this.__isRTL;
    const dirDistance = isRtl ? -distance : distance;
    this._setFlexBasis(this._primaryChild, this._startSize.primary + dirDistance, this._startSize.container);
    this._setFlexBasis(this._secondaryChild, this._startSize.secondary - dirDistance, this._startSize.container);
    if (event.detail.state === "end") {
      this.dispatchEvent(new CustomEvent("splitter-dragend"));
      delete this._startSize;
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const splitLayoutStyles = css`
  :host {
    display: flex;
    overflow: hidden !important;
    transform: translateZ(0);
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([orientation='vertical']) {
    flex-direction: column;
  }

  :host ::slotted(*) {
    flex: 1 1 auto;
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  [part='splitter'] {
    flex: none;
    position: relative;
    z-index: 1;
    overflow: visible;
    min-width: 8px;
    min-height: 8px;
  }

  :host(:not([orientation='vertical'])) > [part='splitter'] {
    cursor: ew-resize;
  }

  :host([orientation='vertical']) > [part='splitter'] {
    cursor: ns-resize;
  }

  [part='handle'] {
    width: 40px;
    height: 40px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate3d(-50%, -50%, 0);
  }

  @media (forced-colors: active) {
    [part~='splitter'] {
      outline: 1px solid;
    }

    [part~='handle']::after {
      background-color: AccentColor !important;
      forced-color-adjust: none;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-split-layout", splitLayoutStyles, { moduleId: "vaadin-split-layout-styles" });
class SplitLayout extends SplitLayoutMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <slot id="primary" name="primary"></slot>
      <div part="splitter" id="splitter">
        <div part="handle"></div>
      </div>
      <slot id="secondary" name="secondary"></slot>
    `;
  }
  static get is() {
    return "vaadin-split-layout";
  }
  /**
   * Fired after dragging the splitter have ended.
   *
   * @event splitter-dragend
   */
}
defineCustomElement(SplitLayout);
registerStyles$1(
  "vaadin-tab",
  css`
    :host {
      box-sizing: border-box;
      padding: 0.5rem 0.75rem;
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      line-height: var(--lumo-line-height-xs);
      font-weight: 500;
      opacity: 1;
      color: var(--lumo-secondary-text-color);
      transition:
        0.15s color,
        0.2s transform;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      position: relative;
      cursor: var(--lumo-clickable-cursor);
      transform-origin: 50% 100%;
      outline: none;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow: hidden;
      min-width: var(--lumo-size-m);
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      --_selection-color: var(--vaadin-selection-color, var(--lumo-primary-color));
      --_selection-color-text: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
    }

    :host(:not([orientation='vertical'])) {
      text-align: center;
    }

    :host([orientation='vertical']) {
      transform-origin: 0% 50%;
      padding: 0.25rem 1rem;
      min-height: var(--lumo-size-m);
      min-width: 0;
    }

    @media (forced-colors: active) {
      :host([focused]) {
        outline: 1px solid;
        outline-offset: -1px;
      }

      :host([orientation='vertical'][selected]) {
        border-bottom: none;
        border-left: 2px solid;
      }
    }

    :host(:hover),
    :host([focus-ring]) {
      color: var(--lumo-body-text-color);
    }

    :host([selected]) {
      color: var(--_selection-color-text);
      transition: 0.6s color;
    }

    :host([active]:not([selected])) {
      color: var(--_selection-color-text);
      transition-duration: 0.1s;
    }

    :host::before,
    :host::after {
      content: '';
      position: absolute;
      display: var(--_lumo-tab-marker-display, block);
      bottom: 0;
      left: 50%;
      width: var(--lumo-size-s);
      height: 2px;
      background-color: var(--lumo-contrast-60pct);
      border-radius: var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0 0;
      transform: translateX(-50%) scale(0);
      transform-origin: 50% 100%;
      transition: 0.14s transform cubic-bezier(0.12, 0.32, 0.54, 1);
      will-change: transform;
    }

    :host([orientation='vertical'])::before,
    :host([orientation='vertical'])::after {
      left: 0;
      bottom: 50%;
      transform: translateY(50%) scale(0);
      width: 2px;
      height: var(--lumo-size-xs);
      border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;
      transform-origin: 100% 50%;
    }

    :host::after {
      box-shadow: 0 0 0 4px var(--_selection-color);
      opacity: 0.15;
      transition:
        0.15s 0.02s transform,
        0.8s 0.17s opacity;
    }

    :host([selected])::before,
    :host([selected])::after {
      background-color: var(--_selection-color);
      transform: translateX(-50%) scale(1);
      transition-timing-function: cubic-bezier(0.12, 0.32, 0.54, 1.5);
    }

    :host([orientation='vertical'][selected])::before,
    :host([orientation='vertical'][selected])::after {
      transform: translateY(50%) scale(1);
    }

    :host([selected]:not([active]))::after {
      opacity: 0;
    }

    :host(:not([orientation='vertical'])) ::slotted(a[href]) {
      justify-content: center;
    }

    :host ::slotted(a) {
      display: flex;
      width: 100%;
      align-items: center;
      height: 100%;
      margin: -0.5rem -0.75rem;
      padding: 0.5rem 0.75rem;
      outline: none;

      /*
          Override the CSS inherited from \`lumo-color\` and \`lumo-typography\`.
          Note: \`!important\` is needed because of the \`:slotted\` specificity.
        */
      text-decoration: none !important;
      color: inherit !important;
    }

    :host ::slotted(vaadin-icon) {
      margin: 0 4px;
      width: var(--lumo-icon-size-m);
      height: var(--lumo-icon-size-m);
    }

    /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
    :host ::slotted(vaadin-icon[icon^='vaadin:']) {
      padding: 0.25rem;
      box-sizing: border-box !important;
    }

    :host(:not([dir='rtl'])) ::slotted(vaadin-icon:first-child) {
      margin-left: 0;
    }

    :host(:not([dir='rtl'])) ::slotted(vaadin-icon:last-child) {
      margin-right: 0;
    }

    :host([theme~='icon-on-top']) {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-around;
      text-align: center;
      padding-bottom: 0.5rem;
      padding-top: 0.25rem;
    }

    :host([theme~='icon-on-top']) ::slotted(a) {
      flex-direction: column;
      align-items: center;
      margin-top: -0.25rem;
      padding-top: 0.25rem;
    }

    :host([theme~='icon-on-top']) ::slotted(vaadin-icon) {
      margin: 0;
    }

    /* Disabled */

    :host([disabled]) {
      pointer-events: none;
      opacity: 1;
      color: var(--lumo-disabled-text-color);
    }

    /* Focus-ring */

    :host([focus-ring]) {
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
      border-radius: var(--lumo-border-radius-m);
    }

    /* RTL specific styles */

    :host([dir='rtl'])::before,
    :host([dir='rtl'])::after {
      left: auto;
      right: 50%;
      transform: translateX(50%) scale(0);
    }

    :host([dir='rtl'][selected]:not([orientation='vertical']))::before,
    :host([dir='rtl'][selected]:not([orientation='vertical']))::after {
      transform: translateX(50%) scale(1);
    }

    :host([dir='rtl']) ::slotted(vaadin-icon:first-child) {
      margin-right: 0;
    }

    :host([dir='rtl']) ::slotted(vaadin-icon:last-child) {
      margin-left: 0;
    }

    :host([orientation='vertical'][dir='rtl']) {
      transform-origin: 100% 50%;
    }

    :host([dir='rtl'][orientation='vertical'])::before,
    :host([dir='rtl'][orientation='vertical'])::after {
      left: auto;
      right: 0;
      border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);
      transform-origin: 0% 50%;
    }
  `,
  { moduleId: "lumo-tab" }
);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const TabMixin = (superClass) => class TabMixinClass extends ItemMixin(superClass) {
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "tab");
  }
  /**
   * Override an event listener from `KeyboardMixin`
   * to handle clicking anchors inside the tabs.
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyUp(event) {
    const willClick = this.hasAttribute("active");
    super._onKeyUp(event);
    if (willClick) {
      const anchor = this.querySelector("a");
      if (anchor) {
        anchor.click();
      }
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const tabStyles = css`
  :host {
    display: block;
  }

  :host([hidden]) {
    display: none !important;
  }

  @media (forced-colors: active) {
    :host([focused]) {
      outline: 1px solid;
      outline-offset: -1px;
    }

    :host([selected]) {
      border-bottom: 2px solid;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-tab", tabStyles, { moduleId: "vaadin-tab-styles" });
class Tab extends ElementMixin(ThemableMixin(TabMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <slot></slot>
      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-tab";
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
  }
}
defineCustomElement(Tab);
registerStyles$1(
  "vaadin-tabs",
  css`
    :host {
      -webkit-tap-highlight-color: transparent;
    }

    :host(:not([orientation='vertical'])) {
      box-shadow: inset 0 -1px 0 0 var(--lumo-contrast-10pct);
      position: relative;
      min-height: var(--lumo-size-l);
    }

    :host([orientation='horizontal']) [part='tabs'] ::slotted(vaadin-tab:not([theme~='icon-on-top'])) {
      justify-content: center;
    }

    :host([orientation='vertical']) {
      box-shadow: -1px 0 0 0 var(--lumo-contrast-10pct);
    }

    :host([orientation='horizontal']) [part='tabs'] {
      margin: 0 0.75rem;
    }

    :host([orientation='vertical']) [part='tabs'] {
      width: 100%;
      margin: 0.5rem 0;
    }

    [part='forward-button'],
    [part='back-button'] {
      position: absolute;
      z-index: 1;
      font-family: lumo-icons;
      color: var(--lumo-tertiary-text-color);
      font-size: var(--lumo-icon-size-m);
      display: flex;
      align-items: center;
      justify-content: center;
      width: 1.5em;
      height: 100%;
      transition: 0.2s opacity;
      top: 0;
    }

    [part='forward-button']:hover,
    [part='back-button']:hover {
      color: inherit;
    }

    :host(:not([dir='rtl'])) [part='forward-button'] {
      right: 0;
    }

    [part='forward-button']::after {
      content: var(--lumo-icons-angle-right);
    }

    [part='back-button']::after {
      content: var(--lumo-icons-angle-left);
    }

    /* Tabs overflow */

    [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: none;
      -webkit-mask-image: var(--_lumo-tabs-overflow-mask-image);
      mask-image: var(--_lumo-tabs-overflow-mask-image);
    }

    /* Horizontal tabs overflow */

    /* Both ends overflowing */
    :host([overflow~='start'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(
        90deg,
        transparent 2em,
        #000 4em,
        #000 calc(100% - 4em),
        transparent calc(100% - 2em)
      );
    }

    /* End overflowing */
    :host([overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, #000 calc(100% - 4em), transparent calc(100% - 2em));
    }

    /* Start overflowing */
    :host([overflow~='start']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, transparent 2em, #000 4em);
    }

    /* Vertical tabs overflow */

    /* Both ends overflowing */
    :host([overflow~='start'][overflow~='end'][orientation='vertical']) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(transparent, #000 2em, #000 calc(100% - 2em), transparent);
    }

    /* End overflowing */
    :host([overflow~='end'][orientation='vertical']) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(#000 calc(100% - 2em), transparent);
    }

    /* Start overflowing */
    :host([overflow~='start'][orientation='vertical']) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(transparent, #000 2em);
    }

    :host [part='tabs'] ::slotted(:not(vaadin-tab)) {
      margin-left: var(--lumo-space-m);
    }

    /* Centered */

    :host([theme~='centered'][orientation='horizontal']) ::slotted(vaadin-tab:first-of-type) {
      margin-inline-start: auto;
    }

    :host([theme~='centered'][orientation='horizontal']) ::slotted(vaadin-tab:last-of-type) {
      margin-inline-end: auto;
    }

    /* Small */

    :host([theme~='small']),
    :host([theme~='small']) [part='tabs'] {
      min-height: var(--lumo-size-m);
    }

    :host([theme~='small']) [part='tabs'] ::slotted(vaadin-tab) {
      font-size: var(--lumo-font-size-s);
    }

    /* Minimal */

    :host([theme~='minimal']) {
      box-shadow: none;
      --_lumo-tab-marker-display: none;
    }

    /* Hide-scroll-buttons */

    :host([theme~='hide-scroll-buttons']) [part='back-button'],
    :host([theme~='hide-scroll-buttons']) [part='forward-button'] {
      display: none;
    }

    /* prettier-ignore */
    :host([theme~='hide-scroll-buttons'][overflow~='start'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(
        90deg,
        transparent,
        #000 2em,
        #000 calc(100% - 2em),
        transparent 100%
      );
    }

    :host([theme~='hide-scroll-buttons'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, #000 calc(100% - 2em), transparent 100%);
    }

    :host([theme~='hide-scroll-buttons'][overflow~='start']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, transparent, #000 2em);
    }

    /* Equal-width tabs */
    :host([theme~='equal-width-tabs']) {
      flex: auto;
    }

    :host([theme~='equal-width-tabs']) [part='tabs'] ::slotted(vaadin-tab) {
      flex: 1 0 0%;
    }

    /* RTL specific styles */

    :host([dir='rtl']) [part='forward-button']::after {
      content: var(--lumo-icons-angle-left);
    }

    :host([dir='rtl']) [part='back-button']::after {
      content: var(--lumo-icons-angle-right);
    }

    :host([orientation='vertical'][dir='rtl']) {
      box-shadow: 1px 0 0 0 var(--lumo-contrast-10pct);
    }

    :host([dir='rtl']) [part='forward-button'] {
      left: 0;
    }

    :host([dir='rtl']) [part='tabs'] ::slotted(:not(vaadin-tab)) {
      margin-left: 0;
      margin-right: var(--lumo-space-m);
    }

    /* Both ends overflowing */
    :host([dir='rtl'][overflow~='start'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(
        -90deg,
        transparent 2em,
        #000 4em,
        #000 calc(100% - 4em),
        transparent calc(100% - 2em)
      );
    }

    /* End overflowing */
    :host([dir='rtl'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, #000 calc(100% - 4em), transparent calc(100% - 2em));
    }

    /* Start overflowing */
    :host([dir='rtl'][overflow~='start']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, transparent 2em, #000 4em);
    }

    :host([dir='rtl'][theme~='hide-scroll-buttons'][overflow~='start'][overflow~='end']:not([orientation='vertical']))
      [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(
        -90deg,
        transparent,
        #000 2em,
        #000 calc(100% - 2em),
        transparent 100%
      );
    }

    :host([dir='rtl'][theme~='hide-scroll-buttons'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, #000 calc(100% - 2em), transparent 100%);
    }

    :host([dir='rtl'][theme~='hide-scroll-buttons'][overflow~='start']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, transparent, #000 2em);
    }
  `,
  { moduleId: "lumo-tabs" }
);
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const TabsMixin = (superClass) => class TabsMixinClass extends ResizeMixin(ListMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Set tabs disposition. Possible values are `horizontal|vertical`
       * @type {!TabsOrientation}
       */
      orientation: {
        value: "horizontal",
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * The index of the selected tab.
       */
      selected: {
        value: 0,
        type: Number
      }
    };
  }
  static get observers() {
    return ["__tabsItemsChanged(items)"];
  }
  constructor() {
    super();
    this.__itemsResizeObserver = new ResizeObserver(() => {
      setTimeout(() => this._updateOverflow());
    });
  }
  /**
   * @return {number}
   * @protected
   */
  get _scrollOffset() {
    return this._vertical ? this._scrollerElement.offsetHeight : this._scrollerElement.offsetWidth;
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.$.scroll;
  }
  /** @private */
  get __direction() {
    return !this._vertical && this.__isRTL ? 1 : -1;
  }
  /** @protected */
  ready() {
    super.ready();
    this._scrollerElement.addEventListener("scroll", () => this._updateOverflow());
    this.setAttribute("role", "tablist");
    afterNextRender(this, () => {
      this._updateOverflow();
    });
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this._updateOverflow();
  }
  /** @private */
  __tabsItemsChanged(items) {
    this.__itemsResizeObserver.disconnect();
    (items || []).forEach((item2) => {
      this.__itemsResizeObserver.observe(item2);
    });
    this._updateOverflow();
  }
  /** @protected */
  _scrollForward() {
    const forwardButtonVisibleWidth = this._getNavigationButtonVisibleWidth("forward-button");
    const backButtonVisibleWidth = this._getNavigationButtonVisibleWidth("back-button");
    const scrollerRect = this._scrollerElement.getBoundingClientRect();
    const itemToScrollTo = [...this.items].reverse().find((item2) => this._isItemVisible(item2, forwardButtonVisibleWidth, backButtonVisibleWidth, scrollerRect));
    const itemRect = itemToScrollTo.getBoundingClientRect();
    const overflowIndicatorCompensation = 20;
    const totalCompensation = overflowIndicatorCompensation + this.shadowRoot.querySelector('[part="back-button"]').clientWidth;
    let scrollOffset;
    if (this.__isRTL) {
      const scrollerRightEdge = scrollerRect.right - totalCompensation;
      scrollOffset = itemRect.right - scrollerRightEdge;
    } else {
      const scrollerLeftEdge = scrollerRect.left + totalCompensation;
      scrollOffset = itemRect.left - scrollerLeftEdge;
    }
    if (-this.__direction * scrollOffset < 1) {
      scrollOffset = -this.__direction * (this._scrollOffset - totalCompensation);
    }
    this._scroll(scrollOffset);
  }
  /** @protected */
  _scrollBack() {
    const forwardButtonVisibleWidth = this._getNavigationButtonVisibleWidth("forward-button");
    const backButtonVisibleWidth = this._getNavigationButtonVisibleWidth("back-button");
    const scrollerRect = this._scrollerElement.getBoundingClientRect();
    const itemToScrollTo = this.items.find(
      (item2) => this._isItemVisible(item2, forwardButtonVisibleWidth, backButtonVisibleWidth, scrollerRect)
    );
    const itemRect = itemToScrollTo.getBoundingClientRect();
    const overflowIndicatorCompensation = 20;
    const totalCompensation = overflowIndicatorCompensation + this.shadowRoot.querySelector('[part="forward-button"]').clientWidth;
    let scrollOffset;
    if (this.__isRTL) {
      const scrollerLeftEdge = scrollerRect.left + totalCompensation;
      scrollOffset = itemRect.left - scrollerLeftEdge;
    } else {
      const scrollerRightEdge = scrollerRect.right - totalCompensation;
      scrollOffset = itemRect.right - scrollerRightEdge;
    }
    if (this.__direction * scrollOffset < 1) {
      scrollOffset = this.__direction * (this._scrollOffset - totalCompensation);
    }
    this._scroll(scrollOffset);
  }
  /** @private */
  _isItemVisible(item2, forwardButtonVisibleWidth, backButtonVisibleWidth, scrollerRect) {
    if (this._vertical) {
      throw new Error("Visibility check is only supported for horizontal tabs.");
    }
    const buttonOnTheRightWidth = this.__isRTL ? backButtonVisibleWidth : forwardButtonVisibleWidth;
    const buttonOnTheLeftWidth = this.__isRTL ? forwardButtonVisibleWidth : backButtonVisibleWidth;
    const scrollerRightEdge = scrollerRect.right - buttonOnTheRightWidth;
    const scrollerLeftEdge = scrollerRect.left + buttonOnTheLeftWidth;
    const itemRect = item2.getBoundingClientRect();
    return scrollerRightEdge > Math.floor(itemRect.left) && scrollerLeftEdge < Math.ceil(itemRect.right);
  }
  /** @private */
  _getNavigationButtonVisibleWidth(buttonPartName) {
    const navigationButton = this.shadowRoot.querySelector(`[part="${buttonPartName}"]`);
    if (window.getComputedStyle(navigationButton).opacity === "0") {
      return 0;
    }
    return navigationButton.clientWidth;
  }
  /** @private */
  _updateOverflow() {
    const scrollPosition = this._vertical ? this._scrollerElement.scrollTop : getNormalizedScrollLeft(this._scrollerElement, this.getAttribute("dir"));
    const scrollSize = this._vertical ? this._scrollerElement.scrollHeight : this._scrollerElement.scrollWidth;
    let overflow = Math.floor(scrollPosition) > 1 ? "start" : "";
    if (Math.ceil(scrollPosition) < Math.ceil(scrollSize - this._scrollOffset)) {
      overflow += " end";
    }
    if (this.__direction === 1) {
      overflow = overflow.replace(/start|end/giu, (matched) => {
        return matched === "start" ? "end" : "start";
      });
    }
    if (overflow) {
      this.setAttribute("overflow", overflow.trim());
    } else {
      this.removeAttribute("overflow");
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const tabsStyles = css`
  :host {
    display: flex;
    align-items: center;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([orientation='vertical']) {
    display: block;
  }

  :host([orientation='horizontal']) [part='tabs'] {
    flex-grow: 1;
    display: flex;
    align-self: stretch;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }

  /* This seems more future-proof than \`overflow: -moz-scrollbars-none\` which is marked obsolete
         and is no longer guaranteed to work:
         https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#Mozilla_Extensions */
  @-moz-document url-prefix() {
    :host([orientation='horizontal']) [part='tabs'] {
      overflow: hidden;
    }
  }

  :host([orientation='horizontal']) [part='tabs']::-webkit-scrollbar {
    display: none;
  }

  :host([orientation='vertical']) [part='tabs'] {
    height: 100%;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  [part='back-button'],
  [part='forward-button'] {
    pointer-events: none;
    opacity: 0;
    cursor: default;
  }

  :host([overflow~='start']) [part='back-button'],
  :host([overflow~='end']) [part='forward-button'] {
    pointer-events: auto;
    opacity: 1;
  }

  [part='back-button']::after {
    content: '\\25C0';
  }

  [part='forward-button']::after {
    content: '\\25B6';
  }

  :host([orientation='vertical']) [part='back-button'],
  :host([orientation='vertical']) [part='forward-button'] {
    display: none;
  }

  /* RTL specific styles */

  :host([dir='rtl']) [part='back-button']::after {
    content: '\\25B6';
  }

  :host([dir='rtl']) [part='forward-button']::after {
    content: '\\25C0';
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-tabs", tabsStyles, { moduleId: "vaadin-tabs-styles" });
class Tabs extends TabsMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <div on-click="_scrollBack" part="back-button" aria-hidden="true"></div>

      <div id="scroll" part="tabs">
        <slot></slot>
      </div>

      <div on-click="_scrollForward" part="forward-button" aria-hidden="true"></div>
    `;
  }
  static get is() {
    return "vaadin-tabs";
  }
}
defineCustomElement(Tabs);
const tabsheet = css`
  :host {
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-m);
    font-family: var(--lumo-font-family);
  }

  :host([theme~='bordered']) {
    border: 1px solid var(--lumo-contrast-20pct);
    border-radius: var(--lumo-border-radius-l);
  }

  [part='tabs-container'] {
    box-shadow: inset 0 -1px 0 0 var(--lumo-contrast-10pct);
    padding: var(--lumo-space-xs) var(--lumo-space-s);
    gap: var(--lumo-space-s);
  }

  ::slotted([slot='tabs']) {
    box-shadow: initial;
    margin: calc(var(--lumo-space-xs) * -1) calc(var(--lumo-space-s) * -1);
  }

  [part='content'] {
    padding: var(--lumo-space-s) var(--lumo-space-m);
    border-bottom-left-radius: inherit;
    border-bottom-right-radius: inherit;
  }

  :host([loading]) [part='content'] {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  :host([theme~='no-padding']) [part='content'] {
    padding: 0;
  }
`;
registerStyles$1("vaadin-tabsheet", [tabsheet, loader], { moduleId: "lumo-tabsheet" });
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TabsheetScroller extends Scroller {
  static get is() {
    return "vaadin-tabsheet-scroller";
  }
}
defineCustomElement(TabsheetScroller);
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TabsSlotController extends SlotController {
  constructor(host) {
    super(host, "tabs");
    this.__tabsItemsChangedListener = this.__tabsItemsChangedListener.bind(this);
    this.__tabsSelectedChangedListener = this.__tabsSelectedChangedListener.bind(this);
    this.__tabIdObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        const tab = mutation.target;
        host.__linkTabAndPanel(tab);
        if (tab.selected) {
          host.__togglePanels(tab);
        }
      });
    });
  }
  /** @private */
  __tabsItemsChangedListener() {
    this.__tabIdObserver.disconnect();
    const items = this.tabs.items || [];
    items.forEach((tab) => {
      this.__tabIdObserver.observe(tab, {
        attributeFilter: ["id"]
      });
    });
    this.host._setItems(items);
  }
  /** @private */
  __tabsSelectedChangedListener() {
    this.host.selected = this.tabs.selected;
  }
  initCustomNode(tabs) {
    if (!(tabs instanceof customElements.get("vaadin-tabs"))) {
      throw Error('The "tabs" slot of a <vaadin-tabsheet> must only contain a <vaadin-tabs> element!');
    }
    this.tabs = tabs;
    tabs.addEventListener("items-changed", this.__tabsItemsChangedListener);
    tabs.addEventListener("selected-changed", this.__tabsSelectedChangedListener);
    this.host.__tabs = tabs;
    this.host.stateTarget = tabs;
    this.__tabsItemsChangedListener();
  }
  teardownNode(tabs) {
    this.tabs = null;
    tabs.removeEventListener("items-changed", this.__tabsItemsChangedListener);
    tabs.removeEventListener("selected-changed", this.__tabsSelectedChangedListener);
    this.host.__tabs = null;
    this.host._setItems([]);
    this.host.stateTarget = void 0;
  }
}
const TabSheetMixin = (superClass) => class extends DelegateStateMixin(superClass) {
  static get properties() {
    return {
      /**
       * The list of `<vaadin-tab>`s from which a selection can be made.
       * It is populated from the elements passed inside the slotted
       * `<vaadin-tabs>`, and updated dynamically when adding or removing items.
       *
       * Note: unlike `<vaadin-combo-box>`, this property is read-only.
       * @type {!Array<!Tab> | undefined}
       */
      items: {
        type: Array,
        readOnly: true,
        notify: true
      },
      /**
       * The index of the selected tab.
       */
      selected: {
        value: 0,
        type: Number,
        notify: true
      },
      /**
       * The slotted <vaadin-tabs> element.
       */
      __tabs: {
        type: Object
      },
      /**
       * The panel elements.
       */
      __panels: {
        type: Array
      }
    };
  }
  static get observers() {
    return ["__itemsOrPanelsChanged(items, __panels)", "__selectedTabItemChanged(selected, items, __panels)"];
  }
  /** @override */
  static get delegateProps() {
    return ["selected", "_theme"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.__overflowController = new OverflowController(this, this.shadowRoot.querySelector('[part="content"]'));
    this.addController(this.__overflowController);
    this._tabsSlotController = new TabsSlotController(this);
    this.addController(this._tabsSlotController);
    const panelSlot = this.shadowRoot.querySelector("#panel-slot");
    this.__panelsObserver = new SlotObserver(panelSlot, ({ addedNodes, removedNodes }) => {
      if (addedNodes.length) {
        addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE && node.hidden) {
            node.__customHidden = true;
          }
        });
      }
      if (removedNodes.length) {
        removedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE && node.hidden) {
            if (node.__customHidden) {
              delete node.__customHidden;
            } else {
              node.hidden = false;
            }
          }
        });
      }
      this.__panels = Array.from(
        panelSlot.assignedNodes({
          flatten: true
        })
      ).filter((node) => node.nodeType === Node.ELEMENT_NODE);
    });
  }
  /**
   * Override method from `DelegateStateMixin` to set delegate `theme`
   * using attribute instead of property (needed for the Lit version).
   * @protected
   * @override
   */
  _delegateProperty(name, value) {
    if (!this.stateTarget) {
      return;
    }
    if (name === "_theme") {
      this._delegateAttribute("theme", value);
      return;
    }
    super._delegateProperty(name, value);
  }
  /**
   * An observer which applies the necessary roles and ARIA attributes
   * to associate the tab elements with the panels.
   * @private
   */
  __itemsOrPanelsChanged(items, panels) {
    if (!items || !panels) {
      return;
    }
    items.forEach((tabItem) => {
      this.__linkTabAndPanel(tabItem, panels);
    });
  }
  /**
   * An observer which toggles the visibility of the panels based on the selected tab.
   * @private
   */
  __selectedTabItemChanged(selected, items, panels) {
    if (!items || !panels || selected === void 0) {
      return;
    }
    this.__togglePanels(items[selected], panels);
  }
  /** @private */
  __togglePanels(selectedTab, panels = this.__panels) {
    const selectedTabId = selectedTab ? selectedTab.id : "";
    const selectedPanel = panels.find((panel) => panel.getAttribute("tab") === selectedTabId);
    const content = this.shadowRoot.querySelector('[part="content"]');
    this.toggleAttribute("loading", !selectedPanel);
    const hasOneVisiblePanel = panels.filter((panel) => !panel.hidden).length === 1;
    if (selectedPanel) {
      content.style.minHeight = "";
    } else if (hasOneVisiblePanel) {
      content.style.minHeight = `${content.offsetHeight}px`;
    }
    panels.forEach((panel) => {
      panel.hidden = panel !== selectedPanel;
    });
  }
  /** @private */
  __linkTabAndPanel(tab, panels = this.__panels) {
    const panel = panels.find((panel2) => panel2.getAttribute("tab") === tab.id);
    if (panel) {
      panel.role = "tabpanel";
      if (!panel.id) {
        panel.id = `tabsheet-panel-${generateUniqueId()}`;
      }
      panel.setAttribute("aria-labelledby", tab.id);
      tab.setAttribute("aria-controls", panel.id);
    }
  }
};
/**
 * @license
 * Copyright (c) 2022 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TabSheet extends TabSheetMixin(ThemableMixin(ElementMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host([hidden]) {
          display: none !important;
        }

        :host {
          display: flex;
          flex-direction: column;
        }

        [part='tabs-container'] {
          position: relative;
          display: flex;
          align-items: center;
        }

        ::slotted([slot='tabs']) {
          flex: 1;
          align-self: stretch;
          min-width: 8em;
        }

        [part='content'] {
          position: relative;
          flex: 1;
          box-sizing: border-box;
        }
      </style>

      <div part="tabs-container">
        <slot name="prefix"></slot>
        <slot name="tabs"></slot>
        <slot name="suffix"></slot>
      </div>

      <vaadin-tabsheet-scroller part="content">
        <div part="loader"></div>
        <slot id="panel-slot"></slot>
      </vaadin-tabsheet-scroller>
    `;
  }
  static get is() {
    return "vaadin-tabsheet";
  }
}
defineCustomElement(TabSheet);
let memoizedTemplate;
customElements.whenDefined("vaadin-text-field").then(() => {
  class BigDecimalFieldElement extends customElements.get("vaadin-text-field") {
    static get template() {
      if (!memoizedTemplate) {
        memoizedTemplate = super.template.cloneNode(true);
        memoizedTemplate.innerHTML += `<style>
                :host {
                  width: 8em;
                }

                :host([dir="rtl"]) [part="input-field"] {
                  direction: ltr;
                }

                :host([dir="rtl"]) [part="input-field"] ::slotted(input) {
                  --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em) !important;
                }
          </style>`;
      }
      return memoizedTemplate;
    }
    static get is() {
      return "vaadin-big-decimal-field";
    }
    static get properties() {
      return {
        _decimalSeparator: {
          type: String,
          value: ".",
          observer: "__decimalSeparatorChanged"
        }
      };
    }
    ready() {
      super.ready();
      this.inputElement.setAttribute("inputmode", "decimal");
    }
    __decimalSeparatorChanged(separator, oldSeparator) {
      this.allowedCharPattern = "[-+\\d" + separator + "]";
      if (this.value && oldSeparator) {
        this.value = this.value.split(oldSeparator).join(separator);
      }
    }
  }
  customElements.define(BigDecimalFieldElement.is, BigDecimalFieldElement);
});
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const emailField = css`
  :host([dir='rtl']) [part='input-field'] ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input:placeholder-shown) {
    --_lumo-text-field-overflow-mask-image: none;
  }
`;
registerStyles$1("vaadin-email-field", [inputFieldShared$1, emailField], {
  moduleId: "lumo-email-field"
});
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const emailFieldStyles = css`
  :host([dir='rtl']) [part='input-field'] {
    direction: ltr;
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input)::placeholder {
    direction: rtl;
    text-align: left;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-email-field", emailFieldStyles, { moduleId: "vaadin-email-field-styles" });
class EmailField extends TextField {
  static get is() {
    return "vaadin-email-field";
  }
  constructor() {
    super();
    this._setType("email");
    this.pattern = "^[a-zA-Z0-9_\\-+]+(?:\\.[a-zA-Z0-9_\\-+]+)*@[a-zA-Z0-9\\-.]+\\.[a-zA-Z0-9\\-]{2,}$";
  }
  /** @protected */
  ready() {
    super.ready();
    if (this.inputElement) {
      this.inputElement.autocapitalize = "off";
    }
  }
}
defineCustomElement(EmailField);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const numberField = css`
  :host([step-buttons-visible]:not([theme~='align-right'])) ::slotted(input) {
    text-align: center;
  }

  :host(:not([disabled])) [part$='button'][disabled] {
    opacity: 0.2;
  }

  :host([step-buttons-visible]) [part='input-field'] {
    padding: 0;
  }

  [part$='button'] {
    cursor: pointer;
    font-size: var(--lumo-icon-size-s);
    width: 1.6em;
    height: 1.6em;
  }

  [part$='button']::before {
    margin-top: 0.3em;
  }

  [part='decrease-button']::before {
    content: var(--lumo-icons-minus);
  }

  [part='increase-button']::before {
    content: var(--lumo-icons-plus);
  }

  /* RTL specific styles */
  :host([dir='rtl']:not([theme~='align-right'])) ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }
`;
registerStyles$1("vaadin-number-field", [inputFieldShared$1, numberField], {
  moduleId: "lumo-number-field"
});
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const NumberFieldMixin = (superClass) => class NumberFieldMixinClass extends InputFieldMixin(superClass) {
  static get properties() {
    return {
      /**
       * The minimum value of the field.
       */
      min: {
        type: Number
      },
      /**
       * The maximum value of the field.
       */
      max: {
        type: Number
      },
      /**
       * Specifies the allowed number intervals of the field.
       * @type {number}
       */
      step: {
        type: Number
      },
      /**
       * Set to true to show increase/decrease buttons.
       * @attr {boolean} step-buttons-visible
       */
      stepButtonsVisible: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return ["_stepChanged(step, inputElement)"];
  }
  static get delegateProps() {
    return [...super.delegateProps, "min", "max"];
  }
  static get constraints() {
    return [...super.constraints, "min", "max", "step"];
  }
  constructor() {
    super();
    this._setType("number");
    this.__onWheel = this.__onWheel.bind(this);
  }
  /** @protected */
  get slotStyles() {
    const tag = this.localName;
    return [
      `
          ${tag} input[type="number"]::-webkit-outer-spin-button,
          ${tag} input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
          }

          ${tag} input[type="number"] {
            -moz-appearance: textfield;
          }

          ${tag}[dir='rtl'] input[type="number"]::placeholder {
            direction: rtl;
          }

          ${tag}[dir='rtl']:not([step-buttons-visible]) input[type="number"]::placeholder {
            text-align: left;
          }
        `
    ];
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /**
   * Whether the input element's value is unparsable.
   *
   * @private
   */
  get __hasUnparsableValue() {
    return this.inputElement.validity.badInput;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
  }
  /**
   * Override the method from `InputConstraintsMixin`
   * to enforce HTML constraint validation even if
   * the user didn't add any constraints explicitly:
   * the field has to be regardless checked for bad input.
   *
   * @override
   */
  checkValidity() {
    if (this.inputElement) {
      return this.inputElement.checkValidity();
    }
    return !this.invalid;
  }
  /**
   * Override the method from `InputMixin` to add
   * a wheel event listener to the input element.
   *
   * @param {HTMLElement} input
   * @override
   * @protected
   */
  _addInputListeners(input) {
    super._addInputListeners(input);
    input.addEventListener("wheel", this.__onWheel);
  }
  /**
   * Override the method from `InputMixin` to remove
   * the wheel event listener from the input element.
   *
   * @param {HTMLElement} input
   * @override
   * @protected
   */
  _removeInputListeners(input) {
    super._removeInputListeners(input);
    input.removeEventListener("wheel", this.__onWheel);
  }
  /**
   * Prevents default browser behavior for wheel events on the input element
   * when it's focused. More precisely, this prevents the browser from attempting
   * to increment or decrement the value when the mouse wheel is used within
   * the input element.
   *
   * CAVEAT: As a side-effect, this also prevents page scrolling when
   * the pointer is positioned over the field and the field is focused.
   *
   * @param {WheelEvent} event
   * @private
   */
  __onWheel(event) {
    if (this.hasAttribute("focused")) {
      event.preventDefault();
    }
  }
  /** @protected */
  _onDecreaseButtonTouchend(e2) {
    if (e2.cancelable) {
      e2.preventDefault();
      this.__blurActiveElement();
      this._decreaseValue();
    }
  }
  /** @protected */
  _onIncreaseButtonTouchend(e2) {
    if (e2.cancelable) {
      e2.preventDefault();
      this.__blurActiveElement();
      this._increaseValue();
    }
  }
  /** @private */
  __blurActiveElement() {
    const activeElement = getDeepActiveElement();
    if (activeElement && activeElement !== this.inputElement) {
      activeElement.blur();
    }
  }
  /** @protected */
  _onDecreaseButtonClick() {
    this._decreaseValue();
  }
  /** @protected */
  _onIncreaseButtonClick() {
    this._increaseValue();
  }
  /** @private */
  _decreaseValue() {
    this._incrementValue(-1);
  }
  /** @private */
  _increaseValue() {
    this._incrementValue(1);
  }
  /** @private */
  _incrementValue(incr) {
    if (this.disabled || this.readonly) {
      return;
    }
    const step = this.step || 1;
    let value = parseFloat(this.value);
    if (!this.value) {
      if (this.min === 0 && incr < 0 || this.max === 0 && incr > 0 || this.max === 0 && this.min === 0) {
        incr = 0;
        value = 0;
      } else if ((this.max == null || this.max >= 0) && (this.min == null || this.min <= 0)) {
        value = 0;
      } else if (this.min > 0) {
        value = this.min;
        if (this.max < 0 && incr < 0) {
          value = this.max;
        }
        incr = 0;
      } else if (this.max < 0) {
        value = this.max;
        if (incr < 0) {
          incr = 0;
        } else if (this._getIncrement(1, value - step) > this.max) {
          value -= 2 * step;
        } else {
          value -= step;
        }
      }
    } else if (value < this.min) {
      incr = 0;
      value = this.min;
    } else if (value > this.max) {
      incr = 0;
      value = this.max;
    }
    const newValue = this._getIncrement(incr, value);
    if (!this.value || incr === 0 || this._incrementIsInsideTheLimits(incr, value)) {
      this.inputElement.value = String(parseFloat(newValue));
      this.inputElement.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
      this.__commitValueChange();
    }
  }
  /** @private */
  _getIncrement(incr, currentValue) {
    let step = this.step || 1, min = this.min || 0;
    const multiplier = Math.max(
      this._getMultiplier(currentValue),
      this._getMultiplier(step),
      this._getMultiplier(min)
    );
    step *= multiplier;
    currentValue = Math.round(currentValue * multiplier);
    min *= multiplier;
    const margin = (currentValue - min) % step;
    if (incr > 0) {
      return (currentValue - margin + step) / multiplier;
    } else if (incr < 0) {
      return (currentValue - (margin || step)) / multiplier;
    }
    return currentValue / multiplier;
  }
  /** @private */
  _getDecimalCount(number) {
    const s3 = String(number);
    const i2 = s3.indexOf(".");
    return i2 === -1 ? 1 : s3.length - i2 - 1;
  }
  /** @private */
  _getMultiplier(number) {
    if (!isNaN(number)) {
      return 10 ** this._getDecimalCount(number);
    }
  }
  /** @private */
  _incrementIsInsideTheLimits(incr, value) {
    if (incr < 0) {
      return this.min == null || this._getIncrement(incr, value) >= this.min;
    } else if (incr > 0) {
      return this.max == null || this._getIncrement(incr, value) <= this.max;
    }
    return this._getIncrement(incr, value) <= this.max && this._getIncrement(incr, value) >= this.min;
  }
  /** @protected */
  _isButtonEnabled(sign) {
    const incr = sign * (this.step || 1);
    const value = parseFloat(this.value);
    return !this.value || !this.disabled && this._incrementIsInsideTheLimits(incr, value);
  }
  /**
   * @param {number} step
   * @param {HTMLElement | undefined} inputElement
   * @protected
   */
  _stepChanged(step, inputElement) {
    if (inputElement) {
      inputElement.step = step || "any";
    }
  }
  /**
   * @param {unknown} newVal
   * @param {unknown} oldVal
   * @protected
   * @override
   */
  _valueChanged(newVal, oldVal) {
    if (newVal && isNaN(parseFloat(newVal))) {
      this.value = "";
    } else if (typeof this.value !== "string") {
      this.value = String(this.value);
    }
    super._valueChanged(this.value, oldVal);
    if (!this.__keepCommittedValue) {
      this.__committedValue = this.value;
      this.__committedUnparsableValueStatus = false;
    }
  }
  /**
   * Override an event listener from `InputControlMixin`
   * to avoid adding a separate listener.
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    if (event.key === "ArrowUp") {
      event.preventDefault();
      this._increaseValue();
    } else if (event.key === "ArrowDown") {
      event.preventDefault();
      this._decreaseValue();
    }
    super._onKeyDown(event);
  }
  /**
   * Native [type=number] inputs don't update their value
   * when you are entering input that the browser is unable to parse
   * e.g. "--5", hence we have to override this method from `InputMixin`
   * so that, when value is empty, it would additionally check
   * for bad input based on the native `validity.badInput` property.
   *
   * @param {InputEvent} event
   * @protected
   * @override
   */
  _setHasInputValue(event) {
    const target = event.composedPath()[0];
    this._hasInputValue = target.value.length > 0 || this.__hasUnparsableValue;
  }
  /**
   * Override this method from `InputMixin` to prevent
   * the value change caused by user input from being treated
   * as initiated programmatically by the developer and therefore
   * from getting silently committed by the value observer without
   * any change event. The value change will be committed later
   * on blur or Enter.
   *
   * @param {InputEvent} event
   * @override
   * @protected
   */
  _onInput(event) {
    this.__keepCommittedValue = true;
    super._onInput(event);
    this.__keepCommittedValue = false;
  }
  /**
   * Override this method from `InputControlMixin`
   * to stop propagation of the native change event.
   *
   * @param {Event}
   * @override
   * @protected
   */
  _onChange(event) {
    event.stopPropagation();
  }
  /**
   * Override this method from `ClearButtonMixin`
   * to properly commit the empty value since
   * the change handler doesn't do that anymore.
   *
   * @param {MouseEvent} event
   * @override
   * @protected
   */
  _onClearAction(event) {
    super._onClearAction(event);
    this.__commitValueChange();
  }
  /**
   * Override this method from `FocusMixin`
   * to commit a possible pending value change on blur.
   *
   * @param {boolean} focused
   * @override
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this.__commitValueChange();
    }
  }
  /**
   * Override this method from `KeyboardMixin`
   * to commit a possible pending value change on Enter.
   *
   * @param {KeyboardEvent} event
   * @override
   * @protected
   */
  _onEnter(event) {
    super._onEnter(event);
    this.__commitValueChange();
  }
  /**
   * Depending on the nature of the value change that has occurred since
   * the last commit attempt, triggers validation and fires an event:
   *
   * Value change             | Event
   * :------------------------|:------------------
   * empty => parsable        | change
   * empty => unparsable      | unparsable-change
   * parsable => empty        | change
   * parsable => parsable     | change
   * parsable => unparsable   | change
   * unparsable => empty      | unparsable-change
   * unparsable => parsable   | change
   * unparsable => unparsable | -
   *
   * Note, there is currently no way to detect unparsable => unparsable changes
   * because the browser doesn't provide access to unparsable values of native
   * [type=number] inputs.
   *
   * @private
   */
  __commitValueChange() {
    if (this.__committedValue !== this.value) {
      this._requestValidation();
      this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
    } else if (this.__committedUnparsableValueStatus !== this.__hasUnparsableValue) {
      this._requestValidation();
      this.dispatchEvent(new CustomEvent("unparsable-change"));
    }
    this.__committedValue = this.value;
    this.__committedUnparsableValueStatus = this.__hasUnparsableValue;
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const numberFieldStyles = css`
  :host([readonly]) [part$='button'] {
    pointer-events: none;
  }

  [part='decrease-button']::before {
    content: '\\2212';
  }

  [part='increase-button']::before {
    content: '+';
  }

  [part='decrease-button'],
  [part='increase-button'] {
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
  }

  :host([dir='rtl']) [part='input-field'] {
    direction: ltr;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-number-field", [inputFieldShared, numberFieldStyles], {
  moduleId: "vaadin-number-field-styles"
});
class NumberField extends NumberFieldMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-number-field";
  }
  static get template() {
    return html`
      <div class="vaadin-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <div
            disabled$="[[!_isButtonEnabled(-1, value, min, max, step)]]"
            part="decrease-button"
            on-click="_onDecreaseButtonClick"
            on-touchend="_onDecreaseButtonTouchend"
            hidden$="[[!stepButtonsVisible]]"
            aria-hidden="true"
            slot="prefix"
          ></div>
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <slot name="suffix" slot="suffix"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div
            disabled$="[[!_isButtonEnabled(1, value, min, max, step)]]"
            part="increase-button"
            on-click="_onIncreaseButtonClick"
            on-touchend="_onIncreaseButtonTouchend"
            hidden$="[[!stepButtonsVisible]]"
            aria-hidden="true"
            slot="suffix"
          ></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
}
defineCustomElement(NumberField);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class IntegerField extends NumberField {
  static get is() {
    return "vaadin-integer-field";
  }
  constructor() {
    super();
    this.allowedCharPattern = "[-+\\d]";
  }
  /**
   * Override an observer from `InputMixin` to clear the value
   * when trying to type invalid characters.
   * @param {string | undefined} newVal
   * @param {string | undefined} oldVal
   * @protected
   * @override
   */
  _valueChanged(newVal, oldVal) {
    if (newVal !== "" && !this.__isInteger(newVal)) {
      console.warn(`Trying to set non-integer value "${newVal}" to <vaadin-integer-field>. Clearing the value.`);
      this.value = "";
      return;
    }
    super._valueChanged(newVal, oldVal);
  }
  /**
   * Override an observer from `NumberField` to reset the step
   * property when an invalid step is set.
   * @param {number} newVal
   * @param {HTMLElement | undefined} inputElement
   * @protected
   * @override
   */
  _stepChanged(step, inputElement) {
    if (step != null && !this.__hasOnlyDigits(step)) {
      console.warn(
        `<vaadin-integer-field> The \`step\` property must be a positive integer but \`${step}\` was provided, so the property was reset to \`null\`.`
      );
      this.step = null;
      return;
    }
    super._stepChanged(step, inputElement);
  }
  /** @private */
  __isInteger(value) {
    return /^(-\d)?\d*$/u.test(String(value));
  }
  /** @private */
  __hasOnlyDigits(value) {
    return /^\d+$/u.test(String(value));
  }
}
defineCustomElement(IntegerField);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class LiveDirective extends Directive {
  constructor(partInfo) {
    super(partInfo);
    if (!(partInfo.type === PartType.PROPERTY || partInfo.type === PartType.ATTRIBUTE || partInfo.type === PartType.BOOLEAN_ATTRIBUTE)) {
      throw new Error("The `live` directive is not allowed on child or event bindings");
    }
    if (!isSingleExpression(partInfo)) {
      throw new Error("`live` bindings can only contain a single expression");
    }
  }
  render(value) {
    return value;
  }
  update(part, [value]) {
    if (value === noChange || value === nothing) {
      return value;
    }
    const element = part.element;
    const name = part.name;
    if (part.type === PartType.PROPERTY) {
      if (value === element[name]) {
        return noChange;
      }
    } else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {
      if (!!value === element.hasAttribute(name)) {
        return noChange;
      }
    } else if (part.type === PartType.ATTRIBUTE) {
      if (element.getAttribute(name) === String(value)) {
        return noChange;
      }
    }
    setCommittedValue(part);
    return value;
  }
}
const live = directive(LiveDirective);
const _window = window;
_window.Vaadin = _window.Vaadin || {};
_window.Vaadin.setLitRenderer = (component, rendererName, templateExpression, returnChannel, clientCallables, propertyNamespace, appId) => {
  const callablesCreator = (itemKey) => {
    return clientCallables.map((clientCallable) => (...args) => {
      if (itemKey !== void 0) {
        returnChannel(clientCallable, itemKey, args[0] instanceof Event ? [] : [...args]);
      }
    });
  };
  const fnArgs = [
    "html",
    "root",
    "live",
    "appId",
    "itemKey",
    "model",
    "item",
    "index",
    ...clientCallables,
    `return html\`${templateExpression}\``
  ];
  const htmlGenerator = new Function(...fnArgs);
  const renderFunction = (root2, model, itemKey) => {
    const { item: item2, index } = model;
    render(htmlGenerator(html$1, root2, live, appId, itemKey, model, item2, index, ...callablesCreator(itemKey)), root2);
  };
  const renderer = (root2, _, model) => {
    const { item: item2 } = model;
    if (root2.__litRenderer !== renderer) {
      root2.innerHTML = "";
      delete root2._$litPart$;
      root2.__litRenderer = renderer;
    }
    const mappedItem = {};
    for (const key in item2) {
      if (key.startsWith(propertyNamespace)) {
        mappedItem[key.replace(propertyNamespace, "")] = item2[key];
      }
    }
    renderFunction(root2, { ...model, item: mappedItem }, item2.key);
  };
  renderer.__rendererId = propertyNamespace;
  component[rendererName] = renderer;
};
_window.Vaadin.unsetLitRenderer = (component, rendererName, rendererId) => {
  var _a2;
  if (((_a2 = component[rendererName]) == null ? void 0 : _a2.__rendererId) === rendererId) {
    component[rendererName] = void 0;
  }
};
registerStyles$1(
  "vaadin-grid-tree-toggle",
  css`
    :host {
      --vaadin-grid-tree-toggle-level-offset: 2em;
      align-items: center;
      vertical-align: middle;
      transform: translateX(calc(var(--lumo-space-s) * -1));
      -webkit-tap-highlight-color: transparent;
    }

    :host(:not([leaf])) {
      cursor: default;
    }

    [part='toggle'] {
      display: inline-block;
      font-size: 1.5em;
      line-height: 1;
      width: 1em;
      height: 1em;
      text-align: center;
      color: var(--lumo-contrast-50pct);
      cursor: var(--lumo-clickable-cursor);
      /* Increase touch target area */
      padding: calc(1em / 3);
      margin: calc(1em / -3);
    }

    :host(:not([dir='rtl'])) [part='toggle'] {
      margin-right: 0;
    }

    @media (hover: hover) {
      :host(:hover) [part='toggle'] {
        color: var(--lumo-contrast-80pct);
      }
    }

    [part='toggle']::before {
      font-family: 'lumo-icons';
      display: inline-block;
      height: 100%;
    }

    :host(:not([expanded])) [part='toggle']::before {
      content: var(--lumo-icons-angle-right);
    }

    :host([expanded]) [part='toggle']::before {
      content: var(--lumo-icons-angle-right);
      transform: rotate(90deg);
    }

    /* Experimental support for hierarchy connectors, using an unsupported selector */
    :host([theme~='connectors']) #level-spacer {
      position: relative;
      z-index: -1;
      font-size: 1em;
      height: 1.5em;
    }

    :host([theme~='connectors']) #level-spacer::before {
      display: block;
      content: '';
      margin-top: calc(var(--lumo-space-m) * -1);
      height: calc(var(--lumo-space-m) + 3em);
      background-image: linear-gradient(
        to right,
        transparent calc(var(--vaadin-grid-tree-toggle-level-offset) - 1px),
        var(--lumo-contrast-10pct) calc(var(--vaadin-grid-tree-toggle-level-offset) - 1px)
      );
      background-size: var(--vaadin-grid-tree-toggle-level-offset) var(--vaadin-grid-tree-toggle-level-offset);
      background-position: calc(var(--vaadin-grid-tree-toggle-level-offset) / 2 - 2px) 0;
    }

    /* RTL specific styles */

    :host([dir='rtl']) {
      margin-left: 0;
      margin-right: calc(var(--lumo-space-s) * -1);
    }

    :host([dir='rtl']) [part='toggle'] {
      margin-left: 0;
    }

    :host([dir='rtl'][expanded]) [part='toggle']::before {
      transform: rotate(-90deg);
    }

    :host([dir='rtl'][theme~='connectors']) #level-spacer::before {
      background-image: linear-gradient(
        to left,
        transparent calc(var(--vaadin-grid-tree-toggle-level-offset) - 1px),
        var(--lumo-contrast-10pct) calc(var(--vaadin-grid-tree-toggle-level-offset) - 1px)
      );
      background-position: calc(100% - (var(--vaadin-grid-tree-toggle-level-offset) / 2 - 2px)) 0;
    }

    :host([dir='rtl']:not([expanded])) [part='toggle']::before,
    :host([dir='rtl'][expanded]) [part='toggle']::before {
      content: var(--lumo-icons-angle-left);
    }
  `,
  { moduleId: "lumo-grid-tree-toggle" }
);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const template$2 = document.createElement("template");
template$2.innerHTML = `
  <style>
    @font-face {
      font-family: "vaadin-grid-tree-icons";
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAQkAA0AAAAABrwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAECAAAABoAAAAcgHwa6EdERUYAAAPsAAAAHAAAAB4AJwAOT1MvMgAAAZQAAAA/AAAAYA8TBIJjbWFwAAAB8AAAAFUAAAFeGJvXWmdhc3AAAAPkAAAACAAAAAgAAAAQZ2x5ZgAAAlwAAABLAAAAhIrPOhFoZWFkAAABMAAAACsAAAA2DsJI02hoZWEAAAFcAAAAHQAAACQHAgPHaG10eAAAAdQAAAAZAAAAHAxVAgBsb2NhAAACSAAAABIAAAASAIAAVG1heHAAAAF8AAAAGAAAACAACgAFbmFtZQAAAqgAAAECAAACTwflzbdwb3N0AAADrAAAADYAAABZQ7Ajh3icY2BkYGAA4twv3Vfi+W2+MnCzMIDANSOmbGSa2YEZRHEwMIEoAAoiB6sAeJxjYGRgYD7w/wADAwsDCDA7MDAyoAI2AFEEAtIAAAB4nGNgZGBg4GBgZgDRDAxMDGgAAAGbABB4nGNgZp7JOIGBlYGBaSbTGQYGhn4IzfiawZiRkwEVMAqgCTA4MDA+38d84P8BBgdmIAapQZJVYGAEAGc/C54AeJxjYYAAxlAIzQTELAwMBxgZGB0ACy0BYwAAAHicY2BgYGaAYBkGRgYQiADyGMF8FgYbIM3FwMHABISMDArP9/3/+/8/WJXC8z0Q9v8nEp5gHVwMMMAIMo+RDYiZoQJMQIKJARUA7WBhGN4AACFKDtoAAAAAAAAAAAgACAAQABgAJgA0AEIAAHichYvBEYBADAKBVHBjBT4swl9KS2k05o0XHd/yW1hAfBFwCv9sIlJu3nZaNS3PXAaXXHI8Lge7DlzF7C1RgXc7xkK6+gvcD2URmQB4nK2RQWoCMRiFX3RUqtCli65yADModOMBLLgQSqHddRFnQghIAnEUvEA3vUUP0LP0Fj1G+yb8R5iEhO9/ef/7FwFwj28o9EthiVp4hBlehcfUP4Ur8o/wBAv8CU+xVFvhOR7UB7tUdUdlVRJ6HnHWTnhM/V24In8JT5j/KzzFSi2E53hUz7jCcrcIiDDwyKSW1JEct2HdIPH1DFytbUM0PofWdNk5E5oUqb/Q6HHBiVGZpfOXkyUMEj5IyBuNmYZQjBobfsuassvnkKLe1OuBBj0VQ8cRni2xjLWsHaM0jrjx3peYA0/vrdmUYqe9iy7bzrX6eNP7Jh1SijX+AaUVbB8AAHicY2BiwA84GBgYmRiYGJkZmBlZGFkZ2djScyoLMgzZS/MyDQwMwLSruZMzlHaB0q4A76kLlwAAAAEAAf//AA94nGNgZGBg4AFiMSBmYmAEQnYgZgHzGAAD6wA2eJxjYGBgZACCKxJigiD6mhFTNowGACmcA/8AAA==) format('woff');
      font-weight: normal;
      font-style: normal;
    }
  </style>
`;
document.head.appendChild(template$2.content);
registerStyles$1(
  "vaadin-grid-tree-toggle",
  css`
    :host {
      display: inline-flex;
      align-items: baseline;
      max-width: 100%;

      /* CSS API for :host */
      --vaadin-grid-tree-toggle-level-offset: 1em;
      --_collapsed-icon: '\\e7be\\00a0';
    }

    :host([dir='rtl']) {
      --_collapsed-icon: '\\e7bd\\00a0';
    }

    :host([hidden]) {
      display: none !important;
    }

    :host(:not([leaf])) {
      cursor: pointer;
    }

    #level-spacer,
    [part='toggle'] {
      flex: none;
    }

    #level-spacer {
      display: inline-block;
      width: calc(var(--_level, '0') * var(--vaadin-grid-tree-toggle-level-offset));
    }

    [part='toggle']::before {
      font-family: 'vaadin-grid-tree-icons';
      line-height: 1em; /* make icon font metrics not affect baseline */
    }

    :host(:not([expanded])) [part='toggle']::before {
      content: var(--_collapsed-icon);
    }

    :host([expanded]) [part='toggle']::before {
      content: '\\e7bc\\00a0'; /* icon glyph + single non-breaking space */
    }

    :host([leaf]) [part='toggle'] {
      visibility: hidden;
    }

    slot {
      display: block;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  `,
  { moduleId: "vaadin-grid-tree-toggle-styles" }
);
const GridTreeToggleMixin = (superClass) => class extends superClass {
  static get properties() {
    return {
      /**
       * Current level of the tree represented with a horizontal offset
       * of the toggle button.
       * @type {number}
       */
      level: {
        type: Number,
        value: 0,
        observer: "_levelChanged",
        sync: true
      },
      /**
       * Hides the toggle icon and disables toggling a tree sublevel.
       * @type {boolean}
       */
      leaf: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Sublevel toggle state.
       * @type {boolean}
       */
      expanded: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        notify: true,
        sync: true
      }
    };
  }
  constructor() {
    super();
    this.addEventListener("click", (e2) => this._onClick(e2));
  }
  /** @private */
  _onClick(e2) {
    if (this.leaf) {
      return;
    }
    if (isFocusable(e2.target) || e2.target instanceof HTMLLabelElement) {
      return;
    }
    e2.preventDefault();
    this.expanded = !this.expanded;
  }
  /** @private */
  _levelChanged(level) {
    const value = Number(level).toString();
    this.style.setProperty("--_level", value);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class GridTreeToggle extends GridTreeToggleMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-grid-tree-toggle";
  }
  static get template() {
    return html`
      <span id="level-spacer"></span>
      <span part="toggle"></span>
      <slot></slot>
    `;
  }
}
defineCustomElement(GridTreeToggle);
registerStyles$1(
  "vaadin-upload",
  css`
    :host {
      line-height: var(--lumo-line-height-m);
    }

    :host(:not([nodrop])) {
      overflow: hidden;
      border: 1px dashed var(--lumo-contrast-20pct);
      border-radius: var(--lumo-border-radius-l);
      padding: var(--lumo-space-m);
      transition:
        background-color 0.6s,
        border-color 0.6s;
    }

    [part='drop-label'] {
      display: inline-block;
      white-space: normal;
      padding: 0 var(--lumo-space-s);
      color: var(--lumo-secondary-text-color);
      font-family: var(--lumo-font-family);
    }

    :host([dragover-valid]) {
      border-color: var(--lumo-primary-color-50pct);
      background: var(--lumo-primary-color-10pct);
      transition:
        background-color 0.1s,
        border-color 0.1s;
    }

    :host([dragover-valid]) [part='drop-label'] {
      color: var(--lumo-primary-text-color);
    }

    :host([disabled]) [part='drop-label'],
    :host([max-files-reached]) [part='drop-label'] {
      color: var(--lumo-disabled-text-color);
    }
  `,
  { moduleId: "lumo-upload" }
);
registerStyles$1(
  "vaadin-upload-icon",
  css`
    :host::before {
      content: var(--lumo-icons-upload);
      font-family: lumo-icons;
      font-size: var(--lumo-icon-size-m);
      line-height: 1;
      vertical-align: -0.25em;
    }
  `,
  { moduleId: "lumo-upload-icon" }
);
registerStyles$1(
  "vaadin-upload-file-list",
  css`
    ::slotted(li:not(:first-of-type)) {
      border-top: 1px solid var(--lumo-contrast-10pct);
    }
  `,
  { moduleId: "lumo-upload-file-list" }
);
const uploadFile = css`
  :host {
    padding: var(--lumo-space-s) 0;
    outline: none;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  :host([focus-ring]) [part='row'] {
    border-radius: var(--lumo-border-radius-s);
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  [part='row'] {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
  }

  [part='status'],
  [part='error'] {
    color: var(--lumo-secondary-text-color);
    font-size: var(--lumo-font-size-s);
  }

  [part='info'] {
    display: flex;
    align-items: baseline;
    flex: auto;
  }

  [part='meta'] {
    width: 0.001px;
    flex: 1 1 auto;
  }

  [part='name'] {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  [part='commands'] {
    display: flex;
    align-items: baseline;
    flex: none;
  }

  [part$='icon'] {
    margin-right: var(--lumo-space-xs);
    font-size: var(--lumo-icon-size-m);
    font-family: 'lumo-icons';
    line-height: 1;
  }

  /* When both icons are hidden, let us keep space for one */
  [part='done-icon'][hidden] + [part='warning-icon'][hidden] {
    display: block !important;
    visibility: hidden;
  }

  [part$='button'] {
    flex: none;
    margin-left: var(--lumo-space-xs);
    cursor: var(--lumo-clickable-cursor);
  }

  [part$='button']:focus {
    outline: none;
    border-radius: var(--lumo-border-radius-s);
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  [part$='icon']::before,
  [part$='button']::before {
    vertical-align: -0.25em;
  }

  [part='done-icon']::before {
    content: var(--lumo-icons-checkmark);
    color: var(--lumo-primary-text-color);
  }

  [part='warning-icon']::before {
    content: var(--lumo-icons-error);
    color: var(--lumo-error-text-color);
  }

  [part='start-button']::before {
    content: var(--lumo-icons-play);
  }

  [part='retry-button']::before {
    content: var(--lumo-icons-reload);
  }

  [part='remove-button']::before {
    content: var(--lumo-icons-cross);
  }

  [part='error'] {
    color: var(--lumo-error-text-color);
  }

  ::slotted([slot='progress']) {
    width: auto;
    margin-left: calc(var(--lumo-icon-size-m) + var(--lumo-space-xs));
    margin-right: calc(var(--lumo-icon-size-m) + var(--lumo-space-xs));
  }
`;
registerStyles$1("vaadin-upload-file", [fieldButton, uploadFile], { moduleId: "lumo-upload-file" });
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class UploadIcon extends ThemableMixin(PolymerElement) {
  static get is() {
    return "vaadin-upload-icon";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
    `;
  }
}
defineCustomElement(UploadIcon);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const template$1 = document.createElement("template");
template$1.innerHTML = `
  <style>
    @font-face {
      font-family: 'vaadin-upload-icons';
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAasAAsAAAAABmAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIF5mNtYXAAAAFoAAAAVAAAAFQXVtKMZ2FzcAAAAbwAAAAIAAAACAAAABBnbHlmAAABxAAAAfQAAAH0bBJxYWhlYWQAAAO4AAAANgAAADYPD267aGhlYQAAA/AAAAAkAAAAJAfCA8tobXR4AAAEFAAAACgAAAAoHgAAx2xvY2EAAAQ8AAAAFgAAABYCSgHsbWF4cAAABFQAAAAgAAAAIAAOADVuYW1lAAAEdAAAAhYAAAIWmmcHf3Bvc3QAAAaMAAAAIAAAACAAAwAAAAMDtwGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6QUDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADgAAAAKAAgAAgACAAEAIOkF//3//wAAAAAAIOkA//3//wAB/+MXBAADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAgAA/8AEAAPAABkAMgAAEz4DMzIeAhczLgMjIg4CBycRIScFIRcOAyMiLgInIx4DMzI+AjcXphZGWmo6SH9kQwyADFiGrmJIhXJbIEYBAFoDWv76YBZGXGw8Rn5lRQyADFmIrWBIhHReIkYCWjJVPSIyVnVDXqN5RiVEYTxG/wBa2loyVT0iMlZ1Q16jeUYnRWE5RgAAAAABAIAAAAOAA4AAAgAAExEBgAMAA4D8gAHAAAAAAwAAAAAEAAOAAAIADgASAAAJASElIiY1NDYzMhYVFAYnETMRAgD+AAQA/gAdIyMdHSMjXYADgPyAgCMdHSMjHR0jwAEA/wAAAQANADMD5gNaAAUAACUBNwUBFwHT/jptATMBppMzAU2a4AIgdAAAAAEAOv/6A8YDhgALAAABJwkBBwkBFwkBNwEDxoz+xv7GjAFA/sCMAToBOoz+wAL6jP7AAUCM/sb+xowBQP7AjAE6AAAAAwAA/8AEAAPAAAcACwASAAABFSE1IREhEQEjNTMJAjMRIRECwP6A/sAEAP0AgIACQP7A/sDAAQABQICA/oABgP8AgAHAAUD+wP6AAYAAAAABAAAAAQAAdhiEdV8PPPUACwQAAAAAANX4FR8AAAAA1fgVHwAA/8AEAAPAAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAQAAAEAAAAAAAAAAAAAAAAAAAAKBAAAAAAAAAAAAAAAAgAAAAQAAAAEAACABAAAAAQAAA0EAAA6BAAAAAAAAAAACgAUAB4AagB4AJwAsADSAPoAAAABAAAACgAzAAMAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAADgCuAAEAAAAAAAEAEwAAAAEAAAAAAAIABwDMAAEAAAAAAAMAEwBaAAEAAAAAAAQAEwDhAAEAAAAAAAUACwA5AAEAAAAAAAYAEwCTAAEAAAAAAAoAGgEaAAMAAQQJAAEAJgATAAMAAQQJAAIADgDTAAMAAQQJAAMAJgBtAAMAAQQJAAQAJgD0AAMAAQQJAAUAFgBEAAMAAQQJAAYAJgCmAAMAAQQJAAoANAE0dmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzVmVyc2lvbiAxLjAAVgBlAHIAcwBpAG8AbgAgADEALgAwdmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzdmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzUmVndWxhcgBSAGUAZwB1AGwAYQBydmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzRm9udCBnZW5lcmF0ZWQgYnkgSWNvTW9vbi4ARgBvAG4AdAAgAGcAZQBuAGUAcgBhAHQAZQBkACAAYgB5ACAASQBjAG8ATQBvAG8AbgAuAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==) format('woff');
      font-weight: normal;
      font-style: normal;
    }
  </style>
`;
document.head.appendChild(template$1.content);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const UploadFileMixin = (superClass) => class UploadFileMixin extends FocusMixin(superClass) {
  static get properties() {
    return {
      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * True if uploading is completed, false otherwise.
       */
      complete: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Error message returned by the server, if any.
       */
      errorMessage: {
        type: String,
        value: "",
        observer: "_errorMessageChanged"
      },
      /**
       * The object representing a file.
       */
      file: {
        type: Object
      },
      /**
       * Name of the uploading file.
       */
      fileName: {
        type: String
      },
      /**
       * True if uploading is not started, false otherwise.
       */
      held: {
        type: Boolean,
        value: false
      },
      /**
       * True if remaining time is unknown, false otherwise.
       */
      indeterminate: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * The object used to localize this component.
       */
      i18n: {
        type: Object
      },
      /**
       * Number representing the uploading progress.
       */
      progress: {
        type: Number
      },
      /**
       * Uploading status.
       */
      status: {
        type: String
      },
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       * @protected
       */
      tabindex: {
        type: Number,
        value: 0
      },
      /**
       * True if uploading is in progress, false otherwise.
       */
      uploading: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /** @private */
      _progress: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["__updateTabindex(tabindex, disabled)", "__updateProgress(_progress, progress, indeterminate)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new SlotController(this, "progress", "vaadin-progress-bar", {
        initializer: (progress) => {
          this._progress = progress;
        }
      })
    );
    this.shadowRoot.addEventListener("focusin", (e2) => {
      const target = e2.composedPath()[0];
      if (target.getAttribute("part").endsWith("button")) {
        this._setFocused(false);
      }
    });
    this.shadowRoot.addEventListener("focusout", (e2) => {
      if (e2.relatedTarget === this) {
        this._setFocused(true);
      }
    });
  }
  /**
   * Override method inherited from `FocusMixin` to mark the file as focused
   * only when the host is focused.
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldSetFocus(event) {
    return event.composedPath()[0] === this;
  }
  /** @private */
  __disabledChanged(disabled) {
    if (disabled) {
      this.removeAttribute("tabindex");
    } else {
      this.setAttribute("tabindex", this.tabindex);
    }
  }
  /** @private */
  _errorMessageChanged(errorMessage) {
    this.toggleAttribute("error", Boolean(errorMessage));
  }
  /** @private */
  __updateTabindex(tabindex, disabled) {
    if (disabled) {
      this.removeAttribute("tabindex");
    } else {
      this.setAttribute("tabindex", tabindex);
    }
  }
  /** @private */
  __updateProgress(progress, value, indeterminate) {
    if (progress) {
      progress.value = isNaN(value) ? 0 : value / 100;
      progress.indeterminate = indeterminate;
    }
  }
  /** @private */
  _fireFileEvent(e2) {
    e2.preventDefault();
    return this.dispatchEvent(
      new CustomEvent(e2.target.getAttribute("file-event"), {
        detail: { file: this.file },
        bubbles: true,
        composed: true
      })
    );
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const uploadFileStyles = css`
  :host {
    display: block;
  }

  [hidden] {
    display: none;
  }

  [part='row'] {
    list-style-type: none;
  }

  button {
    background: transparent;
    padding: 0;
    border: none;
    box-shadow: none;
  }

  :host([complete]) ::slotted([slot='progress']),
  :host([error]) ::slotted([slot='progress']) {
    display: none !important;
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-upload-file", uploadFileStyles, { moduleId: "vaadin-upload-file-styles" });
class UploadFile extends UploadFileMixin(ThemableMixin(ControllerMixin(PolymerElement))) {
  static get template() {
    return html`
      <div part="row">
        <div part="info">
          <div part="done-icon" hidden$="[[!complete]]" aria-hidden="true"></div>
          <div part="warning-icon" hidden$="[[!errorMessage]]" aria-hidden="true"></div>

          <div part="meta">
            <div part="name" id="name">[[fileName]]</div>
            <div part="status" hidden$="[[!status]]" id="status">[[status]]</div>
            <div part="error" id="error" hidden$="[[!errorMessage]]">[[errorMessage]]</div>
          </div>
        </div>
        <div part="commands">
          <button
            type="button"
            part="start-button"
            file-event="file-start"
            on-click="_fireFileEvent"
            hidden$="[[!held]]"
            disabled$="[[disabled]]"
            aria-label$="[[i18n.file.start]]"
            aria-describedby="name"
          ></button>
          <button
            type="button"
            part="retry-button"
            file-event="file-retry"
            on-click="_fireFileEvent"
            hidden$="[[!errorMessage]]"
            disabled$="[[disabled]]"
            aria-label$="[[i18n.file.retry]]"
            aria-describedby="name"
          ></button>
          <button
            type="button"
            part="remove-button"
            file-event="file-abort"
            on-click="_fireFileEvent"
            disabled$="[[disabled]]"
            aria-label$="[[i18n.file.remove]]"
            aria-describedby="name"
          ></button>
        </div>
      </div>

      <slot name="progress"></slot>
    `;
  }
  static get is() {
    return "vaadin-upload-file";
  }
  /**
   * Fired when the retry button is pressed. It is listened by `vaadin-upload`
   * which will start a new upload process of this file.
   *
   * @event file-retry
   * @param {Object} detail
   * @param {Object} detail.file file to retry upload of
   */
  /**
   * Fired when the start button is pressed. It is listened by `vaadin-upload`
   * which will start a new upload process of this file.
   *
   * @event file-start
   * @param {Object} detail
   * @param {Object} detail.file file to start upload of
   */
  /**
   * Fired when abort button is pressed. It is listened by `vaadin-upload` which
   * will abort the upload in progress, and then remove the file from the list.
   *
   * @event file-abort
   * @param {Object} detail
   * @param {Object} detail.file file to abort upload of
   */
}
defineCustomElement(UploadFile);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const UploadFileListMixin = (superClass) => class UploadFileListMixin extends superClass {
  static get properties() {
    return {
      /**
       * The array of files being processed, or already uploaded.
       */
      items: {
        type: Array
      },
      /**
       * The object used to localize upload files.
       */
      i18n: {
        type: Object
      },
      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return ["__updateItems(items, i18n, disabled)"];
  }
  /** @private */
  __updateItems(items, i18n) {
    if (items && i18n) {
      this.requestContentUpdate();
    }
  }
  /**
   * Requests an update for the `vaadin-upload-file` elements.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    const { items, i18n, disabled } = this;
    render(
      html$1`
          ${items.map(
        (file) => html$1`
              <li>
                <vaadin-upload-file
                  .disabled="${disabled}"
                  .file="${file}"
                  .complete="${file.complete}"
                  .errorMessage="${file.error}"
                  .fileName="${file.name}"
                  .held="${file.held}"
                  .indeterminate="${file.indeterminate}"
                  .progress="${file.progress}"
                  .status="${file.status}"
                  .uploading="${file.uploading}"
                  .i18n="${i18n}"
                ></vaadin-upload-file>
              </li>
            `
      )}
        `,
      this
    );
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class UploadFileList extends UploadFileListMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-upload-file-list";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='list'] {
          padding: 0;
          margin: 0;
          list-style-type: none;
        }
      </style>
      <ul part="list">
        <slot></slot>
      </ul>
    `;
  }
}
defineCustomElement(UploadFileList);
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class AddButtonController extends SlotController {
  constructor(host) {
    super(host, "add-button", "vaadin-button");
  }
  /**
   * Override method inherited from `SlotController`
   * to add listeners to default and custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initNode(node) {
    if (node._isDefault) {
      this.defaultNode = node;
    }
    node.addEventListener("touchend", (e2) => {
      this.host._onAddFilesTouchEnd(e2);
    });
    node.addEventListener("click", (e2) => {
      this.host._onAddFilesClick(e2);
    });
    this.host._addButton = node;
  }
}
class DropLabelController extends SlotController {
  constructor(host) {
    super(host, "drop-label", "span");
  }
  /**
   * Override method inherited from `SlotController`
   * to add listeners to default and custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initNode(node) {
    if (node._isDefault) {
      this.defaultNode = node;
    }
    this.host._dropLabel = node;
  }
}
const UploadMixin = (superClass) => class UploadMixin extends superClass {
  static get properties() {
    return {
      /**
       * If true, the user cannot interact with this element.
       * @type {boolean}
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Define whether the element supports dropping files on it for uploading.
       * By default it's enabled in desktop and disabled in touch devices
       * because mobile devices do not support drag events in general. Setting
       * it false means that drop is enabled even in touch-devices, and true
       * disables drop in all devices.
       *
       * @type {boolean}
       * @default true in touch-devices, false otherwise.
       */
      nodrop: {
        type: Boolean,
        reflectToAttribute: true,
        value: isTouch
      },
      /**
       * The server URL. The default value is an empty string, which means that
       * _window.location_ will be used.
       * @type {string}
       */
      target: {
        type: String,
        value: ""
      },
      /**
       * HTTP Method used to send the files. Only POST and PUT are allowed.
       * @type {!UploadMethod}
       */
      method: {
        type: String,
        value: "POST"
      },
      /**
       * Key-Value map to send to the server. If you set this property as an
       * attribute, use a valid JSON string, for example:
       * ```
       * <vaadin-upload headers='{"X-Foo": "Bar"}'></vaadin-upload>
       * ```
       * @type {object | string}
       */
      headers: {
        type: Object,
        value: {}
      },
      /**
       * Max time in milliseconds for the entire upload process, if exceeded the
       * request will be aborted. Zero means that there is no timeout.
       * @type {number}
       */
      timeout: {
        type: Number,
        value: 0
      },
      /** @private */
      _dragover: {
        type: Boolean,
        value: false,
        observer: "_dragoverChanged"
      },
      /**
       * The array of files being processed, or already uploaded.
       *
       * Each element is a [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File)
       * object with a number of extra properties  to track the upload process:
       * - `uploadTarget`: The target URL used to upload this file.
       * - `elapsed`: Elapsed time since the upload started.
       * - `elapsedStr`: Human-readable elapsed time.
       * - `remaining`: Number of seconds remaining for the upload to finish.
       * - `remainingStr`: Human-readable remaining time for the upload to finish.
       * - `progress`: Percentage of the file already uploaded.
       * - `speed`: Upload speed in kB/s.
       * - `size`: File size in bytes.
       * - `totalStr`: Human-readable total size of the file.
       * - `loaded`: Bytes transferred so far.
       * - `loadedStr`: Human-readable uploaded size at the moment.
       * - `status`: Status of the upload process.
       * - `error`: Error message in case the upload failed.
       * - `abort`: True if the file was canceled by the user.
       * - `complete`: True when the file was transferred to the server.
       * - `uploading`: True while transferring data to the server.
       * @type {!Array<!UploadFile>}
       */
      files: {
        type: Array,
        notify: true,
        value: () => [],
        sync: true
      },
      /**
       * Limit of files to upload, by default it is unlimited. If the value is
       * set to one, native file browser will prevent selecting multiple files.
       * @attr {number} max-files
       * @type {number}
       */
      maxFiles: {
        type: Number,
        value: Infinity,
        sync: true
      },
      /**
       * Specifies if the maximum number of files have been uploaded
       * @attr {boolean} max-files-reached
       * @type {boolean}
       */
      maxFilesReached: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },
      /**
       * Specifies the types of files that the server accepts.
       * Syntax: a comma-separated list of MIME type patterns (wildcards are
       * allowed) or file extensions.
       * Notice that MIME types are widely supported, while file extensions
       * are only implemented in certain browsers, so avoid using it.
       * Example: accept="video/*,image/tiff" or accept=".pdf,audio/mp3"
       * @type {string}
       */
      accept: {
        type: String,
        value: ""
      },
      /**
       * Specifies the maximum file size in bytes allowed to upload.
       * Notice that it is a client-side constraint, which will be checked before
       * sending the request. Obviously you need to do the same validation in
       * the server-side and be sure that they are aligned.
       * @attr {number} max-file-size
       * @type {number}
       */
      maxFileSize: {
        type: Number,
        value: Infinity
      },
      /**
       * Specifies if the dragover is validated with maxFiles and
       * accept properties.
       * @private
       */
      _dragoverValid: {
        type: Boolean,
        value: false,
        observer: "_dragoverValidChanged"
      },
      /**
       * Specifies the 'name' property at Content-Disposition
       * @attr {string} form-data-name
       * @type {string}
       */
      formDataName: {
        type: String,
        value: "file"
      },
      /**
       * Prevents upload(s) from immediately uploading upon adding file(s).
       * When set, you must manually trigger uploads using the `uploadFiles` method
       * @attr {boolean} no-auto
       * @type {boolean}
       */
      noAuto: {
        type: Boolean,
        value: false
      },
      /**
       * Set the withCredentials flag on the request.
       * @attr {boolean} with-credentials
       * @type {boolean}
       */
      withCredentials: {
        type: Boolean,
        value: false
      },
      /**
       * Pass-through to input's capture attribute. Allows user to trigger device inputs
       * such as camera or microphone immediately.
       */
      capture: String,
      /**
       * The object used to localize this component.
       * For changing the default localization, change the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure and default values:
       *
       * ```
       * {
       *   dropFiles: {
       *     one: 'Drop file here',
       *     many: 'Drop files here'
       *   },
       *   addFiles: {
       *     one: 'Upload File...',
       *     many: 'Upload Files...'
       *   },
       *   error: {
       *     tooManyFiles: 'Too Many Files.',
       *     fileIsTooBig: 'File is Too Big.',
       *     incorrectFileType: 'Incorrect File Type.'
       *   },
       *   uploading: {
       *     status: {
       *       connecting: 'Connecting...',
       *       stalled: 'Stalled',
       *       processing: 'Processing File...',
       *       held: 'Queued'
       *     },
       *     remainingTime: {
       *       prefix: 'remaining time: ',
       *       unknown: 'unknown remaining time'
       *     },
       *     error: {
       *       serverUnavailable: 'Upload failed, please try again later',
       *       unexpectedServerError: 'Upload failed due to server error',
       *       forbidden: 'Upload forbidden'
       *     }
       *   },
       *   file: {
       *     retry: 'Retry',
       *     start: 'Start',
       *     remove: 'Remove'
       *   },
       *   units: {
       *     size: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
       *     sizeBase: 1000
       *   },
       *   formatSize: function(bytes) {
       *     // returns the size followed by the best suitable unit
       *   },
       *   formatTime: function(seconds, [secs, mins, hours]) {
       *     // returns a 'HH:MM:SS' string
       *   }
       * }
       * ```
       *
       * @type {!UploadI18n}
       * @default {English}
       */
      i18n: {
        type: Object,
        value() {
          return {
            dropFiles: {
              one: "Drop file here",
              many: "Drop files here"
            },
            addFiles: {
              one: "Upload File...",
              many: "Upload Files..."
            },
            error: {
              tooManyFiles: "Too Many Files.",
              fileIsTooBig: "File is Too Big.",
              incorrectFileType: "Incorrect File Type."
            },
            uploading: {
              status: {
                connecting: "Connecting...",
                stalled: "Stalled",
                processing: "Processing File...",
                held: "Queued"
              },
              remainingTime: {
                prefix: "remaining time: ",
                unknown: "unknown remaining time"
              },
              error: {
                serverUnavailable: "Upload failed, please try again later",
                unexpectedServerError: "Upload failed due to server error",
                forbidden: "Upload forbidden"
              }
            },
            file: {
              retry: "Retry",
              start: "Start",
              remove: "Remove"
            },
            units: {
              size: ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
            }
          };
        }
      },
      /** @private */
      _addButton: {
        type: Object
      },
      /** @private */
      _dropLabel: {
        type: Object
      },
      /** @private */
      _fileList: {
        type: Object
      },
      /** @private */
      _files: {
        type: Array
      }
    };
  }
  static get observers() {
    return [
      "__updateAddButton(_addButton, maxFiles, i18n, maxFilesReached, disabled)",
      "__updateDropLabel(_dropLabel, maxFiles, i18n)",
      "__updateFileList(_fileList, files, i18n, disabled)",
      "__updateMaxFilesReached(maxFiles, files)"
    ];
  }
  /** @private */
  get __acceptRegexp() {
    if (!this.accept) {
      return null;
    }
    const processedTokens = this.accept.split(",").map((token) => {
      let processedToken = token.trim();
      processedToken = processedToken.replace(/[+.]/gu, "\\$&");
      if (processedToken.startsWith("\\.")) {
        processedToken = `.*${processedToken}$`;
      }
      return processedToken.replace(/\/\*/gu, "/.*");
    });
    return new RegExp(`^(${processedTokens.join("|")})$`, "iu");
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("dragover", this._onDragover.bind(this));
    this.addEventListener("dragleave", this._onDragleave.bind(this));
    this.addEventListener("drop", this._onDrop.bind(this));
    this.addEventListener("file-retry", this._onFileRetry.bind(this));
    this.addEventListener("file-abort", this._onFileAbort.bind(this));
    this.addEventListener("file-start", this._onFileStart.bind(this));
    this.addEventListener("file-reject", this._onFileReject.bind(this));
    this.addEventListener("upload-start", this._onUploadStart.bind(this));
    this.addEventListener("upload-success", this._onUploadSuccess.bind(this));
    this.addEventListener("upload-error", this._onUploadError.bind(this));
    this._addButtonController = new AddButtonController(this);
    this.addController(this._addButtonController);
    this._dropLabelController = new DropLabelController(this);
    this.addController(this._dropLabelController);
    this.addController(
      new SlotController(this, "file-list", "vaadin-upload-file-list", {
        initializer: (list) => {
          this._fileList = list;
        }
      })
    );
    this.addController(new SlotController(this, "drop-label-icon", "vaadin-upload-icon"));
  }
  /** @private */
  _formatSize(bytes) {
    if (typeof this.i18n.formatSize === "function") {
      return this.i18n.formatSize(bytes);
    }
    const base = this.i18n.units.sizeBase || 1e3;
    const unit = ~~(Math.log(bytes) / Math.log(base));
    const dec = Math.max(0, Math.min(3, unit - 1));
    const size = parseFloat((bytes / base ** unit).toFixed(dec));
    return `${size} ${this.i18n.units.size[unit]}`;
  }
  /** @private */
  _splitTimeByUnits(time) {
    const unitSizes = [60, 60, 24, Infinity];
    const timeValues = [0];
    for (let i2 = 0; i2 < unitSizes.length && time > 0; i2++) {
      timeValues[i2] = time % unitSizes[i2];
      time = Math.floor(time / unitSizes[i2]);
    }
    return timeValues;
  }
  /** @private */
  _formatTime(seconds, split2) {
    if (typeof this.i18n.formatTime === "function") {
      return this.i18n.formatTime(seconds, split2);
    }
    while (split2.length < 3) {
      split2.push(0);
    }
    return split2.reverse().map((number) => {
      return (number < 10 ? "0" : "") + number;
    }).join(":");
  }
  /** @private */
  _formatFileProgress(file) {
    const remainingTime = file.loaded > 0 ? this.i18n.uploading.remainingTime.prefix + file.remainingStr : this.i18n.uploading.remainingTime.unknown;
    return `${file.totalStr}: ${file.progress}% (${remainingTime})`;
  }
  /** @private */
  __updateMaxFilesReached(maxFiles, files) {
    this._setMaxFilesReached(maxFiles >= 0 && files.length >= maxFiles);
  }
  /** @private */
  __updateAddButton(addButton, maxFiles, i18n, maxFilesReached, disabled) {
    if (addButton) {
      addButton.disabled = disabled || maxFilesReached;
      if (addButton === this._addButtonController.defaultNode) {
        addButton.textContent = this._i18nPlural(maxFiles, i18n.addFiles);
      }
    }
  }
  /** @private */
  __updateDropLabel(dropLabel, maxFiles, i18n) {
    if (dropLabel && dropLabel === this._dropLabelController.defaultNode) {
      dropLabel.textContent = this._i18nPlural(maxFiles, i18n.dropFiles);
    }
  }
  /** @private */
  __updateFileList(list, files, i18n, disabled) {
    if (list) {
      list.items = [...files];
      list.i18n = i18n;
      list.disabled = disabled;
    }
  }
  /** @private */
  _onDragover(event) {
    event.preventDefault();
    if (!this.nodrop && !this._dragover) {
      this._dragoverValid = !this.maxFilesReached && !this.disabled;
      this._dragover = true;
    }
    event.dataTransfer.dropEffect = !this._dragoverValid || this.nodrop ? "none" : "copy";
  }
  /** @private */
  _onDragleave(event) {
    event.preventDefault();
    if (this._dragover && !this.nodrop) {
      this._dragover = this._dragoverValid = false;
    }
  }
  /** @private */
  async _onDrop(event) {
    if (!this.nodrop && !this.disabled) {
      event.preventDefault();
      this._dragover = this._dragoverValid = false;
      const files = await this.__getFilesFromDropEvent(event);
      this._addFiles(files);
    }
  }
  /**
   * Get the files from the drop event. The dropped items may contain a
   * combination of files and directories. If a dropped item is a directory,
   * it will be recursively traversed to get all files.
   *
   * @param {!DragEvent} dropEvent - The drop event
   * @returns {Promise<File[]>} - The files from the drop event
   * @private
   */
  __getFilesFromDropEvent(dropEvent) {
    async function getFilesFromEntry(entry) {
      if (entry.isFile) {
        return new Promise((resolve) => {
          entry.file(resolve, () => resolve([]));
        });
      } else if (entry.isDirectory) {
        const reader = entry.createReader();
        const entries = await new Promise((resolve) => {
          reader.readEntries(resolve, () => resolve([]));
        });
        const files = await Promise.all(entries.map(getFilesFromEntry));
        return files.flat();
      }
    }
    const filePromises = Array.from(dropEvent.dataTransfer.items).map((item2) => item2.webkitGetAsEntry()).filter((entry) => !!entry).map(getFilesFromEntry);
    return Promise.all(filePromises).then((files) => files.flat());
  }
  /** @private */
  _createXhr() {
    return new XMLHttpRequest();
  }
  /** @private */
  _configureXhr(xhr) {
    if (typeof this.headers === "string") {
      try {
        this.headers = JSON.parse(this.headers);
      } catch (_) {
        this.headers = void 0;
      }
    }
    Object.entries(this.headers).forEach(([key, value]) => {
      xhr.setRequestHeader(key, value);
    });
    if (this.timeout) {
      xhr.timeout = this.timeout;
    }
    xhr.withCredentials = this.withCredentials;
  }
  /** @private */
  _setStatus(file, total, loaded, elapsed) {
    file.elapsed = elapsed;
    file.elapsedStr = this._formatTime(file.elapsed, this._splitTimeByUnits(file.elapsed));
    file.remaining = Math.ceil(elapsed * (total / loaded - 1));
    file.remainingStr = this._formatTime(file.remaining, this._splitTimeByUnits(file.remaining));
    file.speed = ~~(total / elapsed / 1024);
    file.totalStr = this._formatSize(total);
    file.loadedStr = this._formatSize(loaded);
    file.status = this._formatFileProgress(file);
  }
  /**
   * Triggers the upload of any files that are not completed
   *
   * @param {!UploadFile | !Array<!UploadFile>=} files - Files being uploaded. Defaults to all outstanding files
   */
  uploadFiles(files = this.files) {
    if (files && !Array.isArray(files)) {
      files = [files];
    }
    files = files.filter((file) => !file.complete);
    Array.prototype.forEach.call(files, this._uploadFile.bind(this));
  }
  /** @private */
  _uploadFile(file) {
    if (file.uploading) {
      return;
    }
    const ini = Date.now();
    const xhr = file.xhr = this._createXhr();
    let stalledId, last;
    xhr.upload.onprogress = (e2) => {
      clearTimeout(stalledId);
      last = Date.now();
      const elapsed = (last - ini) / 1e3;
      const loaded = e2.loaded, total = e2.total, progress = ~~(loaded / total * 100);
      file.loaded = loaded;
      file.progress = progress;
      file.indeterminate = loaded <= 0 || loaded >= total;
      if (file.error) {
        file.indeterminate = file.status = void 0;
      } else if (!file.abort) {
        if (progress < 100) {
          this._setStatus(file, total, loaded, elapsed);
          stalledId = setTimeout(() => {
            file.status = this.i18n.uploading.status.stalled;
            this._renderFileList();
          }, 2e3);
        } else {
          file.loadedStr = file.totalStr;
          file.status = this.i18n.uploading.status.processing;
        }
      }
      this._renderFileList();
      this.dispatchEvent(new CustomEvent("upload-progress", { detail: { file, xhr } }));
    };
    xhr.onreadystatechange = () => {
      if (xhr.readyState === 4) {
        clearTimeout(stalledId);
        file.indeterminate = file.uploading = false;
        if (file.abort) {
          return;
        }
        file.status = "";
        const evt2 = this.dispatchEvent(
          new CustomEvent("upload-response", {
            detail: { file, xhr },
            cancelable: true
          })
        );
        if (!evt2) {
          return;
        }
        if (xhr.status === 0) {
          file.error = this.i18n.uploading.error.serverUnavailable;
        } else if (xhr.status >= 500) {
          file.error = this.i18n.uploading.error.unexpectedServerError;
        } else if (xhr.status >= 400) {
          file.error = this.i18n.uploading.error.forbidden;
        }
        file.complete = !file.error;
        this.dispatchEvent(
          new CustomEvent(`upload-${file.error ? "error" : "success"}`, {
            detail: { file, xhr }
          })
        );
        this._renderFileList();
      }
    };
    const formData = new FormData();
    if (!file.uploadTarget) {
      file.uploadTarget = this.target || "";
    }
    file.formDataName = this.formDataName;
    const evt = this.dispatchEvent(
      new CustomEvent("upload-before", {
        detail: { file, xhr },
        cancelable: true
      })
    );
    if (!evt) {
      return;
    }
    formData.append(file.formDataName, file, file.name);
    xhr.open(this.method, file.uploadTarget, true);
    this._configureXhr(xhr);
    file.status = this.i18n.uploading.status.connecting;
    file.uploading = file.indeterminate = true;
    file.complete = file.abort = file.error = file.held = false;
    xhr.upload.onloadstart = () => {
      this.dispatchEvent(
        new CustomEvent("upload-start", {
          detail: { file, xhr }
        })
      );
      this._renderFileList();
    };
    const uploadEvt = this.dispatchEvent(
      new CustomEvent("upload-request", {
        detail: { file, xhr, formData },
        cancelable: true
      })
    );
    if (uploadEvt) {
      xhr.send(formData);
    }
  }
  /** @private */
  _retryFileUpload(file) {
    const evt = this.dispatchEvent(
      new CustomEvent("upload-retry", {
        detail: { file, xhr: file.xhr },
        cancelable: true
      })
    );
    if (evt) {
      this._uploadFile(file);
      this._updateFocus(this.files.indexOf(file));
    }
  }
  /** @private */
  _abortFileUpload(file) {
    const evt = this.dispatchEvent(
      new CustomEvent("upload-abort", {
        detail: { file, xhr: file.xhr },
        cancelable: true
      })
    );
    if (evt) {
      file.abort = true;
      if (file.xhr) {
        file.xhr.abort();
      }
      this._removeFile(file);
    }
  }
  /** @private */
  _renderFileList() {
    if (this._fileList) {
      this._fileList.requestContentUpdate();
    }
  }
  /** @private */
  _addFiles(files) {
    Array.prototype.forEach.call(files, this._addFile.bind(this));
  }
  /**
   * Add the file for uploading. Called internally for each file after picking files from dialog or dropping files.
   *
   * @param {!UploadFile} file File being added
   * @protected
   */
  _addFile(file) {
    if (this.maxFilesReached) {
      this.dispatchEvent(
        new CustomEvent("file-reject", {
          detail: { file, error: this.i18n.error.tooManyFiles }
        })
      );
      return;
    }
    if (this.maxFileSize >= 0 && file.size > this.maxFileSize) {
      this.dispatchEvent(
        new CustomEvent("file-reject", {
          detail: { file, error: this.i18n.error.fileIsTooBig }
        })
      );
      return;
    }
    const re2 = this.__acceptRegexp;
    if (re2 && !(re2.test(file.type) || re2.test(file.name))) {
      this.dispatchEvent(
        new CustomEvent("file-reject", {
          detail: { file, error: this.i18n.error.incorrectFileType }
        })
      );
      return;
    }
    file.loaded = 0;
    file.held = true;
    file.status = this.i18n.uploading.status.held;
    this.files = [file, ...this.files];
    if (!this.noAuto) {
      this._uploadFile(file);
    }
  }
  /** @private */
  _updateFocus(fileIndex) {
    if (this.files.length === 0) {
      this._addButton.focus();
      return;
    }
    const lastFileRemoved = fileIndex === this.files.length;
    if (lastFileRemoved) {
      fileIndex -= 1;
    }
    this._fileList.children[fileIndex].firstElementChild.focus();
  }
  /**
   * Remove file from upload list. Called internally if file upload was canceled.
   * @param {!UploadFile} file File to remove
   * @protected
   */
  _removeFile(file) {
    const fileIndex = this.files.indexOf(file);
    if (fileIndex >= 0) {
      this.files = this.files.filter((i2) => i2 !== file);
      this.dispatchEvent(
        new CustomEvent("file-remove", {
          detail: { file },
          bubbles: true,
          composed: true
        })
      );
      this._updateFocus(fileIndex);
    }
  }
  /** @private */
  _onAddFilesTouchEnd(e2) {
    e2.preventDefault();
    this._onAddFilesClick(e2);
  }
  /** @private */
  _onAddFilesClick(e2) {
    if (this.maxFilesReached) {
      return;
    }
    e2.stopPropagation();
    this.$.fileInput.value = "";
    this.$.fileInput.click();
  }
  /** @private */
  _onFileInputChange(event) {
    this._addFiles(event.target.files);
  }
  /** @private */
  _onFileStart(event) {
    this._uploadFile(event.detail.file);
  }
  /** @private */
  _onFileRetry(event) {
    this._retryFileUpload(event.detail.file);
  }
  /** @private */
  _onFileAbort(event) {
    this._abortFileUpload(event.detail.file);
  }
  /** @private */
  _onFileReject(event) {
    announce(`${event.detail.file.name}: ${event.detail.error}`, { mode: "alert" });
  }
  /** @private */
  _onUploadStart(event) {
    announce(`${event.detail.file.name}: 0%`, { mode: "alert" });
  }
  /** @private */
  _onUploadSuccess(event) {
    announce(`${event.detail.file.name}: 100%`, { mode: "alert" });
  }
  /** @private */
  _onUploadError(event) {
    announce(`${event.detail.file.name}: ${event.detail.file.error}`, { mode: "alert" });
  }
  /** @private */
  _dragoverChanged(dragover) {
    if (dragover) {
      this.setAttribute("dragover", dragover);
    } else {
      this.removeAttribute("dragover");
    }
  }
  /** @private */
  _dragoverValidChanged(dragoverValid) {
    if (dragoverValid) {
      this.setAttribute("dragover-valid", dragoverValid);
    } else {
      this.removeAttribute("dragover-valid");
    }
  }
  /** @private */
  _i18nPlural(value, plural) {
    return value === 1 ? plural.one : plural.many;
  }
  /** @protected */
  _isMultiple(maxFiles) {
    return maxFiles !== 1;
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Upload extends UploadMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          position: relative;
          box-sizing: border-box;
        }

        :host([hidden]) {
          display: none !important;
        }

        [hidden] {
          display: none !important;
        }
      </style>

      <div part="primary-buttons">
        <slot name="add-button"></slot>
        <div part="drop-label" hidden$="[[nodrop]]" id="dropLabelContainer" aria-hidden="true">
          <slot name="drop-label-icon"></slot>
          <slot name="drop-label"></slot>
        </div>
      </div>
      <slot name="file-list"></slot>
      <slot></slot>
      <input
        type="file"
        id="fileInput"
        hidden
        on-change="_onFileInputChange"
        accept$="{{accept}}"
        multiple$="[[_isMultiple(maxFiles)]]"
        capture$="[[capture]]"
      />
    `;
  }
  static get is() {
    return "vaadin-upload";
  }
  /**
   * Fired when a file cannot be added to the queue due to a constrain:
   *  file-size, file-type or maxFiles
   *
   * @event file-reject
   * @param {Object} detail
   * @param {Object} detail.file the file added
   * @param {string} detail.error the cause
   */
  /**
   * Fired before the XHR is opened. Could be used for changing the request
   * URL. If the default is prevented, then XHR would not be opened.
   *
   * @event upload-before
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   * @param {Object} detail.file.uploadTarget the upload request URL, initialized with the value of vaadin-upload `target` property
   */
  /**
   * Fired when the XHR has been opened but not sent yet. Useful for appending
   * data keys to the FormData object, for changing some parameters like
   * headers, etc. If the event is defaultPrevented, `vaadin-upload` will not
   * send the request allowing the user to do something on his own.
   *
   * @event upload-request
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   * @param {Object} detail.formData the FormData object
   */
  /**
   * Fired when the XHR is sent.
   *
   * @event upload-start
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   */
  /**
   * Fired as many times as the progress is updated.
   *
   * @event upload-progress
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded with loaded info
   */
  /**
   * Fired when we have the actual server response, and before the component
   * analyses it. It's useful for developers to make the upload fail depending
   * on the server response. If the event is defaultPrevented the vaadin-upload
   * will return allowing the user to do something on his own like retry the
   * upload, etc. since he has full access to the `xhr` and `file` objects.
   * Otherwise, if the event is not prevented default `vaadin-upload` continues
   * with the normal workflow checking the `xhr.status` and `file.error`
   * which also might be modified by the user to force a customized response.
   *
   * @event upload-response
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   */
  /**
   * Fired in case the upload process succeed.
   *
   * @event upload-success
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded with loaded info
   */
  /**
   * Fired in case the upload process failed.
   *
   * @event upload-error
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   */
  /**
   * Fired when retry upload is requested. If the default is prevented, then
   * retry would not be performed.
   *
   * @event upload-retry
   * @param {Object} detail
   * @param {Object} detail.xhr the previous upload xhr
   * @param {Object} detail.file the file being uploaded
   */
  /**
   * Fired when retry abort is requested. If the default is prevented, then the
   * file upload would not be aborted.
   *
   * @event upload-abort
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   */
}
defineCustomElement(Upload);
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const VirtualListMixin = (superClass) => class VirtualListMixinClass extends ControllerMixin(superClass) {
  static get properties() {
    return {
      /**
       * An array containing items determining how many instances to render.
       * @type {Array<!VirtualListItem> | undefined}
       */
      items: { type: Array, sync: true },
      /**
       * Custom function for rendering the content of every item.
       * Receives three arguments:
       *
       * - `root` The render target element representing one item at a time.
       * - `virtualList` The reference to the `<vaadin-virtual-list>` element.
       * - `model` The object with the properties related with the rendered
       *   item, contains:
       *   - `model.index` The index of the rendered item.
       *   - `model.item` The item.
       * @type {VirtualListRenderer | undefined}
       */
      renderer: { type: Function, sync: true },
      /** @private */
      __virtualizer: Object
    };
  }
  static get observers() {
    return ["__itemsOrRendererChanged(items, renderer, __virtualizer)"];
  }
  /**
   * Gets the index of the first visible item in the viewport.
   *
   * @return {number}
   */
  get firstVisibleIndex() {
    return this.__virtualizer.firstVisibleIndex;
  }
  /**
   * Gets the index of the last visible item in the viewport.
   *
   * @return {number}
   */
  get lastVisibleIndex() {
    return this.__virtualizer.lastVisibleIndex;
  }
  constructor() {
    super();
    this.__onDocumentDragStart = this.__onDocumentDragStart.bind(this);
  }
  /** @protected */
  ready() {
    super.ready();
    this.__virtualizer = new Virtualizer({
      createElements: this.__createElements,
      updateElement: this.__updateElement.bind(this),
      elementsContainer: this,
      scrollTarget: this,
      scrollContainer: this.shadowRoot.querySelector("#items"),
      reorderElements: true
    });
    this.__overflowController = new OverflowController(this);
    this.addController(this.__overflowController);
    processTemplates(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    document.addEventListener("dragstart", this.__onDocumentDragStart, { capture: true });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("dragstart", this.__onDocumentDragStart, { capture: true });
  }
  /**
   * Scroll to a specific index in the virtual list.
   *
   * @param {number} index Index to scroll to
   */
  scrollToIndex(index) {
    this.__virtualizer.scrollToIndex(index);
  }
  /** @private */
  __createElements(count) {
    return [...Array(count)].map(() => document.createElement("div"));
  }
  /** @private */
  __updateElement(el, index) {
    if (el.__renderer !== this.renderer) {
      el.__renderer = this.renderer;
      this.__clearRenderTargetContent(el);
    }
    if (this.renderer) {
      this.renderer(el, this, { item: this.items[index], index });
    }
  }
  /**
   * Clears the content of a render target.
   * @private
   */
  __clearRenderTargetContent(element) {
    element.innerHTML = "";
    delete element._$litPart$;
  }
  /** @private */
  __itemsOrRendererChanged(items, renderer, virtualizer) {
    const hasRenderedItems = this.childElementCount > 0;
    if ((renderer || hasRenderedItems) && virtualizer) {
      virtualizer.size = (items || []).length;
      virtualizer.update();
    }
  }
  /**
   * Webkit-based browsers have issues with generating drag images
   * for elements that have children with massive heights. Chromium
   * browsers crash, while Safari experiences significant performance
   * issues. To mitigate these issues, we hide the items container
   * when drag starts to remove it from the drag image.
   *
   * Virtual lists with fewer rows also have issues on Chromium and Safari
   * where the drag image is not properly clipped and may include
   * content outside the virtual list. Temporary inline styles are applied
   * to mitigate this issue.
   *
   * Related issues:
   * - https://github.com/vaadin/web-components/issues/7985
   * - https://issues.chromium.org/issues/383356871
   * - https://github.com/vaadin/web-components/issues/8386
   *
   * @private
   */
  __onDocumentDragStart(e2) {
    if (e2.target.contains(this)) {
      const elements = [e2.target, this.$.items];
      const originalInlineStyles = elements.map((element) => element.style.cssText);
      if (this.scrollHeight > 2e4) {
        this.$.items.style.display = "none";
      }
      if (isChrome) {
        e2.target.style.willChange = "transform";
      }
      if (isSafari) {
        this.$.items.style.maxHeight = "100%";
      }
      requestAnimationFrame(() => {
        elements.forEach((element, index) => {
          element.style.cssText = originalInlineStyles[index];
        });
      });
    }
  }
  /**
   * Requests an update for the content of the rows.
   * While performing the update, it invokes the renderer passed in the `renderer` property for each visible row.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (this.__virtualizer) {
      this.__virtualizer.update();
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const virtualListStyles = css`
  :host {
    display: block;
    height: 400px;
    overflow: auto;
    flex: auto;
    align-self: stretch;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host(:not([grid])) #items > ::slotted(*) {
    width: 100%;
  }

  #items {
    position: relative;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-virtual-list", virtualListStyles, { moduleId: "vaadin-virtual-list-styles" });
class VirtualList extends ElementMixin(ThemableMixin(VirtualListMixin(PolymerElement))) {
  static get template() {
    return html`
      <div id="items">
        <slot></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-virtual-list";
  }
}
defineCustomElement(VirtualList);
window.Vaadin.Flow.virtualListConnector = {
  initLazy: function(list) {
    if (list.$connector) {
      return;
    }
    const extraItemsBuffer = 20;
    let lastRequestedRange = [0, 0];
    list.$connector = {};
    list.$connector.placeholderItem = { __placeholder: true };
    const updateRequestedItem = function() {
      const visibleIndexes = [...list.children].filter((el) => "__virtualListIndex" in el).map((el) => el.__virtualListIndex);
      const firstNeededItem = Math.min(...visibleIndexes);
      const lastNeededItem = Math.max(...visibleIndexes);
      let first = Math.max(0, firstNeededItem - extraItemsBuffer);
      let last = Math.min(lastNeededItem + extraItemsBuffer, list.items.length);
      if (lastRequestedRange[0] != first || lastRequestedRange[1] != last) {
        lastRequestedRange = [first, last];
        const count = 1 + last - first;
        list.$server.setRequestedRange(first, count);
      }
    };
    const scheduleUpdateRequest = function() {
      list.__requestDebounce = Debouncer2.debounce(list.__requestDebounce, timeOut$1.after(50), updateRequestedItem);
    };
    requestAnimationFrame(() => updateRequestedItem);
    list.patchVirtualListRenderer = function() {
      if (!list.renderer || list.renderer.__virtualListConnectorPatched) {
        return;
      }
      const originalRenderer = list.renderer;
      const renderer = (root2, list2, model) => {
        root2.__virtualListIndex = model.index;
        if (model.item === void 0) {
          if (list2.$connector.placeholderElement) {
            if (!root2.__hasComponentRendererPlaceholder) {
              root2.innerHTML = "";
              delete root2._$litPart$;
              root2.appendChild(list2.$connector.placeholderElement.cloneNode(true));
              root2.__hasComponentRendererPlaceholder = true;
            }
          } else {
            originalRenderer.call(list2, root2, list2, {
              ...model,
              item: list2.$connector.placeholderItem
            });
          }
        } else {
          if (root2.__hasComponentRendererPlaceholder) {
            root2.innerHTML = "";
            root2.__hasComponentRendererPlaceholder = false;
          }
          originalRenderer.call(list2, root2, list2, model);
        }
        scheduleUpdateRequest();
      };
      renderer.__virtualListConnectorPatched = true;
      renderer.__rendererId = originalRenderer.__rendererId;
      list.renderer = renderer;
    };
    list._createPropertyObserver("renderer", "patchVirtualListRenderer", true);
    list.patchVirtualListRenderer();
    list.items = [];
    list.$connector.set = function(index, items) {
      list.items.splice(index, items.length, ...items);
      list.items = [...list.items];
    };
    list.$connector.clear = function(index, length) {
      const clearCount = Math.min(length, list.items.length - index);
      list.$connector.set(index, [...Array(clearCount)]);
    };
    list.$connector.updateData = function(items) {
      const updatedItemsMap = items.reduce((map, item2) => {
        map[item2.key] = item2;
        return map;
      }, {});
      list.items = list.items.map((item2) => {
        if (!item2) {
          return item2;
        }
        return updatedItemsMap[item2.key] || item2;
      });
    };
    list.$connector.updateSize = function(newSize) {
      const delta = newSize - list.items.length;
      if (delta > 0) {
        list.items = [...list.items, ...Array(delta)];
      } else if (delta < 0) {
        list.items = list.items.slice(0, newSize);
      }
    };
    list.$connector.setPlaceholderItem = function(placeholderItem = {}, appId) {
      placeholderItem.__placeholder = true;
      list.$connector.placeholderItem = placeholderItem;
      const nodeId = Object.entries(placeholderItem).find(([key]) => key.endsWith("_nodeid"));
      list.$connector.placeholderElement = nodeId ? Vaadin.Flow.clients[appId].getByNodeId(nodeId[1]) : null;
    };
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2024 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const template = document.createElement("template");
template.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg"><defs>
<g id="lumo:align-center"><path d="M167 217c0-18 17-33 38-34H795c21 0 38 15 38 34 0 18-17 33-38 33H205C184 250 167 235 167 217z m83 191c0-18 13-33 29-33H721c16 0 29 15 29 33 0 18-13 33-29 34H279C263 442 250 427 250 408zM250 792c0-18 13-33 29-34H721c16 0 29 15 29 34s-13 33-29 33H279C263 825 250 810 250 792z m-83-192c0-18 17-33 38-33H795c21 0 38 15 38 33s-17 33-38 33H205C184 633 167 618 167 600z" fill-rule="evenodd" clip-rule="evenodd"></path></g>
<g id="lumo:align-left"><path d="M167 217c0-18 17-33 38-34H795c21 0 38 15 38 34 0 18-17 33-38 33H205C184 250 167 235 167 217z m0 191c0-18 13-33 28-33H638c16 0 29 15 29 33 0 18-13 33-29 34H195C179 442 167 427 167 408zM167 792c0-18 13-33 28-34H638c16 0 29 15 29 34s-13 33-29 33H195C179 825 167 810 167 792z m0-192c0-18 17-33 38-33H795c21 0 38 15 38 33s-17 33-38 33H205C184 633 167 618 167 600z" fill-rule="evenodd" clip-rule="evenodd"></path></g>
<g id="lumo:align-right"><path d="M167 217c0-18 17-33 38-34H795c21 0 38 15 38 34 0 18-17 33-38 33H205C184 250 167 235 167 217z m166 191c0-18 13-33 29-33H805c16 0 29 15 28 33 0 18-13 33-28 34H362C346 442 333 427 333 408zM333 792c0-18 13-33 29-34H805c16 0 29 15 28 34s-13 33-28 33H362C346 825 333 810 333 792z m-166-192c0-18 17-33 38-33H795c21 0 38 15 38 33s-17 33-38 33H205C184 633 167 618 167 600z" fill-rule="evenodd" clip-rule="evenodd"></path></g>
<g id="lumo:angle-down"><path d="M283 391c-18-16-46-15-63 4-16 18-15 46 3 63l244 224c17 15 43 15 60 0l250-229c18-16 20-45 3-63-16-18-45-20-63-4l-220 203-214-198z"></path></g>
<g id="lumo:angle-left"><path d="M601 710c16 18 15 46-3 63-18 16-46 15-63-4l-224-244c-15-17-15-43 0-59l229-250c16-18 45-20 63-4 18 16 20 45 3 63l-203 220 198 215z"></path></g>
<g id="lumo:angle-right"><path d="M399 275c-16-18-15-46 3-63 18-16 46-15 63 4l224 244c15 17 15 43 0 59l-229 250c-16 18-45 20-63 4-18-16-20-45-3-63l203-220-198-215z"></path></g>
<g id="lumo:angle-up"><path d="M283 635c-18 16-46 15-63-3-16-18-15-46 3-63l244-224c17-15 43-15 60 0l250 229c18 16 20 45 3 63-16 18-45 20-63 3l-220-202L283 635z"></path></g>
<g id="lumo:arrow-down"><path d="M538 646l125-112c15-14 39-12 53 4 14 15 12 39-4 53l-187 166c0 0 0 0 0 0-14 13-36 12-50 0l-187-166c-15-14-17-37-4-53 14-15 37-17 53-4L462 646V312c0-21 17-38 38-37s38 17 37 37v334z"></path></g>
<g id="lumo:arrow-left"><path d="M375 538l111 125c14 15 12 39-3 53-15 14-39 12-53-4l-166-187c0 0 0 0 0 0-13-14-12-36 0-50l166-187c14-15 37-17 53-4 15 14 17 37 3 53L375 463h333c21 0 38 17 38 37 0 21-17 38-38 38h-333z"></path></g>
<g id="lumo:arrow-right"><path d="M625 538h-333c-21 0-38-17-38-38 0-21 17-38 38-37h333l-111-126c-14-15-12-39 3-53 15-14 39-12 53 4l166 187c13 14 13 36 0 50 0 0 0 0 0 0l-166 187c-14 15-37 17-53 4-15-14-17-37-3-53l111-125z"></path></g>
<g id="lumo:arrow-up"><path d="M538 354V688c0 21-17 38-38 37s-38-17-38-38V354l-125 112c-15 14-39 12-53-4-14-15-12-39 4-53l187-166c14-13 36-13 50 0 0 0 0 0 0 0l187 166c15 14 17 37 4 53-14 15-37 17-53 4L538 354z"></path></g>
<g id="lumo:bar-chart"><path d="M175 500h108c28 0 50 22 50 50v233c0 28-22 50-50 50H175c-28 0-50-22-50-50v-233c0-28 22-50 50-50z m33 67c-9 0-17 7-16 16v167c0 9 7 17 16 17h42c9 0 17-7 17-17v-167c0-9-7-17-17-16H208zM446 167h108c28 0 50 22 50 50v566c0 28-22 50-50 50h-108c-28 0-50-22-50-50V217c0-28 22-50 50-50z m33 66c-9 0-17 7-17 17v500c0 9 7 17 17 17h42c9 0 17-7 16-17V250c0-9-7-17-16-17h-42zM717 333h108c28 0 50 22 50 50v400c0 28-22 50-50 50h-108c-28 0-50-22-50-50V383c0-28 22-50 50-50z m33 67c-9 0-17 7-17 17v333c0 9 7 17 17 17h42c9 0 17-7 16-17v-333c0-9-7-17-16-17h-42z"></path></g>
<g id="lumo:bell"><path d="M367 675H292v-258C292 325 366 250 459 250H458V208c0-23 18-42 42-41 23 0 42 18 42 41v42h-1C634 250 708 325 708 417V675h-75v-258c0-51-41-92-91-92h-84C408 325 367 366 367 417V675z m-159 37c0-21 17-38 38-37h508c21 0 37 17 38 37 0 21-17 38-38 38H246C225 750 208 733 208 713z m230 71h125v32c0 17-14 31-32 31h-62c-17 0-32-14-31-31v-32z"></path></g>
<g id="lumo:calendar"><path d="M375 208h250v-20C625 176 634 167 646 167h41C699 167 708 176 708 188V208h74c23 0 41 19 41 42v42C823 315 804 333 782 333H218C196 333 177 315 177 292V250C177 227 196 208 218 208H292v-20C292 176 301 167 313 167h41C366 167 375 176 375 188V208zM229 375h42C283 375 292 384 292 396v41C292 449 282 458 271 458h-42C217 458 208 449 208 437v-41C208 384 218 375 229 375z m125 0h42C408 375 417 384 417 396v41C417 449 407 458 396 458h-42C342 458 333 449 333 437v-41C333 384 343 375 354 375z m125 0h42C533 375 542 384 542 396v41C542 449 532 458 521 458h-42C467 458 458 449 458 437v-41C458 384 468 375 479 375z m-250 125h42C283 500 292 509 292 521v41C292 574 282 583 271 583h-42C217 583 208 574 208 562v-41C208 509 218 500 229 500z m125 0h42C408 500 417 509 417 521v41C417 574 407 583 396 583h-42C342 583 333 574 333 562v-41C333 509 343 500 354 500z m125 0h42c12 0 21 9 21 21v41C542 574 532 583 521 583h-42C467 583 458 574 458 562v-41C458 509 468 500 479 500z m-250 125h42C283 625 292 634 292 646v41C292 699 282 708 271 708h-42C217 708 208 699 208 687v-41C208 634 218 625 229 625z m125 0h42C408 625 417 634 417 646v41C417 699 407 708 396 708h-42C342 708 333 699 333 687v-41C333 634 343 625 354 625z m125 0h42c12 0 21 9 21 21v41C542 699 532 708 521 708h-42C467 708 458 699 458 687v-41C458 634 468 625 479 625z m125-250h42C658 375 667 384 667 396v41C667 449 657 458 646 458h-42C592 458 583 449 583 437v-41C583 384 593 375 604 375z m0 125h42c12 0 21 9 21 21v41C667 574 657 583 646 583h-42C592 583 583 574 583 562v-41C583 509 593 500 604 500z m0 125h42c12 0 21 9 21 21v41C667 699 657 708 646 708h-42C592 708 583 699 583 687v-41C583 634 593 625 604 625z m125 0h42c12 0 21 9 21 21v41C792 699 782 708 771 708h-42C717 708 708 699 708 687v-41C708 634 718 625 729 625z m-500 125h42C283 750 292 759 292 771v41C292 824 282 833 271 833h-42C217 833 208 824 208 812v-41C208 759 218 750 229 750z m125 0h42C408 750 417 759 417 771v41C417 824 407 833 396 833h-42C342 833 333 824 333 812v-41C333 759 343 750 354 750z m125 0h42c12 0 21 9 21 21v41C542 824 532 833 521 833h-42C467 833 458 824 458 812v-41C458 759 468 750 479 750z m125 0h42c12 0 21 9 21 21v41C667 824 657 833 646 833h-42C592 833 583 824 583 812v-41C583 759 593 750 604 750z m125 0h42c12 0 21 9 21 21v41C792 824 782 833 771 833h-42C717 833 708 824 708 812v-41C708 759 718 750 729 750z m0-250h42c12 0 21 9 21 21v41C792 574 782 583 771 583h-42C717 583 708 574 708 562v-41C708 509 718 500 729 500z m0-125h42C783 375 792 384 792 396v41C792 449 782 458 771 458h-42C717 458 708 449 708 437v-41C708 384 718 375 729 375z"></path></g>
<g id="lumo:checkmark"><path d="M318 493c-15-15-38-15-53 0-15 15-15 38 0 53l136 136c15 15 38 15 53 0l323-322c15-15 15-38 0-53-15-15-38-15-54 0l-295 296-110-110z"></path></g>
<g id="lumo:chevron-down"><path d="M533 654l210-199c9-9 9-23 0-32C739 419 733 417 726 417H274C261 417 250 427 250 439c0 6 2 12 7 16l210 199c18 17 48 17 66 0z"></path></g>
<g id="lumo:chevron-left"><path d="M346 533l199 210c9 9 23 9 32 0 4-4 7-10 6-17V274C583 261 573 250 561 250c-6 0-12 2-16 7l-199 210c-17 18-17 48 0 66z"></path></g>
<g id="lumo:chevron-right"><path d="M654 533L455 743c-9 9-23 9-32 0C419 739 417 733 417 726V274C417 261 427 250 439 250c6 0 12 2 16 7l199 210c17 18 17 48 0 66z"></path></g>
<g id="lumo:chevron-up"><path d="M533 346l210 199c9 9 9 23 0 32-4 4-10 7-17 6H274C261 583 250 573 250 561c0-6 2-12 7-16l210-199c18-17 48-17 66 0z"></path></g>
<g id="lumo:clock"><path d="M538 489l85 85c15 15 15 38 0 53-15 15-38 15-53 0l-93-93a38 38 0 0 1-2-2C467 525 462 515 462 504V308c0-21 17-38 38-37 21 0 38 17 37 37v181zM500 833c-184 0-333-149-333-333s149-333 333-333 333 149 333 333-149 333-333 333z m0-68c146 0 265-118 265-265 0-146-118-265-265-265-146 0-265 118-265 265 0 146 118 265 265 265z"></path></g>
<g id="lumo:cog"><path d="M833 458l-81-18c-8-25-17-50-29-75L767 292 708 233l-72 49c-21-12-46-25-75-30L542 167h-84l-19 79c-25 8-50 17-71 30L296 233 233 296l47 69c-12 21-21 46-29 71L167 458v84l84 25c8 25 17 50 29 75L233 708 292 767l76-44c21 12 46 25 75 29L458 833h84l19-81c25-8 50-17 75-29L708 767l59-59-44-66c12-21 25-46 29-75L833 542v-84z m-333 217c-96 0-175-79-175-175 0-96 79-175 175-175 96 0 175 79 175 175 0 96-79 175-175 175z"></path></g>
<g id="lumo:cross"><path d="M445 500l-142-141c-15-15-15-40 0-56 15-15 40-15 56 0L500 445l141-142c15-15 40-15 56 0 15 15 15 40 0 56L555 500l142 141c15 15 15 40 0 56-15 15-40 15-56 0L500 555l-141 142c-15 15-40 15-56 0-15-15-15-40 0-56L445 500z"></path></g>
<g id="lumo:download"><path d="M538 521l125-112c15-14 39-12 53 4 14 15 12 39-4 53l-187 166a38 38 0 0 1 0 0c-14 13-36 12-50 0l-187-166c-15-14-17-37-4-53 14-15 37-17 53-4L462 521V188c0-21 17-38 38-38s38 17 37 38v333zM758 704c0-21 17-38 38-37 21 0 38 17 37 37v92c0 21-17 38-37 37H204c-21 0-38-17-37-37v-92c0-21 17-38 37-37s38 17 38 37v54h516v-54z"></path></g>
<g id="lumo:drag-handle"><path d="M458 292c0 35-28 63-62 62C361 354 333 326 333 292s28-63 63-63c35 0 63 28 62 63Zm0 208c0 35-28 63-62 62-35 0-63-28-63-62s28-63 63-63c35 0 63 28 62 63Zm0 208c0 35-28 63-62 63-35 0-63-28-63-63s28-63 63-62c35 0 63 28 62 62Zm209-416c0 35-28 63-63 62S542 326 542 292s28-63 62-63S667 257 667 292Zm0 208c0 35-28 63-63 62S542 535 542 500s28-63 62-63 63 28 63 63Zm0 208c0 35-28 63-63 63S542 743 542 708s28-63 62-62 63 28 63 62Z"></path></g>
<g id="lumo:dropdown"><path d="M317 393c-15-14-39-13-53 3-14 15-13 39 3 53l206 189c14 13 36 13 50 0l210-193c15-14 17-38 3-53-14-15-38-17-53-3l-185 171L317 393z"></path></g>
<g id="lumo:edit"><path d="M673 281l62 56-205 233c-9 10-38 24-85 39a8 8 0 0 1-5 0c-4-1-7-6-6-10l0 0c14-47 25-76 35-86l204-232z m37-42l52-59c15-17 41-18 58-2 17 16 18 42 3 59L772 295l-62-56zM626 208l-67 75h-226C305 283 283 306 283 333v334C283 695 306 717 333 717h334c28 0 50-22 50-50v-185L792 398v269C792 736 736 792 667 792H333C264 792 208 736 208 667V333C208 264 264 208 333 208h293z"></path></g>
<g id="lumo:error"><path d="M500 833c-184 0-333-149-333-333s149-333 333-333 333 149 333 333-149 333-333 333z m0-68c146 0 265-118 265-265 0-146-118-265-265-265-146 0-265 118-265 265 0 146 118 265 265 265zM479 292h42c12 0 21 9 20 20l-11 217c0 8-6 13-13 13h-34c-7 0-13-6-13-13l-11-217C459 301 468 292 479 292zM483 608h34c12 0 21 9 20 21v33c0 12-9 21-20 21h-34c-12 0-21-9-21-21v-33c0-12 9-21 21-21z"></path></g>
<g id="lumo:eye"><path d="M500 750c-187 0-417-163-417-250s230-250 417-250 417 163 417 250-230 250-417 250z m-336-231c20 22 47 46 78 69C322 644 411 678 500 678s178-34 258-90c31-22 59-46 78-69 6-7 12-14 16-19-4-6-9-12-16-19-20-22-47-46-78-69C678 356 589 322 500 322s-178 34-258 90c-31 22-59 46-78 69-6 7-12 14-16 19 4 6 9 12 16 19zM500 646c-81 0-146-65-146-146s65-146 146-146 146 65 146 146-65 146-146 146z m0-75c39 0 71-32 71-71 0-39-32-71-71-71-39 0-71 32-71 71 0 39 32 71 71 71z"></path></g>
<g id="lumo:eye-disabled"><path d="M396 735l60-60c15 2 30 3 44 3 89 0 178-34 258-90 31-22 59-46 78-69 6-7 12-14 16-19-4-6-9-12-16-19-20-22-47-46-78-69-8-5-15-11-23-15l50-51C862 397 917 458 917 500c0 87-230 250-417 250-34 0-69-5-104-15zM215 654C138 603 83 542 83 500c0-87 230-250 417-250 34 0 69 5 104 15l-59 60c-15-2-30-3-45-3-89 0-178 34-258 90-31 22-59 46-78 69-6 7-12 14-16 19 4 6 9 12 16 19 20 22 47 46 78 69 8 5 16 11 24 16L215 654z m271-9l159-159c0 5 1 9 1 14 0 81-65 146-146 146-5 0-9 0-14-1z m-131-131C354 510 354 505 354 500c0-81 65-146 146-146 5 0 10 0 14 1l-159 159z m-167 257L780 179c12-12 32-12 44 0 12 12 12 32 0 44L232 815c-12 12-32 12-44 0s-12-32 0-44z"></path></g>
<g id="lumo:menu"><path d="M167 292c0-23 19-42 41-42h584C815 250 833 268 833 292c0 23-19 42-41 41H208C185 333 167 315 167 292z m0 208c0-23 19-42 41-42h584C815 458 833 477 833 500c0 23-19 42-41 42H208C185 542 167 523 167 500z m0 208c0-23 19-42 41-41h584C815 667 833 685 833 708c0 23-19 42-41 42H208C185 750 167 732 167 708z"></path></g>
<g id="lumo:minus"><path d="M261 461c-22 0-39 18-39 39 0 22 18 39 39 39h478c22 0 39-18 39-39 0-22-18-39-39-39H261z"></path></g>
<g id="lumo:ordered-list"><path d="M138 333V198H136l-43 28v-38l45-31h45V333H138z m-61 128c0-35 27-59 68-59 39 0 66 21 66 53 0 20-11 37-43 64l-29 27v2h74V583H80v-30l55-52c26-24 32-33 33-43 0-13-10-22-24-22-15 0-26 10-26 25v1h-41v-1zM123 759v-31h21c15 0 25-8 25-21 0-13-10-21-25-21-15 0-26 9-26 23h-41c1-34 27-56 68-57 39 0 66 20 66 49 0 20-14 36-33 39v3c24 3 40 19 39 41 0 32-30 54-73 54-41 0-69-22-70-57h43c1 13 11 22 28 22 16 0 27-9 27-22 0-14-10-22-28-22h-21zM333 258c0-18 15-33 34-33h516c18 0 33 15 34 33 0 18-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z"></path></g>
<g id="lumo:phone"><path d="M296 208l42-37c17-15 44-13 58 4a42 42 0 0 1 5 7L459 282c12 20 5 45-15 57l-7 4c-17 10-25 30-19 48l20 66a420 420 0 0 0 93 157l41 45c13 14 35 17 51 8l7-5c20-12 45-5 57 16L745 777c12 20 5 45-15 57a42 42 0 0 1-8 4l-52 17c-61 21-129 4-174-43l-50-52c-81-85-141-189-175-302l-24-78c-19-62 0-129 49-172z"></path></g>
<g id="lumo:photo"><path d="M208 167h584c69 0 125 56 125 125v416c0 69-56 125-125 125H208c-69 0-125-56-125-125V292c0-69 56-125 125-125z m584 75H208c-28 0-50 22-50 50v416c0 28 22 50 50 50h584c28 0 50-22 50-50V292c0-28-22-50-50-50zM239 740l167-167c12-12 31-14 45-6l73 43 172-201c13-15 34-18 50-7l95 67v92l-111-78-169 199c-12 14-32 17-47 8l-76-43-111 111H229c2-7 5-13 10-18zM458 427C458 490 407 542 344 542S229 490 229 427c0-63 51-115 115-115S458 364 458 427z m-62 0C396 398 373 375 344 375S292 398 292 427c0 29 23 52 52 52s52-23 52-52z"></path></g>
<g id="lumo:play"><path d="M689 528l-298 175c-13 8-34 8-48 0-6-4-10-9-10-14V311C333 300 348 292 367 292c9 0 17 2 24 5l298 175c26 15 26 40 0 56z"></path></g>
<g id="lumo:plus"><path d="M461 461H261c-22 0-39 18-39 39 0 22 18 39 39 39h200v200c0 22 18 39 39 39 22 0 39-18 39-39v-200h200c22 0 39-18 39-39 0-22-18-39-39-39h-200V261c0-22-18-39-39-39-22 0-39 18-39 39v200z"></path></g>
<g id="lumo:redo"><path d="M290 614C312 523 393 458 491 458c55 0 106 22 144 57l-88 88c-3 3-5 7-5 11 0 8 6 15 15 15l193-5c17 0 31-15 31-32l5-192c0-4-1-8-4-11-6-6-16-6-22 0l-66 67C641 406 570 375 491 375c-136 0-248 90-281 215-1 2-1 5-1 8-8 44 45 68 73 32 4-5 7-11 8-16z"></path></g>
<g id="lumo:reload"><path d="M500 233V137c0-9 7-16 15-16 4 0 8 2 10 4l133 140c12 12 12 32 0 45l-133 140c-6 6-15 6-21 0C502 447 500 443 500 438V308c-117 0-212 95-212 213 0 117 95 212 212 212 117 0 212-95 212-212 0-21 17-38 38-38s38 17 37 38c0 159-129 288-287 287-159 0-288-129-288-287 0-159 129-288 288-288z"></path></g>
<g id="lumo:resize-handle"><path d="M772 311c12 12 12 32 0 44L355 772c-12 12-32 12-44 0s-12-32 0-44L728 311c12-12 32-12 44 0Zm0 188c12 12 12 32 0 44l-229 229c-12 12-32 12-44 0-12-12-12-32 0-44l229-229c12-12 32-12 44 0Zm0 187c12 12 12 32 0 44l-42 42c-12 12-32 12-44 0-12-12-12-32 0-44l42-42c12-12 32-12 44 0Z" fill-rule="evenodd" clip-rule="evenodd"></path></g>
<g id="lumo:search"><path d="M662 603l131 131c16 16 16 42 0 59-16 16-43 16-59 0l-131-131C562 691 512 708 458 708c-138 0-250-112-250-250 0-138 112-250 250-250 138 0 250 112 250 250 0 54-17 104-46 145zM458 646c104 0 188-84 188-188S562 271 458 271 271 355 271 458s84 188 187 188z"></path></g>
<g id="lumo:undo"><path d="M710 614C688 523 607 458 509 458c-55 0-106 22-144 57l88 88c3 3 5 7 5 11 0 8-6 15-15 15l-193-5c-17 0-31-15-31-32L214 400c0-4 1-8 4-11 6-6 16-6 22 0l66 67C359 406 430 375 509 375c136 0 248 90 281 215 1 2 1 5 1 8 8 44-45 68-73 32-4-5-7-11-8-16z"></path></g>
<g id="lumo:unordered-list"><path d="M146 325c-42 0-67-26-67-63 0-37 25-63 67-63 42 0 67 26 67 63 0 37-25 63-67 63z m0 250c-42 0-67-26-67-63 0-37 25-63 67-63 42 0 67 26 67 63 0 37-25 63-67 63z m0 250c-42 0-67-26-67-63 0-37 25-63 67-63 42 0 67 26 67 63 0 37-25 63-67 63zM333 258c0-18 15-33 34-33h516c18 0 33 15 34 33 0 18-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z"></path></g>
<g id="lumo:upload"><path d="M454 271V604c0 21-17 38-37 38s-38-17-38-38V271L254 382c-15 14-39 12-53-3-14-15-12-39 3-53L391 160c14-13 36-13 51-1 0 0 0 0 0 1l187 166c15 14 17 37 3 53-14 15-37 17-53 3L454 271zM675 704c0-21 17-38 37-37 21 0 38 17 38 37v92c0 21-17 38-38 37H121c-21 0-38-17-38-37v-92c0-21 17-38 38-37s38 17 37 37v54h517v-54z"></path></g>
<g id="lumo:user"><path d="M500 500c-69 0-125-56-125-125s56-125 125-125 125 56 125 125-56 125-125 125z m-292 292c0-115 131-208 292-209s292 93 292 209H208z"></path></g>
</defs></svg>`;
Iconset$1.register("lumo", 1e3, template);
const codeEditor = css`
  [part='input-field'],
  [part='input-field'] ::slotted(textarea) {
    height: auto;
    box-sizing: border-box;
  }

  [part='input-field'] {
    /* Equal to the implicit padding in vaadin-text-field */
    padding-top: calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);
    padding-bottom: calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);
    transition: background-color 0.1s;
    line-height: var(--lumo-line-height-s);
  }

  :host(:not([readonly])) [part='input-field']::after {
    display: none;
  }

  :host([readonly]) [part='input-field'] {
    border: 1px dashed var(--lumo-contrast-30pct);
  }

  :host([readonly]) [part='input-field']::after {
    border: none;
  }

  [part='input-field'] ::slotted(textarea) {
    line-height: inherit;
    --_lumo-text-field-overflow-mask-image: none;
  }
`;
registerStyles$1("jmix-code-editor", [inputFieldShared$1, codeEditor], { moduleId: "lumo-code-editor" });
var ace$1 = { exports: {} };
var hasRequiredAce;
function requireAce() {
  if (hasRequiredAce) return ace$1.exports;
  hasRequiredAce = 1;
  (function(module2, exports2) {
    (function() {
      var ACE_NAMESPACE = "ace";
      var global = /* @__PURE__ */ function() {
        return this;
      }();
      if (!global && typeof window != "undefined") global = window;
      var define2 = function(module3, deps, payload) {
        if (typeof module3 !== "string") {
          if (define2.original)
            define2.original.apply(this, arguments);
          else {
            console.error("dropping module because define wasn't a string.");
            console.trace();
          }
          return;
        }
        if (arguments.length == 2)
          payload = deps;
        if (!define2.modules[module3]) {
          define2.payloads[module3] = payload;
          define2.modules[module3] = null;
        }
      };
      define2.modules = {};
      define2.payloads = {};
      var _require = function(parentId, module3, callback) {
        if (typeof module3 === "string") {
          var payload = lookup(parentId, module3);
          if (payload != void 0) {
            callback && callback();
            return payload;
          }
        } else if (Object.prototype.toString.call(module3) === "[object Array]") {
          var params = [];
          for (var i2 = 0, l = module3.length; i2 < l; ++i2) {
            var dep = lookup(parentId, module3[i2]);
            if (dep == void 0 && require2.original)
              return;
            params.push(dep);
          }
          return callback && callback.apply(null, params) || true;
        }
      };
      var require2 = function(module3, callback) {
        var packagedModule = _require("", module3, callback);
        if (packagedModule == void 0 && require2.original)
          return require2.original.apply(this, arguments);
        return packagedModule;
      };
      var normalizeModule = function(parentId, moduleName) {
        if (moduleName.indexOf("!") !== -1) {
          var chunks = moduleName.split("!");
          return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
        }
        if (moduleName.charAt(0) == ".") {
          var base = parentId.split("/").slice(0, -1).join("/");
          moduleName = base + "/" + moduleName;
          while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
          }
        }
        return moduleName;
      };
      var lookup = function(parentId, moduleName) {
        moduleName = normalizeModule(parentId, moduleName);
        var module3 = define2.modules[moduleName];
        if (!module3) {
          module3 = define2.payloads[moduleName];
          if (typeof module3 === "function") {
            var exports3 = {};
            var mod = {
              id: moduleName,
              uri: "",
              exports: exports3,
              packaged: true
            };
            var req = function(module4, callback) {
              return _require(moduleName, module4, callback);
            };
            var returnValue = module3(req, exports3, mod);
            exports3 = returnValue || mod.exports;
            define2.modules[moduleName] = exports3;
            delete define2.payloads[moduleName];
          }
          module3 = define2.modules[moduleName] = exports3 || module3;
        }
        return module3;
      };
      function exportAce(ns) {
        var root2 = global;
        {
          if (!global[ns])
            global[ns] = {};
          root2 = global[ns];
        }
        if (!root2.define || !root2.define.packaged) {
          define2.original = root2.define;
          root2.define = define2;
          root2.define.packaged = true;
        }
        if (!root2.require || !root2.require.packaged) {
          require2.original = root2.require;
          root2.require = require2;
          root2.require.packaged = true;
        }
      }
      exportAce(ACE_NAMESPACE);
    })();
    ace.define("ace/lib/es6-shim", ["require", "exports", "module"], function(require2, exports3, module3) {
      function defineProp(obj, name, val) {
        Object.defineProperty(obj, name, {
          value: val,
          enumerable: false,
          writable: true,
          configurable: true
        });
      }
      if (!String.prototype.startsWith) {
        defineProp(String.prototype, "startsWith", function(searchString, position) {
          position = position || 0;
          return this.lastIndexOf(searchString, position) === position;
        });
      }
      if (!String.prototype.endsWith) {
        defineProp(String.prototype, "endsWith", function(searchString, position) {
          var subjectString = this;
          if (position === void 0 || position > subjectString.length) {
            position = subjectString.length;
          }
          position -= searchString.length;
          var lastIndex = subjectString.indexOf(searchString, position);
          return lastIndex !== -1 && lastIndex === position;
        });
      }
      if (!String.prototype.repeat) {
        defineProp(String.prototype, "repeat", function(count) {
          var result = "";
          var string = this;
          while (count > 0) {
            if (count & 1)
              result += string;
            if (count >>= 1)
              string += string;
          }
          return result;
        });
      }
      if (!String.prototype.includes) {
        defineProp(String.prototype, "includes", function(str, position) {
          return this.indexOf(str, position) != -1;
        });
      }
      if (!Object.assign) {
        Object.assign = function(target) {
          if (target === void 0 || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== void 0 && source !== null) {
              Object.keys(source).forEach(function(key) {
                output[key] = source[key];
              });
            }
          }
          return output;
        };
      }
      if (!Object.values) {
        Object.values = function(o) {
          return Object.keys(o).map(function(k2) {
            return o[k2];
          });
        };
      }
      if (!Array.prototype.find) {
        defineProp(Array.prototype, "find", function(predicate) {
          var len = this.length;
          var thisArg = arguments[1];
          for (var k2 = 0; k2 < len; k2++) {
            var kValue = this[k2];
            if (predicate.call(thisArg, kValue, k2, this)) {
              return kValue;
            }
          }
        });
      }
      if (!Array.prototype.findIndex) {
        defineProp(Array.prototype, "findIndex", function(predicate) {
          var len = this.length;
          var thisArg = arguments[1];
          for (var k2 = 0; k2 < len; k2++) {
            var kValue = this[k2];
            if (predicate.call(thisArg, kValue, k2, this)) {
              return k2;
            }
          }
        });
      }
      if (!Array.prototype.includes) {
        defineProp(Array.prototype, "includes", function(item2, position) {
          return this.indexOf(item2, position) != -1;
        });
      }
      if (!Array.prototype.fill) {
        defineProp(Array.prototype, "fill", function(value) {
          var O2 = this;
          var len = O2.length >>> 0;
          var start = arguments[1];
          var relativeStart = start >> 0;
          var k2 = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
          var end = arguments[2];
          var relativeEnd = end === void 0 ? len : end >> 0;
          var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
          while (k2 < final) {
            O2[k2] = value;
            k2++;
          }
          return O2;
        });
      }
      if (!Array.of) {
        defineProp(Array, "of", function() {
          return Array.prototype.slice.call(arguments);
        });
      }
    });
    ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/es6-shim"], function(require2, exports3, module3) {
      require2("./es6-shim");
    });
    ace.define("ace/lib/lang", ["require", "exports", "module"], function(require2, exports3, module3) {
      exports3.last = function(a3) {
        return a3[a3.length - 1];
      };
      exports3.stringReverse = function(string) {
        return string.split("").reverse().join("");
      };
      exports3.stringRepeat = function(string, count) {
        var result = "";
        while (count > 0) {
          if (count & 1)
            result += string;
          if (count >>= 1)
            string += string;
        }
        return result;
      };
      var trimBeginRegexp = /^\s\s*/;
      var trimEndRegexp = /\s\s*$/;
      exports3.stringTrimLeft = function(string) {
        return string.replace(trimBeginRegexp, "");
      };
      exports3.stringTrimRight = function(string) {
        return string.replace(trimEndRegexp, "");
      };
      exports3.copyObject = function(obj) {
        var copy = {};
        for (var key in obj) {
          copy[key] = obj[key];
        }
        return copy;
      };
      exports3.copyArray = function(array) {
        var copy = [];
        for (var i2 = 0, l = array.length; i2 < l; i2++) {
          if (array[i2] && typeof array[i2] == "object")
            copy[i2] = this.copyObject(array[i2]);
          else
            copy[i2] = array[i2];
        }
        return copy;
      };
      exports3.deepCopy = function deepCopy(obj) {
        if (typeof obj !== "object" || !obj)
          return obj;
        var copy;
        if (Array.isArray(obj)) {
          copy = [];
          for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
          }
          return copy;
        }
        if (Object.prototype.toString.call(obj) !== "[object Object]")
          return obj;
        copy = {};
        for (var key in obj)
          copy[key] = deepCopy(obj[key]);
        return copy;
      };
      exports3.arrayToMap = function(arr) {
        var map = {};
        for (var i2 = 0; i2 < arr.length; i2++) {
          map[arr[i2]] = 1;
        }
        return map;
      };
      exports3.createMap = function(props) {
        var map = /* @__PURE__ */ Object.create(null);
        for (var i2 in props) {
          map[i2] = props[i2];
        }
        return map;
      };
      exports3.arrayRemove = function(array, value) {
        for (var i2 = 0; i2 <= array.length; i2++) {
          if (value === array[i2]) {
            array.splice(i2, 1);
          }
        }
      };
      exports3.escapeRegExp = function(str) {
        return str.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
      };
      exports3.escapeHTML = function(str) {
        return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
      };
      exports3.getMatchOffsets = function(string, regExp) {
        var matches2 = [];
        string.replace(regExp, function(str) {
          matches2.push({
            offset: arguments[arguments.length - 2],
            length: str.length
          });
        });
        return matches2;
      };
      exports3.deferredCall = function(fcn) {
        var timer = null;
        var callback = function() {
          timer = null;
          fcn();
        };
        var deferred = function(timeout) {
          deferred.cancel();
          timer = setTimeout(callback, timeout || 0);
          return deferred;
        };
        deferred.schedule = deferred;
        deferred.call = function() {
          this.cancel();
          fcn();
          return deferred;
        };
        deferred.cancel = function() {
          clearTimeout(timer);
          timer = null;
          return deferred;
        };
        deferred.isPending = function() {
          return timer;
        };
        return deferred;
      };
      exports3.delayedCall = function(fcn, defaultTimeout) {
        var timer = null;
        var callback = function() {
          timer = null;
          fcn();
        };
        var _self = function(timeout) {
          if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.delay = function(timeout) {
          timer && clearTimeout(timer);
          timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.schedule = _self;
        _self.call = function() {
          this.cancel();
          fcn();
        };
        _self.cancel = function() {
          timer && clearTimeout(timer);
          timer = null;
        };
        _self.isPending = function() {
          return timer;
        };
        return _self;
      };
    });
    ace.define("ace/lib/useragent", ["require", "exports", "module"], function(require2, exports3, module3) {
      exports3.OS = {
        LINUX: "LINUX",
        MAC: "MAC",
        WINDOWS: "WINDOWS"
      };
      exports3.getOS = function() {
        if (exports3.isMac) {
          return exports3.OS.MAC;
        } else if (exports3.isLinux) {
          return exports3.OS.LINUX;
        } else {
          return exports3.OS.WINDOWS;
        }
      };
      var _navigator = typeof navigator == "object" ? navigator : {};
      var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
      var ua = _navigator.userAgent || "";
      var appName = _navigator.appName || "";
      exports3.isWin = os == "win";
      exports3.isMac = os == "mac";
      exports3.isLinux = os == "linux";
      exports3.isIE = appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]);
      exports3.isOldIE = exports3.isIE && exports3.isIE < 9;
      exports3.isGecko = exports3.isMozilla = ua.match(/ Gecko\/\d+/);
      exports3.isOpera = typeof opera == "object" && Object.prototype.toString.call(window.opera) == "[object Opera]";
      exports3.isWebKit = parseFloat(ua.split("WebKit/")[1]) || void 0;
      exports3.isChrome = parseFloat(ua.split(" Chrome/")[1]) || void 0;
      exports3.isEdge = parseFloat(ua.split(" Edge/")[1]) || void 0;
      exports3.isAIR = ua.indexOf("AdobeAIR") >= 0;
      exports3.isAndroid = ua.indexOf("Android") >= 0;
      exports3.isChromeOS = ua.indexOf(" CrOS ") >= 0;
      exports3.isIOS = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
      if (exports3.isIOS)
        exports3.isMac = true;
      exports3.isMobile = exports3.isIOS || exports3.isAndroid;
    });
    ace.define("ace/lib/dom", ["require", "exports", "module", "ace/lib/useragent"], function(require2, exports3, module3) {
      var useragent = require2("./useragent");
      var XHTML_NS = "http://www.w3.org/1999/xhtml";
      exports3.buildDom = function buildDom(arr, parent, refs) {
        if (typeof arr == "string" && arr) {
          var txt = document.createTextNode(arr);
          if (parent)
            parent.appendChild(txt);
          return txt;
        }
        if (!Array.isArray(arr)) {
          if (arr && arr.appendChild && parent)
            parent.appendChild(arr);
          return arr;
        }
        if (typeof arr[0] != "string" || !arr[0]) {
          var els = [];
          for (var i2 = 0; i2 < arr.length; i2++) {
            var ch = buildDom(arr[i2], parent, refs);
            ch && els.push(ch);
          }
          return els;
        }
        var el = document.createElement(arr[0]);
        var options = arr[1];
        var childIndex = 1;
        if (options && typeof options == "object" && !Array.isArray(options))
          childIndex = 2;
        for (var i2 = childIndex; i2 < arr.length; i2++)
          buildDom(arr[i2], el, refs);
        if (childIndex == 2) {
          Object.keys(options).forEach(function(n) {
            var val = options[n];
            if (n === "class") {
              el.className = Array.isArray(val) ? val.join(" ") : val;
            } else if (typeof val == "function" || n == "value" || n[0] == "$") {
              el[n] = val;
            } else if (n === "ref") {
              if (refs)
                refs[val] = el;
            } else if (n === "style") {
              if (typeof val == "string")
                el.style.cssText = val;
            } else if (val != null) {
              el.setAttribute(n, val);
            }
          });
        }
        if (parent)
          parent.appendChild(el);
        return el;
      };
      exports3.getDocumentHead = function(doc) {
        if (!doc)
          doc = document;
        return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
      };
      exports3.createElement = function(tag, ns) {
        return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
      };
      exports3.removeChildren = function(element) {
        element.innerHTML = "";
      };
      exports3.createTextNode = function(textContent, element) {
        var doc = element ? element.ownerDocument : document;
        return doc.createTextNode(textContent);
      };
      exports3.createFragment = function(element) {
        var doc = element ? element.ownerDocument : document;
        return doc.createDocumentFragment();
      };
      exports3.hasCssClass = function(el, name) {
        var classes = (el.className + "").split(/\s+/g);
        return classes.indexOf(name) !== -1;
      };
      exports3.addCssClass = function(el, name) {
        if (!exports3.hasCssClass(el, name)) {
          el.className += " " + name;
        }
      };
      exports3.removeCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g);
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          classes.splice(index, 1);
        }
        el.className = classes.join(" ");
      };
      exports3.toggleCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g), add = true;
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          add = false;
          classes.splice(index, 1);
        }
        if (add)
          classes.push(name);
        el.className = classes.join(" ");
        return add;
      };
      exports3.setCssClass = function(node, className, include) {
        if (include) {
          exports3.addCssClass(node, className);
        } else {
          exports3.removeCssClass(node, className);
        }
      };
      exports3.hasCssString = function(id, doc) {
        var index = 0, sheets;
        doc = doc || document;
        if (sheets = doc.querySelectorAll("style")) {
          while (index < sheets.length) {
            if (sheets[index++].id === id) {
              return true;
            }
          }
        }
      };
      exports3.removeElementById = function(id, doc) {
        doc = doc || document;
        if (doc.getElementById(id)) {
          doc.getElementById(id).remove();
        }
      };
      var strictCSP;
      var cssCache = [];
      exports3.useStrictCSP = function(value) {
        strictCSP = value;
        if (value == false)
          insertPendingStyles();
        else if (!cssCache)
          cssCache = [];
      };
      function insertPendingStyles() {
        var cache = cssCache;
        cssCache = null;
        cache && cache.forEach(function(item2) {
          importCssString(item2[0], item2[1]);
        });
      }
      function importCssString(cssText, id, target) {
        if (typeof document == "undefined")
          return;
        if (cssCache) {
          if (target) {
            insertPendingStyles();
          } else if (target === false) {
            return cssCache.push([cssText, id]);
          }
        }
        if (strictCSP)
          return;
        var container = target;
        if (!target || !target.getRootNode) {
          container = document;
        } else {
          container = target.getRootNode();
          if (!container || container == target)
            container = document;
        }
        var doc = container.ownerDocument || container;
        if (id && exports3.hasCssString(id, container))
          return null;
        if (id)
          cssText += "\n/*# sourceURL=ace/css/" + id + " */";
        var style = exports3.createElement("style");
        style.appendChild(doc.createTextNode(cssText));
        if (id)
          style.id = id;
        if (container == doc)
          container = exports3.getDocumentHead(doc);
        container.insertBefore(style, container.firstChild);
      }
      exports3.importCssString = importCssString;
      exports3.importCssStylsheet = function(uri, doc) {
        exports3.buildDom(["link", { rel: "stylesheet", href: uri }], exports3.getDocumentHead(doc));
      };
      exports3.scrollbarWidth = function(doc) {
        var inner = exports3.createElement("ace_inner");
        inner.style.width = "100%";
        inner.style.minWidth = "0px";
        inner.style.height = "200px";
        inner.style.display = "block";
        var outer = exports3.createElement("ace_outer");
        var style = outer.style;
        style.position = "absolute";
        style.left = "-10000px";
        style.overflow = "hidden";
        style.width = "200px";
        style.minWidth = "0px";
        style.height = "150px";
        style.display = "block";
        outer.appendChild(inner);
        var body = doc && doc.documentElement || document && document.documentElement;
        if (!body)
          return 0;
        body.appendChild(outer);
        var noScrollbar = inner.offsetWidth;
        style.overflow = "scroll";
        var withScrollbar = inner.offsetWidth;
        if (noScrollbar === withScrollbar) {
          withScrollbar = outer.clientWidth;
        }
        body.removeChild(outer);
        return noScrollbar - withScrollbar;
      };
      exports3.computedStyle = function(element, style) {
        return window.getComputedStyle(element, "") || {};
      };
      exports3.setStyle = function(styles2, property, value) {
        if (styles2[property] !== value) {
          styles2[property] = value;
        }
      };
      exports3.HAS_CSS_ANIMATION = false;
      exports3.HAS_CSS_TRANSFORMS = false;
      exports3.HI_DPI = useragent.isWin ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5 : true;
      if (useragent.isChromeOS)
        exports3.HI_DPI = false;
      if (typeof document !== "undefined") {
        var div = document.createElement("div");
        if (exports3.HI_DPI && div.style.transform !== void 0)
          exports3.HAS_CSS_TRANSFORMS = true;
        if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
          exports3.HAS_CSS_ANIMATION = true;
        div = null;
      }
      if (exports3.HAS_CSS_TRANSFORMS) {
        exports3.translate = function(element, tx, ty) {
          element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
        };
      } else {
        exports3.translate = function(element, tx, ty) {
          element.style.top = Math.round(ty) + "px";
          element.style.left = Math.round(tx) + "px";
        };
      }
    });
    ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports3, module3) {
      /*
      * based on code from:
      *
      * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
      * Available via the MIT or new BSD license.
      * see: http://github.com/jrburke/requirejs for details
      */
      var dom = require2("./dom");
      exports3.get = function(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            callback(xhr.responseText);
          }
        };
        xhr.send(null);
      };
      exports3.loadScript = function(path, callback) {
        var head = dom.getDocumentHead();
        var s3 = document.createElement("script");
        s3.src = path;
        head.appendChild(s3);
        s3.onload = s3.onreadystatechange = function(_, isAbort) {
          if (isAbort || !s3.readyState || s3.readyState == "loaded" || s3.readyState == "complete") {
            s3 = s3.onload = s3.onreadystatechange = null;
            if (!isAbort)
              callback();
          }
        };
      };
      exports3.qualifyURL = function(url) {
        var a3 = document.createElement("a");
        a3.href = url;
        return a3.href;
      };
    });
    ace.define("ace/lib/oop", ["require", "exports", "module"], function(require2, exports3, module3) {
      exports3.inherits = function(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
      exports3.mixin = function(obj, mixin) {
        for (var key in mixin) {
          obj[key] = mixin[key];
        }
        return obj;
      };
      exports3.implement = function(proto2, mixin) {
        exports3.mixin(proto2, mixin);
      };
    });
    ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function(require2, exports3, module3) {
      var EventEmitter = {};
      var stopPropagation = function() {
        this.propagationStopped = true;
      };
      var preventDefault = function() {
        this.defaultPrevented = true;
      };
      EventEmitter._emit = EventEmitter._dispatchEvent = function(eventName, e2) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});
        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length && !defaultHandler)
          return;
        if (typeof e2 != "object" || !e2)
          e2 = {};
        if (!e2.type)
          e2.type = eventName;
        if (!e2.stopPropagation)
          e2.stopPropagation = stopPropagation;
        if (!e2.preventDefault)
          e2.preventDefault = preventDefault;
        listeners = listeners.slice();
        for (var i2 = 0; i2 < listeners.length; i2++) {
          listeners[i2](e2, this);
          if (e2.propagationStopped)
            break;
        }
        if (defaultHandler && !e2.defaultPrevented)
          return defaultHandler(e2, this);
      };
      EventEmitter._signal = function(eventName, e2) {
        var listeners = (this._eventRegistry || {})[eventName];
        if (!listeners)
          return;
        listeners = listeners.slice();
        for (var i2 = 0; i2 < listeners.length; i2++)
          listeners[i2](e2, this);
      };
      EventEmitter.once = function(eventName, callback) {
        var _self = this;
        this.on(eventName, function newCallback() {
          _self.off(eventName, newCallback);
          callback.apply(null, arguments);
        });
        if (!callback) {
          return new Promise(function(resolve) {
            callback = resolve;
          });
        }
      };
      EventEmitter.setDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
          handlers = this._defaultHandlers = { _disabled_: {} };
        if (handlers[eventName]) {
          var old = handlers[eventName];
          var disabled = handlers._disabled_[eventName];
          if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
          disabled.push(old);
          var i2 = disabled.indexOf(callback);
          if (i2 != -1)
            disabled.splice(i2, 1);
        }
        handlers[eventName] = callback;
      };
      EventEmitter.removeDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
          return;
        var disabled = handlers._disabled_[eventName];
        if (handlers[eventName] == callback) {
          if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
        } else if (disabled) {
          var i2 = disabled.indexOf(callback);
          if (i2 != -1)
            disabled.splice(i2, 1);
        }
      };
      EventEmitter.on = EventEmitter.addEventListener = function(eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          listeners = this._eventRegistry[eventName] = [];
        if (listeners.indexOf(callback) == -1)
          listeners[capturing ? "unshift" : "push"](callback);
        return callback;
      };
      EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(eventName, callback) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          return;
        var index = listeners.indexOf(callback);
        if (index !== -1)
          listeners.splice(index, 1);
      };
      EventEmitter.removeAllListeners = function(eventName) {
        if (!eventName)
          this._eventRegistry = this._defaultHandlers = void 0;
        if (this._eventRegistry)
          this._eventRegistry[eventName] = void 0;
        if (this._defaultHandlers)
          this._defaultHandlers[eventName] = void 0;
      };
      exports3.EventEmitter = EventEmitter;
    });
    ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      "no use strict";
      var oop = require2("./oop");
      var EventEmitter = require2("./event_emitter").EventEmitter;
      var optionsProvider = {
        setOptions: function(optList) {
          Object.keys(optList).forEach(function(key) {
            this.setOption(key, optList[key]);
          }, this);
        },
        getOptions: function(optionNames) {
          var result = {};
          if (!optionNames) {
            var options = this.$options;
            optionNames = Object.keys(options).filter(function(key) {
              return !options[key].hidden;
            });
          } else if (!Array.isArray(optionNames)) {
            result = optionNames;
            optionNames = Object.keys(result);
          }
          optionNames.forEach(function(key) {
            result[key] = this.getOption(key);
          }, this);
          return result;
        },
        setOption: function(name, value) {
          if (this["$" + name] === value)
            return;
          var opt = this.$options[name];
          if (!opt) {
            return warn('misspelled option "' + name + '"');
          }
          if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
          if (!opt.handlesSet)
            this["$" + name] = value;
          if (opt && opt.set)
            opt.set.call(this, value);
        },
        getOption: function(name) {
          var opt = this.$options[name];
          if (!opt) {
            return warn('misspelled option "' + name + '"');
          }
          if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
          return opt && opt.get ? opt.get.call(this) : this["$" + name];
        }
      };
      function warn(message) {
        if (typeof console != "undefined" && console.warn)
          console.warn.apply(console, arguments);
      }
      function reportError(msg, data) {
        var e2 = new Error(msg);
        e2.data = data;
        if (typeof console == "object" && console.error)
          console.error(e2);
        setTimeout(function() {
          throw e2;
        });
      }
      var AppConfig = (
        /** @class */
        function() {
          function AppConfig2() {
            this.$defaultOptions = {};
          }
          AppConfig2.prototype.defineOptions = function(obj, path, options) {
            if (!obj.$options)
              this.$defaultOptions[path] = obj.$options = {};
            Object.keys(options).forEach(function(key) {
              var opt = options[key];
              if (typeof opt == "string")
                opt = { forwardTo: opt };
              opt.name || (opt.name = key);
              obj.$options[opt.name] = opt;
              if ("initialValue" in opt)
                obj["$" + opt.name] = opt.initialValue;
            });
            oop.implement(obj, optionsProvider);
            return this;
          };
          AppConfig2.prototype.resetOptions = function(obj) {
            Object.keys(obj.$options).forEach(function(key) {
              var opt = obj.$options[key];
              if ("value" in opt)
                obj.setOption(key, opt.value);
            });
          };
          AppConfig2.prototype.setDefaultValue = function(path, name, value) {
            if (!path) {
              for (path in this.$defaultOptions)
                if (this.$defaultOptions[path][name])
                  break;
              if (!this.$defaultOptions[path][name])
                return false;
            }
            var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
            if (opts[name]) {
              if (opts.forwardTo)
                this.setDefaultValue(opts.forwardTo, name, value);
              else
                opts[name].value = value;
            }
          };
          AppConfig2.prototype.setDefaultValues = function(path, optionHash) {
            Object.keys(optionHash).forEach(function(key) {
              this.setDefaultValue(path, key, optionHash[key]);
            }, this);
          };
          return AppConfig2;
        }()
      );
      AppConfig.prototype.warn = warn;
      AppConfig.prototype.reportError = reportError;
      oop.implement(AppConfig.prototype, EventEmitter);
      exports3.AppConfig = AppConfig;
    });
    ace.define("ace/theme/textmate.css", ["require", "exports", "module"], function(require2, exports3, module3) {
      module3.exports = '.ace-tm .ace_gutter {\n  background: #f0f0f0;\n  color: #333;\n}\n\n.ace-tm .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-tm .ace_fold {\n    background-color: #6B72E6;\n}\n\n.ace-tm {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-tm .ace_cursor {\n  color: black;\n}\n        \n.ace-tm .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-tm .ace_storage,\n.ace-tm .ace_keyword {\n  color: blue;\n}\n\n.ace-tm .ace_constant {\n  color: rgb(197, 6, 11);\n}\n\n.ace-tm .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-tm .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-tm .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_invalid {\n  background-color: rgba(255, 0, 0, 0.1);\n  color: red;\n}\n\n.ace-tm .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-tm .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_support.ace_type,\n.ace-tm .ace_support.ace_class {\n  color: rgb(109, 121, 222);\n}\n\n.ace-tm .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-tm .ace_string {\n  color: rgb(3, 106, 7);\n}\n\n.ace-tm .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-tm .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-tm .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-tm .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-tm .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-tm .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-tm .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-tm .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-tm .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-tm .ace_meta.ace_tag {\n  color:rgb(0, 22, 142);\n}\n\n.ace-tm .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-tm .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n.ace-tm.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px white;\n}\n.ace-tm .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-tm .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-tm .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-tm .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-tm .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-tm .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-tm .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-tm .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n';
    });
    ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/theme/textmate.css", "ace/lib/dom"], function(require2, exports3, module3) {
      exports3.isDark = false;
      exports3.cssClass = "ace-tm";
      exports3.cssText = require2("./textmate.css");
      exports3.$id = "ace/theme/textmate";
      var dom = require2("../lib/dom");
      dom.importCssString(exports3.cssText, exports3.cssClass, false);
    });
    ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/net", "ace/lib/dom", "ace/lib/app_config", "ace/theme/textmate"], function(require2, exports3, module3) {
      "no use strict";
      var lang = require2("./lib/lang");
      var net = require2("./lib/net");
      var dom = require2("./lib/dom");
      var AppConfig = require2("./lib/app_config").AppConfig;
      module3.exports = exports3 = new AppConfig();
      var options = {
        packaged: false,
        workerPath: null,
        modePath: null,
        themePath: null,
        basePath: "",
        suffix: ".js",
        $moduleUrls: {},
        loadWorkerFromBlob: true,
        sharedPopups: false,
        useStrictCSP: null
      };
      exports3.get = function(key) {
        if (!options.hasOwnProperty(key))
          throw new Error("Unknown config key: " + key);
        return options[key];
      };
      exports3.set = function(key, value) {
        if (options.hasOwnProperty(key))
          options[key] = value;
        else if (this.setDefaultValue("", key, value) == false)
          throw new Error("Unknown config key: " + key);
        if (key == "useStrictCSP")
          dom.useStrictCSP(value);
      };
      exports3.all = function() {
        return lang.copyObject(options);
      };
      exports3.$modes = {};
      exports3.moduleUrl = function(name, component) {
        if (options.$moduleUrls[name])
          return options.$moduleUrls[name];
        var parts = name.split("/");
        component = component || parts[parts.length - 2] || "";
        var sep = component == "snippets" ? "/" : "-";
        var base = parts[parts.length - 1];
        if (component == "worker" && sep == "-") {
          var re2 = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
          base = base.replace(re2, "");
        }
        if ((!base || base == component) && parts.length > 1)
          base = parts[parts.length - 2];
        var path = options[component + "Path"];
        if (path == null) {
          path = options.basePath;
        } else if (sep == "/") {
          component = sep = "";
        }
        if (path && path.slice(-1) != "/")
          path += "/";
        return path + component + sep + base + this.get("suffix");
      };
      exports3.setModuleUrl = function(name, subst) {
        return options.$moduleUrls[name] = subst;
      };
      var loader2 = function(moduleName, cb) {
        if (moduleName === "ace/theme/textmate" || moduleName === "./theme/textmate")
          return cb(null, require2("./theme/textmate"));
        return console.error("loader is not configured");
      };
      exports3.setLoader = function(cb) {
        loader2 = cb;
      };
      exports3.dynamicModules = /* @__PURE__ */ Object.create(null);
      exports3.$loading = {};
      exports3.loadModule = function(moduleName, onLoad) {
        var module4, moduleType;
        if (Array.isArray(moduleName)) {
          moduleType = moduleName[0];
          moduleName = moduleName[1];
        }
        var load = function(module5) {
          if (module5 && !exports3.$loading[moduleName])
            return onLoad && onLoad(module5);
          if (!exports3.$loading[moduleName])
            exports3.$loading[moduleName] = [];
          exports3.$loading[moduleName].push(onLoad);
          if (exports3.$loading[moduleName].length > 1)
            return;
          var afterLoad = function() {
            loader2(moduleName, function(err, module6) {
              exports3._emit("load.module", { name: moduleName, module: module6 });
              var listeners = exports3.$loading[moduleName];
              exports3.$loading[moduleName] = null;
              listeners.forEach(function(onLoad2) {
                onLoad2 && onLoad2(module6);
              });
            });
          };
          if (!exports3.get("packaged"))
            return afterLoad();
          net.loadScript(exports3.moduleUrl(moduleName, moduleType), afterLoad);
          reportErrorIfPathIsNotConfigured();
        };
        if (exports3.dynamicModules[moduleName]) {
          exports3.dynamicModules[moduleName]().then(function(module5) {
            if (module5.default) {
              load(module5.default);
            } else {
              load(module5);
            }
          });
        } else {
          try {
            module4 = require2(moduleName);
          } catch (e2) {
          }
          load(module4);
        }
      };
      exports3.setModuleLoader = function(moduleName, onLoad) {
        exports3.dynamicModules[moduleName] = onLoad;
      };
      var reportErrorIfPathIsNotConfigured = function() {
        if (!options.basePath && !options.workerPath && !options.modePath && !options.themePath && !Object.keys(options.$moduleUrls).length) {
          console.error("Unable to infer path to ace from script src,", "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes", "or with webpack use ace/webpack-resolver");
          reportErrorIfPathIsNotConfigured = function() {
          };
        }
      };
      exports3.version = "1.18.0";
    });
    ace.define("ace/loader_build", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/config"], function(require2, exports3, module3) {
      require2("./lib/fixoldbrowsers");
      var config = require2("./config");
      config.setLoader(function(moduleName, cb) {
        require2([moduleName], function(module4) {
          cb(null, module4);
        });
      });
      var global = /* @__PURE__ */ function() {
        return this || typeof window != "undefined" && window;
      }();
      module3.exports = function(ace2) {
        config.init = init2;
        ace2.require = require2;
      };
      init2(true);
      function init2(packaged) {
        if (!global || !global.document)
          return;
        config.set("packaged", packaged || require2.packaged || module3.packaged || global.define && (void 0).packaged);
        var scriptOptions = {};
        var scriptUrl = "";
        var currentScript = document.currentScript || document._currentScript;
        var currentDocument = currentScript && currentScript.ownerDocument || document;
        if (currentScript && currentScript.src) {
          scriptUrl = currentScript.src.split(/[?#]/)[0].split("/").slice(0, -1).join("/") || "";
        }
        var scripts = currentDocument.getElementsByTagName("script");
        for (var i2 = 0; i2 < scripts.length; i2++) {
          var script = scripts[i2];
          var src = script.src || script.getAttribute("src");
          if (!src)
            continue;
          var attributes = script.attributes;
          for (var j = 0, l = attributes.length; j < l; j++) {
            var attr = attributes[j];
            if (attr.name.indexOf("data-ace-") === 0) {
              scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
          }
          var m3 = src.match(/^(.*)\/ace([\-.]\w+)?\.js(\?|$)/);
          if (m3)
            scriptUrl = m3[1];
        }
        if (scriptUrl) {
          scriptOptions.base = scriptOptions.base || scriptUrl;
          scriptOptions.packaged = true;
        }
        scriptOptions.basePath = scriptOptions.base;
        scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
        scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
        scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
        delete scriptOptions.base;
        for (var key in scriptOptions)
          if (typeof scriptOptions[key] !== "undefined")
            config.set(key, scriptOptions[key]);
      }
      function deHyphenate(str) {
        return str.replace(/-(.)/g, function(m3, m1) {
          return m1.toUpperCase();
        });
      }
    });
    ace.define("ace/range", ["require", "exports", "module"], function(require2, exports3, module3) {
      var comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };
      var Range = (
        /** @class */
        function() {
          function Range2(startRow, startColumn, endRow, endColumn) {
            this.start = {
              row: startRow,
              column: startColumn
            };
            this.end = {
              row: endRow,
              column: endColumn
            };
          }
          Range2.prototype.isEqual = function(range) {
            return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
          };
          Range2.prototype.toString = function() {
            return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
          };
          Range2.prototype.contains = function(row, column) {
            return this.compare(row, column) == 0;
          };
          Range2.prototype.compareRange = function(range) {
            var cmp, end = range.end, start = range.start;
            cmp = this.compare(end.row, end.column);
            if (cmp == 1) {
              cmp = this.compare(start.row, start.column);
              if (cmp == 1) {
                return 2;
              } else if (cmp == 0) {
                return 1;
              } else {
                return 0;
              }
            } else if (cmp == -1) {
              return -2;
            } else {
              cmp = this.compare(start.row, start.column);
              if (cmp == -1) {
                return -1;
              } else if (cmp == 1) {
                return 42;
              } else {
                return 0;
              }
            }
          };
          Range2.prototype.comparePoint = function(p) {
            return this.compare(p.row, p.column);
          };
          Range2.prototype.containsRange = function(range) {
            return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
          };
          Range2.prototype.intersects = function(range) {
            var cmp = this.compareRange(range);
            return cmp == -1 || cmp == 0 || cmp == 1;
          };
          Range2.prototype.isEnd = function(row, column) {
            return this.end.row == row && this.end.column == column;
          };
          Range2.prototype.isStart = function(row, column) {
            return this.start.row == row && this.start.column == column;
          };
          Range2.prototype.setStart = function(row, column) {
            if (typeof row == "object") {
              this.start.column = row.column;
              this.start.row = row.row;
            } else {
              this.start.row = row;
              this.start.column = column;
            }
          };
          Range2.prototype.setEnd = function(row, column) {
            if (typeof row == "object") {
              this.end.column = row.column;
              this.end.row = row.row;
            } else {
              this.end.row = row;
              this.end.column = column;
            }
          };
          Range2.prototype.inside = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          Range2.prototype.insideStart = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isEnd(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          Range2.prototype.insideEnd = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isStart(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          Range2.prototype.compare = function(row, column) {
            if (!this.isMultiLine()) {
              if (row === this.start.row) {
                return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
              }
            }
            if (row < this.start.row)
              return -1;
            if (row > this.end.row)
              return 1;
            if (this.start.row === row)
              return column >= this.start.column ? 0 : -1;
            if (this.end.row === row)
              return column <= this.end.column ? 0 : 1;
            return 0;
          };
          Range2.prototype.compareStart = function(row, column) {
            if (this.start.row == row && this.start.column == column) {
              return -1;
            } else {
              return this.compare(row, column);
            }
          };
          Range2.prototype.compareEnd = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
              return 1;
            } else {
              return this.compare(row, column);
            }
          };
          Range2.prototype.compareInside = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
              return 1;
            } else if (this.start.row == row && this.start.column == column) {
              return -1;
            } else {
              return this.compare(row, column);
            }
          };
          Range2.prototype.clipRows = function(firstRow, lastRow) {
            if (this.end.row > lastRow)
              var end = { row: lastRow + 1, column: 0 };
            else if (this.end.row < firstRow)
              var end = { row: firstRow, column: 0 };
            if (this.start.row > lastRow)
              var start = { row: lastRow + 1, column: 0 };
            else if (this.start.row < firstRow)
              var start = { row: firstRow, column: 0 };
            return Range2.fromPoints(start || this.start, end || this.end);
          };
          Range2.prototype.extend = function(row, column) {
            var cmp = this.compare(row, column);
            if (cmp == 0)
              return this;
            else if (cmp == -1)
              var start = { row, column };
            else
              var end = { row, column };
            return Range2.fromPoints(start || this.start, end || this.end);
          };
          Range2.prototype.isEmpty = function() {
            return this.start.row === this.end.row && this.start.column === this.end.column;
          };
          Range2.prototype.isMultiLine = function() {
            return this.start.row !== this.end.row;
          };
          Range2.prototype.clone = function() {
            return Range2.fromPoints(this.start, this.end);
          };
          Range2.prototype.collapseRows = function() {
            if (this.end.column == 0)
              return new Range2(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
            else
              return new Range2(this.start.row, 0, this.end.row, 0);
          };
          Range2.prototype.toScreenRange = function(session) {
            var screenPosStart = session.documentToScreenPosition(this.start);
            var screenPosEnd = session.documentToScreenPosition(this.end);
            return new Range2(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
          };
          Range2.prototype.moveBy = function(row, column) {
            this.start.row += row;
            this.start.column += column;
            this.end.row += row;
            this.end.column += column;
          };
          return Range2;
        }()
      );
      Range.fromPoints = function(start, end) {
        return new Range(start.row, start.column, end.row, end.column);
      };
      Range.comparePoints = comparePoints;
      Range.comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };
      exports3.Range = Range;
    });
    ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/oop"], function(require2, exports3, module3) {
      /*! @license
      		==========================================================================
      		SproutCore -- JavaScript Application Framework
      		copyright 2006-2009, Sprout Systems Inc., Apple Inc. and contributors.
      
      		Permission is hereby granted, free of charge, to any person obtaining a
      		copy of this software and associated documentation files (the "Software"),
      		to deal in the Software without restriction, including without limitation
      		the rights to use, copy, modify, merge, publish, distribute, sublicense,
      		and/or sell copies of the Software, and to permit persons to whom the
      		Software is furnished to do so, subject to the following conditions:
      
      		The above copyright notice and this permission notice shall be included in
      		all copies or substantial portions of the Software.
      
      		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
      		FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
      		DEALINGS IN THE SOFTWARE.
      
      		SproutCore and the SproutCore logo are trademarks of Sprout Systems, Inc.
      
      		For more information about SproutCore, visit http://www.sproutcore.com
      
      
      		==========================================================================
      		@license */
      var oop = require2("./oop");
      var Keys = function() {
        var ret = {
          MODIFIER_KEYS: {
            16: "Shift",
            17: "Ctrl",
            18: "Alt",
            224: "Meta",
            91: "MetaLeft",
            92: "MetaRight",
            93: "ContextMenu"
          },
          KEY_MODS: {
            "ctrl": 1,
            "alt": 2,
            "option": 2,
            "shift": 4,
            "super": 8,
            "meta": 8,
            "command": 8,
            "cmd": 8,
            "control": 1
          },
          FUNCTION_KEYS: {
            8: "Backspace",
            9: "Tab",
            13: "Return",
            19: "Pause",
            27: "Esc",
            32: "Space",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "Left",
            38: "Up",
            39: "Right",
            40: "Down",
            44: "Print",
            45: "Insert",
            46: "Delete",
            96: "Numpad0",
            97: "Numpad1",
            98: "Numpad2",
            99: "Numpad3",
            100: "Numpad4",
            101: "Numpad5",
            102: "Numpad6",
            103: "Numpad7",
            104: "Numpad8",
            105: "Numpad9",
            "-13": "NumpadEnter",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "Numlock",
            145: "Scrolllock"
          },
          PRINTABLE_KEYS: {
            32: " ",
            48: "0",
            49: "1",
            50: "2",
            51: "3",
            52: "4",
            53: "5",
            54: "6",
            55: "7",
            56: "8",
            57: "9",
            59: ";",
            61: "=",
            65: "a",
            66: "b",
            67: "c",
            68: "d",
            69: "e",
            70: "f",
            71: "g",
            72: "h",
            73: "i",
            74: "j",
            75: "k",
            76: "l",
            77: "m",
            78: "n",
            79: "o",
            80: "p",
            81: "q",
            82: "r",
            83: "s",
            84: "t",
            85: "u",
            86: "v",
            87: "w",
            88: "x",
            89: "y",
            90: "z",
            107: "+",
            109: "-",
            110: ".",
            186: ";",
            187: "=",
            188: ",",
            189: "-",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: "'",
            111: "/",
            106: "*"
          }
        };
        ret.PRINTABLE_KEYS[173] = "-";
        var name, i2;
        for (i2 in ret.FUNCTION_KEYS) {
          name = ret.FUNCTION_KEYS[i2].toLowerCase();
          ret[name] = parseInt(i2, 10);
        }
        for (i2 in ret.PRINTABLE_KEYS) {
          name = ret.PRINTABLE_KEYS[i2].toLowerCase();
          ret[name] = parseInt(i2, 10);
        }
        oop.mixin(ret, ret.MODIFIER_KEYS);
        oop.mixin(ret, ret.PRINTABLE_KEYS);
        oop.mixin(ret, ret.FUNCTION_KEYS);
        ret.enter = ret["return"];
        ret.escape = ret.esc;
        ret.del = ret["delete"];
        (function() {
          var mods = ["cmd", "ctrl", "alt", "shift"];
          for (var i3 = Math.pow(2, mods.length); i3--; ) {
            ret.KEY_MODS[i3] = mods.filter(function(x2) {
              return i3 & ret.KEY_MODS[x2];
            }).join("-") + "-";
          }
        })();
        ret.KEY_MODS[0] = "";
        ret.KEY_MODS[-1] = "input-";
        return ret;
      }();
      oop.mixin(exports3, Keys);
      exports3.keyCodeToString = function(keyCode) {
        var keyString = Keys[keyCode];
        if (typeof keyString != "string")
          keyString = String.fromCharCode(keyCode);
        return keyString.toLowerCase();
      };
    });
    ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require2, exports3, module3) {
      var keys = require2("./keys");
      var useragent = require2("./useragent");
      var pressedKeys = null;
      var ts = 0;
      var activeListenerOptions;
      function detectListenerOptionsSupport() {
        activeListenerOptions = false;
        try {
          document.createComment("").addEventListener("test", function() {
          }, {
            get passive() {
              activeListenerOptions = { passive: false };
            }
          });
        } catch (e2) {
        }
      }
      function getListenerOptions() {
        if (activeListenerOptions == void 0)
          detectListenerOptionsSupport();
        return activeListenerOptions;
      }
      function EventListener(elem, type, callback) {
        this.elem = elem;
        this.type = type;
        this.callback = callback;
      }
      EventListener.prototype.destroy = function() {
        removeListener2(this.elem, this.type, this.callback);
        this.elem = this.type = this.callback = void 0;
      };
      var addListener2 = exports3.addListener = function(elem, type, callback, destroyer) {
        elem.addEventListener(type, callback, getListenerOptions());
        if (destroyer)
          destroyer.$toDestroy.push(new EventListener(elem, type, callback));
      };
      var removeListener2 = exports3.removeListener = function(elem, type, callback) {
        elem.removeEventListener(type, callback, getListenerOptions());
      };
      exports3.stopEvent = function(e2) {
        exports3.stopPropagation(e2);
        exports3.preventDefault(e2);
        return false;
      };
      exports3.stopPropagation = function(e2) {
        if (e2.stopPropagation)
          e2.stopPropagation();
      };
      exports3.preventDefault = function(e2) {
        if (e2.preventDefault)
          e2.preventDefault();
      };
      exports3.getButton = function(e2) {
        if (e2.type == "dblclick")
          return 0;
        if (e2.type == "contextmenu" || useragent.isMac && (e2.ctrlKey && !e2.altKey && !e2.shiftKey))
          return 2;
        return e2.button;
      };
      exports3.capture = function(el, eventHandler, releaseCaptureHandler) {
        var ownerDocument = el && el.ownerDocument || document;
        function onMouseUp(e2) {
          eventHandler && eventHandler(e2);
          releaseCaptureHandler && releaseCaptureHandler(e2);
          removeListener2(ownerDocument, "mousemove", eventHandler);
          removeListener2(ownerDocument, "mouseup", onMouseUp);
          removeListener2(ownerDocument, "dragstart", onMouseUp);
        }
        addListener2(ownerDocument, "mousemove", eventHandler);
        addListener2(ownerDocument, "mouseup", onMouseUp);
        addListener2(ownerDocument, "dragstart", onMouseUp);
        return onMouseUp;
      };
      exports3.addMouseWheelListener = function(el, callback, destroyer) {
        addListener2(el, "wheel", function(e2) {
          var factor = 0.15;
          var deltaX = e2.deltaX || 0;
          var deltaY = e2.deltaY || 0;
          switch (e2.deltaMode) {
            case e2.DOM_DELTA_PIXEL:
              e2.wheelX = deltaX * factor;
              e2.wheelY = deltaY * factor;
              break;
            case e2.DOM_DELTA_LINE:
              var linePixels = 15;
              e2.wheelX = deltaX * linePixels;
              e2.wheelY = deltaY * linePixels;
              break;
            case e2.DOM_DELTA_PAGE:
              var pagePixels = 150;
              e2.wheelX = deltaX * pagePixels;
              e2.wheelY = deltaY * pagePixels;
              break;
          }
          callback(e2);
        }, destroyer);
      };
      exports3.addMultiMouseDownListener = function(elements, timeouts2, eventHandler, callbackName, destroyer) {
        var clicks = 0;
        var startX, startY, timer;
        var eventNames = {
          2: "dblclick",
          3: "tripleclick",
          4: "quadclick"
        };
        function onMousedown(e2) {
          if (exports3.getButton(e2) !== 0) {
            clicks = 0;
          } else if (e2.detail > 1) {
            clicks++;
            if (clicks > 4)
              clicks = 1;
          } else {
            clicks = 1;
          }
          if (useragent.isIE) {
            var isNewClick = Math.abs(e2.clientX - startX) > 5 || Math.abs(e2.clientY - startY) > 5;
            if (!timer || isNewClick)
              clicks = 1;
            if (timer)
              clearTimeout(timer);
            timer = setTimeout(function() {
              timer = null;
            }, timeouts2[clicks - 1] || 600);
            if (clicks == 1) {
              startX = e2.clientX;
              startY = e2.clientY;
            }
          }
          e2._clicks = clicks;
          eventHandler[callbackName]("mousedown", e2);
          if (clicks > 4)
            clicks = 0;
          else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e2);
        }
        if (!Array.isArray(elements))
          elements = [elements];
        elements.forEach(function(el) {
          addListener2(el, "mousedown", onMousedown, destroyer);
        });
      };
      var getModifierHash = function(e2) {
        return 0 | (e2.ctrlKey ? 1 : 0) | (e2.altKey ? 2 : 0) | (e2.shiftKey ? 4 : 0) | (e2.metaKey ? 8 : 0);
      };
      exports3.getModifierString = function(e2) {
        return keys.KEY_MODS[getModifierHash(e2)];
      };
      function normalizeCommandKeys(callback, e2, keyCode) {
        var hashId = getModifierHash(e2);
        if (!useragent.isMac && pressedKeys) {
          if (e2.getModifierState && (e2.getModifierState("OS") || e2.getModifierState("Win")))
            hashId |= 8;
          if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
              pressedKeys.altGr = 0;
            else
              return;
          }
          if (keyCode === 18 || keyCode === 17) {
            var location2 = "location" in e2 ? e2.location : e2.keyLocation;
            if (keyCode === 17 && location2 === 1) {
              if (pressedKeys[keyCode] == 1)
                ts = e2.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location2 === 2) {
              var dt = e2.timeStamp - ts;
              if (dt < 50)
                pressedKeys.altGr = true;
            }
          }
        }
        if (keyCode in keys.MODIFIER_KEYS) {
          keyCode = -1;
        }
        if (!hashId && keyCode === 13) {
          var location2 = "location" in e2 ? e2.location : e2.keyLocation;
          if (location2 === 3) {
            callback(e2, hashId, -keyCode);
            if (e2.defaultPrevented)
              return;
          }
        }
        if (useragent.isChromeOS && hashId & 8) {
          callback(e2, hashId, keyCode);
          if (e2.defaultPrevented)
            return;
          else
            hashId &= -9;
        }
        if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
          return false;
        }
        return callback(e2, hashId, keyCode);
      }
      exports3.addCommandKeyListener = function(el, callback, destroyer) {
        if (useragent.isOldGecko || useragent.isOpera && !("KeyboardEvent" in window)) {
          var lastKeyDownKeyCode = null;
          addListener2(el, "keydown", function(e2) {
            lastKeyDownKeyCode = e2.keyCode;
          }, destroyer);
          addListener2(el, "keypress", function(e2) {
            return normalizeCommandKeys(callback, e2, lastKeyDownKeyCode);
          }, destroyer);
        } else {
          var lastDefaultPrevented = null;
          addListener2(el, "keydown", function(e2) {
            pressedKeys[e2.keyCode] = (pressedKeys[e2.keyCode] || 0) + 1;
            var result = normalizeCommandKeys(callback, e2, e2.keyCode);
            lastDefaultPrevented = e2.defaultPrevented;
            return result;
          }, destroyer);
          addListener2(el, "keypress", function(e2) {
            if (lastDefaultPrevented && (e2.ctrlKey || e2.altKey || e2.shiftKey || e2.metaKey)) {
              exports3.stopEvent(e2);
              lastDefaultPrevented = null;
            }
          }, destroyer);
          addListener2(el, "keyup", function(e2) {
            pressedKeys[e2.keyCode] = null;
          }, destroyer);
          if (!pressedKeys) {
            resetPressedKeys();
            addListener2(window, "focus", resetPressedKeys);
          }
        }
      };
      function resetPressedKeys() {
        pressedKeys = /* @__PURE__ */ Object.create(null);
      }
      if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
        var postMessageId = 1;
        exports3.nextTick = function(callback, win) {
          win = win || window;
          var messageName = "zero-timeout-message-" + postMessageId++;
          var listener = function(e2) {
            if (e2.data == messageName) {
              exports3.stopPropagation(e2);
              removeListener2(win, "message", listener);
              callback();
            }
          };
          addListener2(win, "message", listener);
          win.postMessage(messageName, "*");
        };
      }
      exports3.$idleBlocked = false;
      exports3.onIdle = function(cb, timeout) {
        return setTimeout(function handler() {
          if (!exports3.$idleBlocked) {
            cb();
          } else {
            setTimeout(handler, 100);
          }
        }, timeout);
      };
      exports3.$idleBlockId = null;
      exports3.blockIdle = function(delay) {
        if (exports3.$idleBlockId)
          clearTimeout(exports3.$idleBlockId);
        exports3.$idleBlocked = true;
        exports3.$idleBlockId = setTimeout(function() {
          exports3.$idleBlocked = false;
        }, delay || 100);
      };
      exports3.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame);
      if (exports3.nextFrame)
        exports3.nextFrame = exports3.nextFrame.bind(window);
      else
        exports3.nextFrame = function(callback) {
          setTimeout(callback, 17);
        };
    });
    ace.define("ace/clipboard", ["require", "exports", "module"], function(require2, exports3, module3) {
      var $cancelT;
      module3.exports = {
        lineMode: false,
        pasteCancelled: function() {
          if ($cancelT && $cancelT > Date.now() - 50)
            return true;
          return $cancelT = false;
        },
        cancel: function() {
          $cancelT = Date.now();
        }
      };
    });
    ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang", "ace/clipboard", "ace/lib/keys"], function(require2, exports3, module3) {
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var dom = require2("../lib/dom");
      var lang = require2("../lib/lang");
      var clipboard = require2("../clipboard");
      var BROKEN_SETDATA = useragent.isChrome < 18;
      var USE_IE_MIME_TYPE = useragent.isIE;
      var HAS_FOCUS_ARGS = useragent.isChrome > 63;
      var MAX_LINE_LENGTH = 400;
      var KEYS = require2("../lib/keys");
      var MODS = KEYS.KEY_MODS;
      var isIOS2 = useragent.isIOS;
      var valueResetRegex = isIOS2 ? /\s/ : /\n/;
      var isMobile = useragent.isMobile;
      var TextInput = function(parentNode, host) {
        var text = dom.createElement("textarea");
        text.className = "ace_text-input";
        text.setAttribute("wrap", "off");
        text.setAttribute("autocorrect", "off");
        text.setAttribute("autocapitalize", "off");
        text.setAttribute("spellcheck", false);
        text.style.opacity = "0";
        parentNode.insertBefore(text, parentNode.firstChild);
        var copied = false;
        var pasted = false;
        var inComposition = false;
        var sendingText = false;
        var tempStyle = "";
        if (!isMobile)
          text.style.fontSize = "1px";
        var commandMode = false;
        var ignoreFocusEvents = false;
        var lastValue = "";
        var lastSelectionStart = 0;
        var lastSelectionEnd = 0;
        var lastRestoreEnd = 0;
        try {
          var isFocused = document.activeElement === text;
        } catch (e2) {
        }
        this.setAriaOptions = function(options) {
          if (options.activeDescendant) {
            text.setAttribute("aria-haspopup", "true");
            text.setAttribute("aria-autocomplete", options.inline ? "both" : "list");
            text.setAttribute("aria-activedescendant", options.activeDescendant);
          } else {
            text.setAttribute("aria-haspopup", "false");
            text.setAttribute("aria-autocomplete", "both");
            text.removeAttribute("aria-activedescendant");
          }
          if (options.role) {
            text.setAttribute("role", options.role);
          }
        };
        this.setAriaOptions({ role: "textbox" });
        event.addListener(text, "blur", function(e2) {
          if (ignoreFocusEvents)
            return;
          host.onBlur(e2);
          isFocused = false;
          if (isMobile && !isIOS2)
            document.removeEventListener("selectionchange", detectSelectionChange);
        }, host);
        event.addListener(text, "focus", function(e2) {
          if (ignoreFocusEvents)
            return;
          isFocused = true;
          if (useragent.isEdge) {
            try {
              if (!document.hasFocus())
                return;
            } catch (e3) {
            }
          }
          host.onFocus(e2);
          if (useragent.isEdge)
            setTimeout(resetSelection);
          else
            resetSelection();
          if (isMobile && !isIOS2)
            document.addEventListener("selectionchange", detectSelectionChange);
        }, host);
        this.$focusScroll = false;
        this.focus = function() {
          if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
            return text.focus({ preventScroll: true });
          var top = text.style.top;
          text.style.position = "fixed";
          text.style.top = "0px";
          try {
            var isTransformed = text.getBoundingClientRect().top != 0;
          } catch (e2) {
            return;
          }
          var ancestors = [];
          if (isTransformed) {
            var t2 = text.parentElement;
            while (t2 && t2.nodeType == 1) {
              ancestors.push(t2);
              t2.setAttribute("ace_nocontext", true);
              if (!t2.parentElement && t2.getRootNode)
                t2 = t2.getRootNode().host;
              else
                t2 = t2.parentElement;
            }
          }
          text.focus({ preventScroll: true });
          if (isTransformed) {
            ancestors.forEach(function(p) {
              p.removeAttribute("ace_nocontext");
            });
          }
          setTimeout(function() {
            text.style.position = "";
            if (text.style.top == "0px")
              text.style.top = top;
          }, 0);
        };
        this.blur = function() {
          text.blur();
        };
        this.isFocused = function() {
          return isFocused;
        };
        host.on("beforeEndOperation", function() {
          var curOp = host.curOp;
          var commandName = curOp && curOp.command && curOp.command.name;
          if (commandName == "insertstring")
            return;
          var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
          if (inComposition && isUserAction) {
            lastValue = text.value = "";
            onCompositionEnd();
          }
          resetSelection();
        });
        var resetSelection = isIOS2 ? function(value) {
          if (!isFocused || copied && !value || sendingText)
            return;
          if (!value)
            value = "";
          var newValue = "\n ab" + value + "cde fg\n";
          if (newValue != text.value)
            text.value = lastValue = newValue;
          var selectionStart = 4;
          var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));
          if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {
            text.setSelectionRange(selectionStart, selectionEnd);
          }
          lastSelectionStart = selectionStart;
          lastSelectionEnd = selectionEnd;
        } : function() {
          if (inComposition || sendingText)
            return;
          if (!isFocused && !afterContextMenu)
            return;
          inComposition = true;
          var selectionStart = 0;
          var selectionEnd = 0;
          var line = "";
          if (host.session) {
            var selection = host.selection;
            var range = selection.getRange();
            var row = selection.cursor.row;
            selectionStart = range.start.column;
            selectionEnd = range.end.column;
            line = host.session.getLine(row);
            if (range.start.row != row) {
              var prevLine = host.session.getLine(row - 1);
              selectionStart = range.start.row < row - 1 ? 0 : selectionStart;
              selectionEnd += prevLine.length + 1;
              line = prevLine + "\n" + line;
            } else if (range.end.row != row) {
              var nextLine = host.session.getLine(row + 1);
              selectionEnd = range.end.row > row + 1 ? nextLine.length : selectionEnd;
              selectionEnd += line.length + 1;
              line = line + "\n" + nextLine;
            } else if (isMobile && row > 0) {
              line = "\n" + line;
              selectionEnd += 1;
              selectionStart += 1;
            }
            if (line.length > MAX_LINE_LENGTH) {
              if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                line = line.slice(0, MAX_LINE_LENGTH);
              } else {
                line = "\n";
                if (selectionStart == selectionEnd) {
                  selectionStart = selectionEnd = 0;
                } else {
                  selectionStart = 0;
                  selectionEnd = 1;
                }
              }
            }
          }
          var newValue = line + "\n\n";
          if (newValue != lastValue) {
            text.value = lastValue = newValue;
            lastSelectionStart = lastSelectionEnd = newValue.length;
          }
          if (afterContextMenu) {
            lastSelectionStart = text.selectionStart;
            lastSelectionEnd = text.selectionEnd;
          }
          if (lastSelectionEnd != selectionEnd || lastSelectionStart != selectionStart || text.selectionEnd != lastSelectionEnd) {
            try {
              text.setSelectionRange(selectionStart, selectionEnd);
              lastSelectionStart = selectionStart;
              lastSelectionEnd = selectionEnd;
            } catch (e2) {
            }
          }
          inComposition = false;
        };
        this.resetSelection = resetSelection;
        if (isFocused)
          host.onFocus();
        var isAllSelected = function(text2) {
          return text2.selectionStart === 0 && text2.selectionEnd >= lastValue.length && text2.value === lastValue && lastValue && text2.selectionEnd !== lastSelectionEnd;
        };
        var onSelect = function(e2) {
          if (inComposition)
            return;
          if (copied) {
            copied = false;
          } else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
          } else if (isMobile && text.selectionStart != lastSelectionStart) {
            resetSelection();
          }
        };
        function detectSelectionChange(e2) {
          if (!text || !text.parentNode)
            document.removeEventListener("selectionchange", detectSelectionChange);
          if (inComposition)
            return;
          if (text.selectionStart !== text.selectionEnd)
            return;
          var startDiff = text.selectionStart - lastSelectionStart;
          var oldLenght = lastSelectionEnd - lastSelectionStart;
          if (startDiff > 0) {
            startDiff = Math.max(startDiff - oldLenght, 1);
          } else if (startDiff === 0 && oldLenght) {
            startDiff = -1;
          }
          var repeat = Math.abs(startDiff);
          var key = startDiff > 0 ? KEYS.right : KEYS.left;
          for (var i2 = 0; i2 < repeat; i2++) {
            host.onCommandKey({}, 0, key);
          }
        }
        var inputHandler = null;
        this.setInputHandler = function(cb) {
          inputHandler = cb;
        };
        this.getInputHandler = function() {
          return inputHandler;
        };
        var afterContextMenu = false;
        var sendText = function(value, fromInput) {
          if (afterContextMenu)
            afterContextMenu = false;
          if (pasted) {
            resetSelection();
            if (value)
              host.onPaste(value);
            pasted = false;
            return "";
          } else {
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;
            var extendLeft = lastSelectionStart;
            var extendRight = lastValue.length - lastSelectionEnd;
            var inserted = value;
            var restoreStart = value.length - selectionStart;
            var restoreEnd = value.length - selectionEnd;
            var i2 = 0;
            while (extendLeft > 0 && lastValue[i2] == value[i2]) {
              i2++;
              extendLeft--;
            }
            inserted = inserted.slice(i2);
            i2 = 1;
            while (extendRight > 0 && lastValue.length - i2 > lastSelectionStart - 1 && lastValue[lastValue.length - i2] == value[value.length - i2]) {
              i2++;
              extendRight--;
            }
            restoreStart -= i2 - 1;
            restoreEnd -= i2 - 1;
            var endIndex = inserted.length - i2 + 1;
            if (endIndex < 0) {
              extendLeft = -endIndex;
              endIndex = 0;
            }
            inserted = inserted.slice(0, endIndex);
            if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
              return "";
            sendingText = true;
            var shouldReset = false;
            if (useragent.isAndroid && inserted == ". ") {
              inserted = "  ";
              shouldReset = true;
            }
            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {
              host.onTextInput(inserted);
            } else {
              host.onTextInput(inserted, {
                extendLeft,
                extendRight,
                restoreStart,
                restoreEnd
              });
            }
            sendingText = false;
            lastValue = value;
            lastSelectionStart = selectionStart;
            lastSelectionEnd = selectionEnd;
            lastRestoreEnd = restoreEnd;
            return shouldReset ? "\n" : inserted;
          }
        };
        var onInput = function(e2) {
          if (inComposition)
            return onCompositionUpdate();
          if (e2 && e2.inputType) {
            if (e2.inputType == "historyUndo")
              return host.execCommand("undo");
            if (e2.inputType == "historyRedo")
              return host.execCommand("redo");
          }
          var data = text.value;
          var inserted = sendText(data, true);
          if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted) || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd) {
            resetSelection();
          }
        };
        var handleClipboardData = function(e2, data, forceIEMime) {
          var clipboardData = e2.clipboardData || window.clipboardData;
          if (!clipboardData || BROKEN_SETDATA)
            return;
          var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
          try {
            if (data) {
              return clipboardData.setData(mime, data) !== false;
            } else {
              return clipboardData.getData(mime);
            }
          } catch (e3) {
            if (!forceIEMime)
              return handleClipboardData(e3, data, true);
          }
        };
        var doCopy = function(e2, isCut) {
          var data = host.getCopyText();
          if (!data)
            return event.preventDefault(e2);
          if (handleClipboardData(e2, data)) {
            if (isIOS2) {
              resetSelection(data);
              copied = data;
              setTimeout(function() {
                copied = false;
              }, 10);
            }
            isCut ? host.onCut() : host.onCopy();
            event.preventDefault(e2);
          } else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function() {
              copied = false;
              resetSelection();
              isCut ? host.onCut() : host.onCopy();
            });
          }
        };
        var onCut = function(e2) {
          doCopy(e2, true);
        };
        var onCopy = function(e2) {
          doCopy(e2, false);
        };
        var onPaste = function(e2) {
          var data = handleClipboardData(e2);
          if (clipboard.pasteCancelled())
            return;
          if (typeof data == "string") {
            if (data)
              host.onPaste(data, e2);
            if (useragent.isIE)
              setTimeout(resetSelection);
            event.preventDefault(e2);
          } else {
            text.value = "";
            pasted = true;
          }
        };
        event.addCommandKeyListener(text, host.onCommandKey.bind(host), host);
        event.addListener(text, "select", onSelect, host);
        event.addListener(text, "input", onInput, host);
        event.addListener(text, "cut", onCut, host);
        event.addListener(text, "copy", onCopy, host);
        event.addListener(text, "paste", onPaste, host);
        if (!("oncut" in text) || !("oncopy" in text) || !("onpaste" in text)) {
          event.addListener(parentNode, "keydown", function(e2) {
            if (useragent.isMac && !e2.metaKey || !e2.ctrlKey)
              return;
            switch (e2.keyCode) {
              case 67:
                onCopy(e2);
                break;
              case 86:
                onPaste(e2);
                break;
              case 88:
                onCut(e2);
                break;
            }
          }, host);
        }
        var onCompositionStart = function(e2) {
          if (inComposition || !host.onCompositionStart || host.$readOnly)
            return;
          inComposition = {};
          if (commandMode)
            return;
          if (e2.data)
            inComposition.useTextareaForIME = false;
          setTimeout(onCompositionUpdate, 0);
          host._signal("compositionStart");
          host.on("mousedown", cancelComposition);
          var range = host.getSelectionRange();
          range.end.row = range.start.row;
          range.end.column = range.start.column;
          inComposition.markerRange = range;
          inComposition.selectionStart = lastSelectionStart;
          host.onCompositionStart(inComposition);
          if (inComposition.useTextareaForIME) {
            lastValue = text.value = "";
            lastSelectionStart = 0;
            lastSelectionEnd = 0;
          } else {
            if (text.msGetInputContext)
              inComposition.context = text.msGetInputContext();
            if (text.getInputContext)
              inComposition.context = text.getInputContext();
          }
        };
        var onCompositionUpdate = function() {
          if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
            return;
          if (commandMode)
            return cancelComposition();
          if (inComposition.useTextareaForIME) {
            host.onCompositionUpdate(text.value);
          } else {
            var data = text.value;
            sendText(data);
            if (inComposition.markerRange) {
              if (inComposition.context) {
                inComposition.markerRange.start.column = inComposition.selectionStart = inComposition.context.compositionStartOffset;
              }
              inComposition.markerRange.end.column = inComposition.markerRange.start.column + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
            }
          }
        };
        var onCompositionEnd = function(e2) {
          if (!host.onCompositionEnd || host.$readOnly)
            return;
          inComposition = false;
          host.onCompositionEnd();
          host.off("mousedown", cancelComposition);
          if (e2)
            onInput();
        };
        function cancelComposition() {
          ignoreFocusEvents = true;
          text.blur();
          text.focus();
          ignoreFocusEvents = false;
        }
        var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
        function onKeyup(e2) {
          if (e2.keyCode == 27 && text.value.length < text.selectionStart) {
            if (!inComposition)
              lastValue = text.value;
            lastSelectionStart = lastSelectionEnd = -1;
            resetSelection();
          }
          syncComposition();
        }
        event.addListener(text, "compositionstart", onCompositionStart, host);
        event.addListener(text, "compositionupdate", onCompositionUpdate, host);
        event.addListener(text, "keyup", onKeyup, host);
        event.addListener(text, "keydown", syncComposition, host);
        event.addListener(text, "compositionend", onCompositionEnd, host);
        this.getElement = function() {
          return text;
        };
        this.setCommandMode = function(value) {
          commandMode = value;
          text.readOnly = false;
        };
        this.setReadOnly = function(readOnly) {
          if (!commandMode)
            text.readOnly = readOnly;
        };
        this.setCopyWithEmptySelection = function(value) {
        };
        this.onContextMenu = function(e2) {
          afterContextMenu = true;
          resetSelection();
          host._emit("nativecontextmenu", { target: host, domEvent: e2 });
          this.moveToMouse(e2, true);
        };
        this.moveToMouse = function(e2, bringToFront) {
          if (!tempStyle)
            tempStyle = text.style.cssText;
          text.style.cssText = (bringToFront ? "z-index:100000;" : "") + (useragent.isIE ? "opacity:0.1;" : "") + "text-indent: -" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + "px;";
          var rect = host.container.getBoundingClientRect();
          var style = dom.computedStyle(host.container);
          var top = rect.top + (parseInt(style.borderTopWidth) || 0);
          var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
          var maxTop = rect.bottom - top - text.clientHeight - 2;
          var move = function(e3) {
            dom.translate(text, e3.clientX - left - 2, Math.min(e3.clientY - top - 2, maxTop));
          };
          move(e2);
          if (e2.type != "mousedown")
            return;
          host.renderer.$isMousePressed = true;
          clearTimeout(closeTimeout);
          if (useragent.isWin)
            event.capture(host.container, move, onContextMenuClose);
        };
        this.onContextMenuClose = onContextMenuClose;
        var closeTimeout;
        function onContextMenuClose() {
          clearTimeout(closeTimeout);
          closeTimeout = setTimeout(function() {
            if (tempStyle) {
              text.style.cssText = tempStyle;
              tempStyle = "";
            }
            host.renderer.$isMousePressed = false;
            if (host.renderer.$keepTextAreaAtCursor)
              host.renderer.$moveTextAreaToCursor();
          }, 0);
        }
        var onContextMenu = function(e2) {
          host.textInput.onContextMenu(e2);
          onContextMenuClose();
        };
        event.addListener(text, "mouseup", onContextMenu, host);
        event.addListener(text, "mousedown", function(e2) {
          e2.preventDefault();
          onContextMenuClose();
        }, host);
        event.addListener(host.renderer.scroller, "contextmenu", onContextMenu, host);
        event.addListener(text, "contextmenu", onContextMenu, host);
        if (isIOS2)
          addIosSelectionHandler(parentNode, host, text);
        function addIosSelectionHandler(parentNode2, host2, text2) {
          var typingResetTimeout = null;
          var typing = false;
          text2.addEventListener("keydown", function(e2) {
            if (typingResetTimeout)
              clearTimeout(typingResetTimeout);
            typing = true;
          }, true);
          text2.addEventListener("keyup", function(e2) {
            typingResetTimeout = setTimeout(function() {
              typing = false;
            }, 100);
          }, true);
          var detectArrowKeys = function(e2) {
            if (document.activeElement !== text2)
              return;
            if (typing || inComposition || host2.$mouseHandler.isMousePressed)
              return;
            if (copied) {
              return;
            }
            var selectionStart = text2.selectionStart;
            var selectionEnd = text2.selectionEnd;
            var key = null;
            var modifier = 0;
            if (selectionStart == 0) {
              key = KEYS.up;
            } else if (selectionStart == 1) {
              key = KEYS.home;
            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == "\n") {
              key = KEYS.end;
            } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == " ") {
              key = KEYS.left;
              modifier = MODS.option;
            } else if (selectionStart < lastSelectionStart || selectionStart == lastSelectionStart && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
              key = KEYS.left;
            } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split("\n").length > 2) {
              key = KEYS.down;
            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == " ") {
              key = KEYS.right;
              modifier = MODS.option;
            } else if (selectionEnd > lastSelectionEnd || selectionEnd == lastSelectionEnd && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
              key = KEYS.right;
            }
            if (selectionStart !== selectionEnd)
              modifier |= MODS.shift;
            if (key) {
              var result = host2.onCommandKey({}, modifier, key);
              if (!result && host2.commands) {
                key = KEYS.keyCodeToString(key);
                var command = host2.commands.findKeyCommand(modifier, key);
                if (command)
                  host2.execCommand(command);
              }
              lastSelectionStart = selectionStart;
              lastSelectionEnd = selectionEnd;
              resetSelection("");
            }
          };
          document.addEventListener("selectionchange", detectArrowKeys);
          host2.on("destroy", function() {
            document.removeEventListener("selectionchange", detectArrowKeys);
          });
        }
        this.destroy = function() {
          if (text.parentElement)
            text.parentElement.removeChild(text);
        };
      };
      exports3.TextInput = TextInput;
      exports3.$setUserAgentForTests = function(_isMobile, _isIOS) {
        isMobile = _isMobile;
        isIOS2 = _isIOS;
      };
    });
    ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/useragent"], function(require2, exports3, module3) {
      var useragent = require2("../lib/useragent");
      var DRAG_OFFSET = 0;
      var SCROLL_COOLDOWN_T = 550;
      var DefaultHandlers = (
        /** @class */
        function() {
          function DefaultHandlers2(mouseHandler) {
            mouseHandler.$clickSelection = null;
            var editor = mouseHandler.editor;
            editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
            editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
            editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
            editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
            editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
            var exports4 = [
              "select",
              "startSelect",
              "selectEnd",
              "selectAllEnd",
              "selectByWordsEnd",
              "selectByLinesEnd",
              "dragWait",
              "dragWaitEnd",
              "focusWait"
            ];
            exports4.forEach(function(x2) {
              mouseHandler[x2] = this[x2];
            }, this);
            mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
            mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
          }
          DefaultHandlers2.prototype.onMouseDown = function(ev) {
            var inSelection = ev.inSelection();
            var pos = ev.getDocumentPosition();
            this.mousedownEvent = ev;
            var editor = this.editor;
            var button2 = ev.getButton();
            if (button2 !== 0) {
              var selectionRange = editor.getSelectionRange();
              var selectionEmpty = selectionRange.isEmpty();
              if (selectionEmpty || button2 == 1)
                editor.selection.moveToPosition(pos);
              if (button2 == 2) {
                editor.textInput.onContextMenu(ev.domEvent);
                if (!useragent.isMozilla)
                  ev.preventDefault();
              }
              return;
            }
            this.mousedownEvent.time = Date.now();
            if (inSelection && !editor.isFocused()) {
              editor.focus();
              if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {
                this.setState("focusWait");
                this.captureMouse(ev);
                return;
              }
            }
            this.captureMouse(ev);
            this.startSelect(pos, ev.domEvent._clicks > 1);
            return ev.preventDefault();
          };
          DefaultHandlers2.prototype.startSelect = function(pos, waitForClickSelection) {
            pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
            var editor = this.editor;
            if (!this.mousedownEvent)
              return;
            if (this.mousedownEvent.getShiftKey())
              editor.selection.selectToPosition(pos);
            else if (!waitForClickSelection)
              editor.selection.moveToPosition(pos);
            if (!waitForClickSelection)
              this.select();
            editor.setStyle("ace_selecting");
            this.setState("select");
          };
          DefaultHandlers2.prototype.select = function() {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            if (this.$clickSelection) {
              var cmp = this.$clickSelection.comparePoint(cursor);
              if (cmp == -1) {
                anchor = this.$clickSelection.end;
              } else if (cmp == 1) {
                anchor = this.$clickSelection.start;
              } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
              }
              editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
          };
          DefaultHandlers2.prototype.extendSelectionBy = function(unitName) {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            var range = editor.selection[unitName](cursor.row, cursor.column);
            if (this.$clickSelection) {
              var cmpStart = this.$clickSelection.comparePoint(range.start);
              var cmpEnd = this.$clickSelection.comparePoint(range.end);
              if (cmpStart == -1 && cmpEnd <= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                  cursor = range.start;
              } else if (cmpEnd == 1 && cmpStart >= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                  cursor = range.end;
              } else if (cmpStart == -1 && cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
              } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
              }
              editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
          };
          DefaultHandlers2.prototype.selectByLinesEnd = function() {
            this.$clickSelection = null;
            this.editor.unsetStyle("ace_selecting");
          };
          DefaultHandlers2.prototype.focusWait = function() {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            var time = Date.now();
            if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)
              this.startSelect(this.mousedownEvent.getDocumentPosition());
          };
          DefaultHandlers2.prototype.onDoubleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;
            var session = editor.session;
            var range = session.getBracketRange(pos);
            if (range) {
              if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
              }
              this.setState("select");
            } else {
              range = editor.selection.getWordRange(pos.row, pos.column);
              this.setState("selectByWords");
            }
            this.$clickSelection = range;
            this.select();
          };
          DefaultHandlers2.prototype.onTripleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;
            this.setState("selectByLines");
            var range = editor.getSelectionRange();
            if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
              this.$clickSelection = editor.selection.getLineRange(range.start.row);
              this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
            } else {
              this.$clickSelection = editor.selection.getLineRange(pos.row);
            }
            this.select();
          };
          DefaultHandlers2.prototype.onQuadClick = function(ev) {
            var editor = this.editor;
            editor.selectAll();
            this.$clickSelection = editor.getSelectionRange();
            this.setState("selectAll");
          };
          DefaultHandlers2.prototype.onMouseWheel = function(ev) {
            if (ev.getAccelKey())
              return;
            if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
              ev.wheelX = ev.wheelY;
              ev.wheelY = 0;
            }
            var editor = this.editor;
            if (!this.$lastScroll)
              this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
            var prevScroll = this.$lastScroll;
            var t2 = ev.domEvent.timeStamp;
            var dt = t2 - prevScroll.t;
            var vx = dt ? ev.wheelX / dt : prevScroll.vx;
            var vy = dt ? ev.wheelY / dt : prevScroll.vy;
            if (dt < SCROLL_COOLDOWN_T) {
              vx = (vx + prevScroll.vx) / 2;
              vy = (vy + prevScroll.vy) / 2;
            }
            var direction = Math.abs(vx / vy);
            var canScroll = false;
            if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
              canScroll = true;
            if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
              canScroll = true;
            if (canScroll) {
              prevScroll.allowed = t2;
            } else if (t2 - prevScroll.allowed < SCROLL_COOLDOWN_T) {
              var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx) && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
              if (isSlower) {
                canScroll = true;
                prevScroll.allowed = t2;
              } else {
                prevScroll.allowed = 0;
              }
            }
            prevScroll.t = t2;
            prevScroll.vx = vx;
            prevScroll.vy = vy;
            if (canScroll) {
              editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
              return ev.stop();
            }
          };
          return DefaultHandlers2;
        }()
      );
      DefaultHandlers.prototype.selectEnd = DefaultHandlers.prototype.selectByLinesEnd;
      DefaultHandlers.prototype.selectAllEnd = DefaultHandlers.prototype.selectByLinesEnd;
      DefaultHandlers.prototype.selectByWordsEnd = DefaultHandlers.prototype.selectByLinesEnd;
      exports3.DefaultHandlers = DefaultHandlers;
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      function calcRangeOrientation(range, cursor) {
        if (range.start.row == range.end.row)
          var cmp = 2 * cursor.column - range.start.column - range.end.column;
        else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
          var cmp = cursor.column - 4;
        else
          var cmp = 2 * cursor.row - range.start.row - range.end.row;
        if (cmp < 0)
          return { cursor: range.start, anchor: range.end };
        else
          return { cursor: range.end, anchor: range.start };
      }
    });
    ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/dom", "ace/range"], function(require2, exports3, module3) {
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d3, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d4[p] = b3[p];
          };
          return extendStatics(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var __values = this && this.__values || function(o) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o[s3], i2 = 0;
        if (m3) return m3.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i2 >= o.length) o = void 0;
            return { value: o && o[i2++], done: !o };
          }
        };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var dom = require2("./lib/dom");
      var Range = require2("./range").Range;
      var CLASSNAME = "ace_tooltip";
      var Tooltip2 = (
        /** @class */
        function() {
          function Tooltip3(parentNode) {
            this.isOpen = false;
            this.$element = null;
            this.$parentNode = parentNode;
          }
          Tooltip3.prototype.$init = function() {
            this.$element = dom.createElement("div");
            this.$element.className = CLASSNAME;
            this.$element.style.display = "none";
            this.$parentNode.appendChild(this.$element);
            return this.$element;
          };
          Tooltip3.prototype.getElement = function() {
            return this.$element || this.$init();
          };
          Tooltip3.prototype.setText = function(text) {
            this.getElement().textContent = text;
          };
          Tooltip3.prototype.setHtml = function(html3) {
            this.getElement().innerHTML = html3;
          };
          Tooltip3.prototype.setPosition = function(x2, y3) {
            this.getElement().style.left = x2 + "px";
            this.getElement().style.top = y3 + "px";
          };
          Tooltip3.prototype.setClassName = function(className) {
            dom.addCssClass(this.getElement(), className);
          };
          Tooltip3.prototype.setTheme = function(theme) {
            this.$element.className = CLASSNAME + " " + (theme.isDark ? "ace_dark " : "") + (theme.cssClass || "");
          };
          Tooltip3.prototype.show = function(text, x2, y3) {
            if (text != null)
              this.setText(text);
            if (x2 != null && y3 != null)
              this.setPosition(x2, y3);
            if (!this.isOpen) {
              this.getElement().style.display = "block";
              this.isOpen = true;
            }
          };
          Tooltip3.prototype.hide = function() {
            if (this.isOpen) {
              this.getElement().style.display = "none";
              this.getElement().className = CLASSNAME;
              this.isOpen = false;
            }
          };
          Tooltip3.prototype.getHeight = function() {
            return this.getElement().offsetHeight;
          };
          Tooltip3.prototype.getWidth = function() {
            return this.getElement().offsetWidth;
          };
          Tooltip3.prototype.destroy = function() {
            this.isOpen = false;
            if (this.$element && this.$element.parentNode) {
              this.$element.parentNode.removeChild(this.$element);
            }
          };
          return Tooltip3;
        }()
      );
      var PopupManager = (
        /** @class */
        function() {
          function PopupManager2() {
            this.popups = [];
          }
          PopupManager2.prototype.addPopup = function(popup) {
            this.popups.push(popup);
            this.updatePopups();
          };
          PopupManager2.prototype.removePopup = function(popup) {
            var index = this.popups.indexOf(popup);
            if (index !== -1) {
              this.popups.splice(index, 1);
              this.updatePopups();
            }
          };
          PopupManager2.prototype.updatePopups = function() {
            var e_1, _a2, e_2, _b2;
            this.popups.sort(function(a3, b2) {
              return b2.priority - a3.priority;
            });
            var visiblepopups = [];
            try {
              for (var _c2 = __values(this.popups), _d2 = _c2.next(); !_d2.done; _d2 = _c2.next()) {
                var popup = _d2.value;
                var shouldDisplay = true;
                try {
                  for (var visiblepopups_1 = (e_2 = void 0, __values(visiblepopups)), visiblepopups_1_1 = visiblepopups_1.next(); !visiblepopups_1_1.done; visiblepopups_1_1 = visiblepopups_1.next()) {
                    var visiblePopup = visiblepopups_1_1.value;
                    if (this.doPopupsOverlap(visiblePopup, popup)) {
                      shouldDisplay = false;
                      break;
                    }
                  }
                } catch (e_2_1) {
                  e_2 = { error: e_2_1 };
                } finally {
                  try {
                    if (visiblepopups_1_1 && !visiblepopups_1_1.done && (_b2 = visiblepopups_1.return)) _b2.call(visiblepopups_1);
                  } finally {
                    if (e_2) throw e_2.error;
                  }
                }
                if (shouldDisplay) {
                  visiblepopups.push(popup);
                } else {
                  popup.hide();
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_d2 && !_d2.done && (_a2 = _c2.return)) _a2.call(_c2);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          };
          PopupManager2.prototype.doPopupsOverlap = function(popupA, popupB) {
            var rectA = popupA.getElement().getBoundingClientRect();
            var rectB = popupB.getElement().getBoundingClientRect();
            return rectA.left < rectB.right && rectA.right > rectB.left && rectA.top < rectB.bottom && rectA.bottom > rectB.top;
          };
          return PopupManager2;
        }()
      );
      var popupManager = new PopupManager();
      exports3.popupManager = popupManager;
      exports3.Tooltip = Tooltip2;
      var HoverTooltip = (
        /** @class */
        function(_super) {
          __extends(HoverTooltip2, _super);
          function HoverTooltip2() {
            var _this = _super.call(this, document.body) || this;
            _this.timeout = void 0;
            _this.lastT = 0;
            _this.idleTime = 350;
            _this.lastEvent = void 0;
            _this.onMouseOut = _this.onMouseOut.bind(_this);
            _this.onMouseMove = _this.onMouseMove.bind(_this);
            _this.waitForHover = _this.waitForHover.bind(_this);
            _this.hide = _this.hide.bind(_this);
            var el = _this.getElement();
            el.style.whiteSpace = "pre-wrap";
            el.style.pointerEvents = "auto";
            el.addEventListener("mouseout", _this.onMouseOut);
            el.tabIndex = -1;
            el.addEventListener("blur", (function() {
              if (document.activeElement != el)
                this.hide();
            }).bind(_this));
            return _this;
          }
          HoverTooltip2.prototype.addToEditor = function(editor) {
            editor.on("mousemove", this.onMouseMove);
            editor.on("mousedown", this.hide);
            editor.renderer.getMouseEventTarget().addEventListener("mouseout", this.onMouseOut, true);
          };
          HoverTooltip2.prototype.removeFromEditor = function(editor) {
            editor.off("mousemove", this.onMouseMove);
            editor.off("mousedown", this.hide);
            editor.renderer.getMouseEventTarget().removeEventListener("mouseout", this.onMouseOut, true);
            if (this.timeout) {
              clearTimeout(this.timeout);
              this.timeout = null;
            }
          };
          HoverTooltip2.prototype.onMouseMove = function(e2, editor) {
            this.lastEvent = e2;
            this.lastT = Date.now();
            var isMousePressed = editor.$mouseHandler.isMousePressed;
            if (this.isOpen) {
              var pos = this.lastEvent && this.lastEvent.getDocumentPosition();
              if (!this.range || !this.range.contains(pos.row, pos.column) || isMousePressed || this.isOutsideOfText(this.lastEvent)) {
                this.hide();
              }
            }
            if (this.timeout || isMousePressed)
              return;
            this.lastEvent = e2;
            this.timeout = setTimeout(this.waitForHover, this.idleTime);
          };
          HoverTooltip2.prototype.waitForHover = function() {
            if (this.timeout)
              clearTimeout(this.timeout);
            var dt = Date.now() - this.lastT;
            if (this.idleTime - dt > 10) {
              this.timeout = setTimeout(this.waitForHover, this.idleTime - dt);
              return;
            }
            this.timeout = null;
            if (this.lastEvent && !this.isOutsideOfText(this.lastEvent)) {
              this.$gatherData(this.lastEvent, this.lastEvent.editor);
            }
          };
          HoverTooltip2.prototype.isOutsideOfText = function(e2) {
            var editor = e2.editor;
            var docPos = e2.getDocumentPosition();
            var line = editor.session.getLine(docPos.row);
            if (docPos.column == line.length) {
              var screenPos = editor.renderer.pixelToScreenCoordinates(e2.clientX, e2.clientY);
              var clippedPos = editor.session.documentToScreenPosition(docPos.row, docPos.column);
              if (clippedPos.column != screenPos.column || clippedPos.row != screenPos.row) {
                return true;
              }
            }
            return false;
          };
          HoverTooltip2.prototype.setDataProvider = function(value) {
            this.$gatherData = value;
          };
          HoverTooltip2.prototype.showForRange = function(editor, range, domNode, startingEvent) {
            if (startingEvent && startingEvent != this.lastEvent)
              return;
            if (this.isOpen && document.activeElement == this.getElement())
              return;
            var renderer = editor.renderer;
            if (!this.isOpen) {
              popupManager.addPopup(this);
              this.$registerCloseEvents();
              this.setTheme(renderer.theme);
            }
            this.isOpen = true;
            this.addMarker(range, editor.session);
            this.range = Range.fromPoints(range.start, range.end);
            var element = this.getElement();
            element.innerHTML = "";
            element.appendChild(domNode);
            element.style.display = "block";
            var position = renderer.textToScreenCoordinates(range.start.row, range.start.column);
            var cursorPos = editor.getCursorPosition();
            var labelHeight = element.clientHeight;
            var rect = renderer.scroller.getBoundingClientRect();
            var isTopdown = true;
            if (this.row > cursorPos.row) {
              isTopdown = true;
            } else if (this.row < cursorPos.row) {
              isTopdown = false;
            }
            if (position.pageY - labelHeight + renderer.lineHeight < rect.top) {
              isTopdown = true;
            } else if (position.pageY + labelHeight > rect.bottom) {
              isTopdown = false;
            }
            if (!isTopdown) {
              position.pageY -= labelHeight;
            } else {
              position.pageY += renderer.lineHeight;
            }
            element.style.maxWidth = rect.width - (position.pageX - rect.left) + "px";
            this.setPosition(position.pageX, position.pageY);
          };
          HoverTooltip2.prototype.addMarker = function(range, session) {
            if (this.marker) {
              this.$markerSession.removeMarker(this.marker);
            }
            this.$markerSession = session;
            this.marker = session && session.addMarker(range, "ace_highlight-marker", "text");
          };
          HoverTooltip2.prototype.hide = function(e2) {
            if (!e2 && document.activeElement == this.getElement())
              return;
            if (e2 && e2.target && e2.type != "keydown" && this.$element.contains(e2.target))
              return;
            this.lastEvent = null;
            if (this.timeout)
              clearTimeout(this.timeout);
            this.timeout = null;
            this.addMarker(null);
            if (this.isOpen) {
              this.$removeCloseEvents();
              this.getElement().style.display = "none";
              this.isOpen = false;
              popupManager.removePopup(this);
            }
          };
          HoverTooltip2.prototype.$registerCloseEvents = function() {
            window.addEventListener("keydown", this.hide, true);
            window.addEventListener("mousewheel", this.hide, true);
            window.addEventListener("mousedown", this.hide, true);
          };
          HoverTooltip2.prototype.$removeCloseEvents = function() {
            window.removeEventListener("keydown", this.hide, true);
            window.removeEventListener("mousewheel", this.hide, true);
            window.removeEventListener("mousedown", this.hide, true);
          };
          HoverTooltip2.prototype.onMouseOut = function(e2) {
            if (this.timeout) {
              clearTimeout(this.timeout);
              this.timeout = null;
            }
            this.lastEvent = null;
            if (!this.isOpen)
              return;
            if (!e2.relatedTarget || e2.relatedTarget == this.getElement())
              return;
            if (e2 && e2.currentTarget.contains(e2.relatedTarget))
              return;
            if (!e2.relatedTarget.classList.contains("ace_content"))
              this.hide();
          };
          return HoverTooltip2;
        }(Tooltip2)
      );
      exports3.HoverTooltip = HoverTooltip;
    });
    ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/tooltip"], function(require2, exports3, module3) {
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d3, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d4[p] = b3[p];
          };
          return extendStatics(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var __values = this && this.__values || function(o) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o[s3], i2 = 0;
        if (m3) return m3.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i2 >= o.length) o = void 0;
            return { value: o && o[i2++], done: !o };
          }
        };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var dom = require2("../lib/dom");
      var event = require2("../lib/event");
      var Tooltip2 = require2("../tooltip").Tooltip;
      function GutterHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var gutter = editor.renderer.$gutterLayer;
        var tooltip = new GutterTooltip(editor.container);
        mouseHandler.editor.setDefaultHandler("guttermousedown", function(e2) {
          if (!editor.isFocused() || e2.getButton() != 0)
            return;
          var gutterRegion = gutter.getRegion(e2);
          if (gutterRegion == "foldWidgets")
            return;
          var row = e2.getDocumentPosition().row;
          var selection = editor.session.selection;
          if (e2.getShiftKey())
            selection.selectTo(row, 0);
          else {
            if (e2.domEvent.detail == 2) {
              editor.selectAll();
              return e2.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
          }
          mouseHandler.setState("selectByLines");
          mouseHandler.captureMouse(e2);
          return e2.preventDefault();
        });
        var tooltipTimeout, mouseEvent, tooltipContent;
        var annotationLabels = {
          error: { singular: "error", plural: "errors" },
          warning: { singular: "warning", plural: "warnings" },
          info: { singular: "information message", plural: "information messages" }
        };
        function showTooltip() {
          var row = mouseEvent.getDocumentPosition().row;
          var annotationsInRow = gutter.$annotations[row];
          var annotation;
          if (annotationsInRow)
            annotation = { text: Array.from(annotationsInRow.text), type: Array.from(annotationsInRow.type) };
          else
            annotation = { text: [], type: [] };
          var fold = gutter.session.getFoldLine(row);
          if (fold && gutter.$showFoldedAnnotations) {
            var annotationsInFold = { error: [], warning: [], info: [] };
            var mostSevereAnnotationInFoldType;
            for (var i2 = row + 1; i2 <= fold.end.row; i2++) {
              if (!gutter.$annotations[i2])
                continue;
              for (var j = 0; j < gutter.$annotations[i2].text.length; j++) {
                var annotationType = gutter.$annotations[i2].type[j];
                annotationsInFold[annotationType].push(gutter.$annotations[i2].text[j]);
                if (annotationType === "error") {
                  mostSevereAnnotationInFoldType = "error_fold";
                  continue;
                }
                if (annotationType === "warning") {
                  mostSevereAnnotationInFoldType = "warning_fold";
                  continue;
                }
              }
            }
            if (mostSevereAnnotationInFoldType === "error_fold" || mostSevereAnnotationInFoldType === "warning_fold") {
              var summaryFoldedAnnotations = "".concat(annotationsToSummaryString(annotationsInFold), " in folded code.");
              annotation.text.push(summaryFoldedAnnotations);
              annotation.type.push(mostSevereAnnotationInFoldType);
            }
          }
          if (annotation.text.length === 0)
            return hideTooltip();
          var maxRow = editor.session.getLength();
          if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
              return hideTooltip();
          }
          var annotationMessages = { error: [], warning: [], info: [] };
          var iconClassName = gutter.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
          for (var i2 = 0; i2 < annotation.text.length; i2++) {
            var line = "<span class='ace_".concat(annotation.type[i2], " ").concat(iconClassName, "' aria-label='").concat(annotationLabels[annotation.type[i2].replace("_fold", "")].singular, "' role=img> </span> ").concat(annotation.text[i2]);
            annotationMessages[annotation.type[i2].replace("_fold", "")].push(line);
          }
          tooltipContent = [].concat(annotationMessages.error, annotationMessages.warning, annotationMessages.info).join("<br>");
          tooltip.setHtml(tooltipContent);
          tooltip.setClassName("ace_gutter-tooltip");
          tooltip.$element.setAttribute("aria-live", "polite");
          if (!tooltip.isOpen) {
            tooltip.setTheme(editor.renderer.theme);
          }
          tooltip.show();
          editor._signal("showGutterTooltip", tooltip);
          editor.on("mousewheel", hideTooltip);
          if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
          } else {
            var gutterElement = gutter.$lines.cells[row].element.querySelector("[class*=ace_icon]");
            var rect = gutterElement.getBoundingClientRect();
            var style = tooltip.getElement().style;
            style.left = rect.right + "px";
            style.top = rect.bottom + "px";
          }
        }
        function hideTooltip() {
          if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
          if (tooltipContent) {
            tooltip.hide();
            tooltipContent = null;
            editor._signal("hideGutterTooltip", tooltip);
            editor.off("mousewheel", hideTooltip);
          }
        }
        function annotationsToSummaryString(annotations) {
          var e_1, _a2;
          var summary = [];
          var annotationTypes = ["error", "warning", "info"];
          try {
            for (var annotationTypes_1 = __values(annotationTypes), annotationTypes_1_1 = annotationTypes_1.next(); !annotationTypes_1_1.done; annotationTypes_1_1 = annotationTypes_1.next()) {
              var annotationType = annotationTypes_1_1.value;
              if (!annotations[annotationType].length)
                continue;
              var label = annotations[annotationType].length === 1 ? annotationLabels[annotationType].singular : annotationLabels[annotationType].plural;
              summary.push("".concat(annotations[annotationType].length, " ").concat(label));
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (annotationTypes_1_1 && !annotationTypes_1_1.done && (_a2 = annotationTypes_1.return)) _a2.call(annotationTypes_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return summary.join(", ");
        }
        function moveTooltip(e2) {
          tooltip.setPosition(e2.x, e2.y);
        }
        mouseHandler.editor.setDefaultHandler("guttermousemove", function(e2) {
          var target = e2.domEvent.target || e2.domEvent.srcElement;
          if (dom.hasCssClass(target, "ace_fold-widget"))
            return hideTooltip();
          if (tooltipContent && mouseHandler.$tooltipFollowsMouse)
            moveTooltip(e2);
          mouseEvent = e2;
          if (tooltipTimeout)
            return;
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
              showTooltip();
            else
              hideTooltip();
          }, 50);
        });
        event.addListener(editor.renderer.$gutter, "mouseout", function(e2) {
          mouseEvent = null;
          if (!tooltipContent || tooltipTimeout)
            return;
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            hideTooltip();
          }, 50);
        }, editor);
        editor.on("changeSession", hideTooltip);
      }
      var GutterTooltip = (
        /** @class */
        function(_super) {
          __extends(GutterTooltip2, _super);
          function GutterTooltip2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          GutterTooltip2.prototype.setPosition = function(x2, y3) {
            var windowWidth = window.innerWidth || document.documentElement.clientWidth;
            var windowHeight = window.innerHeight || document.documentElement.clientHeight;
            var width = this.getWidth();
            var height = this.getHeight();
            x2 += 15;
            y3 += 15;
            if (x2 + width > windowWidth) {
              x2 -= x2 + width - windowWidth;
            }
            if (y3 + height > windowHeight) {
              y3 -= 20 + height;
            }
            Tooltip2.prototype.setPosition.call(this, x2, y3);
          };
          return GutterTooltip2;
        }(Tooltip2)
      );
      exports3.GutterHandler = GutterHandler;
    });
    ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require2, exports3, module3) {
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var MouseEvent2 = (
        /** @class */
        function() {
          function MouseEvent3(domEvent, editor) {
            this.domEvent = domEvent;
            this.editor = editor;
            this.x = this.clientX = domEvent.clientX;
            this.y = this.clientY = domEvent.clientY;
            this.$pos = null;
            this.$inSelection = null;
            this.propagationStopped = false;
            this.defaultPrevented = false;
            this.getAccelKey = useragent.isMac ? function() {
              return this.domEvent.metaKey;
            } : function() {
              return this.domEvent.ctrlKey;
            };
          }
          MouseEvent3.prototype.stopPropagation = function() {
            event.stopPropagation(this.domEvent);
            this.propagationStopped = true;
          };
          MouseEvent3.prototype.preventDefault = function() {
            event.preventDefault(this.domEvent);
            this.defaultPrevented = true;
          };
          MouseEvent3.prototype.stop = function() {
            this.stopPropagation();
            this.preventDefault();
          };
          MouseEvent3.prototype.getDocumentPosition = function() {
            if (this.$pos)
              return this.$pos;
            this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
            return this.$pos;
          };
          MouseEvent3.prototype.inSelection = function() {
            if (this.$inSelection !== null)
              return this.$inSelection;
            var editor = this.editor;
            var selectionRange = editor.getSelectionRange();
            if (selectionRange.isEmpty())
              this.$inSelection = false;
            else {
              var pos = this.getDocumentPosition();
              this.$inSelection = selectionRange.contains(pos.row, pos.column);
            }
            return this.$inSelection;
          };
          MouseEvent3.prototype.getButton = function() {
            return event.getButton(this.domEvent);
          };
          MouseEvent3.prototype.getShiftKey = function() {
            return this.domEvent.shiftKey;
          };
          return MouseEvent3;
        }()
      );
      exports3.MouseEvent = MouseEvent2;
    });
    ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function(require2, exports3, module3) {
      var dom = require2("../lib/dom");
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var AUTOSCROLL_DELAY = 200;
      var SCROLL_CURSOR_DELAY = 200;
      var SCROLL_CURSOR_HYSTERESIS = 5;
      function DragdropHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var dragImage = dom.createElement("div");
        dragImage.style.cssText = "top:-100px;position:absolute;z-index:2147483647;opacity:0.5";
        dragImage.textContent = " ";
        var exports4 = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
        exports4.forEach(function(x3) {
          mouseHandler[x3] = this[x3];
        }, this);
        editor.on("mousedown", this.onMouseDown.bind(mouseHandler));
        var mouseTarget = editor.container;
        var dragSelectionMarker, x2, y3;
        var timerId, range;
        var dragCursor, counter = 0;
        var dragOperation;
        var isInternal;
        var autoScrollStartTime;
        var cursorMovedTime;
        var cursorPointOnCaretMoved;
        this.onDragStart = function(e2) {
          if (this.cancelDrag || !mouseTarget.draggable) {
            var self2 = this;
            setTimeout(function() {
              self2.startSelect();
              self2.captureMouse(e2);
            }, 0);
            return e2.preventDefault();
          }
          range = editor.getSelectionRange();
          var dataTransfer = e2.dataTransfer;
          dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
          editor.container.appendChild(dragImage);
          dataTransfer.setDragImage && dataTransfer.setDragImage(dragImage, 0, 0);
          setTimeout(function() {
            editor.container.removeChild(dragImage);
          });
          dataTransfer.clearData();
          dataTransfer.setData("Text", editor.session.getTextRange());
          isInternal = true;
          this.setState("drag");
        };
        this.onDragEnd = function(e2) {
          mouseTarget.draggable = false;
          isInternal = false;
          this.setState(null);
          if (!editor.getReadOnly()) {
            var dropEffect = e2.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
              editor.session.remove(editor.getSelectionRange());
            editor.$resetCursorStyle();
          }
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
        };
        this.onDragEnter = function(e2) {
          if (editor.getReadOnly() || !canAccept(e2.dataTransfer))
            return;
          x2 = e2.clientX;
          y3 = e2.clientY;
          if (!dragSelectionMarker)
            addDragMarker();
          counter++;
          e2.dataTransfer.dropEffect = dragOperation = getDropEffect(e2);
          return event.preventDefault(e2);
        };
        this.onDragOver = function(e2) {
          if (editor.getReadOnly() || !canAccept(e2.dataTransfer))
            return;
          x2 = e2.clientX;
          y3 = e2.clientY;
          if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
          }
          if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;
          e2.dataTransfer.dropEffect = dragOperation = getDropEffect(e2);
          return event.preventDefault(e2);
        };
        this.onDragLeave = function(e2) {
          counter--;
          if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e2);
          }
        };
        this.onDrop = function(e2) {
          if (!dragCursor)
            return;
          var dataTransfer = e2.dataTransfer;
          if (isInternal) {
            switch (dragOperation) {
              case "move":
                if (range.contains(dragCursor.row, dragCursor.column)) {
                  range = {
                    start: dragCursor,
                    end: dragCursor
                  };
                } else {
                  range = editor.moveText(range, dragCursor);
                }
                break;
              case "copy":
                range = editor.moveText(range, dragCursor, true);
                break;
            }
          } else {
            var dropData = dataTransfer.getData("Text");
            range = {
              start: dragCursor,
              end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
          }
          clearDragMarker();
          return event.preventDefault(e2);
        };
        event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler), editor);
        function scrollCursorIntoView(cursor, prevCursor) {
          var now = Date.now();
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          var hMovement = !prevCursor || cursor.column != prevCursor.column;
          if (!cursorMovedTime || vMovement || hMovement) {
            editor.moveCursorToPosition(cursor);
            cursorMovedTime = now;
            cursorPointOnCaretMoved = { x: x2, y: y3 };
          } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x2, y3);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
              cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
              editor.renderer.scrollCursorIntoView();
              cursorMovedTime = null;
            }
          }
        }
        function autoScroll(cursor, prevCursor) {
          var now = Date.now();
          var lineHeight = editor.renderer.layerConfig.lineHeight;
          var characterWidth = editor.renderer.layerConfig.characterWidth;
          var editorRect = editor.renderer.scroller.getBoundingClientRect();
          var offsets = {
            x: {
              left: x2 - editorRect.left,
              right: editorRect.right - x2
            },
            y: {
              top: y3 - editorRect.top,
              bottom: editorRect.bottom - y3
            }
          };
          var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
          var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
          var scrollCursor = { row: cursor.row, column: cursor.column };
          if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += offsets.x.left < offsets.x.right ? -3 : 2;
          }
          if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += offsets.y.top < offsets.y.bottom ? -1 : 1;
          }
          var vScroll = cursor.row != scrollCursor.row;
          var hScroll = cursor.column != scrollCursor.column;
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          if (vScroll || hScroll && !vMovement) {
            if (!autoScrollStartTime)
              autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
              editor.renderer.scrollCursorIntoView(scrollCursor);
          } else {
            autoScrollStartTime = null;
          }
        }
        function onDragInterval() {
          var prevCursor = dragCursor;
          dragCursor = editor.renderer.screenToTextCoordinates(x2, y3);
          scrollCursorIntoView(dragCursor, prevCursor);
          autoScroll(dragCursor, prevCursor);
        }
        function addDragMarker() {
          range = editor.selection.toOrientedRange();
          dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
          editor.clearSelection();
          if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
          clearInterval(timerId);
          onDragInterval();
          timerId = setInterval(onDragInterval, 20);
          counter = 0;
          event.addListener(document, "mousemove", onMouseMove);
        }
        function clearDragMarker() {
          clearInterval(timerId);
          editor.session.removeMarker(dragSelectionMarker);
          dragSelectionMarker = null;
          editor.selection.fromOrientedRange(range);
          if (editor.isFocused() && !isInternal)
            editor.$resetCursorStyle();
          range = null;
          dragCursor = null;
          counter = 0;
          autoScrollStartTime = null;
          cursorMovedTime = null;
          event.removeListener(document, "mousemove", onMouseMove);
        }
        var onMouseMoveTimer = null;
        function onMouseMove() {
          if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function() {
              if (onMouseMoveTimer != null && dragSelectionMarker)
                clearDragMarker();
            }, 20);
          }
        }
        function canAccept(dataTransfer) {
          var types = dataTransfer.types;
          return !types || Array.prototype.some.call(types, function(type) {
            return type == "text/plain" || type == "Text";
          });
        }
        function getDropEffect(e2) {
          var copyAllowed = ["copy", "copymove", "all", "uninitialized"];
          var moveAllowed = ["move", "copymove", "linkmove", "all", "uninitialized"];
          var copyModifierState = useragent.isMac ? e2.altKey : e2.ctrlKey;
          var effectAllowed = "uninitialized";
          try {
            effectAllowed = e2.dataTransfer.effectAllowed.toLowerCase();
          } catch (e3) {
          }
          var dropEffect = "none";
          if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
          else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
          else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
          return dropEffect;
        }
      }
      (function() {
        this.dragWait = function() {
          var interval = Date.now() - this.mousedownEvent.time;
          if (interval > this.editor.getDragDelay())
            this.startDrag();
        };
        this.dragWaitEnd = function() {
          var target = this.editor.container;
          target.draggable = false;
          this.startSelect(this.mousedownEvent.getDocumentPosition());
          this.selectEnd();
        };
        this.dragReadyEnd = function(e2) {
          this.editor.$resetCursorStyle();
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
          this.dragWaitEnd();
        };
        this.startDrag = function() {
          this.cancelDrag = false;
          var editor = this.editor;
          var target = editor.container;
          target.draggable = true;
          editor.renderer.$cursorLayer.setBlinking(false);
          editor.setStyle("ace_dragging");
          var cursorStyle = useragent.isWin ? "default" : "move";
          editor.renderer.setCursorStyle(cursorStyle);
          this.setState("dragReady");
        };
        this.onMouseDrag = function(e2) {
          var target = this.editor.container;
          if (useragent.isIE && this.state == "dragReady") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
              target.dragDrop();
          }
          if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
              target.draggable = false;
              this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
          }
        };
        this.onMouseDown = function(e2) {
          if (!this.$dragEnabled)
            return;
          this.mousedownEvent = e2;
          var editor = this.editor;
          var inSelection = e2.inSelection();
          var button2 = e2.getButton();
          var clickCount = e2.domEvent.detail || 1;
          if (clickCount === 1 && button2 === 0 && inSelection) {
            if (e2.editor.inMultiSelectMode && (e2.getAccelKey() || e2.getShiftKey()))
              return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e2.domEvent.target || e2.domEvent.srcElement;
            if ("unselectable" in eventTarget)
              eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
              if (useragent.isWebKit) {
                this.cancelDrag = true;
                var mouseTarget = editor.container;
                mouseTarget.draggable = true;
              }
              this.setState("dragWait");
            } else {
              this.startDrag();
            }
            this.captureMouse(e2, this.onMouseDrag.bind(this));
            e2.defaultPrevented = true;
          }
        };
      }).call(DragdropHandler.prototype);
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      exports3.DragdropHandler = DragdropHandler;
    });
    ace.define("ace/mouse/touch_handler", ["require", "exports", "module", "ace/mouse/mouse_event", "ace/lib/event", "ace/lib/dom"], function(require2, exports3, module3) {
      var MouseEvent2 = require2("./mouse_event").MouseEvent;
      var event = require2("../lib/event");
      var dom = require2("../lib/dom");
      exports3.addTouchListeners = function(el, editor) {
        var mode = "scroll";
        var startX;
        var startY;
        var touchStartT;
        var lastT;
        var longTouchTimer;
        var animationTimer;
        var animationSteps = 0;
        var pos;
        var clickCount = 0;
        var vX = 0;
        var vY = 0;
        var pressed;
        var contextMenu;
        function createContextMenu() {
          var clipboard = window.navigator && window.navigator.clipboard;
          var isOpen = false;
          var updateMenu = function() {
            var selected = editor.getCopyText();
            var hasUndo = editor.session.getUndoManager().hasUndo();
            contextMenu.replaceChild(dom.buildDom(isOpen ? [
              "span",
              !selected && ["span", { class: "ace_mobile-button", action: "selectall" }, "Select All"],
              selected && ["span", { class: "ace_mobile-button", action: "copy" }, "Copy"],
              selected && ["span", { class: "ace_mobile-button", action: "cut" }, "Cut"],
              clipboard && ["span", { class: "ace_mobile-button", action: "paste" }, "Paste"],
              hasUndo && ["span", { class: "ace_mobile-button", action: "undo" }, "Undo"],
              ["span", { class: "ace_mobile-button", action: "find" }, "Find"],
              ["span", { class: "ace_mobile-button", action: "openCommandPallete" }, "Palette"]
            ] : ["span"]), contextMenu.firstChild);
          };
          var handleClick = function(e2) {
            var action = e2.target.getAttribute("action");
            if (action == "more" || !isOpen) {
              isOpen = !isOpen;
              return updateMenu();
            }
            if (action == "paste") {
              clipboard.readText().then(function(text) {
                editor.execCommand(action, text);
              });
            } else if (action) {
              if (action == "cut" || action == "copy") {
                if (clipboard)
                  clipboard.writeText(editor.getCopyText());
                else
                  document.execCommand("copy");
              }
              editor.execCommand(action);
            }
            contextMenu.firstChild.style.display = "none";
            isOpen = false;
            if (action != "openCommandPallete")
              editor.focus();
          };
          contextMenu = dom.buildDom([
            "div",
            {
              class: "ace_mobile-menu",
              ontouchstart: function(e2) {
                mode = "menu";
                e2.stopPropagation();
                e2.preventDefault();
                editor.textInput.focus();
              },
              ontouchend: function(e2) {
                e2.stopPropagation();
                e2.preventDefault();
                handleClick(e2);
              },
              onclick: handleClick
            },
            ["span"],
            ["span", { class: "ace_mobile-button", action: "more" }, "..."]
          ], editor.container);
        }
        function showContextMenu() {
          if (!contextMenu)
            createContextMenu();
          var cursor = editor.selection.cursor;
          var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);
          var leftOffset = editor.renderer.textToScreenCoordinates(0, 0).pageX;
          var scrollLeft = editor.renderer.scrollLeft;
          var rect = editor.container.getBoundingClientRect();
          contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
          if (pagePos.pageX - rect.left < rect.width - 70) {
            contextMenu.style.left = "";
            contextMenu.style.right = "10px";
          } else {
            contextMenu.style.right = "";
            contextMenu.style.left = leftOffset + scrollLeft - rect.left + "px";
          }
          contextMenu.style.display = "";
          contextMenu.firstChild.style.display = "none";
          editor.on("input", hideContextMenu);
        }
        function hideContextMenu(e2) {
          if (contextMenu)
            contextMenu.style.display = "none";
          editor.off("input", hideContextMenu);
        }
        function handleLongTap() {
          longTouchTimer = null;
          clearTimeout(longTouchTimer);
          var range = editor.selection.getRange();
          var inSelection = range.contains(pos.row, pos.column);
          if (range.isEmpty() || !inSelection) {
            editor.selection.moveToPosition(pos);
            editor.selection.selectWord();
          }
          mode = "wait";
          showContextMenu();
        }
        function switchToSelectionMode() {
          longTouchTimer = null;
          clearTimeout(longTouchTimer);
          editor.selection.moveToPosition(pos);
          var range = clickCount >= 2 ? editor.selection.getLineRange(pos.row) : editor.session.getBracketRange(pos);
          if (range && !range.isEmpty()) {
            editor.selection.setRange(range);
          } else {
            editor.selection.selectWord();
          }
          mode = "wait";
        }
        event.addListener(el, "contextmenu", function(e2) {
          if (!pressed)
            return;
          var textarea = editor.textInput.getElement();
          textarea.focus();
        }, editor);
        event.addListener(el, "touchstart", function(e2) {
          var touches = e2.touches;
          if (longTouchTimer || touches.length > 1) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
            touchStartT = -1;
            mode = "zoom";
            return;
          }
          pressed = editor.$mouseHandler.isMousePressed = true;
          var h3 = editor.renderer.layerConfig.lineHeight;
          var w2 = editor.renderer.layerConfig.lineHeight;
          var t2 = e2.timeStamp;
          lastT = t2;
          var touchObj = touches[0];
          var x2 = touchObj.clientX;
          var y3 = touchObj.clientY;
          if (Math.abs(startX - x2) + Math.abs(startY - y3) > h3)
            touchStartT = -1;
          startX = e2.clientX = x2;
          startY = e2.clientY = y3;
          vX = vY = 0;
          var ev = new MouseEvent2(e2, editor);
          pos = ev.getDocumentPosition();
          if (t2 - touchStartT < 500 && touches.length == 1 && !animationSteps) {
            clickCount++;
            e2.preventDefault();
            e2.button = 0;
            switchToSelectionMode();
          } else {
            clickCount = 0;
            var cursor = editor.selection.cursor;
            var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;
            var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);
            var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);
            var rect = editor.renderer.scroller.getBoundingClientRect();
            var offsetTop = editor.renderer.layerConfig.offset;
            var offsetLeft = editor.renderer.scrollLeft;
            var weightedDistance = function(x3, y4) {
              x3 = x3 / w2;
              y4 = y4 / h3 - 0.75;
              return x3 * x3 + y4 * y4;
            };
            if (e2.clientX < rect.left) {
              mode = "zoom";
              return;
            }
            var diff1 = weightedDistance(e2.clientX - rect.left - cursorPos.left + offsetLeft, e2.clientY - rect.top - cursorPos.top + offsetTop);
            var diff2 = weightedDistance(e2.clientX - rect.left - anchorPos.left + offsetLeft, e2.clientY - rect.top - anchorPos.top + offsetTop);
            if (diff1 < 3.5 && diff2 < 3.5)
              mode = diff1 > diff2 ? "cursor" : "anchor";
            if (diff2 < 3.5)
              mode = "anchor";
            else if (diff1 < 3.5)
              mode = "cursor";
            else
              mode = "scroll";
            longTouchTimer = setTimeout(handleLongTap, 450);
          }
          touchStartT = t2;
        }, editor);
        event.addListener(el, "touchend", function(e2) {
          pressed = editor.$mouseHandler.isMousePressed = false;
          if (animationTimer)
            clearInterval(animationTimer);
          if (mode == "zoom") {
            mode = "";
            animationSteps = 0;
          } else if (longTouchTimer) {
            editor.selection.moveToPosition(pos);
            animationSteps = 0;
            showContextMenu();
          } else if (mode == "scroll") {
            animate();
            hideContextMenu();
          } else {
            showContextMenu();
          }
          clearTimeout(longTouchTimer);
          longTouchTimer = null;
        }, editor);
        event.addListener(el, "touchmove", function(e2) {
          if (longTouchTimer) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
          }
          var touches = e2.touches;
          if (touches.length > 1 || mode == "zoom")
            return;
          var touchObj = touches[0];
          var wheelX = startX - touchObj.clientX;
          var wheelY = startY - touchObj.clientY;
          if (mode == "wait") {
            if (wheelX * wheelX + wheelY * wheelY > 4)
              mode = "cursor";
            else
              return e2.preventDefault();
          }
          startX = touchObj.clientX;
          startY = touchObj.clientY;
          e2.clientX = touchObj.clientX;
          e2.clientY = touchObj.clientY;
          var t2 = e2.timeStamp;
          var dt = t2 - lastT;
          lastT = t2;
          if (mode == "scroll") {
            var mouseEvent = new MouseEvent2(e2, editor);
            mouseEvent.speed = 1;
            mouseEvent.wheelX = wheelX;
            mouseEvent.wheelY = wheelY;
            if (10 * Math.abs(wheelX) < Math.abs(wheelY))
              wheelX = 0;
            if (10 * Math.abs(wheelY) < Math.abs(wheelX))
              wheelY = 0;
            if (dt != 0) {
              vX = wheelX / dt;
              vY = wheelY / dt;
            }
            editor._emit("mousewheel", mouseEvent);
            if (!mouseEvent.propagationStopped) {
              vX = vY = 0;
            }
          } else {
            var ev = new MouseEvent2(e2, editor);
            var pos2 = ev.getDocumentPosition();
            if (mode == "cursor")
              editor.selection.moveCursorToPosition(pos2);
            else if (mode == "anchor")
              editor.selection.setSelectionAnchor(pos2.row, pos2.column);
            editor.renderer.scrollCursorIntoView(pos2);
            e2.preventDefault();
          }
        }, editor);
        function animate() {
          animationSteps += 60;
          animationTimer = setInterval(function() {
            if (animationSteps-- <= 0) {
              clearInterval(animationTimer);
              animationTimer = null;
            }
            if (Math.abs(vX) < 0.01)
              vX = 0;
            if (Math.abs(vY) < 0.01)
              vY = 0;
            if (animationSteps < 20)
              vX = 0.9 * vX;
            if (animationSteps < 20)
              vY = 0.9 * vY;
            var oldScrollTop = editor.session.getScrollTop();
            editor.renderer.scrollBy(10 * vX, 10 * vY);
            if (oldScrollTop == editor.session.getScrollTop())
              animationSteps = 0;
          }, 10);
        }
      };
    });
    ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/mouse/touch_handler", "ace/config"], function(require2, exports3, module3) {
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var DefaultHandlers = require2("./default_handlers").DefaultHandlers;
      var DefaultGutterHandler = require2("./default_gutter_handler").GutterHandler;
      var MouseEvent2 = require2("./mouse_event").MouseEvent;
      var DragdropHandler = require2("./dragdrop_handler").DragdropHandler;
      var addTouchListeners = require2("./touch_handler").addTouchListeners;
      var config = require2("../config");
      var MouseHandler = (
        /** @class */
        function() {
          function MouseHandler2(editor) {
            var _self = this;
            this.editor = editor;
            new DefaultHandlers(this);
            new DefaultGutterHandler(this);
            new DragdropHandler(this);
            var focusEditor = function(e2) {
              var windowBlurred = !document.hasFocus || !document.hasFocus() || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
              if (windowBlurred)
                window.focus();
              editor.focus();
              setTimeout(function() {
                if (!editor.isFocused())
                  editor.focus();
              });
            };
            var mouseTarget = editor.renderer.getMouseEventTarget();
            event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"), editor);
            event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"), editor);
            event.addMultiMouseDownListener([
              mouseTarget,
              editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
              editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
              editor.textInput && editor.textInput.getElement()
            ].filter(Boolean), [400, 300, 250], this, "onMouseEvent", editor);
            event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"), editor);
            addTouchListeners(editor.container, editor);
            var gutterEl = editor.renderer.$gutter;
            event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), editor);
            event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"), editor);
            event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), editor);
            event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), editor);
            event.addListener(mouseTarget, "mousedown", focusEditor, editor);
            event.addListener(gutterEl, "mousedown", focusEditor, editor);
            if (useragent.isIE && editor.renderer.scrollBarV) {
              event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor, editor);
              event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor, editor);
            }
            editor.on("mousemove", function(e2) {
              if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
                return;
              var character = editor.renderer.screenToTextCoordinates(e2.x, e2.y);
              var range = editor.session.selection.getRange();
              var renderer = editor.renderer;
              if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
                renderer.setCursorStyle("default");
              } else {
                renderer.setCursorStyle("");
              }
            }, editor);
          }
          MouseHandler2.prototype.onMouseEvent = function(name, e2) {
            if (!this.editor.session)
              return;
            this.editor._emit(name, new MouseEvent2(e2, this.editor));
          };
          MouseHandler2.prototype.onMouseMove = function(name, e2) {
            var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
            if (!listeners || !listeners.length)
              return;
            this.editor._emit(name, new MouseEvent2(e2, this.editor));
          };
          MouseHandler2.prototype.onMouseWheel = function(name, e2) {
            var mouseEvent = new MouseEvent2(e2, this.editor);
            mouseEvent.speed = this.$scrollSpeed * 2;
            mouseEvent.wheelX = e2.wheelX;
            mouseEvent.wheelY = e2.wheelY;
            this.editor._emit(name, mouseEvent);
          };
          MouseHandler2.prototype.setState = function(state) {
            this.state = state;
          };
          MouseHandler2.prototype.captureMouse = function(ev, mouseMoveHandler) {
            this.x = ev.x;
            this.y = ev.y;
            this.isMousePressed = true;
            var editor = this.editor;
            var renderer = this.editor.renderer;
            renderer.$isMousePressed = true;
            var self2 = this;
            var onMouseMove = function(e2) {
              if (!e2)
                return;
              if (useragent.isWebKit && !e2.which && self2.releaseMouse)
                return self2.releaseMouse();
              self2.x = e2.clientX;
              self2.y = e2.clientY;
              mouseMoveHandler && mouseMoveHandler(e2);
              self2.mouseEvent = new MouseEvent2(e2, self2.editor);
              self2.$mouseMoved = true;
            };
            var onCaptureEnd = function(e2) {
              editor.off("beforeEndOperation", onOperationEnd);
              clearInterval(timerId);
              if (editor.session)
                onCaptureInterval();
              self2[self2.state + "End"] && self2[self2.state + "End"](e2);
              self2.state = "";
              self2.isMousePressed = renderer.$isMousePressed = false;
              if (renderer.$keepTextAreaAtCursor)
                renderer.$moveTextAreaToCursor();
              self2.$onCaptureMouseMove = self2.releaseMouse = null;
              e2 && self2.onMouseEvent("mouseup", e2);
              editor.endOperation();
            };
            var onCaptureInterval = function() {
              self2[self2.state] && self2[self2.state]();
              self2.$mouseMoved = false;
            };
            if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
              return setTimeout(function() {
                onCaptureEnd(ev);
              });
            }
            var onOperationEnd = function(e2) {
              if (!self2.releaseMouse)
                return;
              if (editor.curOp.command.name && editor.curOp.selectionChanged) {
                self2[self2.state + "End"] && self2[self2.state + "End"]();
                self2.state = "";
                self2.releaseMouse();
              }
            };
            editor.on("beforeEndOperation", onOperationEnd);
            editor.startOperation({ command: { name: "mouse" } });
            self2.$onCaptureMouseMove = onMouseMove;
            self2.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
            var timerId = setInterval(onCaptureInterval, 20);
          };
          MouseHandler2.prototype.cancelContextMenu = function() {
            var stop = (function(e2) {
              if (e2 && e2.domEvent && e2.domEvent.type != "contextmenu")
                return;
              this.editor.off("nativecontextmenu", stop);
              if (e2 && e2.domEvent)
                event.stopEvent(e2.domEvent);
            }).bind(this);
            setTimeout(stop, 10);
            this.editor.on("nativecontextmenu", stop);
          };
          MouseHandler2.prototype.destroy = function() {
            if (this.releaseMouse)
              this.releaseMouse();
          };
          return MouseHandler2;
        }()
      );
      MouseHandler.prototype.releaseMouse = null;
      config.defineOptions(MouseHandler.prototype, "mouseHandler", {
        scrollSpeed: { initialValue: 2 },
        dragDelay: { initialValue: useragent.isMac ? 150 : 0 },
        dragEnabled: { initialValue: true },
        focusTimeout: { initialValue: 0 },
        tooltipFollowsMouse: { initialValue: true }
      });
      exports3.MouseHandler = MouseHandler;
    });
    ace.define("ace/mouse/fold_handler", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports3, module3) {
      var dom = require2("../lib/dom");
      var FoldHandler = (
        /** @class */
        /* @__PURE__ */ function() {
          function FoldHandler2(editor) {
            editor.on("click", function(e2) {
              var position = e2.getDocumentPosition();
              var session = editor.session;
              var fold = session.getFoldAt(position.row, position.column, 1);
              if (fold) {
                if (e2.getAccelKey())
                  session.removeFold(fold);
                else
                  session.expandFold(fold);
                e2.stop();
              }
              var target = e2.domEvent && e2.domEvent.target;
              if (target && dom.hasCssClass(target, "ace_inline_button")) {
                if (dom.hasCssClass(target, "ace_toggle_wrap")) {
                  session.setOption("wrap", !session.getUseWrapMode());
                  editor.renderer.scrollCursorIntoView();
                }
              }
            });
            editor.on("gutterclick", function(e2) {
              var gutterRegion = editor.renderer.$gutterLayer.getRegion(e2);
              if (gutterRegion == "foldWidgets") {
                var row = e2.getDocumentPosition().row;
                var session = editor.session;
                if (session.foldWidgets && session.foldWidgets[row])
                  editor.session.onFoldWidgetClick(row, e2);
                if (!editor.isFocused())
                  editor.focus();
                e2.stop();
              }
            });
            editor.on("gutterdblclick", function(e2) {
              var gutterRegion = editor.renderer.$gutterLayer.getRegion(e2);
              if (gutterRegion == "foldWidgets") {
                var row = e2.getDocumentPosition().row;
                var session = editor.session;
                var data = session.getParentFoldRangeData(row, true);
                var range = data.range || data.firstRange;
                if (range) {
                  row = range.start.row;
                  var fold = session.getFoldAt(row, session.getLine(row).length, 1);
                  if (fold) {
                    session.removeFold(fold);
                  } else {
                    session.addFold("...", range);
                    editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
                  }
                }
                e2.stop();
              }
            });
          }
          return FoldHandler2;
        }()
      );
      exports3.FoldHandler = FoldHandler;
    });
    ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function(require2, exports3, module3) {
      var keyUtil = require2("../lib/keys");
      var event = require2("../lib/event");
      var KeyBinding = (
        /** @class */
        function() {
          function KeyBinding2(editor) {
            this.$editor = editor;
            this.$data = { editor };
            this.$handlers = [];
            this.setDefaultHandler(editor.commands);
          }
          KeyBinding2.prototype.setDefaultHandler = function(kb) {
            this.removeKeyboardHandler(this.$defaultHandler);
            this.$defaultHandler = kb;
            this.addKeyboardHandler(kb, 0);
          };
          KeyBinding2.prototype.setKeyboardHandler = function(kb) {
            var h3 = this.$handlers;
            if (h3[h3.length - 1] == kb)
              return;
            while (h3[h3.length - 1] && h3[h3.length - 1] != this.$defaultHandler)
              this.removeKeyboardHandler(h3[h3.length - 1]);
            this.addKeyboardHandler(kb, 1);
          };
          KeyBinding2.prototype.addKeyboardHandler = function(kb, pos) {
            if (!kb)
              return;
            if (typeof kb == "function" && !kb.handleKeyboard)
              kb.handleKeyboard = kb;
            var i2 = this.$handlers.indexOf(kb);
            if (i2 != -1)
              this.$handlers.splice(i2, 1);
            if (pos == void 0)
              this.$handlers.push(kb);
            else
              this.$handlers.splice(pos, 0, kb);
            if (i2 == -1 && kb.attach)
              kb.attach(this.$editor);
          };
          KeyBinding2.prototype.removeKeyboardHandler = function(kb) {
            var i2 = this.$handlers.indexOf(kb);
            if (i2 == -1)
              return false;
            this.$handlers.splice(i2, 1);
            kb.detach && kb.detach(this.$editor);
            return true;
          };
          KeyBinding2.prototype.getKeyboardHandler = function() {
            return this.$handlers[this.$handlers.length - 1];
          };
          KeyBinding2.prototype.getStatusText = function() {
            var data = this.$data;
            var editor = data.editor;
            return this.$handlers.map(function(h3) {
              return h3.getStatusText && h3.getStatusText(editor, data) || "";
            }).filter(Boolean).join(" ");
          };
          KeyBinding2.prototype.$callKeyboardHandlers = function(hashId, keyString, keyCode, e2) {
            var toExecute;
            var success = false;
            var commands = this.$editor.commands;
            for (var i2 = this.$handlers.length; i2--; ) {
              toExecute = this.$handlers[i2].handleKeyboard(this.$data, hashId, keyString, keyCode, e2);
              if (!toExecute || !toExecute.command)
                continue;
              if (toExecute.command == "null") {
                success = true;
              } else {
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e2);
              }
              if (success && e2 && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
                event.stopEvent(e2);
              }
              if (success)
                break;
            }
            if (!success && hashId == -1) {
              toExecute = { command: "insertstring" };
              success = commands.exec("insertstring", this.$editor, keyString);
            }
            if (success && this.$editor._signal)
              this.$editor._signal("keyboardActivity", toExecute);
            return success;
          };
          KeyBinding2.prototype.onCommandKey = function(e2, hashId, keyCode) {
            var keyString = keyUtil.keyCodeToString(keyCode);
            return this.$callKeyboardHandlers(hashId, keyString, keyCode, e2);
          };
          KeyBinding2.prototype.onTextInput = function(text) {
            return this.$callKeyboardHandlers(-1, text);
          };
          return KeyBinding2;
        }()
      );
      exports3.KeyBinding = KeyBinding;
    });
    ace.define("ace/lib/bidiutil", ["require", "exports", "module"], function(require2, exports3, module3) {
      var dir = 0, hiLevel = 0;
      var lastArabic = false, hasUBAT_B = false, hasUBAT_S = false;
      var impTab_LTR = [
        [0, 3, 0, 1, 0, 0, 0],
        [0, 3, 0, 1, 2, 2, 0],
        [0, 3, 0, 17, 2, 0, 1],
        [0, 3, 5, 5, 4, 1, 0],
        [0, 3, 21, 21, 4, 0, 1],
        [0, 3, 5, 5, 4, 2, 0]
      ];
      var impTab_RTL = [
        [2, 0, 1, 1, 0, 1, 0],
        [2, 0, 1, 1, 0, 2, 0],
        [2, 0, 2, 1, 3, 2, 0],
        [2, 0, 2, 33, 3, 1, 1]
      ];
      var LTR = 0, RTL = 1;
      var L2 = 0;
      var R2 = 1;
      var EN = 2;
      var AN = 3;
      var ON = 4;
      var B2 = 5;
      var S3 = 6;
      var AL = 7;
      var WS = 8;
      var CS = 9;
      var ES = 10;
      var ET = 11;
      var NSM = 12;
      var LRE = 13;
      var RLE = 14;
      var PDF = 15;
      var LRO = 16;
      var RLO = 17;
      var BN = 18;
      var UnicodeTBL00 = [
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        S3,
        B2,
        S3,
        WS,
        B2,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        B2,
        B2,
        B2,
        S3,
        WS,
        ON,
        ON,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        ON,
        ES,
        CS,
        ES,
        CS,
        CS,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        CS,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        ON,
        ON,
        ON,
        ON,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        B2,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        CS,
        ON,
        ET,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        L2,
        ON,
        ON,
        BN,
        ON,
        ON,
        ET,
        ET,
        EN,
        EN,
        ON,
        L2,
        ON,
        ON,
        ON,
        EN,
        L2,
        ON,
        ON,
        ON,
        ON,
        ON
      ];
      var UnicodeTBL20 = [
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        BN,
        BN,
        BN,
        L2,
        R2,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        WS,
        B2,
        LRE,
        RLE,
        PDF,
        LRO,
        RLO,
        CS,
        ET,
        ET,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        CS,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        WS
      ];
      function _computeLevels(chars, levels, len, charTypes) {
        var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i2 = null, ix = null, classes = [];
        if (!charTypes) {
          for (i2 = 0, charTypes = []; i2 < len; i2++) {
            charTypes[i2] = _getCharacterType(chars[i2]);
          }
        }
        hiLevel = dir;
        lastArabic = false;
        hasUBAT_B = false;
        hasUBAT_S = false;
        for (ix = 0; ix < len; ix++) {
          prevState = newState;
          classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
          newState = impTab[prevState][newClass];
          action = newState & 240;
          newState &= 15;
          levels[ix] = newLevel = impTab[newState][5];
          if (action > 0) {
            if (action == 16) {
              for (i2 = condPos; i2 < ix; i2++) {
                levels[i2] = 1;
              }
              condPos = -1;
            } else {
              condPos = -1;
            }
          }
          cond = impTab[newState][6];
          if (cond) {
            if (condPos == -1) {
              condPos = ix;
            }
          } else {
            if (condPos > -1) {
              for (i2 = condPos; i2 < ix; i2++) {
                levels[i2] = newLevel;
              }
              condPos = -1;
            }
          }
          if (charTypes[ix] == B2) {
            levels[ix] = 0;
          }
          hiLevel |= newLevel;
        }
        if (hasUBAT_S) {
          for (i2 = 0; i2 < len; i2++) {
            if (charTypes[i2] == S3) {
              levels[i2] = dir;
              for (var j = i2 - 1; j >= 0; j--) {
                if (charTypes[j] == WS) {
                  levels[j] = dir;
                } else {
                  break;
                }
              }
            }
          }
        }
      }
      function _invertLevel(lev, levels, _array) {
        if (hiLevel < lev) {
          return;
        }
        if (lev == 1 && dir == RTL && !hasUBAT_B) {
          _array.reverse();
          return;
        }
        var len = _array.length, start = 0, end, lo, hi, tmp;
        while (start < len) {
          if (levels[start] >= lev) {
            end = start + 1;
            while (end < len && levels[end] >= lev) {
              end++;
            }
            for (lo = start, hi = end - 1; lo < hi; lo++, hi--) {
              tmp = _array[lo];
              _array[lo] = _array[hi];
              _array[hi] = tmp;
            }
            start = end;
          }
          start++;
        }
      }
      function _getCharClass(chars, types, classes, ix) {
        var cType = types[ix], wType, nType, len, i2;
        switch (cType) {
          case L2:
          case R2:
            lastArabic = false;
          case ON:
          case AN:
            return cType;
          case EN:
            return lastArabic ? AN : EN;
          case AL:
            lastArabic = true;
            return R2;
          case WS:
            return ON;
          case CS:
            if (ix < 1 || ix + 1 >= types.length || (wType = classes[ix - 1]) != EN && wType != AN || (nType = types[ix + 1]) != EN && nType != AN) {
              return ON;
            }
            if (lastArabic) {
              nType = AN;
            }
            return nType == wType ? nType : ON;
          case ES:
            wType = ix > 0 ? classes[ix - 1] : B2;
            if (wType == EN && ix + 1 < types.length && types[ix + 1] == EN) {
              return EN;
            }
            return ON;
          case ET:
            if (ix > 0 && classes[ix - 1] == EN) {
              return EN;
            }
            if (lastArabic) {
              return ON;
            }
            i2 = ix + 1;
            len = types.length;
            while (i2 < len && types[i2] == ET) {
              i2++;
            }
            if (i2 < len && types[i2] == EN) {
              return EN;
            }
            return ON;
          case NSM:
            len = types.length;
            i2 = ix + 1;
            while (i2 < len && types[i2] == NSM) {
              i2++;
            }
            if (i2 < len) {
              var c2 = chars[ix], rtlCandidate = c2 >= 1425 && c2 <= 2303 || c2 == 64286;
              wType = types[i2];
              if (rtlCandidate && (wType == R2 || wType == AL)) {
                return R2;
              }
            }
            if (ix < 1 || (wType = types[ix - 1]) == B2) {
              return ON;
            }
            return classes[ix - 1];
          case B2:
            lastArabic = false;
            hasUBAT_B = true;
            return dir;
          case S3:
            hasUBAT_S = true;
            return ON;
          case LRE:
          case RLE:
          case LRO:
          case RLO:
          case PDF:
            lastArabic = false;
          case BN:
            return ON;
        }
      }
      function _getCharacterType(ch) {
        var uc = ch.charCodeAt(0), hi = uc >> 8;
        if (hi == 0) {
          return uc > 191 ? L2 : UnicodeTBL00[uc];
        } else if (hi == 5) {
          return /[\u0591-\u05f4]/.test(ch) ? R2 : L2;
        } else if (hi == 6) {
          if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
            return NSM;
          else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
            return AN;
          else if (uc == 1642)
            return ET;
          else if (/[\u06f0-\u06f9]/.test(ch))
            return EN;
          else
            return AL;
        } else if (hi == 32 && uc <= 8287) {
          return UnicodeTBL20[uc & 255];
        } else if (hi == 254) {
          return uc >= 65136 ? AL : ON;
        }
        return ON;
      }
      exports3.L = L2;
      exports3.R = R2;
      exports3.EN = EN;
      exports3.ON_R = 3;
      exports3.AN = 4;
      exports3.R_H = 5;
      exports3.B = 6;
      exports3.RLE = 7;
      exports3.DOT = "·";
      exports3.doBidiReorder = function(text, textCharTypes, isRtl) {
        if (text.length < 2)
          return {};
        var chars = text.split(""), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];
        dir = isRtl ? RTL : LTR;
        _computeLevels(chars, levels, chars.length, textCharTypes);
        for (var i2 = 0; i2 < logicalFromVisual.length; logicalFromVisual[i2] = i2, i2++)
          ;
        _invertLevel(2, levels, logicalFromVisual);
        _invertLevel(1, levels, logicalFromVisual);
        for (var i2 = 0; i2 < logicalFromVisual.length - 1; i2++) {
          if (textCharTypes[i2] === AN) {
            levels[i2] = exports3.AN;
          } else if (levels[i2] === R2 && (textCharTypes[i2] > AL && textCharTypes[i2] < LRE || textCharTypes[i2] === ON || textCharTypes[i2] === BN)) {
            levels[i2] = exports3.ON_R;
          } else if (i2 > 0 && chars[i2 - 1] === "ل" && /\u0622|\u0623|\u0625|\u0627/.test(chars[i2])) {
            levels[i2 - 1] = levels[i2] = exports3.R_H;
            i2++;
          }
        }
        if (chars[chars.length - 1] === exports3.DOT)
          levels[chars.length - 1] = exports3.B;
        if (chars[0] === "‫")
          levels[0] = exports3.RLE;
        for (var i2 = 0; i2 < logicalFromVisual.length; i2++) {
          bidiLevels[i2] = levels[logicalFromVisual[i2]];
        }
        return { "logicalFromVisual": logicalFromVisual, "bidiLevels": bidiLevels };
      };
      exports3.hasBidiCharacters = function(text, textCharTypes) {
        var ret = false;
        for (var i2 = 0; i2 < text.length; i2++) {
          textCharTypes[i2] = _getCharacterType(text.charAt(i2));
          if (!ret && (textCharTypes[i2] == R2 || textCharTypes[i2] == AL || textCharTypes[i2] == AN))
            ret = true;
        }
        return ret;
      };
      exports3.getVisualFromLogicalIdx = function(logIdx, rowMap) {
        for (var i2 = 0; i2 < rowMap.logicalFromVisual.length; i2++) {
          if (rowMap.logicalFromVisual[i2] == logIdx)
            return i2;
        }
        return 0;
      };
    });
    ace.define("ace/bidihandler", ["require", "exports", "module", "ace/lib/bidiutil", "ace/lib/lang"], function(require2, exports3, module3) {
      var bidiUtil = require2("./lib/bidiutil");
      var lang = require2("./lib/lang");
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;
      var BidiHandler = (
        /** @class */
        function() {
          function BidiHandler2(session) {
            this.session = session;
            this.bidiMap = {};
            this.currentRow = null;
            this.bidiUtil = bidiUtil;
            this.charWidths = [];
            this.EOL = "¬";
            this.showInvisibles = true;
            this.isRtlDir = false;
            this.$isRtl = false;
            this.line = "";
            this.wrapIndent = 0;
            this.EOF = "¶";
            this.RLE = "‫";
            this.contentWidth = 0;
            this.fontMetrics = null;
            this.rtlLineOffset = 0;
            this.wrapOffset = 0;
            this.isMoveLeftOperation = false;
            this.seenBidi = bidiRE.test(session.getValue());
          }
          BidiHandler2.prototype.isBidiRow = function(screenRow, docRow, splitIndex) {
            if (!this.seenBidi)
              return false;
            if (screenRow !== this.currentRow) {
              this.currentRow = screenRow;
              this.updateRowLine(docRow, splitIndex);
              this.updateBidiMap();
            }
            return this.bidiMap.bidiLevels;
          };
          BidiHandler2.prototype.onChange = function(delta) {
            if (!this.seenBidi) {
              if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                this.seenBidi = true;
                this.currentRow = null;
              }
            } else {
              this.currentRow = null;
            }
          };
          BidiHandler2.prototype.getDocumentRow = function() {
            var docRow = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
              var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
              if (index >= 0)
                docRow = this.session.$docRowCache[index];
            }
            return docRow;
          };
          BidiHandler2.prototype.getSplitIndex = function() {
            var splitIndex = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
              var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
              while (this.currentRow - splitIndex > 0) {
                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                if (currentIndex !== prevIndex)
                  break;
                prevIndex = currentIndex;
                splitIndex++;
              }
            } else {
              splitIndex = this.currentRow;
            }
            return splitIndex;
          };
          BidiHandler2.prototype.updateRowLine = function(docRow, splitIndex) {
            if (docRow === void 0)
              docRow = this.getDocumentRow();
            var isLastRow = docRow === this.session.getLength() - 1, endOfLine = isLastRow ? this.EOF : this.EOL;
            this.wrapIndent = 0;
            this.line = this.session.getLine(docRow);
            this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
            if (this.session.$useWrapMode) {
              var splits = this.session.$wrapData[docRow];
              if (splits) {
                if (splitIndex === void 0)
                  splitIndex = this.getSplitIndex();
                if (splitIndex > 0 && splits.length) {
                  this.wrapIndent = splits.indent;
                  this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
                  this.line = splitIndex < splits.length ? this.line.substring(splits[splitIndex - 1], splits[splitIndex]) : this.line.substring(splits[splits.length - 1]);
                } else {
                  this.line = this.line.substring(0, splits[splitIndex]);
                }
                if (splitIndex == splits.length) {
                  this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
                }
              }
            } else {
              this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
            }
            var session = this.session, shift = 0, size;
            this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i2) {
              if (ch === "	" || session.isFullWidth(ch.charCodeAt(0))) {
                size = ch === "	" ? session.getScreenTabSize(i2 + shift) : 2;
                shift += size - 1;
                return lang.stringRepeat(bidiUtil.DOT, size);
              }
              return ch;
            });
            if (this.isRtlDir) {
              this.fontMetrics.$main.textContent = this.line.charAt(this.line.length - 1) == bidiUtil.DOT ? this.line.substr(0, this.line.length - 1) : this.line;
              this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
            }
          };
          BidiHandler2.prototype.updateBidiMap = function() {
            var textCharTypes = [];
            if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
              this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
            } else {
              this.bidiMap = {};
            }
          };
          BidiHandler2.prototype.markAsDirty = function() {
            this.currentRow = null;
          };
          BidiHandler2.prototype.updateCharacterWidths = function(fontMetrics) {
            if (this.characterWidth === fontMetrics.$characterSize.width)
              return;
            this.fontMetrics = fontMetrics;
            var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
            var bidiCharWidth = fontMetrics.$measureCharWidth("ה");
            this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
            this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
            this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
            this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;
            this.currentRow = null;
          };
          BidiHandler2.prototype.setShowInvisibles = function(showInvisibles) {
            this.showInvisibles = showInvisibles;
            this.currentRow = null;
          };
          BidiHandler2.prototype.setEolChar = function(eolChar) {
            this.EOL = eolChar;
          };
          BidiHandler2.prototype.setContentWidth = function(width) {
            this.contentWidth = width;
          };
          BidiHandler2.prototype.isRtlLine = function(row) {
            if (this.$isRtl)
              return true;
            if (row != void 0)
              return this.session.getLine(row).charAt(0) == this.RLE;
            else
              return this.isRtlDir;
          };
          BidiHandler2.prototype.setRtlDirection = function(editor, isRtlDir) {
            var cursor = editor.getCursorPosition();
            for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {
              if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)
                editor.session.doc.removeInLine(row, 0, 1);
              else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)
                editor.session.doc.insert({ column: 0, row }, editor.session.$bidiHandler.RLE);
            }
          };
          BidiHandler2.prototype.getPosLeft = function(col) {
            col -= this.wrapIndent;
            var leftBoundary = this.line.charAt(0) === this.RLE ? 1 : 0;
            var logicalIdx = col > leftBoundary ? this.session.getOverwrite() ? col : col - 1 : leftBoundary;
            var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;
            if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)
              visualIdx++;
            for (var i2 = 0; i2 < visualIdx; i2++) {
              left += this.charWidths[levels[i2]];
            }
            if (!this.session.getOverwrite() && col > leftBoundary && levels[visualIdx] % 2 === 0)
              left += this.charWidths[levels[visualIdx]];
            if (this.wrapIndent)
              left += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            if (this.isRtlDir)
              left += this.rtlLineOffset;
            return left;
          };
          BidiHandler2.prototype.getSelections = function(startCol, endCol) {
            var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0, selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;
            if (this.wrapIndent)
              offset += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
              logIdx = map.logicalFromVisual[visIdx];
              level = levels[visIdx];
              isSelected = logIdx >= selColMin && logIdx < selColMax;
              if (isSelected && !isSelectedPrev) {
                selectionStart = offset;
              } else if (!isSelected && isSelectedPrev) {
                selections.push({ left: selectionStart, width: offset - selectionStart });
              }
              offset += this.charWidths[level];
              isSelectedPrev = isSelected;
            }
            if (isSelected && visIdx === levels.length) {
              selections.push({ left: selectionStart, width: offset - selectionStart });
            }
            if (this.isRtlDir) {
              for (var i2 = 0; i2 < selections.length; i2++) {
                selections[i2].left += this.rtlLineOffset;
              }
            }
            return selections;
          };
          BidiHandler2.prototype.offsetToCol = function(posX) {
            if (this.isRtlDir)
              posX -= this.rtlLineOffset;
            var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];
            if (this.wrapIndent)
              posX -= this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            while (posX > offset + charWidth / 2) {
              offset += charWidth;
              if (visualIdx === levels.length - 1) {
                charWidth = 0;
                break;
              }
              charWidth = this.charWidths[levels[++visualIdx]];
            }
            if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && levels[visualIdx] % 2 === 0) {
              if (posX < offset)
                visualIdx--;
              logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            } else if (visualIdx > 0 && levels[visualIdx - 1] % 2 === 0 && levels[visualIdx] % 2 !== 0) {
              logicalIdx = 1 + (posX > offset ? this.bidiMap.logicalFromVisual[visualIdx] : this.bidiMap.logicalFromVisual[visualIdx - 1]);
            } else if (this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && levels[visualIdx - 1] % 2 === 0 || !this.isRtlDir && visualIdx === 0 && levels[visualIdx] % 2 !== 0) {
              logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
            } else {
              if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && charWidth !== 0)
                visualIdx--;
              logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            }
            if (logicalIdx === 0 && this.isRtlDir)
              logicalIdx++;
            return logicalIdx + this.wrapIndent;
          };
          return BidiHandler2;
        }()
      );
      exports3.BidiHandler = BidiHandler;
    });
    ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function(require2, exports3, module3) {
      var oop = require2("./lib/oop");
      var lang = require2("./lib/lang");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Range = require2("./range").Range;
      var Selection = function(session) {
        this.session = session;
        this.doc = session.getDocument();
        this.clearSelection();
        this.cursor = this.lead = this.doc.createAnchor(0, 0);
        this.anchor = this.doc.createAnchor(0, 0);
        this.$silent = false;
        var self2 = this;
        this.cursor.on("change", function(e2) {
          self2.$cursorChanged = true;
          if (!self2.$silent)
            self2._emit("changeCursor");
          if (!self2.$isEmpty && !self2.$silent)
            self2._emit("changeSelection");
          if (!self2.$keepDesiredColumnOnChange && e2.old.column != e2.value.column)
            self2.$desiredColumn = null;
        });
        this.anchor.on("change", function() {
          self2.$anchorChanged = true;
          if (!self2.$isEmpty && !self2.$silent)
            self2._emit("changeSelection");
        });
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.isEmpty = function() {
          return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
        };
        this.isMultiLine = function() {
          return !this.$isEmpty && this.anchor.row != this.cursor.row;
        };
        this.getCursor = function() {
          return this.lead.getPosition();
        };
        this.setAnchor = function(row, column) {
          this.$isEmpty = false;
          this.anchor.setPosition(row, column);
        };
        this.setSelectionAnchor = this.setAnchor;
        this.getAnchor = function() {
          if (this.$isEmpty)
            return this.getSelectionLead();
          return this.anchor.getPosition();
        };
        this.getSelectionAnchor = this.getAnchor;
        this.getSelectionLead = function() {
          return this.lead.getPosition();
        };
        this.isBackwards = function() {
          var anchor = this.anchor;
          var lead = this.lead;
          return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
        };
        this.getRange = function() {
          var anchor = this.anchor;
          var lead = this.lead;
          if (this.$isEmpty)
            return Range.fromPoints(lead, lead);
          return this.isBackwards() ? Range.fromPoints(lead, anchor) : Range.fromPoints(anchor, lead);
        };
        this.clearSelection = function() {
          if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
          }
        };
        this.selectAll = function() {
          this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
        };
        this.setRange = this.setSelectionRange = function(range, reverse) {
          var start = reverse ? range.end : range.start;
          var end = reverse ? range.start : range.end;
          this.$setSelection(start.row, start.column, end.row, end.column);
        };
        this.$setSelection = function(anchorRow, anchorColumn, cursorRow, cursorColumn) {
          if (this.$silent)
            return;
          var wasEmpty = this.$isEmpty;
          var wasMultiselect = this.inMultiSelectMode;
          this.$silent = true;
          this.$cursorChanged = this.$anchorChanged = false;
          this.anchor.setPosition(anchorRow, anchorColumn);
          this.cursor.setPosition(cursorRow, cursorColumn);
          this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
          this.$silent = false;
          if (this.$cursorChanged)
            this._emit("changeCursor");
          if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)
            this._emit("changeSelection");
        };
        this.$moveSelection = function(mover) {
          var lead = this.lead;
          if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);
          mover.call(this);
        };
        this.selectTo = function(row, column) {
          this.$moveSelection(function() {
            this.moveCursorTo(row, column);
          });
        };
        this.selectToPosition = function(pos) {
          this.$moveSelection(function() {
            this.moveCursorToPosition(pos);
          });
        };
        this.moveTo = function(row, column) {
          this.clearSelection();
          this.moveCursorTo(row, column);
        };
        this.moveToPosition = function(pos) {
          this.clearSelection();
          this.moveCursorToPosition(pos);
        };
        this.selectUp = function() {
          this.$moveSelection(this.moveCursorUp);
        };
        this.selectDown = function() {
          this.$moveSelection(this.moveCursorDown);
        };
        this.selectRight = function() {
          this.$moveSelection(this.moveCursorRight);
        };
        this.selectLeft = function() {
          this.$moveSelection(this.moveCursorLeft);
        };
        this.selectLineStart = function() {
          this.$moveSelection(this.moveCursorLineStart);
        };
        this.selectLineEnd = function() {
          this.$moveSelection(this.moveCursorLineEnd);
        };
        this.selectFileEnd = function() {
          this.$moveSelection(this.moveCursorFileEnd);
        };
        this.selectFileStart = function() {
          this.$moveSelection(this.moveCursorFileStart);
        };
        this.selectWordRight = function() {
          this.$moveSelection(this.moveCursorWordRight);
        };
        this.selectWordLeft = function() {
          this.$moveSelection(this.moveCursorWordLeft);
        };
        this.getWordRange = function(row, column) {
          if (typeof column == "undefined") {
            var cursor = row || this.lead;
            row = cursor.row;
            column = cursor.column;
          }
          return this.session.getWordRange(row, column);
        };
        this.selectWord = function() {
          this.setSelectionRange(this.getWordRange());
        };
        this.selectAWord = function() {
          var cursor = this.getCursor();
          var range = this.session.getAWordRange(cursor.row, cursor.column);
          this.setSelectionRange(range);
        };
        this.getLineRange = function(row, excludeLastChar) {
          var rowStart = typeof row == "number" ? row : this.lead.row;
          var rowEnd;
          var foldLine = this.session.getFoldLine(rowStart);
          if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
          } else {
            rowEnd = rowStart;
          }
          if (excludeLastChar === true)
            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
          else
            return new Range(rowStart, 0, rowEnd + 1, 0);
        };
        this.selectLine = function() {
          this.setSelectionRange(this.getLineRange());
        };
        this.moveCursorUp = function() {
          this.moveCursorBy(-1, 0);
        };
        this.moveCursorDown = function() {
          this.moveCursorBy(1, 0);
        };
        this.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {
          var start = cursor.column;
          var end = cursor.column + tabSize;
          if (direction < 0) {
            start = cursor.column - tabSize;
            end = cursor.column;
          }
          return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length - 1 == tabSize;
        };
        this.moveCursorLeft = function() {
          var cursor = this.lead.getPosition(), fold;
          if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
          } else if (cursor.column === 0) {
            if (cursor.row > 0) {
              this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
          } else {
            var tabSize = this.session.getTabSize();
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
              this.moveCursorBy(0, -tabSize);
            } else {
              this.moveCursorBy(0, -1);
            }
          }
        };
        this.moveCursorRight = function() {
          var cursor = this.lead.getPosition(), fold;
          if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
          } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
            if (this.lead.row < this.doc.getLength() - 1) {
              this.moveCursorTo(this.lead.row + 1, 0);
            }
          } else {
            var tabSize = this.session.getTabSize();
            var cursor = this.lead;
            if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
              this.moveCursorBy(0, tabSize);
            } else {
              this.moveCursorBy(0, 1);
            }
          }
        };
        this.moveCursorLineStart = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var screenRow = this.session.documentToScreenRow(row, column);
          var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
          var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
          var leadingSpace = beforeCursor.match(/^\s*/);
          if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
            firstColumnPosition.column += leadingSpace[0].length;
          this.moveCursorToPosition(firstColumnPosition);
        };
        this.moveCursorLineEnd = function() {
          var lead = this.lead;
          var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
          if (this.lead.column == lineEnd.column) {
            var line = this.session.getLine(lineEnd.row);
            if (lineEnd.column == line.length) {
              var textEnd = line.search(/\s+$/);
              if (textEnd > 0)
                lineEnd.column = textEnd;
            }
          }
          this.moveCursorTo(lineEnd.row, lineEnd.column);
        };
        this.moveCursorFileEnd = function() {
          var row = this.doc.getLength() - 1;
          var column = this.doc.getLine(row).length;
          this.moveCursorTo(row, column);
        };
        this.moveCursorFileStart = function() {
          this.moveCursorTo(0, 0);
        };
        this.moveCursorLongWordRight = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var line = this.doc.getLine(row);
          var rightOfCursor = line.substring(column);
          this.session.nonTokenRe.lastIndex = 0;
          this.session.tokenRe.lastIndex = 0;
          var fold = this.session.getFoldAt(row, column, 1);
          if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return;
          }
          if (this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
          }
          if (column >= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row < this.doc.getLength() - 1)
              this.moveCursorWordRight();
            return;
          }
          if (this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
          }
          this.moveCursorTo(row, column);
        };
        this.moveCursorLongWordLeft = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var fold;
          if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return;
          }
          var str = this.session.getFoldStringAt(row, column, -1);
          if (str == null) {
            str = this.doc.getLine(row).substring(0, column);
          }
          var leftOfCursor = lang.stringReverse(str);
          this.session.nonTokenRe.lastIndex = 0;
          this.session.tokenRe.lastIndex = 0;
          if (this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
          }
          if (column <= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row > 0)
              this.moveCursorWordLeft();
            return;
          }
          if (this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
          }
          this.moveCursorTo(row, column);
        };
        this.$shortWordEndIndex = function(rightOfCursor) {
          var index = 0, ch;
          var whitespaceRe = /\s/;
          var tokenRe = this.session.tokenRe;
          tokenRe.lastIndex = 0;
          if (this.session.tokenRe.exec(rightOfCursor)) {
            index = this.session.tokenRe.lastIndex;
          } else {
            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
              index++;
            if (index < 1) {
              tokenRe.lastIndex = 0;
              while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                tokenRe.lastIndex = 0;
                index++;
                if (whitespaceRe.test(ch)) {
                  if (index > 2) {
                    index--;
                    break;
                  } else {
                    while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                      index++;
                    if (index > 2)
                      break;
                  }
                }
              }
            }
          }
          tokenRe.lastIndex = 0;
          return index;
        };
        this.moveCursorShortWordRight = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var line = this.doc.getLine(row);
          var rightOfCursor = line.substring(column);
          var fold = this.session.getFoldAt(row, column, 1);
          if (fold)
            return this.moveCursorTo(fold.end.row, fold.end.column);
          if (column == line.length) {
            var l = this.doc.getLength();
            do {
              row++;
              rightOfCursor = this.doc.getLine(row);
            } while (row < l && /^\s*$/.test(rightOfCursor));
            if (!/^\s+/.test(rightOfCursor))
              rightOfCursor = "";
            column = 0;
          }
          var index = this.$shortWordEndIndex(rightOfCursor);
          this.moveCursorTo(row, column + index);
        };
        this.moveCursorShortWordLeft = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var fold;
          if (fold = this.session.getFoldAt(row, column, -1))
            return this.moveCursorTo(fold.start.row, fold.start.column);
          var line = this.session.getLine(row).substring(0, column);
          if (column === 0) {
            do {
              row--;
              line = this.doc.getLine(row);
            } while (row > 0 && /^\s*$/.test(line));
            column = line.length;
            if (!/\s+$/.test(line))
              line = "";
          }
          var leftOfCursor = lang.stringReverse(line);
          var index = this.$shortWordEndIndex(leftOfCursor);
          return this.moveCursorTo(row, column - index);
        };
        this.moveCursorWordRight = function() {
          if (this.session.$selectLongWords)
            this.moveCursorLongWordRight();
          else
            this.moveCursorShortWordRight();
        };
        this.moveCursorWordLeft = function() {
          if (this.session.$selectLongWords)
            this.moveCursorLongWordLeft();
          else
            this.moveCursorShortWordLeft();
        };
        this.moveCursorBy = function(rows, chars) {
          var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
          var offsetX;
          if (chars === 0) {
            if (rows !== 0) {
              if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
              } else {
                offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
              }
            }
            if (this.$desiredColumn)
              screenPos.column = this.$desiredColumn;
            else
              this.$desiredColumn = screenPos.column;
          }
          if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
            var widget = this.session.lineWidgets[this.lead.row];
            if (rows < 0)
              rows -= widget.rowsAbove || 0;
            else if (rows > 0)
              rows += widget.rowCount - (widget.rowsAbove || 0);
          }
          var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
          if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) ;
          this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
        };
        this.moveCursorToPosition = function(position) {
          this.moveCursorTo(position.row, position.column);
        };
        this.moveCursorTo = function(row, column, keepDesiredColumn) {
          var fold = this.session.getFoldAt(row, column, 1);
          if (fold) {
            row = fold.start.row;
            column = fold.start.column;
          }
          this.$keepDesiredColumnOnChange = true;
          var line = this.session.getLine(row);
          if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
            if (this.lead.row == row && this.lead.column == column + 1)
              column = column - 1;
            else
              column = column + 1;
          }
          this.lead.setPosition(row, column);
          this.$keepDesiredColumnOnChange = false;
          if (!keepDesiredColumn)
            this.$desiredColumn = null;
        };
        this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
          var pos = this.session.screenToDocumentPosition(row, column);
          this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
        };
        this.detach = function() {
          this.lead.detach();
          this.anchor.detach();
        };
        this.fromOrientedRange = function(range) {
          this.setSelectionRange(range, range.cursor == range.start);
          this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
        };
        this.toOrientedRange = function(range) {
          var r = this.getRange();
          if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
          } else {
            range = r;
          }
          range.cursor = this.isBackwards() ? range.start : range.end;
          range.desiredColumn = this.$desiredColumn;
          return range;
        };
        this.getRangeOfMovements = function(func) {
          var start = this.getCursor();
          try {
            func(this);
            var end = this.getCursor();
            return Range.fromPoints(start, end);
          } catch (e2) {
            return Range.fromPoints(start, start);
          } finally {
            this.moveCursorToPosition(start);
          }
        };
        this.toJSON = function() {
          if (this.rangeCount) {
            var data = this.ranges.map(function(r) {
              var r1 = r.clone();
              r1.isBackwards = r.cursor == r.start;
              return r1;
            });
          } else {
            var data = this.getRange();
            data.isBackwards = this.isBackwards();
          }
          return data;
        };
        this.fromJSON = function(data) {
          if (data.start == void 0) {
            if (this.rangeList && data.length > 1) {
              this.toSingleRange(data[0]);
              for (var i2 = data.length; i2--; ) {
                var r = Range.fromPoints(data[i2].start, data[i2].end);
                if (data[i2].isBackwards)
                  r.cursor = r.start;
                this.addRange(r, true);
              }
              return;
            } else {
              data = data[0];
            }
          }
          if (this.rangeList)
            this.toSingleRange(data);
          this.setSelectionRange(data, data.isBackwards);
        };
        this.isEqual = function(data) {
          if ((data.length || this.rangeCount) && data.length != this.rangeCount)
            return false;
          if (!data.length || !this.ranges)
            return this.getRange().isEqual(data);
          for (var i2 = this.ranges.length; i2--; ) {
            if (!this.ranges[i2].isEqual(data[i2]))
              return false;
          }
          return true;
        };
      }).call(Selection.prototype);
      exports3.Selection = Selection;
    });
    ace.define("ace/tokenizer", ["require", "exports", "module", "ace/config"], function(require2, exports3, module3) {
      var config = require2("./config");
      var MAX_TOKEN_COUNT = 2e3;
      var Tokenizer = (
        /** @class */
        function() {
          function Tokenizer2(rules) {
            this.states = rules;
            this.regExps = {};
            this.matchMappings = {};
            for (var key in this.states) {
              var state = this.states[key];
              var ruleRegExps = [];
              var matchTotal = 0;
              var mapping = this.matchMappings[key] = { defaultToken: "text" };
              var flag = "g";
              var splitterRurles = [];
              for (var i2 = 0; i2 < state.length; i2++) {
                var rule = state[i2];
                if (rule.defaultToken)
                  mapping.defaultToken = rule.defaultToken;
                if (rule.caseInsensitive && flag.indexOf("i") === -1)
                  flag += "i";
                if (rule.unicode && flag.indexOf("u") === -1)
                  flag += "u";
                if (rule.regex == null)
                  continue;
                if (rule.regex instanceof RegExp)
                  rule.regex = rule.regex.toString().slice(1, -1);
                var adjustedregex = rule.regex;
                var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                if (Array.isArray(rule.token)) {
                  if (rule.token.length == 1 || matchcount == 1) {
                    rule.token = rule.token[0];
                  } else if (matchcount - 1 != rule.token.length) {
                    this.reportError("number of classes and regexp groups doesn't match", {
                      rule,
                      groupCount: matchcount - 1
                    });
                    rule.token = rule.token[0];
                  } else {
                    rule.tokenArray = rule.token;
                    rule.token = null;
                    rule.onMatch = this.$arrayTokens;
                  }
                } else if (typeof rule.token == "function" && !rule.onMatch) {
                  if (matchcount > 1)
                    rule.onMatch = this.$applyToken;
                  else
                    rule.onMatch = rule.token;
                }
                if (matchcount > 1) {
                  if (/\\\d/.test(rule.regex)) {
                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match2, digit) {
                      return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                    });
                  } else {
                    matchcount = 1;
                    adjustedregex = this.removeCapturingGroups(rule.regex);
                  }
                  if (!rule.splitRegex && typeof rule.token != "string")
                    splitterRurles.push(rule);
                }
                mapping[matchTotal] = i2;
                matchTotal += matchcount;
                ruleRegExps.push(adjustedregex);
                if (!rule.onMatch)
                  rule.onMatch = null;
              }
              if (!ruleRegExps.length) {
                mapping[0] = 0;
                ruleRegExps.push("$");
              }
              splitterRurles.forEach(function(rule2) {
                rule2.splitRegex = this.createSplitterRegexp(rule2.regex, flag);
              }, this);
              this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
            }
          }
          Tokenizer2.prototype.$setMaxTokenCount = function(m3) {
            MAX_TOKEN_COUNT = m3 | 0;
          };
          Tokenizer2.prototype.$applyToken = function(str) {
            var values = this.splitRegex.exec(str).slice(1);
            var types = this.token.apply(this, values);
            if (typeof types === "string")
              return [{ type: types, value: str }];
            var tokens = [];
            for (var i2 = 0, l = types.length; i2 < l; i2++) {
              if (values[i2])
                tokens[tokens.length] = {
                  type: types[i2],
                  value: values[i2]
                };
            }
            return tokens;
          };
          Tokenizer2.prototype.$arrayTokens = function(str) {
            if (!str)
              return [];
            var values = this.splitRegex.exec(str);
            if (!values)
              return "text";
            var tokens = [];
            var types = this.tokenArray;
            for (var i2 = 0, l = types.length; i2 < l; i2++) {
              if (values[i2 + 1])
                tokens[tokens.length] = {
                  type: types[i2],
                  value: values[i2 + 1]
                };
            }
            return tokens;
          };
          Tokenizer2.prototype.removeCapturingGroups = function(src) {
            var r = src.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g, function(x2, y3) {
              return y3 ? "(?:" : x2;
            });
            return r;
          };
          Tokenizer2.prototype.createSplitterRegexp = function(src, flag) {
            if (src.indexOf("(?=") != -1) {
              var stack = 0;
              var inChClass = false;
              var lastCapture = {};
              src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(m3, esc, parenOpen, parenClose, square, index) {
                if (inChClass) {
                  inChClass = square != "]";
                } else if (square) {
                  inChClass = true;
                } else if (parenClose) {
                  if (stack == lastCapture.stack) {
                    lastCapture.end = index + 1;
                    lastCapture.stack = -1;
                  }
                  stack--;
                } else if (parenOpen) {
                  stack++;
                  if (parenOpen.length != 1) {
                    lastCapture.stack = stack;
                    lastCapture.start = index;
                  }
                }
                return m3;
              });
              if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
            }
            if (src.charAt(0) != "^")
              src = "^" + src;
            if (src.charAt(src.length - 1) != "$")
              src += "$";
            return new RegExp(src, (flag || "").replace("g", ""));
          };
          Tokenizer2.prototype.getLineTokens = function(line, startState) {
            if (startState && typeof startState != "string") {
              var stack = startState.slice(0);
              startState = stack[0];
              if (startState === "#tmp") {
                stack.shift();
                startState = stack.shift();
              }
            } else
              var stack = [];
            var currentState = startState || "start";
            var state = this.states[currentState];
            if (!state) {
              currentState = "start";
              state = this.states[currentState];
            }
            var mapping = this.matchMappings[currentState];
            var re2 = this.regExps[currentState];
            re2.lastIndex = 0;
            var match2, tokens = [];
            var lastIndex = 0;
            var matchAttempts = 0;
            var token = { type: null, value: "" };
            while (match2 = re2.exec(line)) {
              var type = mapping.defaultToken;
              var rule = null;
              var value = match2[0];
              var index = re2.lastIndex;
              if (index - value.length > lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type) {
                  token.value += skipped;
                } else {
                  if (token.type)
                    tokens.push(token);
                  token = { type, value: skipped };
                }
              }
              for (var i2 = 0; i2 < match2.length - 2; i2++) {
                if (match2[i2 + 1] === void 0)
                  continue;
                rule = state[mapping[i2]];
                if (rule.onMatch)
                  type = rule.onMatch(value, currentState, stack, line);
                else
                  type = rule.token;
                if (rule.next) {
                  if (typeof rule.next == "string") {
                    currentState = rule.next;
                  } else {
                    currentState = rule.next(currentState, stack);
                  }
                  state = this.states[currentState];
                  if (!state) {
                    this.reportError("state doesn't exist", currentState);
                    currentState = "start";
                    state = this.states[currentState];
                  }
                  mapping = this.matchMappings[currentState];
                  lastIndex = index;
                  re2 = this.regExps[currentState];
                  re2.lastIndex = index;
                }
                if (rule.consumeLineEnd)
                  lastIndex = index;
                break;
              }
              if (value) {
                if (typeof type === "string") {
                  if ((!rule || rule.merge !== false) && token.type === type) {
                    token.value += value;
                  } else {
                    if (token.type)
                      tokens.push(token);
                    token = { type, value };
                  }
                } else if (type) {
                  if (token.type)
                    tokens.push(token);
                  token = { type: null, value: "" };
                  for (var i2 = 0; i2 < type.length; i2++)
                    tokens.push(type[i2]);
                }
              }
              if (lastIndex == line.length)
                break;
              lastIndex = index;
              if (matchAttempts++ > MAX_TOKEN_COUNT) {
                if (matchAttempts > 2 * line.length) {
                  this.reportError("infinite loop with in ace tokenizer", {
                    startState,
                    line
                  });
                }
                while (lastIndex < line.length) {
                  if (token.type)
                    tokens.push(token);
                  token = {
                    value: line.substring(lastIndex, lastIndex += 500),
                    type: "overflow"
                  };
                }
                currentState = "start";
                stack = [];
                break;
              }
            }
            if (token.type)
              tokens.push(token);
            if (stack.length > 1) {
              if (stack[0] !== currentState)
                stack.unshift("#tmp", currentState);
            }
            return {
              tokens,
              state: stack.length ? stack : currentState
            };
          };
          return Tokenizer2;
        }()
      );
      Tokenizer.prototype.reportError = config.reportError;
      exports3.Tokenizer = Tokenizer;
    });
    ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/lang"], function(require2, exports3, module3) {
      var lang = require2("../lib/lang");
      var TextHighlightRules = function() {
        this.$rules = {
          "start": [{
            token: "empty_line",
            regex: "^$"
          }, {
            defaultToken: "text"
          }]
        };
      };
      (function() {
        this.addRules = function(rules, prefix) {
          if (!prefix) {
            for (var key in rules)
              this.$rules[key] = rules[key];
            return;
          }
          for (var key in rules) {
            var state = rules[key];
            for (var i2 = 0; i2 < state.length; i2++) {
              var rule = state[i2];
              if (rule.next || rule.onMatch) {
                if (typeof rule.next == "string") {
                  if (rule.next.indexOf(prefix) !== 0)
                    rule.next = prefix + rule.next;
                }
                if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                  rule.nextState = prefix + rule.nextState;
              }
            }
            this.$rules[prefix + key] = state;
          }
        };
        this.getRules = function() {
          return this.$rules;
        };
        this.embedRules = function(HighlightRules, prefix, escapeRules, states, append) {
          var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
          if (states) {
            for (var i2 = 0; i2 < states.length; i2++)
              states[i2] = prefix + states[i2];
          } else {
            states = [];
            for (var key in embedRules)
              states.push(prefix + key);
          }
          this.addRules(embedRules, prefix);
          if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i2 = 0; i2 < states.length; i2++)
              addRules.apply(this.$rules[states[i2]], lang.deepCopy(escapeRules));
          }
          if (!this.$embeds)
            this.$embeds = [];
          this.$embeds.push(prefix);
        };
        this.getEmbeds = function() {
          return this.$embeds;
        };
        var pushState = function(currentState, stack) {
          if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
          return this.nextState;
        };
        var popState = function(currentState, stack) {
          stack.shift();
          return stack.shift() || "start";
        };
        this.normalizeRules = function() {
          var id = 0;
          var rules = this.$rules;
          function processState(key) {
            var state = rules[key];
            state.processed = true;
            for (var i2 = 0; i2 < state.length; i2++) {
              var rule = state[i2];
              var toInsert = null;
              if (Array.isArray(rule)) {
                toInsert = rule;
                rule = {};
              }
              if (!rule.regex && rule.start) {
                rule.regex = rule.start;
                if (!rule.next)
                  rule.next = [];
                rule.next.push({
                  defaultToken: rule.token
                }, {
                  token: rule.token + ".end",
                  regex: rule.end || rule.start,
                  next: "pop"
                });
                rule.token = rule.token + ".start";
                rule.push = true;
              }
              var next = rule.next || rule.push;
              if (next && Array.isArray(next)) {
                var stateName = rule.stateName;
                if (!stateName) {
                  stateName = rule.token;
                  if (typeof stateName != "string")
                    stateName = stateName[0] || "";
                  if (rules[stateName])
                    stateName += id++;
                }
                rules[stateName] = next;
                rule.next = stateName;
                processState(stateName);
              } else if (next == "pop") {
                rule.next = popState;
              }
              if (rule.push) {
                rule.nextState = rule.next || rule.push;
                rule.next = pushState;
                delete rule.push;
              }
              if (rule.rules) {
                for (var r in rule.rules) {
                  if (rules[r]) {
                    if (rules[r].push)
                      rules[r].push.apply(rules[r], rule.rules[r]);
                  } else {
                    rules[r] = rule.rules[r];
                  }
                }
              }
              var includeName = typeof rule == "string" ? rule : rule.include;
              if (includeName) {
                if (includeName === "$self")
                  includeName = "start";
                if (Array.isArray(includeName))
                  toInsert = includeName.map(function(x2) {
                    return rules[x2];
                  });
                else
                  toInsert = rules[includeName];
              }
              if (toInsert) {
                var args = [i2, 1].concat(toInsert);
                if (rule.noEscape)
                  args = args.filter(function(x2) {
                    return !x2.next;
                  });
                state.splice.apply(state, args);
                i2--;
              }
              if (rule.keywordMap) {
                rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                delete rule.defaultToken;
              }
            }
          }
          Object.keys(rules).forEach(processState, this);
        };
        this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
          var keywords = /* @__PURE__ */ Object.create(null);
          this.$keywordList = [];
          Object.keys(map).forEach(function(className) {
            var a3 = map[className];
            var list = a3.split(splitChar || "|");
            for (var i2 = list.length; i2--; ) {
              var word = list[i2];
              this.$keywordList.push(word);
              if (ignoreCase)
                word = word.toLowerCase();
              keywords[word] = className;
            }
          }, this);
          map = null;
          return ignoreCase ? function(value) {
            return keywords[value.toLowerCase()] || defaultToken;
          } : function(value) {
            return keywords[value] || defaultToken;
          };
        };
        this.getKeywords = function() {
          return this.$keywords;
        };
      }).call(TextHighlightRules.prototype);
      exports3.TextHighlightRules = TextHighlightRules;
    });
    ace.define("ace/mode/behaviour", ["require", "exports", "module"], function(require2, exports3, module3) {
      var Behaviour = function() {
        this.$behaviours = {};
      };
      (function() {
        this.add = function(name, action, callback) {
          switch (void 0) {
            case this.$behaviours:
              this.$behaviours = {};
            case this.$behaviours[name]:
              this.$behaviours[name] = {};
          }
          this.$behaviours[name][action] = callback;
        };
        this.addBehaviours = function(behaviours) {
          for (var key in behaviours) {
            for (var action in behaviours[key]) {
              this.add(key, action, behaviours[key][action]);
            }
          }
        };
        this.remove = function(name) {
          if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
          }
        };
        this.inherit = function(mode, filter2) {
          if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter2);
          } else {
            var behaviours = mode.getBehaviours(filter2);
          }
          this.addBehaviours(behaviours);
        };
        this.getBehaviours = function(filter2) {
          if (!filter2) {
            return this.$behaviours;
          } else {
            var ret = {};
            for (var i2 = 0; i2 < filter2.length; i2++) {
              if (this.$behaviours[filter2[i2]]) {
                ret[filter2[i2]] = this.$behaviours[filter2[i2]];
              }
            }
            return ret;
          }
        };
      }).call(Behaviour.prototype);
      exports3.Behaviour = Behaviour;
    });
    ace.define("ace/token_iterator", ["require", "exports", "module", "ace/range"], function(require2, exports3, module3) {
      var Range = require2("./range").Range;
      var TokenIterator = (
        /** @class */
        function() {
          function TokenIterator2(session, initialRow, initialColumn) {
            this.$session = session;
            this.$row = initialRow;
            this.$rowTokens = session.getTokens(initialRow);
            var token = session.getTokenAt(initialRow, initialColumn);
            this.$tokenIndex = token ? token.index : -1;
          }
          TokenIterator2.prototype.stepBackward = function() {
            this.$tokenIndex -= 1;
            while (this.$tokenIndex < 0) {
              this.$row -= 1;
              if (this.$row < 0) {
                this.$row = 0;
                return null;
              }
              this.$rowTokens = this.$session.getTokens(this.$row);
              this.$tokenIndex = this.$rowTokens.length - 1;
            }
            return this.$rowTokens[this.$tokenIndex];
          };
          TokenIterator2.prototype.stepForward = function() {
            this.$tokenIndex += 1;
            var rowCount;
            while (this.$tokenIndex >= this.$rowTokens.length) {
              this.$row += 1;
              if (!rowCount)
                rowCount = this.$session.getLength();
              if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
              }
              this.$rowTokens = this.$session.getTokens(this.$row);
              this.$tokenIndex = 0;
            }
            return this.$rowTokens[this.$tokenIndex];
          };
          TokenIterator2.prototype.getCurrentToken = function() {
            return this.$rowTokens[this.$tokenIndex];
          };
          TokenIterator2.prototype.getCurrentTokenRow = function() {
            return this.$row;
          };
          TokenIterator2.prototype.getCurrentTokenColumn = function() {
            var rowTokens = this.$rowTokens;
            var tokenIndex = this.$tokenIndex;
            var column = rowTokens[tokenIndex].start;
            if (column !== void 0)
              return column;
            column = 0;
            while (tokenIndex > 0) {
              tokenIndex -= 1;
              column += rowTokens[tokenIndex].value.length;
            }
            return column;
          };
          TokenIterator2.prototype.getCurrentTokenPosition = function() {
            return { row: this.$row, column: this.getCurrentTokenColumn() };
          };
          TokenIterator2.prototype.getCurrentTokenRange = function() {
            var token = this.$rowTokens[this.$tokenIndex];
            var column = this.getCurrentTokenColumn();
            return new Range(this.$row, column, this.$row, column + token.value.length);
          };
          return TokenIterator2;
        }()
      );
      exports3.TokenIterator = TokenIterator;
    });
    ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function(require2, exports3, module3) {
      var oop = require2("../../lib/oop");
      var Behaviour = require2("../behaviour").Behaviour;
      var TokenIterator = require2("../../token_iterator").TokenIterator;
      var lang = require2("../../lib/lang");
      var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"];
      var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"];
      var context;
      var contextCache = {};
      var defaultQuotes = { '"': '"', "'": "'" };
      var initContext = function(editor) {
        var id = -1;
        if (editor.multiSelect) {
          id = editor.selection.index;
          if (contextCache.rangeCount != editor.multiSelect.rangeCount)
            contextCache = { rangeCount: editor.multiSelect.rangeCount };
        }
        if (contextCache[id])
          return context = contextCache[id];
        context = contextCache[id] = {
          autoInsertedBrackets: 0,
          autoInsertedRow: -1,
          autoInsertedLineEnd: "",
          maybeInsertedBrackets: 0,
          maybeInsertedRow: -1,
          maybeInsertedLineStart: "",
          maybeInsertedLineEnd: ""
        };
      };
      var getWrapped = function(selection, selected, opening, closing2) {
        var rowDiff = selection.end.row - selection.start.row;
        return {
          text: opening + selected + closing2,
          selection: [
            0,
            selection.start.column + 1,
            rowDiff,
            selection.end.column + (rowDiff ? 0 : 1)
          ]
        };
      };
      var CstyleBehaviour = function(options) {
        this.add("braces", "insertion", function(state, action, editor, session, text) {
          var cursor = editor.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          if (text == "{") {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, "{", "}");
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options && options.braces) {
                CstyleBehaviour.recordAutoInsert(editor, session, "}");
                return {
                  text: "{}",
                  selection: [1, 1]
                };
              } else {
                CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                return {
                  text: "{",
                  selection: [1, 1]
                };
              }
            }
          } else if (text == "}") {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == "}") {
              var matching = session.$findOpeningBracket("}", { column: cursor.column + 1, row: cursor.row });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          } else if (text == "\n" || text == "\r\n") {
            initContext(editor);
            var closing2 = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
              closing2 = lang.stringRepeat("}", context.maybeInsertedBrackets);
              CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === "}") {
              var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, "}");
              if (!openBracePos)
                return null;
              var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing2) {
              var next_indent = this.$getIndent(line);
            } else {
              CstyleBehaviour.clearMaybeInsertedClosing();
              return;
            }
            var indent = next_indent + session.getTabString();
            return {
              text: "\n" + indent + "\n" + next_indent + closing2,
              selection: [1, indent.length, 1, indent.length]
            };
          } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
          }
        });
        this.add("braces", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == "{") {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == "}") {
              range.end.column++;
              return range;
            } else {
              context.maybeInsertedBrackets--;
            }
          }
        });
        this.add("parens", "insertion", function(state, action, editor, session, text) {
          if (text == "(") {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, "(", ")");
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              CstyleBehaviour.recordAutoInsert(editor, session, ")");
              return {
                text: "()",
                selection: [1, 1]
              };
            }
          } else if (text == ")") {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ")") {
              var matching = session.$findOpeningBracket(")", { column: cursor.column + 1, row: cursor.row });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("parens", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == "(") {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ")") {
              range.end.column++;
              return range;
            }
          }
        });
        this.add("brackets", "insertion", function(state, action, editor, session, text) {
          if (text == "[") {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, "[", "]");
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              CstyleBehaviour.recordAutoInsert(editor, session, "]");
              return {
                text: "[]",
                selection: [1, 1]
              };
            }
          } else if (text == "]") {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == "]") {
              var matching = session.$findOpeningBracket("]", { column: cursor.column + 1, row: cursor.row });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("brackets", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == "[") {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == "]") {
              range.end.column++;
              return range;
            }
          }
        });
        this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
          var quotes = session.$mode.$quotes || defaultQuotes;
          if (text.length == 1 && quotes[text]) {
            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)
              return;
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, quote, quote);
            } else if (!selected) {
              var cursor = editor.getCursorPosition();
              var line = session.doc.getLine(cursor.row);
              var leftChar = line.substring(cursor.column - 1, cursor.column);
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              var token = session.getTokenAt(cursor.row, cursor.column);
              var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
              if (leftChar == "\\" && token && /escape/.test(token.type))
                return null;
              var stringBefore = token && /string|escape/.test(token.type);
              var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
              var pair;
              if (rightChar == quote) {
                pair = stringBefore !== stringAfter;
                if (pair && /string\.end/.test(rightToken.type))
                  pair = false;
              } else {
                if (stringBefore && !stringAfter)
                  return null;
                if (stringBefore && stringAfter)
                  return null;
                var wordRe = session.$mode.tokenRe;
                wordRe.lastIndex = 0;
                var isWordBefore = wordRe.test(leftChar);
                wordRe.lastIndex = 0;
                var isWordAfter = wordRe.test(rightChar);
                var pairQuotesAfter = session.$mode.$pairQuotesAfter;
                var shouldPairQuotes = pairQuotesAfter && pairQuotesAfter[quote] && pairQuotesAfter[quote].test(leftChar);
                if (!shouldPairQuotes && isWordBefore || isWordAfter)
                  return null;
                if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                  return null;
                var charBefore = line[cursor.column - 2];
                if (leftChar == quote && (charBefore == quote || wordRe.test(charBefore)))
                  return null;
                pair = true;
              }
              return {
                text: pair ? quote + quote : "",
                selection: [1, 1]
              };
            }
          }
        });
        this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
          var quotes = session.$mode.$quotes || defaultQuotes;
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
              range.end.column++;
              return range;
            }
          }
        });
      };
      CstyleBehaviour.isSaneInsertion = function(editor, session) {
        var cursor = editor.getCursorPosition();
        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
          if (/[)}\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))
            return true;
          var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
          if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
            return false;
        }
        iterator.stepForward();
        return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
      };
      CstyleBehaviour.$matchTokenType = function(token, types) {
        return types.indexOf(token.type || token) > -1;
      };
      CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
          context.autoInsertedBrackets = 0;
        context.autoInsertedRow = cursor.row;
        context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
        context.autoInsertedBrackets++;
      };
      CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this.isMaybeInsertedClosing(cursor, line))
          context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = cursor.row;
        context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
        context.maybeInsertedLineEnd = line.substr(cursor.column);
        context.maybeInsertedBrackets++;
      };
      CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
        return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
      };
      CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
        return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
      };
      CstyleBehaviour.popAutoInsertedClosing = function() {
        context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
        context.autoInsertedBrackets--;
      };
      CstyleBehaviour.clearMaybeInsertedClosing = function() {
        if (context) {
          context.maybeInsertedBrackets = 0;
          context.maybeInsertedRow = -1;
        }
      };
      oop.inherits(CstyleBehaviour, Behaviour);
      exports3.CstyleBehaviour = CstyleBehaviour;
    });
    ace.define("ace/unicode", ["require", "exports", "module"], function(require2, exports3, module3) {
      var wordChars = [48, 9, 8, 25, 5, 0, 2, 25, 48, 0, 11, 0, 5, 0, 6, 22, 2, 30, 2, 457, 5, 11, 15, 4, 8, 0, 2, 0, 18, 116, 2, 1, 3, 3, 9, 0, 2, 2, 2, 0, 2, 19, 2, 82, 2, 138, 2, 4, 3, 155, 12, 37, 3, 0, 8, 38, 10, 44, 2, 0, 2, 1, 2, 1, 2, 0, 9, 26, 6, 2, 30, 10, 7, 61, 2, 9, 5, 101, 2, 7, 3, 9, 2, 18, 3, 0, 17, 58, 3, 100, 15, 53, 5, 0, 6, 45, 211, 57, 3, 18, 2, 5, 3, 11, 3, 9, 2, 1, 7, 6, 2, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 0, 4, 3, 3, 8, 3, 1, 3, 3, 9, 0, 5, 1, 2, 4, 3, 11, 16, 2, 2, 5, 5, 1, 3, 21, 2, 6, 2, 1, 2, 1, 2, 1, 3, 0, 2, 4, 5, 1, 3, 2, 4, 0, 8, 3, 2, 0, 8, 15, 12, 2, 2, 8, 2, 2, 2, 21, 2, 6, 2, 1, 2, 4, 3, 9, 2, 2, 2, 2, 3, 0, 16, 3, 3, 9, 18, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 3, 8, 3, 1, 3, 2, 9, 1, 5, 1, 2, 4, 3, 9, 2, 0, 17, 1, 2, 5, 4, 2, 2, 3, 4, 1, 2, 0, 2, 1, 4, 1, 4, 2, 4, 11, 5, 4, 4, 2, 2, 3, 3, 0, 7, 0, 15, 9, 18, 2, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 4, 7, 2, 2, 2, 3, 8, 1, 2, 1, 7, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 3, 8, 2, 2, 2, 3, 8, 1, 8, 0, 2, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 15, 4, 7, 2, 2, 2, 3, 10, 0, 9, 3, 3, 9, 11, 5, 3, 1, 2, 17, 4, 23, 2, 8, 2, 0, 3, 6, 4, 0, 5, 5, 2, 0, 2, 7, 19, 1, 14, 57, 6, 14, 2, 9, 40, 1, 2, 0, 3, 1, 2, 0, 3, 0, 7, 3, 2, 6, 2, 2, 2, 0, 2, 0, 3, 1, 2, 12, 2, 2, 3, 4, 2, 0, 2, 5, 3, 9, 3, 1, 35, 0, 24, 1, 7, 9, 12, 0, 2, 0, 2, 0, 5, 9, 2, 35, 5, 19, 2, 5, 5, 7, 2, 35, 10, 0, 58, 73, 7, 77, 3, 37, 11, 42, 2, 0, 4, 328, 2, 3, 3, 6, 2, 0, 2, 3, 3, 40, 2, 3, 3, 32, 2, 3, 3, 6, 2, 0, 2, 3, 3, 14, 2, 56, 2, 3, 3, 66, 5, 0, 33, 15, 17, 84, 13, 619, 3, 16, 2, 25, 6, 74, 22, 12, 2, 6, 12, 20, 12, 19, 13, 12, 2, 2, 2, 1, 13, 51, 3, 29, 4, 0, 5, 1, 3, 9, 34, 2, 3, 9, 7, 87, 9, 42, 6, 69, 11, 28, 4, 11, 5, 11, 11, 39, 3, 4, 12, 43, 5, 25, 7, 10, 38, 27, 5, 62, 2, 28, 3, 10, 7, 9, 14, 0, 89, 75, 5, 9, 18, 8, 13, 42, 4, 11, 71, 55, 9, 9, 4, 48, 83, 2, 2, 30, 14, 230, 23, 280, 3, 5, 3, 37, 3, 5, 3, 7, 2, 0, 2, 0, 2, 0, 2, 30, 3, 52, 2, 6, 2, 0, 4, 2, 2, 6, 4, 3, 3, 5, 5, 12, 6, 2, 2, 6, 67, 1, 20, 0, 29, 0, 14, 0, 17, 4, 60, 12, 5, 0, 4, 11, 18, 0, 5, 0, 3, 9, 2, 0, 4, 4, 7, 0, 2, 0, 2, 0, 2, 3, 2, 10, 3, 3, 6, 4, 5, 0, 53, 1, 2684, 46, 2, 46, 2, 132, 7, 6, 15, 37, 11, 53, 10, 0, 17, 22, 10, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 31, 48, 0, 470, 1, 36, 5, 2, 4, 6, 1, 5, 85, 3, 1, 3, 2, 2, 89, 2, 3, 6, 40, 4, 93, 18, 23, 57, 15, 513, 6581, 75, 20939, 53, 1164, 68, 45, 3, 268, 4, 27, 21, 31, 3, 13, 13, 1, 2, 24, 9, 69, 11, 1, 38, 8, 3, 102, 3, 1, 111, 44, 25, 51, 13, 68, 12, 9, 7, 23, 4, 0, 5, 45, 3, 35, 13, 28, 4, 64, 15, 10, 39, 54, 10, 13, 3, 9, 7, 22, 4, 1, 5, 66, 25, 2, 227, 42, 2, 1, 3, 9, 7, 11171, 13, 22, 5, 48, 8453, 301, 3, 61, 3, 105, 39, 6, 13, 4, 6, 11, 2, 12, 2, 4, 2, 0, 2, 1, 2, 1, 2, 107, 34, 362, 19, 63, 3, 53, 41, 11, 5, 15, 17, 6, 13, 1, 25, 2, 33, 4, 2, 134, 20, 9, 8, 25, 5, 0, 2, 25, 12, 88, 4, 5, 3, 5, 3, 5, 3, 2];
      var code = 0;
      var str = [];
      for (var i2 = 0; i2 < wordChars.length; i2 += 2) {
        str.push(code += wordChars[i2]);
        if (wordChars[i2 + 1])
          str.push(45, code += wordChars[i2 + 1]);
      }
      exports3.wordChars = String.fromCharCode.apply(null, str);
    });
    ace.define("ace/mode/text", ["require", "exports", "module", "ace/config", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour/cstyle", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function(require2, exports3, module3) {
      var config = require2("../config");
      var Tokenizer = require2("../tokenizer").Tokenizer;
      var TextHighlightRules = require2("./text_highlight_rules").TextHighlightRules;
      var CstyleBehaviour = require2("./behaviour/cstyle").CstyleBehaviour;
      var unicode = require2("../unicode");
      var lang = require2("../lib/lang");
      var TokenIterator = require2("../token_iterator").TokenIterator;
      var Range = require2("../range").Range;
      var Mode = function() {
        this.HighlightRules = TextHighlightRules;
      };
      (function() {
        this.$defaultBehaviour = new CstyleBehaviour();
        this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");
        this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");
        this.getTokenizer = function() {
          if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
          }
          return this.$tokenizer;
        };
        this.lineCommentStart = "";
        this.blockComment = "";
        this.toggleCommentLines = function(state, session, startRow, endRow) {
          var doc = session.doc;
          var ignoreBlankLines = true;
          var shouldRemove = true;
          var minIndent = Infinity;
          var tabSize = session.getTabSize();
          var insertAtTabStop = false;
          if (!this.lineCommentStart) {
            if (!this.blockComment)
              return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
            var comment = function(line, i2) {
              if (testRemove(line, i2))
                return;
              if (!ignoreBlankLines || /\S/.test(line)) {
                doc.insertInLine({ row: i2, column: line.length }, lineCommentEnd);
                doc.insertInLine({ row: i2, column: minIndent }, lineCommentStart);
              }
            };
            var uncomment = function(line, i2) {
              var m3;
              if (m3 = line.match(regexpEnd))
                doc.removeInLine(i2, line.length - m3[0].length, line.length);
              if (m3 = line.match(regexpStart))
                doc.removeInLine(i2, m3[1].length, m3[0].length);
            };
            var testRemove = function(line, row) {
              if (regexpStart.test(line))
                return true;
              var tokens = session.getTokens(row);
              for (var i2 = 0; i2 < tokens.length; i2++) {
                if (tokens[i2].type === "comment")
                  return true;
              }
            };
          } else {
            if (Array.isArray(this.lineCommentStart)) {
              var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
              var lineCommentStart = this.lineCommentStart[0];
            } else {
              var regexpStart = lang.escapeRegExp(this.lineCommentStart);
              var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
            insertAtTabStop = session.getUseSoftTabs();
            var uncomment = function(line, i2) {
              var m3 = line.match(regexpStart);
              if (!m3)
                return;
              var start = m3[1].length, end = m3[0].length;
              if (!shouldInsertSpace(line, start, end) && m3[0][end - 1] == " ")
                end--;
              doc.removeInLine(i2, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function(line, i2) {
              if (!ignoreBlankLines || /\S/.test(line)) {
                if (shouldInsertSpace(line, minIndent, minIndent))
                  doc.insertInLine({ row: i2, column: minIndent }, commentWithSpace);
                else
                  doc.insertInLine({ row: i2, column: minIndent }, lineCommentStart);
              }
            };
            var testRemove = function(line, i2) {
              return regexpStart.test(line);
            };
            var shouldInsertSpace = function(line, before, after) {
              var spaces = 0;
              while (before-- && line.charAt(before) == " ")
                spaces++;
              if (spaces % tabSize != 0)
                return false;
              var spaces = 0;
              while (line.charAt(after++) == " ")
                spaces++;
              if (tabSize > 2)
                return spaces % tabSize != tabSize - 1;
              else
                return spaces % tabSize == 0;
            };
          }
          function iter(fun) {
            for (var i2 = startRow; i2 <= endRow; i2++)
              fun(doc.getLine(i2), i2);
          }
          var minEmptyLength = Infinity;
          iter(function(line, i2) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
              if (indent < minIndent)
                minIndent = indent;
              if (shouldRemove && !testRemove(line, i2))
                shouldRemove = false;
            } else if (minEmptyLength > line.length) {
              minEmptyLength = line.length;
            }
          });
          if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
          }
          if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;
          iter(shouldRemove ? uncomment : comment);
        };
        this.toggleBlockComment = function(state, session, range, cursor) {
          var comment = this.blockComment;
          if (!comment)
            return;
          if (!comment.start && comment[0])
            comment = comment[0];
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          var token = iterator.getCurrentToken();
          session.selection;
          var initialRange = session.selection.toOrientedRange();
          var startRow, colDiff;
          if (token && /comment/.test(token.type)) {
            var startRange, endRange;
            while (token && /comment/.test(token.type)) {
              var i2 = token.value.indexOf(comment.start);
              if (i2 != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i2;
                startRange = new Range(row, column, row, column + comment.start.length);
                break;
              }
              token = iterator.stepBackward();
            }
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
              var i2 = token.value.indexOf(comment.end);
              if (i2 != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i2;
                endRange = new Range(row, column, row, column + comment.end.length);
                break;
              }
              token = iterator.stepForward();
            }
            if (endRange)
              session.remove(endRange);
            if (startRange) {
              session.remove(startRange);
              startRow = startRange.start.row;
              colDiff = -comment.start.length;
            }
          } else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
          }
          if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
          if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
          session.selection.fromOrientedRange(initialRange);
        };
        this.getNextLineIndent = function(state, line, tab) {
          return this.$getIndent(line);
        };
        this.checkOutdent = function(state, line, input) {
          return false;
        };
        this.autoOutdent = function(state, doc, row) {
        };
        this.$getIndent = function(line) {
          return line.match(/^\s*/)[0];
        };
        this.createWorker = function(session) {
          return null;
        };
        this.createModeDelegates = function(mapping) {
          this.$embeds = [];
          this.$modes = {};
          for (var i2 in mapping) {
            if (mapping[i2]) {
              var Mode2 = mapping[i2];
              var id = Mode2.prototype.$id;
              var mode = config.$modes[id];
              if (!mode)
                config.$modes[id] = mode = new Mode2();
              if (!config.$modes[i2])
                config.$modes[i2] = mode;
              this.$embeds.push(i2);
              this.$modes[i2] = mode;
            }
          }
          var delegations = [
            "toggleBlockComment",
            "toggleCommentLines",
            "getNextLineIndent",
            "checkOutdent",
            "autoOutdent",
            "transformAction",
            "getCompletions"
          ];
          for (var i2 = 0; i2 < delegations.length; i2++) {
            (function(scope) {
              var functionName = delegations[i2];
              var defaultHandler = scope[functionName];
              scope[delegations[i2]] = function() {
                return this.$delegator(functionName, arguments, defaultHandler);
              };
            })(this);
          }
        };
        this.$delegator = function(method, args, defaultHandler) {
          var state = args[0] || "start";
          if (typeof state != "string") {
            if (Array.isArray(state[2])) {
              var language = state[2][state[2].length - 1];
              var mode = this.$modes[language];
              if (mode)
                return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));
            }
            state = state[0] || "start";
          }
          for (var i2 = 0; i2 < this.$embeds.length; i2++) {
            if (!this.$modes[this.$embeds[i2]])
              continue;
            var split2 = state.split(this.$embeds[i2]);
            if (!split2[0] && split2[1]) {
              args[0] = split2[1];
              var mode = this.$modes[this.$embeds[i2]];
              return mode[method].apply(mode, args);
            }
          }
          var ret = defaultHandler.apply(this, args);
          return defaultHandler ? ret : void 0;
        };
        this.transformAction = function(state, action, editor, session, param) {
          if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
              if (behaviours[key][action]) {
                var ret = behaviours[key][action].apply(this, arguments);
                if (ret) {
                  return ret;
                }
              }
            }
          }
        };
        this.getKeywords = function(append) {
          if (!this.completionKeywords) {
            var rules = this.$tokenizer.rules;
            var completionKeywords = [];
            for (var rule in rules) {
              var ruleItr = rules[rule];
              for (var r = 0, l = ruleItr.length; r < l; r++) {
                if (typeof ruleItr[r].token === "string") {
                  if (/keyword|support|storage/.test(ruleItr[r].token))
                    completionKeywords.push(ruleItr[r].regex);
                } else if (typeof ruleItr[r].token === "object") {
                  for (var a3 = 0, aLength = ruleItr[r].token.length; a3 < aLength; a3++) {
                    if (/keyword|support|storage/.test(ruleItr[r].token[a3])) {
                      var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a3];
                      completionKeywords.push(rule.substr(1, rule.length - 2));
                    }
                  }
                }
              }
            }
            this.completionKeywords = completionKeywords;
          }
          if (!append)
            return this.$keywordList;
          return completionKeywords.concat(this.$keywordList || []);
        };
        this.$createKeywordList = function() {
          if (!this.$highlightRules)
            this.getTokenizer();
          return this.$keywordList = this.$highlightRules.$keywordList || [];
        };
        this.getCompletions = function(state, session, pos, prefix) {
          var keywords = this.$keywordList || this.$createKeywordList();
          return keywords.map(function(word) {
            return {
              name: word,
              value: word,
              score: 0,
              meta: "keyword"
            };
          });
        };
        this.$id = "ace/mode/text";
      }).call(Mode.prototype);
      exports3.Mode = Mode;
    });
    ace.define("ace/apply_delta", ["require", "exports", "module"], function(require2, exports3, module3) {
      exports3.applyDelta = function(docLines, delta, doNotValidate) {
        var row = delta.start.row;
        var startColumn = delta.start.column;
        var line = docLines[row] || "";
        switch (delta.action) {
          case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
              docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
              var args = [row, 1].concat(delta.lines);
              docLines.splice.apply(docLines, args);
              docLines[row] = line.substring(0, startColumn) + docLines[row];
              docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
          case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
              docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
              docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
            }
            break;
        }
      };
    });
    ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      var oop = require2("./lib/oop");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Anchor = (
        /** @class */
        function() {
          function Anchor2(doc, row, column) {
            this.$onChange = this.onChange.bind(this);
            this.attach(doc);
            if (typeof column == "undefined")
              this.setPosition(row.row, row.column);
            else
              this.setPosition(row, column);
          }
          Anchor2.prototype.getPosition = function() {
            return this.$clipPositionToDocument(this.row, this.column);
          };
          Anchor2.prototype.getDocument = function() {
            return this.document;
          };
          Anchor2.prototype.onChange = function(delta) {
            if (delta.start.row == delta.end.row && delta.start.row != this.row)
              return;
            if (delta.start.row > this.row)
              return;
            var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
            this.setPosition(point.row, point.column, true);
          };
          Anchor2.prototype.setPosition = function(row, column, noClip) {
            var pos;
            if (noClip) {
              pos = {
                row,
                column
              };
            } else {
              pos = this.$clipPositionToDocument(row, column);
            }
            if (this.row == pos.row && this.column == pos.column)
              return;
            var old = {
              row: this.row,
              column: this.column
            };
            this.row = pos.row;
            this.column = pos.column;
            this._signal("change", {
              old,
              value: pos
            });
          };
          Anchor2.prototype.detach = function() {
            this.document.off("change", this.$onChange);
          };
          Anchor2.prototype.attach = function(doc) {
            this.document = doc || this.document;
            this.document.on("change", this.$onChange);
          };
          Anchor2.prototype.$clipPositionToDocument = function(row, column) {
            var pos = {};
            if (row >= this.document.getLength()) {
              pos.row = Math.max(0, this.document.getLength() - 1);
              pos.column = this.document.getLine(pos.row).length;
            } else if (row < 0) {
              pos.row = 0;
              pos.column = 0;
            } else {
              pos.row = row;
              pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
            }
            if (column < 0)
              pos.column = 0;
            return pos;
          };
          return Anchor2;
        }()
      );
      Anchor.prototype.$insertRight = false;
      oop.implement(Anchor.prototype, EventEmitter);
      function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
        return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
      }
      function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == "insert";
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end;
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
          return {
            row: point.row,
            column: point.column
          };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
          return {
            row: point.row + deltaRowShift,
            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
          };
        }
        return {
          row: deltaStart.row,
          column: deltaStart.column
        };
      }
      exports3.Anchor = Anchor;
    });
    ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function(require2, exports3, module3) {
      var oop = require2("./lib/oop");
      var applyDelta = require2("./apply_delta").applyDelta;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Range = require2("./range").Range;
      var Anchor = require2("./anchor").Anchor;
      var Document2 = (
        /** @class */
        function() {
          function Document3(textOrLines) {
            this.$lines = [""];
            if (textOrLines.length === 0) {
              this.$lines = [""];
            } else if (Array.isArray(textOrLines)) {
              this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
            } else {
              this.insert({ row: 0, column: 0 }, textOrLines);
            }
          }
          Document3.prototype.setValue = function(text) {
            var len = this.getLength() - 1;
            this.remove(new Range(0, 0, len, this.getLine(len).length));
            this.insert({ row: 0, column: 0 }, text || "");
          };
          Document3.prototype.getValue = function() {
            return this.getAllLines().join(this.getNewLineCharacter());
          };
          Document3.prototype.createAnchor = function(row, column) {
            return new Anchor(this, row, column);
          };
          Document3.prototype.$detectNewLine = function(text) {
            var match2 = text.match(/^.*?(\r\n|\r|\n)/m);
            this.$autoNewLine = match2 ? match2[1] : "\n";
            this._signal("changeNewLineMode");
          };
          Document3.prototype.getNewLineCharacter = function() {
            switch (this.$newLineMode) {
              case "windows":
                return "\r\n";
              case "unix":
                return "\n";
              default:
                return this.$autoNewLine || "\n";
            }
          };
          Document3.prototype.setNewLineMode = function(newLineMode) {
            if (this.$newLineMode === newLineMode)
              return;
            this.$newLineMode = newLineMode;
            this._signal("changeNewLineMode");
          };
          Document3.prototype.getNewLineMode = function() {
            return this.$newLineMode;
          };
          Document3.prototype.isNewLine = function(text) {
            return text == "\r\n" || text == "\r" || text == "\n";
          };
          Document3.prototype.getLine = function(row) {
            return this.$lines[row] || "";
          };
          Document3.prototype.getLines = function(firstRow, lastRow) {
            return this.$lines.slice(firstRow, lastRow + 1);
          };
          Document3.prototype.getAllLines = function() {
            return this.getLines(0, this.getLength());
          };
          Document3.prototype.getLength = function() {
            return this.$lines.length;
          };
          Document3.prototype.getTextRange = function(range) {
            return this.getLinesForRange(range).join(this.getNewLineCharacter());
          };
          Document3.prototype.getLinesForRange = function(range) {
            var lines;
            if (range.start.row === range.end.row) {
              lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
            } else {
              lines = this.getLines(range.start.row, range.end.row);
              lines[0] = (lines[0] || "").substring(range.start.column);
              var l = lines.length - 1;
              if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
            }
            return lines;
          };
          Document3.prototype.insertLines = function(row, lines) {
            console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
            return this.insertFullLines(row, lines);
          };
          Document3.prototype.removeLines = function(firstRow, lastRow) {
            console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
            return this.removeFullLines(firstRow, lastRow);
          };
          Document3.prototype.insertNewLine = function(position) {
            console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
            return this.insertMergedLines(position, ["", ""]);
          };
          Document3.prototype.insert = function(position, text) {
            if (this.getLength() <= 1)
              this.$detectNewLine(text);
            return this.insertMergedLines(position, this.$split(text));
          };
          Document3.prototype.insertInLine = function(position, text) {
            var start = this.clippedPos(position.row, position.column);
            var end = this.pos(position.row, position.column + text.length);
            this.applyDelta({
              start,
              end,
              action: "insert",
              lines: [text]
            }, true);
            return this.clonePos(end);
          };
          Document3.prototype.clippedPos = function(row, column) {
            var length = this.getLength();
            if (row === void 0) {
              row = length;
            } else if (row < 0) {
              row = 0;
            } else if (row >= length) {
              row = length - 1;
              column = void 0;
            }
            var line = this.getLine(row);
            if (column == void 0)
              column = line.length;
            column = Math.min(Math.max(column, 0), line.length);
            return { row, column };
          };
          Document3.prototype.clonePos = function(pos) {
            return { row: pos.row, column: pos.column };
          };
          Document3.prototype.pos = function(row, column) {
            return { row, column };
          };
          Document3.prototype.$clipPosition = function(position) {
            var length = this.getLength();
            if (position.row >= length) {
              position.row = Math.max(0, length - 1);
              position.column = this.getLine(length - 1).length;
            } else {
              position.row = Math.max(0, position.row);
              position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
            }
            return position;
          };
          Document3.prototype.insertFullLines = function(row, lines) {
            row = Math.min(Math.max(row, 0), this.getLength());
            var column = 0;
            if (row < this.getLength()) {
              lines = lines.concat([""]);
              column = 0;
            } else {
              lines = [""].concat(lines);
              row--;
              column = this.$lines[row].length;
            }
            this.insertMergedLines({ row, column }, lines);
          };
          Document3.prototype.insertMergedLines = function(position, lines) {
            var start = this.clippedPos(position.row, position.column);
            var end = {
              row: start.row + lines.length - 1,
              column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
            };
            this.applyDelta({
              start,
              end,
              action: "insert",
              lines
            });
            return this.clonePos(end);
          };
          Document3.prototype.remove = function(range) {
            var start = this.clippedPos(range.start.row, range.start.column);
            var end = this.clippedPos(range.end.row, range.end.column);
            this.applyDelta({
              start,
              end,
              action: "remove",
              lines: this.getLinesForRange({ start, end })
            });
            return this.clonePos(start);
          };
          Document3.prototype.removeInLine = function(row, startColumn, endColumn) {
            var start = this.clippedPos(row, startColumn);
            var end = this.clippedPos(row, endColumn);
            this.applyDelta({
              start,
              end,
              action: "remove",
              lines: this.getLinesForRange({ start, end })
            }, true);
            return this.clonePos(start);
          };
          Document3.prototype.removeFullLines = function(firstRow, lastRow) {
            firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
            lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
            var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
            var deleteLastNewLine = lastRow < this.getLength() - 1;
            var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
            var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
            var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
            var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
            var range = new Range(startRow, startCol, endRow, endCol);
            var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
            this.applyDelta({
              start: range.start,
              end: range.end,
              action: "remove",
              lines: this.getLinesForRange(range)
            });
            return deletedLines;
          };
          Document3.prototype.removeNewLine = function(row) {
            if (row < this.getLength() - 1 && row >= 0) {
              this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
              });
            }
          };
          Document3.prototype.replace = function(range, text) {
            if (!(range instanceof Range))
              range = Range.fromPoints(range.start, range.end);
            if (text.length === 0 && range.isEmpty())
              return range.start;
            if (text == this.getTextRange(range))
              return range.end;
            this.remove(range);
            var end;
            if (text) {
              end = this.insert(range.start, text);
            } else {
              end = range.start;
            }
            return end;
          };
          Document3.prototype.applyDeltas = function(deltas) {
            for (var i2 = 0; i2 < deltas.length; i2++) {
              this.applyDelta(deltas[i2]);
            }
          };
          Document3.prototype.revertDeltas = function(deltas) {
            for (var i2 = deltas.length - 1; i2 >= 0; i2--) {
              this.revertDelta(deltas[i2]);
            }
          };
          Document3.prototype.applyDelta = function(delta, doNotValidate) {
            var isInsert = delta.action == "insert";
            if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {
              return;
            }
            if (isInsert && delta.lines.length > 2e4) {
              this.$splitAndapplyLargeDelta(delta, 2e4);
            } else {
              applyDelta(this.$lines, delta, doNotValidate);
              this._signal("change", delta);
            }
          };
          Document3.prototype.$safeApplyDelta = function(delta) {
            var docLength = this.$lines.length;
            if (delta.action == "remove" && delta.start.row < docLength && delta.end.row < docLength || delta.action == "insert" && delta.start.row <= docLength) {
              this.applyDelta(delta);
            }
          };
          Document3.prototype.$splitAndapplyLargeDelta = function(delta, MAX) {
            var lines = delta.lines;
            var l = lines.length - MAX + 1;
            var row = delta.start.row;
            var column = delta.start.column;
            for (var from = 0, to = 0; from < l; from = to) {
              to += MAX - 1;
              var chunk = lines.slice(from, to);
              chunk.push("");
              this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
              }, true);
            }
            delta.lines = lines.slice(from);
            delta.start.row = row + from;
            delta.start.column = column;
            this.applyDelta(delta, true);
          };
          Document3.prototype.revertDelta = function(delta) {
            this.$safeApplyDelta({
              start: this.clonePos(delta.start),
              end: this.clonePos(delta.end),
              action: delta.action == "insert" ? "remove" : "insert",
              lines: delta.lines.slice()
            });
          };
          Document3.prototype.indexToPosition = function(index, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            for (var i2 = startRow || 0, l = lines.length; i2 < l; i2++) {
              index -= lines[i2].length + newlineLength;
              if (index < 0)
                return { row: i2, column: index + lines[i2].length + newlineLength };
            }
            return { row: l - 1, column: index + lines[l - 1].length + newlineLength };
          };
          Document3.prototype.positionToIndex = function(pos, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            var index = 0;
            var row = Math.min(pos.row, lines.length);
            for (var i2 = startRow || 0; i2 < row; ++i2)
              index += lines[i2].length + newlineLength;
            return index + pos.column;
          };
          return Document3;
        }()
      );
      Document2.prototype.$split = "aaa".split(/a/).length === 0 ? function(text) {
        return text.replace(/\r\n|\r/g, "\n").split("\n");
      } : function(text) {
        return text.split(/\r\n|\r|\n/);
      };
      Document2.prototype.$autoNewLine = "";
      Document2.prototype.$newLineMode = "auto";
      oop.implement(Document2.prototype, EventEmitter);
      exports3.Document = Document2;
    });
    ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      var oop = require2("./lib/oop");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var BackgroundTokenizer = (
        /** @class */
        function() {
          function BackgroundTokenizer2(tokenizer, editor) {
            this.running = false;
            this.lines = [];
            this.states = [];
            this.currentLine = 0;
            this.tokenizer = tokenizer;
            var self2 = this;
            this.$worker = function() {
              if (!self2.running) {
                return;
              }
              var workerStart = /* @__PURE__ */ new Date();
              var currentLine = self2.currentLine;
              var endLine = -1;
              var doc = self2.doc;
              var startLine = currentLine;
              while (self2.lines[currentLine])
                currentLine++;
              var len = doc.getLength();
              var processedLines = 0;
              self2.running = false;
              while (currentLine < len) {
                self2.$tokenizeRow(currentLine);
                endLine = currentLine;
                do {
                  currentLine++;
                } while (self2.lines[currentLine]);
                processedLines++;
                if (processedLines % 5 === 0 && /* @__PURE__ */ new Date() - workerStart > 20) {
                  self2.running = setTimeout(self2.$worker, 20);
                  break;
                }
              }
              self2.currentLine = currentLine;
              if (endLine == -1)
                endLine = currentLine;
              if (startLine <= endLine)
                self2.fireUpdateEvent(startLine, endLine);
            };
          }
          BackgroundTokenizer2.prototype.setTokenizer = function(tokenizer) {
            this.tokenizer = tokenizer;
            this.lines = [];
            this.states = [];
            this.start(0);
          };
          BackgroundTokenizer2.prototype.setDocument = function(doc) {
            this.doc = doc;
            this.lines = [];
            this.states = [];
            this.stop();
          };
          BackgroundTokenizer2.prototype.fireUpdateEvent = function(firstRow, lastRow) {
            var data = {
              first: firstRow,
              last: lastRow
            };
            this._signal("update", { data });
          };
          BackgroundTokenizer2.prototype.start = function(startRow) {
            this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
            this.lines.splice(this.currentLine, this.lines.length);
            this.states.splice(this.currentLine, this.states.length);
            this.stop();
            this.running = setTimeout(this.$worker, 700);
          };
          BackgroundTokenizer2.prototype.scheduleStart = function() {
            if (!this.running)
              this.running = setTimeout(this.$worker, 700);
          };
          BackgroundTokenizer2.prototype.$updateOnChange = function(delta) {
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;
            if (len === 0) {
              this.lines[startRow] = null;
            } else if (delta.action == "remove") {
              this.lines.splice(startRow, len + 1, null);
              this.states.splice(startRow, len + 1, null);
            } else {
              var args = Array(len + 1);
              args.unshift(startRow, 1);
              this.lines.splice.apply(this.lines, args);
              this.states.splice.apply(this.states, args);
            }
            this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
            this.stop();
          };
          BackgroundTokenizer2.prototype.stop = function() {
            if (this.running)
              clearTimeout(this.running);
            this.running = false;
          };
          BackgroundTokenizer2.prototype.getTokens = function(row) {
            return this.lines[row] || this.$tokenizeRow(row);
          };
          BackgroundTokenizer2.prototype.getState = function(row) {
            if (this.currentLine == row)
              this.$tokenizeRow(row);
            return this.states[row] || "start";
          };
          BackgroundTokenizer2.prototype.$tokenizeRow = function(row) {
            var line = this.doc.getLine(row);
            var state = this.states[row - 1];
            var data = this.tokenizer.getLineTokens(line, state, row);
            if (this.states[row] + "" !== data.state + "") {
              this.states[row] = data.state;
              this.lines[row + 1] = null;
              if (this.currentLine > row + 1)
                this.currentLine = row + 1;
            } else if (this.currentLine == row) {
              this.currentLine = row + 1;
            }
            return this.lines[row] = data.tokens;
          };
          BackgroundTokenizer2.prototype.cleanup = function() {
            this.running = false;
            this.lines = [];
            this.states = [];
            this.currentLine = 0;
            this.removeAllListeners();
          };
          return BackgroundTokenizer2;
        }()
      );
      oop.implement(BackgroundTokenizer.prototype, EventEmitter);
      exports3.BackgroundTokenizer = BackgroundTokenizer;
    });
    ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/range"], function(require2, exports3, module3) {
      var lang = require2("./lib/lang");
      var Range = require2("./range").Range;
      var SearchHighlight = (
        /** @class */
        function() {
          function SearchHighlight2(regExp, clazz, type) {
            if (type === void 0) {
              type = "text";
            }
            this.setRegexp(regExp);
            this.clazz = clazz;
            this.type = type;
          }
          SearchHighlight2.prototype.setRegexp = function(regExp) {
            if (this.regExp + "" == regExp + "")
              return;
            this.regExp = regExp;
            this.cache = [];
          };
          SearchHighlight2.prototype.update = function(html3, markerLayer, session, config) {
            if (!this.regExp)
              return;
            var start = config.firstRow, end = config.lastRow;
            var renderedMarkerRanges = {};
            for (var i2 = start; i2 <= end; i2++) {
              var ranges = this.cache[i2];
              if (ranges == null) {
                ranges = lang.getMatchOffsets(session.getLine(i2), this.regExp);
                if (ranges.length > this.MAX_RANGES)
                  ranges = ranges.slice(0, this.MAX_RANGES);
                ranges = ranges.map(function(match2) {
                  return new Range(i2, match2.offset, i2, match2.offset + match2.length);
                });
                this.cache[i2] = ranges.length ? ranges : "";
              }
              for (var j = ranges.length; j--; ) {
                var rangeToAddMarkerTo = ranges[j].toScreenRange(session);
                var rangeAsString = rangeToAddMarkerTo.toString();
                if (renderedMarkerRanges[rangeAsString])
                  continue;
                renderedMarkerRanges[rangeAsString] = true;
                markerLayer.drawSingleLineMarker(html3, rangeToAddMarkerTo, this.clazz, config);
              }
            }
          };
          return SearchHighlight2;
        }()
      );
      SearchHighlight.prototype.MAX_RANGES = 500;
      exports3.SearchHighlight = SearchHighlight;
    });
    ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function(require2, exports3, module3) {
      var Range = require2("../range").Range;
      var FoldLine = (
        /** @class */
        function() {
          function FoldLine2(foldData, folds) {
            this.foldData = foldData;
            if (Array.isArray(folds)) {
              this.folds = folds;
            } else {
              folds = this.folds = [folds];
            }
            var last = folds[folds.length - 1];
            this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
            this.start = this.range.start;
            this.end = this.range.end;
            this.folds.forEach(function(fold) {
              fold.setFoldLine(this);
            }, this);
          }
          FoldLine2.prototype.shiftRow = function(shift) {
            this.start.row += shift;
            this.end.row += shift;
            this.folds.forEach(function(fold) {
              fold.start.row += shift;
              fold.end.row += shift;
            });
          };
          FoldLine2.prototype.addFold = function(fold) {
            if (fold.sameRow) {
              if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
              }
              this.folds.push(fold);
              this.folds.sort(function(a3, b2) {
                return -a3.range.compareEnd(b2.start.row, b2.start.column);
              });
              if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                this.end.row = fold.end.row;
                this.end.column = fold.end.column;
              } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
              }
            } else if (fold.start.row == this.end.row) {
              this.folds.push(fold);
              this.end.row = fold.end.row;
              this.end.column = fold.end.column;
            } else if (fold.end.row == this.start.row) {
              this.folds.unshift(fold);
              this.start.row = fold.start.row;
              this.start.column = fold.start.column;
            } else {
              throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
            }
            fold.foldLine = this;
          };
          FoldLine2.prototype.containsRow = function(row) {
            return row >= this.start.row && row <= this.end.row;
          };
          FoldLine2.prototype.walk = function(callback, endRow, endColumn) {
            var lastEnd = 0, folds = this.folds, fold, cmp, stop, isNewRow = true;
            if (endRow == null) {
              endRow = this.end.row;
              endColumn = this.end.column;
            }
            for (var i2 = 0; i2 < folds.length; i2++) {
              fold = folds[i2];
              cmp = fold.range.compareStart(endRow, endColumn);
              if (cmp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
              }
              stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
              stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
              if (stop || cmp === 0) {
                return;
              }
              isNewRow = !fold.sameRow;
              lastEnd = fold.end.column;
            }
            callback(null, endRow, endColumn, lastEnd, isNewRow);
          };
          FoldLine2.prototype.getNextFoldTo = function(row, column) {
            var fold, cmp;
            for (var i2 = 0; i2 < this.folds.length; i2++) {
              fold = this.folds[i2];
              cmp = fold.range.compareEnd(row, column);
              if (cmp == -1) {
                return {
                  fold,
                  kind: "after"
                };
              } else if (cmp === 0) {
                return {
                  fold,
                  kind: "inside"
                };
              }
            }
            return null;
          };
          FoldLine2.prototype.addRemoveChars = function(row, column, len) {
            var ret = this.getNextFoldTo(row, column), fold, folds;
            if (ret) {
              fold = ret.fold;
              if (ret.kind == "inside" && fold.start.column != column && fold.start.row != row) {
                window.console && window.console.log(row, column, fold);
              } else if (fold.start.row == row) {
                folds = this.folds;
                var i2 = folds.indexOf(fold);
                if (i2 === 0) {
                  this.start.column += len;
                }
                for (i2; i2 < folds.length; i2++) {
                  fold = folds[i2];
                  fold.start.column += len;
                  if (!fold.sameRow) {
                    return;
                  }
                  fold.end.column += len;
                }
                this.end.column += len;
              }
            }
          };
          FoldLine2.prototype.split = function(row, column) {
            var pos = this.getNextFoldTo(row, column);
            if (!pos || pos.kind == "inside")
              return null;
            var fold = pos.fold;
            var folds = this.folds;
            var foldData = this.foldData;
            var i2 = folds.indexOf(fold);
            var foldBefore = folds[i2 - 1];
            this.end.row = foldBefore.end.row;
            this.end.column = foldBefore.end.column;
            folds = folds.splice(i2, folds.length - i2);
            var newFoldLine = new FoldLine2(foldData, folds);
            foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
            return newFoldLine;
          };
          FoldLine2.prototype.merge = function(foldLineNext) {
            var folds = foldLineNext.folds;
            for (var i2 = 0; i2 < folds.length; i2++) {
              this.addFold(folds[i2]);
            }
            var foldData = this.foldData;
            foldData.splice(foldData.indexOf(foldLineNext), 1);
          };
          FoldLine2.prototype.toString = function() {
            var ret = [this.range.toString() + ": ["];
            this.folds.forEach(function(fold) {
              ret.push("  " + fold.toString());
            });
            ret.push("]");
            return ret.join("\n");
          };
          FoldLine2.prototype.idxToPosition = function(idx) {
            var lastFoldEndColumn = 0;
            for (var i2 = 0; i2 < this.folds.length; i2++) {
              var fold = this.folds[i2];
              idx -= fold.start.column - lastFoldEndColumn;
              if (idx < 0) {
                return {
                  row: fold.start.row,
                  column: fold.start.column + idx
                };
              }
              idx -= fold.placeholder.length;
              if (idx < 0) {
                return fold.start;
              }
              lastFoldEndColumn = fold.end.column;
            }
            return {
              row: this.end.row,
              column: this.end.column + idx
            };
          };
          return FoldLine2;
        }()
      );
      exports3.FoldLine = FoldLine;
    });
    ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function(require2, exports3, module3) {
      var Range = require2("./range").Range;
      var comparePoints = Range.comparePoints;
      var RangeList = (
        /** @class */
        function() {
          function RangeList2() {
            this.ranges = [];
            this.$bias = 1;
          }
          RangeList2.prototype.pointIndex = function(pos, excludeEdges, startIndex) {
            var list = this.ranges;
            for (var i2 = startIndex || 0; i2 < list.length; i2++) {
              var range = list[i2];
              var cmpEnd = comparePoints(pos, range.end);
              if (cmpEnd > 0)
                continue;
              var cmpStart = comparePoints(pos, range.start);
              if (cmpEnd === 0)
                return excludeEdges && cmpStart !== 0 ? -i2 - 2 : i2;
              if (cmpStart > 0 || cmpStart === 0 && !excludeEdges)
                return i2;
              return -i2 - 1;
            }
            return -i2 - 1;
          };
          RangeList2.prototype.add = function(range) {
            var excludeEdges = !range.isEmpty();
            var startIndex = this.pointIndex(range.start, excludeEdges);
            if (startIndex < 0)
              startIndex = -startIndex - 1;
            var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
            if (endIndex < 0)
              endIndex = -endIndex - 1;
            else
              endIndex++;
            return this.ranges.splice(startIndex, endIndex - startIndex, range);
          };
          RangeList2.prototype.addList = function(list) {
            var removed = [];
            for (var i2 = list.length; i2--; ) {
              removed.push.apply(removed, this.add(list[i2]));
            }
            return removed;
          };
          RangeList2.prototype.substractPoint = function(pos) {
            var i2 = this.pointIndex(pos);
            if (i2 >= 0)
              return this.ranges.splice(i2, 1);
          };
          RangeList2.prototype.merge = function() {
            var removed = [];
            var list = this.ranges;
            list = list.sort(function(a3, b2) {
              return comparePoints(a3.start, b2.start);
            });
            var next = list[0], range;
            for (var i2 = 1; i2 < list.length; i2++) {
              range = next;
              next = list[i2];
              var cmp = comparePoints(range.end, next.start);
              if (cmp < 0)
                continue;
              if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                continue;
              if (comparePoints(range.end, next.end) < 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
              }
              list.splice(i2, 1);
              removed.push(next);
              next = range;
              i2--;
            }
            this.ranges = list;
            return removed;
          };
          RangeList2.prototype.contains = function(row, column) {
            return this.pointIndex({ row, column }) >= 0;
          };
          RangeList2.prototype.containsPoint = function(pos) {
            return this.pointIndex(pos) >= 0;
          };
          RangeList2.prototype.rangeAtPoint = function(pos) {
            var i2 = this.pointIndex(pos);
            if (i2 >= 0)
              return this.ranges[i2];
          };
          RangeList2.prototype.clipRows = function(startRow, endRow) {
            var list = this.ranges;
            if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
              return [];
            var startIndex = this.pointIndex({ row: startRow, column: 0 });
            if (startIndex < 0)
              startIndex = -startIndex - 1;
            var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);
            if (endIndex < 0)
              endIndex = -endIndex - 1;
            var clipped = [];
            for (var i2 = startIndex; i2 < endIndex; i2++) {
              clipped.push(list[i2]);
            }
            return clipped;
          };
          RangeList2.prototype.removeAll = function() {
            return this.ranges.splice(0, this.ranges.length);
          };
          RangeList2.prototype.attach = function(session) {
            if (this.session)
              this.detach();
            this.session = session;
            this.onChange = this.$onChange.bind(this);
            this.session.on("change", this.onChange);
          };
          RangeList2.prototype.detach = function() {
            if (!this.session)
              return;
            this.session.removeListener("change", this.onChange);
            this.session = null;
          };
          RangeList2.prototype.$onChange = function(delta) {
            var start = delta.start;
            var end = delta.end;
            var startRow = start.row;
            var endRow = end.row;
            var ranges = this.ranges;
            for (var i2 = 0, n = ranges.length; i2 < n; i2++) {
              var r = ranges[i2];
              if (r.end.row >= startRow)
                break;
            }
            if (delta.action == "insert") {
              var lineDif = endRow - startRow;
              var colDiff = -start.column + end.column;
              for (; i2 < n; i2++) {
                var r = ranges[i2];
                if (r.start.row > startRow)
                  break;
                if (r.start.row == startRow && r.start.column >= start.column) {
                  if (r.start.column == start.column && this.$bias <= 0) ;
                  else {
                    r.start.column += colDiff;
                    r.start.row += lineDif;
                  }
                }
                if (r.end.row == startRow && r.end.column >= start.column) {
                  if (r.end.column == start.column && this.$bias < 0) {
                    continue;
                  }
                  if (r.end.column == start.column && colDiff > 0 && i2 < n - 1) {
                    if (r.end.column > r.start.column && r.end.column == ranges[i2 + 1].start.column)
                      r.end.column -= colDiff;
                  }
                  r.end.column += colDiff;
                  r.end.row += lineDif;
                }
              }
            } else {
              var lineDif = startRow - endRow;
              var colDiff = start.column - end.column;
              for (; i2 < n; i2++) {
                var r = ranges[i2];
                if (r.start.row > endRow)
                  break;
                if (r.end.row < endRow && (startRow < r.end.row || startRow == r.end.row && start.column < r.end.column)) {
                  r.end.row = startRow;
                  r.end.column = start.column;
                } else if (r.end.row == endRow) {
                  if (r.end.column <= end.column) {
                    if (lineDif || r.end.column > start.column) {
                      r.end.column = start.column;
                      r.end.row = start.row;
                    }
                  } else {
                    r.end.column += colDiff;
                    r.end.row += lineDif;
                  }
                } else if (r.end.row > endRow) {
                  r.end.row += lineDif;
                }
                if (r.start.row < endRow && (startRow < r.start.row || startRow == r.start.row && start.column < r.start.column)) {
                  r.start.row = startRow;
                  r.start.column = start.column;
                } else if (r.start.row == endRow) {
                  if (r.start.column <= end.column) {
                    if (lineDif || r.start.column > start.column) {
                      r.start.column = start.column;
                      r.start.row = start.row;
                    }
                  } else {
                    r.start.column += colDiff;
                    r.start.row += lineDif;
                  }
                } else if (r.start.row > endRow) {
                  r.start.row += lineDif;
                }
              }
            }
            if (lineDif != 0 && i2 < n) {
              for (; i2 < n; i2++) {
                var r = ranges[i2];
                r.start.row += lineDif;
                r.end.row += lineDif;
              }
            }
          };
          return RangeList2;
        }()
      );
      RangeList.prototype.comparePoints = comparePoints;
      exports3.RangeList = RangeList;
    });
    ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range_list"], function(require2, exports3, module3) {
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d3, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d4[p] = b3[p];
          };
          return extendStatics(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var RangeList = require2("../range_list").RangeList;
      var Fold = (
        /** @class */
        function(_super) {
          __extends(Fold2, _super);
          function Fold2(range, placeholder) {
            var _this = _super.call(this) || this;
            _this.foldLine = null;
            _this.placeholder = placeholder;
            _this.range = range;
            _this.start = range.start;
            _this.end = range.end;
            _this.sameRow = range.start.row == range.end.row;
            _this.subFolds = _this.ranges = [];
            return _this;
          }
          Fold2.prototype.toString = function() {
            return '"' + this.placeholder + '" ' + this.range.toString();
          };
          Fold2.prototype.setFoldLine = function(foldLine) {
            this.foldLine = foldLine;
            this.subFolds.forEach(function(fold) {
              fold.setFoldLine(foldLine);
            });
          };
          Fold2.prototype.clone = function() {
            var range = this.range.clone();
            var fold = new Fold2(range, this.placeholder);
            this.subFolds.forEach(function(subFold) {
              fold.subFolds.push(subFold.clone());
            });
            fold.collapseChildren = this.collapseChildren;
            return fold;
          };
          Fold2.prototype.addSubFold = function(fold) {
            if (this.range.isEqual(fold))
              return;
            consumeRange(fold, this.start);
            var row = fold.start.row, column = fold.start.column;
            for (var i2 = 0, cmp = -1; i2 < this.subFolds.length; i2++) {
              cmp = this.subFolds[i2].range.compare(row, column);
              if (cmp != 1)
                break;
            }
            var afterStart = this.subFolds[i2];
            var firstConsumed = 0;
            if (cmp == 0) {
              if (afterStart.range.containsRange(fold))
                return afterStart.addSubFold(fold);
              else
                firstConsumed = 1;
            }
            var row = fold.range.end.row, column = fold.range.end.column;
            for (var j = i2, cmp = -1; j < this.subFolds.length; j++) {
              cmp = this.subFolds[j].range.compare(row, column);
              if (cmp != 1)
                break;
            }
            if (cmp == 0)
              j++;
            var consumedFolds = this.subFolds.splice(i2, j - i2, fold);
            var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
            for (var k2 = firstConsumed; k2 < last; k2++) {
              fold.addSubFold(consumedFolds[k2]);
            }
            fold.setFoldLine(this.foldLine);
            return fold;
          };
          Fold2.prototype.restoreRange = function(range) {
            return restoreRange(range, this.start);
          };
          return Fold2;
        }(RangeList)
      );
      function consumePoint(point, anchor) {
        point.row -= anchor.row;
        if (point.row == 0)
          point.column -= anchor.column;
      }
      function consumeRange(range, anchor) {
        consumePoint(range.start, anchor);
        consumePoint(range.end, anchor);
      }
      function restorePoint(point, anchor) {
        if (point.row == 0)
          point.column += anchor.column;
        point.row += anchor.row;
      }
      function restoreRange(range, anchor) {
        restorePoint(range.start, anchor);
        restorePoint(range.end, anchor);
      }
      exports3.Fold = Fold;
    });
    ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator"], function(require2, exports3, module3) {
      var Range = require2("../range").Range;
      var FoldLine = require2("./fold_line").FoldLine;
      var Fold = require2("./fold").Fold;
      var TokenIterator = require2("../token_iterator").TokenIterator;
      function Folding() {
        this.getFoldAt = function(row, column, side) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine)
            return null;
          var folds = foldLine.folds;
          for (var i2 = 0; i2 < folds.length; i2++) {
            var range = folds[i2].range;
            if (range.contains(row, column)) {
              if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {
                continue;
              } else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {
                continue;
              }
              return folds[i2];
            }
          }
        };
        this.getFoldsInRange = function(range) {
          var start = range.start;
          var end = range.end;
          var foldLines = this.$foldData;
          var foundFolds = [];
          start.column += 1;
          end.column -= 1;
          for (var i2 = 0; i2 < foldLines.length; i2++) {
            var cmp = foldLines[i2].range.compareRange(range);
            if (cmp == 2) {
              continue;
            } else if (cmp == -2) {
              break;
            }
            var folds = foldLines[i2].folds;
            for (var j = 0; j < folds.length; j++) {
              var fold = folds[j];
              cmp = fold.range.compareRange(range);
              if (cmp == -2) {
                break;
              } else if (cmp == 2) {
                continue;
              } else if (cmp == 42) {
                break;
              }
              foundFolds.push(fold);
            }
          }
          start.column -= 1;
          end.column += 1;
          return foundFolds;
        };
        this.getFoldsInRangeList = function(ranges) {
          if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function(range) {
              folds = folds.concat(this.getFoldsInRange(range));
            }, this);
          } else {
            var folds = this.getFoldsInRange(ranges);
          }
          return folds;
        };
        this.getAllFolds = function() {
          var folds = [];
          var foldLines = this.$foldData;
          for (var i2 = 0; i2 < foldLines.length; i2++)
            for (var j = 0; j < foldLines[i2].folds.length; j++)
              folds.push(foldLines[i2].folds[j]);
          return folds;
        };
        this.getFoldStringAt = function(row, column, trim, foldLine) {
          foldLine = foldLine || this.getFoldLine(row);
          if (!foldLine)
            return null;
          var lastFold = {
            end: { column: 0 }
          };
          var str, fold;
          for (var i2 = 0; i2 < foldLine.folds.length; i2++) {
            fold = foldLine.folds[i2];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
              str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
              break;
            } else if (cmp === 0) {
              return null;
            }
            lastFold = fold;
          }
          if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);
          if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
          else if (trim == 1)
            return str.substring(column - lastFold.end.column);
          else
            return str;
        };
        this.getFoldLine = function(docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i2 = 0;
          if (startFoldLine)
            i2 = foldData.indexOf(startFoldLine);
          if (i2 == -1)
            i2 = 0;
          for (i2; i2 < foldData.length; i2++) {
            var foldLine = foldData[i2];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
              return foldLine;
            } else if (foldLine.end.row > docRow) {
              return null;
            }
          }
          return null;
        };
        this.getNextFoldLine = function(docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i2 = 0;
          if (startFoldLine)
            i2 = foldData.indexOf(startFoldLine);
          if (i2 == -1)
            i2 = 0;
          for (i2; i2 < foldData.length; i2++) {
            var foldLine = foldData[i2];
            if (foldLine.end.row >= docRow) {
              return foldLine;
            }
          }
          return null;
        };
        this.getFoldedRowCount = function(first, last) {
          var foldData = this.$foldData, rowCount = last - first + 1;
          for (var i2 = 0; i2 < foldData.length; i2++) {
            var foldLine = foldData[i2], end = foldLine.end.row, start = foldLine.start.row;
            if (end >= last) {
              if (start < last) {
                if (start >= first)
                  rowCount -= last - start;
                else
                  rowCount = 0;
              }
              break;
            } else if (end >= first) {
              if (start >= first)
                rowCount -= end - start;
              else
                rowCount -= end - first + 1;
            }
          }
          return rowCount;
        };
        this.$addFoldLine = function(foldLine) {
          this.$foldData.push(foldLine);
          this.$foldData.sort(function(a3, b2) {
            return a3.start.row - b2.start.row;
          });
          return foldLine;
        };
        this.addFold = function(placeholder, range) {
          var foldData = this.$foldData;
          var added = false;
          var fold;
          if (placeholder instanceof Fold)
            fold = placeholder;
          else {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
          }
          this.$clipRangeToDocument(fold.range);
          var startRow = fold.start.row;
          var startColumn = fold.start.column;
          var endRow = fold.end.row;
          var endColumn = fold.end.column;
          var startFold = this.getFoldAt(startRow, startColumn, 1);
          var endFold = this.getFoldAt(endRow, endColumn, -1);
          if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);
          if (startFold && !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);
          if (endFold && !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
          var folds = this.getFoldsInRange(fold.range);
          if (folds.length > 0) {
            this.removeFolds(folds);
            if (!fold.collapseChildren) {
              folds.forEach(function(subFold) {
                fold.addSubFold(subFold);
              });
            }
          }
          for (var i2 = 0; i2 < foldData.length; i2++) {
            var foldLine = foldData[i2];
            if (endRow == foldLine.start.row) {
              foldLine.addFold(fold);
              added = true;
              break;
            } else if (startRow == foldLine.end.row) {
              foldLine.addFold(fold);
              added = true;
              if (!fold.sameRow) {
                var foldLineNext = foldData[i2 + 1];
                if (foldLineNext && foldLineNext.start.row == endRow) {
                  foldLine.merge(foldLineNext);
                  break;
                }
              }
              break;
            } else if (endRow <= foldLine.start.row) {
              break;
            }
          }
          if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
          if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
          else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
          this.$modified = true;
          this._signal("changeFold", { data: fold, action: "add" });
          return fold;
        };
        this.addFolds = function(folds) {
          folds.forEach(function(fold) {
            this.addFold(fold);
          }, this);
        };
        this.removeFold = function(fold) {
          var foldLine = fold.foldLine;
          var startRow = foldLine.start.row;
          var endRow = foldLine.end.row;
          var foldLines = this.$foldData;
          var folds = foldLine.folds;
          if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
          } else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
          } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
          } else if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
          } else {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
          }
          if (!this.$updating) {
            if (this.$useWrapMode)
              this.$updateWrapData(startRow, endRow);
            else
              this.$updateRowLengthCache(startRow, endRow);
          }
          this.$modified = true;
          this._signal("changeFold", { data: fold, action: "remove" });
        };
        this.removeFolds = function(folds) {
          var cloneFolds = [];
          for (var i2 = 0; i2 < folds.length; i2++) {
            cloneFolds.push(folds[i2]);
          }
          cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
          }, this);
          this.$modified = true;
        };
        this.expandFold = function(fold) {
          this.removeFold(fold);
          fold.subFolds.forEach(function(subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
          }, this);
          if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
          }
          fold.subFolds = [];
        };
        this.expandFolds = function(folds) {
          folds.forEach(function(fold) {
            this.expandFold(fold);
          }, this);
        };
        this.unfold = function(location2, expandInner) {
          var range, folds;
          if (location2 == null) {
            range = new Range(0, 0, this.getLength(), 0);
            if (expandInner == null)
              expandInner = true;
          } else if (typeof location2 == "number") {
            range = new Range(location2, 0, location2, this.getLine(location2).length);
          } else if ("row" in location2) {
            range = Range.fromPoints(location2, location2);
          } else if (Array.isArray(location2)) {
            folds = [];
            location2.forEach(function(range2) {
              folds = folds.concat(this.unfold(range2));
            }, this);
            return folds;
          } else {
            range = location2;
          }
          folds = this.getFoldsInRangeList(range);
          var outermostFolds = folds;
          while (folds.length == 1 && Range.comparePoints(folds[0].start, range.start) < 0 && Range.comparePoints(folds[0].end, range.end) > 0) {
            this.expandFolds(folds);
            folds = this.getFoldsInRangeList(range);
          }
          if (expandInner != false) {
            this.removeFolds(folds);
          } else {
            this.expandFolds(folds);
          }
          if (outermostFolds.length)
            return outermostFolds;
        };
        this.isRowFolded = function(docRow, startFoldRow) {
          return !!this.getFoldLine(docRow, startFoldRow);
        };
        this.getRowFoldEnd = function(docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.end.row : docRow;
        };
        this.getRowFoldStart = function(docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.start.row : docRow;
        };
        this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
          if (startRow == null)
            startRow = foldLine.start.row;
          if (startColumn == null)
            startColumn = 0;
          if (endRow == null)
            endRow = foldLine.end.row;
          if (endColumn == null)
            endColumn = this.getLine(endRow).length;
          var doc = this.doc;
          var textLine = "";
          foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow)
              return;
            if (row == startRow) {
              if (column < startColumn)
                return;
              lastColumn = Math.max(startColumn, lastColumn);
            }
            if (placeholder != null) {
              textLine += placeholder;
            } else {
              textLine += doc.getLine(row).substring(lastColumn, column);
            }
          }, endRow, endColumn);
          return textLine;
        };
        this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
          } else {
            return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
          }
        };
        this.$cloneFoldData = function() {
          var fd = [];
          fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
              return fold.clone();
            });
            return new FoldLine(fd, folds);
          });
          return fd;
        };
        this.toggleFold = function(tryToUnfold) {
          var selection = this.selection;
          var range = selection.getRange();
          var fold;
          var bracketPos;
          if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);
            if (fold) {
              this.expandFold(fold);
              return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
              if (range.comparePoint(bracketPos) == 1) {
                range.end = bracketPos;
              } else {
                range.start = bracketPos;
                range.start.column++;
                range.end.column--;
              }
            } else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
              if (range.comparePoint(bracketPos) == 1)
                range.end = bracketPos;
              else
                range.start = bracketPos;
              range.start.column++;
            } else {
              range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
          } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
              this.expandFolds(folds);
              return;
            } else if (folds.length == 1) {
              fold = folds[0];
            }
          }
          if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);
          if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
          }
          var placeholder = "...";
          if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length < 4)
              return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
          }
          this.addFold(placeholder, range);
        };
        this.getCommentFoldRange = function(row, column, dir) {
          var iterator = new TokenIterator(this, row, column);
          var token = iterator.getCurrentToken();
          var type = token && token.type;
          if (token && /^comment|string/.test(type)) {
            type = type.match(/comment|string/)[0];
            if (type == "comment")
              type += "|doc-start";
            var re2 = new RegExp(type);
            var range = new Range();
            if (dir != 1) {
              do {
                token = iterator.stepBackward();
              } while (token && re2.test(token.type) && !/^comment.end/.test(token.type));
              token = iterator.stepForward();
            }
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + (/^comment.start/.test(token.type) ? token.value.length : 2);
            iterator = new TokenIterator(this, row, column);
            if (dir != -1) {
              var lastRow = -1;
              do {
                token = iterator.stepForward();
                if (lastRow == -1) {
                  var state = this.getState(iterator.$row);
                  if (!re2.test(state))
                    lastRow = iterator.$row;
                } else if (iterator.$row > lastRow) {
                  break;
                }
              } while (token && re2.test(token.type) && !/^comment.start/.test(token.type));
              token = iterator.stepBackward();
            } else
              token = iterator.getCurrentToken();
            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn();
            if (!/^comment.end/.test(token.type)) {
              range.end.column += token.value.length - 2;
            }
            return range;
          }
        };
        this.foldAll = function(startRow, endRow, depth, test) {
          if (depth == void 0)
            depth = 1e5;
          var foldWidgets = this.foldWidgets;
          if (!foldWidgets)
            return;
          endRow = endRow || this.getLength();
          startRow = startRow || 0;
          for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
              foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
              continue;
            if (test && !test(row))
              continue;
            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
              row = range.end.row;
              range.collapseChildren = depth;
              this.addFold("...", range);
            }
          }
        };
        this.foldToLevel = function(level) {
          this.foldAll();
          while (level-- > 0)
            this.unfold(null, false);
        };
        this.foldAllComments = function() {
          var session = this;
          this.foldAll(null, null, null, function(row) {
            var tokens = session.getTokens(row);
            for (var i2 = 0; i2 < tokens.length; i2++) {
              var token = tokens[i2];
              if (token.type == "text" && /^\s+$/.test(token.value))
                continue;
              if (/comment/.test(token.type))
                return true;
              return false;
            }
          });
        };
        this.$foldStyles = {
          "manual": 1,
          "markbegin": 1,
          "markbeginend": 1
        };
        this.$foldStyle = "markbegin";
        this.setFoldStyle = function(style) {
          if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
          if (this.$foldStyle == style)
            return;
          this.$foldStyle = style;
          if (style == "manual")
            this.unfold();
          var mode = this.$foldMode;
          this.$setFolding(null);
          this.$setFolding(mode);
        };
        this.$setFolding = function(foldMode) {
          if (this.$foldMode == foldMode)
            return;
          this.$foldMode = foldMode;
          this.off("change", this.$updateFoldWidgets);
          this.off("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
          this._signal("changeAnnotation");
          if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
          }
          this.foldWidgets = [];
          this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
          this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
          this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
          this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
          this.on("change", this.$updateFoldWidgets);
          this.on("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
        };
        this.getParentFoldRangeData = function(row, ignoreCurrent) {
          var fw = this.foldWidgets;
          if (!fw || ignoreCurrent && fw[row])
            return {};
          var i2 = row - 1, firstRange;
          while (i2 >= 0) {
            var c2 = fw[i2];
            if (c2 == null)
              c2 = fw[i2] = this.getFoldWidget(i2);
            if (c2 == "start") {
              var range = this.getFoldWidgetRange(i2);
              if (!firstRange)
                firstRange = range;
              if (range && range.end.row >= row)
                break;
            }
            i2--;
          }
          return {
            range: i2 !== -1 && range,
            firstRange
          };
        };
        this.onFoldWidgetClick = function(row, e2) {
          e2 = e2.domEvent;
          var options = {
            children: e2.shiftKey,
            all: e2.ctrlKey || e2.metaKey,
            siblings: e2.altKey
          };
          var range = this.$toggleFoldWidget(row, options);
          if (!range) {
            var el = e2.target || e2.srcElement;
            if (el && /ace_fold-widget/.test(el.className))
              el.className += " ace_invalid";
          }
        };
        this.$toggleFoldWidget = function(row, options) {
          if (!this.getFoldWidget)
            return;
          var type = this.getFoldWidget(row);
          var line = this.getLine(row);
          var dir = type === "end" ? -1 : 1;
          var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
          if (fold) {
            if (options.children || options.all)
              this.removeFold(fold);
            else
              this.expandFold(fold);
            return fold;
          }
          var range = this.getFoldWidgetRange(row, true);
          if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
              this.removeFold(fold);
              return fold;
            }
          }
          if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
              var startRow = data.range.start.row + 1;
              var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 1e4 : 0);
          } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 1e4 : 0);
          } else if (range) {
            if (options.all)
              range.collapseChildren = 1e4;
            this.addFold("...", range);
          }
          return range;
        };
        this.toggleFoldWidget = function(toggleParent) {
          var row = this.selection.getCursor().row;
          row = this.getRowFoldStart(row);
          var range = this.$toggleFoldWidget(row, {});
          if (range)
            return;
          var data = this.getParentFoldRangeData(row, true);
          range = data.range || data.firstRange;
          if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);
            if (fold) {
              this.removeFold(fold);
            } else {
              this.addFold("...", range);
            }
          }
        };
        this.updateFoldWidgets = function(delta) {
          var firstRow = delta.start.row;
          var len = delta.end.row - firstRow;
          if (len === 0) {
            this.foldWidgets[firstRow] = null;
          } else if (delta.action == "remove") {
            this.foldWidgets.splice(firstRow, len + 1, null);
          } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
          }
        };
        this.tokenizerUpdateFoldWidgets = function(e2) {
          var rows = e2.data;
          if (rows.first != rows.last) {
            if (this.foldWidgets.length > rows.first)
              this.foldWidgets.splice(rows.first, this.foldWidgets.length);
          }
        };
      }
      exports3.Folding = Folding;
    });
    ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function(require2, exports3, module3) {
      var TokenIterator = require2("../token_iterator").TokenIterator;
      var Range = require2("../range").Range;
      function BracketMatch() {
        this.findMatchingBracket = function(position, chr) {
          if (position.column == 0)
            return null;
          var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
          if (charBeforeCursor == "")
            return null;
          var match2 = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
          if (!match2)
            return null;
          if (match2[1])
            return this.$findClosingBracket(match2[1], position);
          else
            return this.$findOpeningBracket(match2[2], position);
        };
        this.getBracketRange = function(pos) {
          var line = this.getLine(pos.row);
          var before = true, range;
          var chr = line.charAt(pos.column - 1);
          var match2 = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
          if (!match2) {
            chr = line.charAt(pos.column);
            pos = { row: pos.row, column: pos.column + 1 };
            match2 = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
          }
          if (!match2)
            return null;
          if (match2[1]) {
            var bracketPos = this.$findClosingBracket(match2[1], pos);
            if (!bracketPos)
              return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
              range.end.column++;
              range.start.column--;
            }
            range.cursor = range.end;
          } else {
            var bracketPos = this.$findOpeningBracket(match2[2], pos);
            if (!bracketPos)
              return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
              range.start.column++;
              range.end.column--;
            }
            range.cursor = range.start;
          }
          return range;
        };
        this.getMatchingBracketRanges = function(pos, isBackwards) {
          var line = this.getLine(pos.row);
          var bracketsRegExp = /([\(\[\{])|([\)\]\}])/;
          var chr = !isBackwards && line.charAt(pos.column - 1);
          var match2 = chr && chr.match(bracketsRegExp);
          if (!match2) {
            chr = (isBackwards === void 0 || isBackwards) && line.charAt(pos.column);
            pos = {
              row: pos.row,
              column: pos.column + 1
            };
            match2 = chr && chr.match(bracketsRegExp);
          }
          if (!match2)
            return null;
          var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
          var bracketPos = match2[1] ? this.$findClosingBracket(match2[1], pos) : this.$findOpeningBracket(match2[2], pos);
          if (!bracketPos)
            return [startRange];
          var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);
          return [startRange, endRange];
        };
        this.$brackets = {
          ")": "(",
          "(": ")",
          "]": "[",
          "[": "]",
          "{": "}",
          "}": "{",
          "<": ">",
          ">": "<"
        };
        this.$findOpeningBracket = function(bracket, position, typeRe) {
          var openBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position.row, position.column);
          var token = iterator.getCurrentToken();
          if (!token)
            token = iterator.stepForward();
          if (!token)
            return;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)").replace(/-close\b/, "-(close|open)") + ")+");
          }
          var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
          var value = token.value;
          while (true) {
            while (valueIndex >= 0) {
              var chr = value.charAt(valueIndex);
              if (chr == openBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex -= 1;
            }
            do {
              token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
              break;
            value = token.value;
            valueIndex = value.length - 1;
          }
          return null;
        };
        this.$findClosingBracket = function(bracket, position, typeRe) {
          var closingBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position.row, position.column);
          var token = iterator.getCurrentToken();
          if (!token)
            token = iterator.stepForward();
          if (!token)
            return;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)").replace(/-open\b/, "-(close|open)") + ")+");
          }
          var valueIndex = position.column - iterator.getCurrentTokenColumn();
          while (true) {
            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
              var chr = value.charAt(valueIndex);
              if (chr == closingBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex += 1;
            }
            do {
              token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
              break;
            valueIndex = 0;
          }
          return null;
        };
        this.getMatchingTags = function(pos) {
          var iterator = new TokenIterator(this, pos.row, pos.column);
          var token = this.$findTagName(iterator);
          if (!token)
            return;
          var prevToken = iterator.stepBackward();
          if (prevToken.value === "<") {
            return this.$findClosingTag(iterator, token);
          } else {
            return this.$findOpeningTag(iterator, token);
          }
        };
        this.$findTagName = function(iterator) {
          var token = iterator.getCurrentToken();
          var found = false;
          var backward = false;
          if (token && token.type.indexOf("tag-name") === -1) {
            do {
              if (backward)
                token = iterator.stepBackward();
              else
                token = iterator.stepForward();
              if (token) {
                if (token.value === "/>") {
                  backward = true;
                } else if (token.type.indexOf("tag-name") !== -1) {
                  found = true;
                }
              }
            } while (token && !found);
          }
          return token;
        };
        this.$findClosingTag = function(iterator, token) {
          var prevToken;
          var currentTag = token.value;
          var tag = token.value;
          var depth = 0;
          var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
          token = iterator.stepForward();
          var openTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
          var foundOpenTagEnd = false;
          do {
            prevToken = token;
            token = iterator.stepForward();
            if (token) {
              if (token.value === ">" && !foundOpenTagEnd) {
                var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                foundOpenTagEnd = true;
              }
              if (token.type.indexOf("tag-name") !== -1) {
                currentTag = token.value;
                if (tag === currentTag) {
                  if (prevToken.value === "<") {
                    depth++;
                  } else if (prevToken.value === "</") {
                    depth--;
                    if (depth < 0) {
                      iterator.stepBackward();
                      var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                      token = iterator.stepForward();
                      var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
                      token = iterator.stepForward();
                      if (token && token.value === ">") {
                        var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                      } else {
                        return;
                      }
                    }
                  }
                }
              } else if (tag === currentTag && token.value === "/>") {
                depth--;
                if (depth < 0) {
                  var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                  var closeTagName = closeTagStart;
                  var closeTagEnd = closeTagName;
                  var openTagEnd = new Range(openTagName.end.row, openTagName.end.column, openTagName.end.row, openTagName.end.column + 1);
                }
              }
            }
          } while (token && depth >= 0);
          if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
              openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
              closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
              openTagName,
              closeTagName
            };
          }
        };
        this.$findOpeningTag = function(iterator, token) {
          var prevToken = iterator.getCurrentToken();
          var tag = token.value;
          var depth = 0;
          var startRow = iterator.getCurrentTokenRow();
          var startColumn = iterator.getCurrentTokenColumn();
          var endColumn = startColumn + 2;
          var closeTagStart = new Range(startRow, startColumn, startRow, endColumn);
          iterator.stepForward();
          var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
          token = iterator.stepForward();
          if (!token || token.value !== ">")
            return;
          var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
          iterator.stepBackward();
          iterator.stepBackward();
          do {
            token = prevToken;
            startRow = iterator.getCurrentTokenRow();
            startColumn = iterator.getCurrentTokenColumn();
            endColumn = startColumn + token.value.length;
            prevToken = iterator.stepBackward();
            if (token) {
              if (token.type.indexOf("tag-name") !== -1) {
                if (tag === token.value) {
                  if (prevToken.value === "<") {
                    depth++;
                    if (depth > 0) {
                      var openTagName = new Range(startRow, startColumn, startRow, endColumn);
                      var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                      do {
                        token = iterator.stepForward();
                      } while (token && token.value !== ">");
                      var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                    }
                  } else if (prevToken.value === "</") {
                    depth--;
                  }
                }
              } else if (token.value === "/>") {
                var stepCount = 0;
                var tmpToken = prevToken;
                while (tmpToken) {
                  if (tmpToken.type.indexOf("tag-name") !== -1 && tmpToken.value === tag) {
                    depth--;
                    break;
                  } else if (tmpToken.value === "<") {
                    break;
                  }
                  tmpToken = iterator.stepBackward();
                  stepCount++;
                }
                for (var i2 = 0; i2 < stepCount; i2++) {
                  iterator.stepForward();
                }
              }
            }
          } while (prevToken && depth <= 0);
          if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
              openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
              closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
              openTagName,
              closeTagName
            };
          }
        };
      }
      exports3.BracketMatch = BracketMatch;
    });
    ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/bidihandler", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function(require2, exports3, module3) {
      var oop = require2("./lib/oop");
      var lang = require2("./lib/lang");
      var BidiHandler = require2("./bidihandler").BidiHandler;
      var config = require2("./config");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Selection = require2("./selection").Selection;
      var TextMode = require2("./mode/text").Mode;
      var Range = require2("./range").Range;
      var Document2 = require2("./document").Document;
      var BackgroundTokenizer = require2("./background_tokenizer").BackgroundTokenizer;
      var SearchHighlight = require2("./search_highlight").SearchHighlight;
      var EditSession = (
        /** @class */
        function() {
          function EditSession2(text, mode) {
            this.$breakpoints = [];
            this.$decorations = [];
            this.$frontMarkers = {};
            this.$backMarkers = {};
            this.$markerId = 1;
            this.$undoSelect = true;
            this.$foldData = [];
            this.id = "session" + ++EditSession2.$uid;
            this.$foldData.toString = function() {
              return this.join("\n");
            };
            this.bgTokenizer = new BackgroundTokenizer(new TextMode().getTokenizer(), this);
            var _self = this;
            this.bgTokenizer.on("update", function(e2) {
              _self._signal("tokenizerUpdate", e2);
            });
            this.on("changeFold", this.onChangeFold.bind(this));
            this.$onChange = this.onChange.bind(this);
            if (typeof text != "object" || !text.getLine)
              text = new Document2(text);
            this.setDocument(text);
            this.selection = new Selection(this);
            this.$bidiHandler = new BidiHandler(this);
            config.resetOptions(this);
            this.setMode(mode);
            config._signal("session", this);
            this.destroyed = false;
          }
          EditSession2.prototype.setDocument = function(doc) {
            if (this.doc)
              this.doc.off("change", this.$onChange);
            this.doc = doc;
            doc.on("change", this.$onChange, true);
            this.bgTokenizer.setDocument(this.getDocument());
            this.resetCaches();
          };
          EditSession2.prototype.getDocument = function() {
            return this.doc;
          };
          EditSession2.prototype.$resetRowCache = function(docRow) {
            if (!docRow) {
              this.$docRowCache = [];
              this.$screenRowCache = [];
              return;
            }
            var l = this.$docRowCache.length;
            var i2 = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
            if (l > i2) {
              this.$docRowCache.splice(i2, l);
              this.$screenRowCache.splice(i2, l);
            }
          };
          EditSession2.prototype.$getRowCacheIndex = function(cacheArray, val) {
            var low = 0;
            var hi = cacheArray.length - 1;
            while (low <= hi) {
              var mid = low + hi >> 1;
              var c2 = cacheArray[mid];
              if (val > c2)
                low = mid + 1;
              else if (val < c2)
                hi = mid - 1;
              else
                return mid;
            }
            return low - 1;
          };
          EditSession2.prototype.resetCaches = function() {
            this.$modified = true;
            this.$wrapData = [];
            this.$rowLengthCache = [];
            this.$resetRowCache(0);
            if (!this.destroyed)
              this.bgTokenizer.start(0);
          };
          EditSession2.prototype.onChangeFold = function(e2) {
            var fold = e2.data;
            this.$resetRowCache(fold.start.row);
          };
          EditSession2.prototype.onChange = function(delta) {
            this.$modified = true;
            this.$bidiHandler.onChange(delta);
            this.$resetRowCache(delta.start.row);
            var removedFolds = this.$updateInternalDataOnChange(delta);
            if (!this.$fromUndo && this.$undoManager) {
              if (removedFolds && removedFolds.length) {
                this.$undoManager.add({
                  action: "removeFolds",
                  folds: removedFolds
                }, this.mergeUndoDeltas);
                this.mergeUndoDeltas = true;
              }
              this.$undoManager.add(delta, this.mergeUndoDeltas);
              this.mergeUndoDeltas = true;
              this.$informUndoManager.schedule();
            }
            this.bgTokenizer.$updateOnChange(delta);
            this._signal("change", delta);
          };
          EditSession2.prototype.setValue = function(text) {
            this.doc.setValue(text);
            this.selection.moveTo(0, 0);
            this.$resetRowCache(0);
            this.setUndoManager(this.$undoManager);
            this.getUndoManager().reset();
          };
          EditSession2.prototype.toString = function() {
            return this.doc.getValue();
          };
          EditSession2.prototype.getSelection = function() {
            return this.selection;
          };
          EditSession2.prototype.getState = function(row) {
            return this.bgTokenizer.getState(row);
          };
          EditSession2.prototype.getTokens = function(row) {
            return this.bgTokenizer.getTokens(row);
          };
          EditSession2.prototype.getTokenAt = function(row, column) {
            var tokens = this.bgTokenizer.getTokens(row);
            var token, c2 = 0;
            if (column == null) {
              var i2 = tokens.length - 1;
              c2 = this.getLine(row).length;
            } else {
              for (var i2 = 0; i2 < tokens.length; i2++) {
                c2 += tokens[i2].value.length;
                if (c2 >= column)
                  break;
              }
            }
            token = tokens[i2];
            if (!token)
              return null;
            token.index = i2;
            token.start = c2 - token.value.length;
            return token;
          };
          EditSession2.prototype.setUndoManager = function(undoManager) {
            this.$undoManager = undoManager;
            if (this.$informUndoManager)
              this.$informUndoManager.cancel();
            if (undoManager) {
              var self2 = this;
              undoManager.addSession(this);
              this.$syncInformUndoManager = function() {
                self2.$informUndoManager.cancel();
                self2.mergeUndoDeltas = false;
              };
              this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
            } else {
              this.$syncInformUndoManager = function() {
              };
            }
          };
          EditSession2.prototype.markUndoGroup = function() {
            if (this.$syncInformUndoManager)
              this.$syncInformUndoManager();
          };
          EditSession2.prototype.getUndoManager = function() {
            return this.$undoManager || this.$defaultUndoManager;
          };
          EditSession2.prototype.getTabString = function() {
            if (this.getUseSoftTabs()) {
              return lang.stringRepeat(" ", this.getTabSize());
            } else {
              return "	";
            }
          };
          EditSession2.prototype.setUseSoftTabs = function(val) {
            this.setOption("useSoftTabs", val);
          };
          EditSession2.prototype.getUseSoftTabs = function() {
            return this.$useSoftTabs && !this.$mode.$indentWithTabs;
          };
          EditSession2.prototype.setTabSize = function(tabSize) {
            this.setOption("tabSize", tabSize);
          };
          EditSession2.prototype.getTabSize = function() {
            return this.$tabSize;
          };
          EditSession2.prototype.isTabStop = function(position) {
            return this.$useSoftTabs && position.column % this.$tabSize === 0;
          };
          EditSession2.prototype.setNavigateWithinSoftTabs = function(navigateWithinSoftTabs) {
            this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
          };
          EditSession2.prototype.getNavigateWithinSoftTabs = function() {
            return this.$navigateWithinSoftTabs;
          };
          EditSession2.prototype.setOverwrite = function(overwrite) {
            this.setOption("overwrite", overwrite);
          };
          EditSession2.prototype.getOverwrite = function() {
            return this.$overwrite;
          };
          EditSession2.prototype.toggleOverwrite = function() {
            this.setOverwrite(!this.$overwrite);
          };
          EditSession2.prototype.addGutterDecoration = function(row, className) {
            if (!this.$decorations[row])
              this.$decorations[row] = "";
            this.$decorations[row] += " " + className;
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.removeGutterDecoration = function(row, className) {
            this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.getBreakpoints = function() {
            return this.$breakpoints;
          };
          EditSession2.prototype.setBreakpoints = function(rows) {
            this.$breakpoints = [];
            for (var i2 = 0; i2 < rows.length; i2++) {
              this.$breakpoints[rows[i2]] = "ace_breakpoint";
            }
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.clearBreakpoints = function() {
            this.$breakpoints = [];
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.setBreakpoint = function(row, className) {
            if (className === void 0)
              className = "ace_breakpoint";
            if (className)
              this.$breakpoints[row] = className;
            else
              delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.clearBreakpoint = function(row) {
            delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.addMarker = function(range, clazz, type, inFront) {
            var id = this.$markerId++;
            var marker = {
              range,
              type: type || "line",
              renderer: typeof type == "function" ? type : null,
              clazz,
              inFront: !!inFront,
              id
            };
            if (inFront) {
              this.$frontMarkers[id] = marker;
              this._signal("changeFrontMarker");
            } else {
              this.$backMarkers[id] = marker;
              this._signal("changeBackMarker");
            }
            return id;
          };
          EditSession2.prototype.addDynamicMarker = function(marker, inFront) {
            if (!marker.update)
              return;
            var id = this.$markerId++;
            marker.id = id;
            marker.inFront = !!inFront;
            if (inFront) {
              this.$frontMarkers[id] = marker;
              this._signal("changeFrontMarker");
            } else {
              this.$backMarkers[id] = marker;
              this._signal("changeBackMarker");
            }
            return marker;
          };
          EditSession2.prototype.removeMarker = function(markerId) {
            var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
            if (!marker)
              return;
            var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
            delete markers[markerId];
            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
          };
          EditSession2.prototype.getMarkers = function(inFront) {
            return inFront ? this.$frontMarkers : this.$backMarkers;
          };
          EditSession2.prototype.highlight = function(re2) {
            if (!this.$searchHighlight) {
              var highlight = new SearchHighlight(null, "ace_selected-word", "text");
              this.$searchHighlight = this.addDynamicMarker(highlight);
            }
            this.$searchHighlight.setRegexp(re2);
          };
          EditSession2.prototype.highlightLines = function(startRow, endRow, clazz, inFront) {
            if (typeof endRow != "number") {
              clazz = endRow;
              endRow = startRow;
            }
            if (!clazz)
              clazz = "ace_step";
            var range = new Range(startRow, 0, endRow, Infinity);
            range.id = this.addMarker(range, clazz, "fullLine", inFront);
            return range;
          };
          EditSession2.prototype.setAnnotations = function(annotations) {
            this.$annotations = annotations;
            this._signal("changeAnnotation", {});
          };
          EditSession2.prototype.getAnnotations = function() {
            return this.$annotations || [];
          };
          EditSession2.prototype.clearAnnotations = function() {
            this.setAnnotations([]);
          };
          EditSession2.prototype.$detectNewLine = function(text) {
            var match2 = text.match(/^.*?(\r?\n)/m);
            if (match2) {
              this.$autoNewLine = match2[1];
            } else {
              this.$autoNewLine = "\n";
            }
          };
          EditSession2.prototype.getWordRange = function(row, column) {
            var line = this.getLine(row);
            var inToken = false;
            if (column > 0)
              inToken = !!line.charAt(column - 1).match(this.tokenRe);
            if (!inToken)
              inToken = !!line.charAt(column).match(this.tokenRe);
            if (inToken)
              var re2 = this.tokenRe;
            else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
              var re2 = /\s/;
            else
              var re2 = this.nonTokenRe;
            var start = column;
            if (start > 0) {
              do {
                start--;
              } while (start >= 0 && line.charAt(start).match(re2));
              start++;
            }
            var end = column;
            while (end < line.length && line.charAt(end).match(re2)) {
              end++;
            }
            return new Range(row, start, row, end);
          };
          EditSession2.prototype.getAWordRange = function(row, column) {
            var wordRange = this.getWordRange(row, column);
            var line = this.getLine(wordRange.end.row);
            while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
              wordRange.end.column += 1;
            }
            return wordRange;
          };
          EditSession2.prototype.setNewLineMode = function(newLineMode) {
            this.doc.setNewLineMode(newLineMode);
          };
          EditSession2.prototype.getNewLineMode = function() {
            return this.doc.getNewLineMode();
          };
          EditSession2.prototype.setUseWorker = function(useWorker) {
            this.setOption("useWorker", useWorker);
          };
          EditSession2.prototype.getUseWorker = function() {
            return this.$useWorker;
          };
          EditSession2.prototype.onReloadTokenizer = function(e2) {
            var rows = e2.data;
            this.bgTokenizer.start(rows.first);
            this._signal("tokenizerUpdate", e2);
          };
          EditSession2.prototype.setMode = function(mode, cb) {
            if (mode && typeof mode === "object") {
              if (mode.getTokenizer)
                return this.$onChangeMode(mode);
              var options = mode;
              var path = options.path;
            } else {
              path = mode || "ace/mode/text";
            }
            if (!this.$modes["ace/mode/text"])
              this.$modes["ace/mode/text"] = new TextMode();
            if (this.$modes[path] && !options) {
              this.$onChangeMode(this.$modes[path]);
              cb && cb();
              return;
            }
            this.$modeId = path;
            config.loadModule(["mode", path], (function(m3) {
              if (this.$modeId !== path)
                return cb && cb();
              if (this.$modes[path] && !options) {
                this.$onChangeMode(this.$modes[path]);
              } else if (m3 && m3.Mode) {
                m3 = new m3.Mode(options);
                if (!options) {
                  this.$modes[path] = m3;
                  m3.$id = path;
                }
                this.$onChangeMode(m3);
              }
              cb && cb();
            }).bind(this));
            if (!this.$mode)
              this.$onChangeMode(this.$modes["ace/mode/text"], true);
          };
          EditSession2.prototype.$onChangeMode = function(mode, $isPlaceholder) {
            if (!$isPlaceholder)
              this.$modeId = mode.$id;
            if (this.$mode === mode)
              return;
            var oldMode = this.$mode;
            this.$mode = mode;
            this.$stopWorker();
            if (this.$useWorker)
              this.$startWorker();
            var tokenizer = mode.getTokenizer();
            if (tokenizer.on !== void 0) {
              var onReloadTokenizer = this.onReloadTokenizer.bind(this);
              tokenizer.on("update", onReloadTokenizer);
            }
            this.bgTokenizer.setTokenizer(tokenizer);
            this.bgTokenizer.setDocument(this.getDocument());
            this.tokenRe = mode.tokenRe;
            this.nonTokenRe = mode.nonTokenRe;
            if (!$isPlaceholder) {
              if (mode.attachToSession)
                mode.attachToSession(this);
              this.$options.wrapMethod.set.call(this, this.$wrapMethod);
              this.$setFolding(mode.foldingRules);
              this.bgTokenizer.start(0);
              this._emit("changeMode", { oldMode, mode });
            }
          };
          EditSession2.prototype.$stopWorker = function() {
            if (this.$worker) {
              this.$worker.terminate();
              this.$worker = null;
            }
          };
          EditSession2.prototype.$startWorker = function() {
            try {
              this.$worker = this.$mode.createWorker(this);
            } catch (e2) {
              config.warn("Could not load worker", e2);
              this.$worker = null;
            }
          };
          EditSession2.prototype.getMode = function() {
            return this.$mode;
          };
          EditSession2.prototype.setScrollTop = function(scrollTop) {
            if (this.$scrollTop === scrollTop || isNaN(scrollTop))
              return;
            this.$scrollTop = scrollTop;
            this._signal("changeScrollTop", scrollTop);
          };
          EditSession2.prototype.getScrollTop = function() {
            return this.$scrollTop;
          };
          EditSession2.prototype.setScrollLeft = function(scrollLeft) {
            if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
              return;
            this.$scrollLeft = scrollLeft;
            this._signal("changeScrollLeft", scrollLeft);
          };
          EditSession2.prototype.getScrollLeft = function() {
            return this.$scrollLeft;
          };
          EditSession2.prototype.getScreenWidth = function() {
            this.$computeWidth();
            if (this.lineWidgets)
              return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
            return this.screenWidth;
          };
          EditSession2.prototype.getLineWidgetMaxWidth = function() {
            if (this.lineWidgetsWidth != null)
              return this.lineWidgetsWidth;
            var width = 0;
            this.lineWidgets.forEach(function(w2) {
              if (w2 && w2.screenWidth > width)
                width = w2.screenWidth;
            });
            return this.lineWidgetWidth = width;
          };
          EditSession2.prototype.$computeWidth = function(force) {
            if (this.$modified || force) {
              this.$modified = false;
              if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;
              var lines = this.doc.getAllLines();
              var cache = this.$rowLengthCache;
              var longestScreenLine = 0;
              var foldIndex = 0;
              var foldLine = this.$foldData[foldIndex];
              var foldStart = foldLine ? foldLine.start.row : Infinity;
              var len = lines.length;
              for (var i2 = 0; i2 < len; i2++) {
                if (i2 > foldStart) {
                  i2 = foldLine.end.row + 1;
                  if (i2 >= len)
                    break;
                  foldLine = this.$foldData[foldIndex++];
                  foldStart = foldLine ? foldLine.start.row : Infinity;
                }
                if (cache[i2] == null)
                  cache[i2] = this.$getStringScreenWidth(lines[i2])[0];
                if (cache[i2] > longestScreenLine)
                  longestScreenLine = cache[i2];
              }
              this.screenWidth = longestScreenLine;
            }
          };
          EditSession2.prototype.getLine = function(row) {
            return this.doc.getLine(row);
          };
          EditSession2.prototype.getLines = function(firstRow, lastRow) {
            return this.doc.getLines(firstRow, lastRow);
          };
          EditSession2.prototype.getLength = function() {
            return this.doc.getLength();
          };
          EditSession2.prototype.getTextRange = function(range) {
            return this.doc.getTextRange(range || this.selection.getRange());
          };
          EditSession2.prototype.insert = function(position, text) {
            return this.doc.insert(position, text);
          };
          EditSession2.prototype.remove = function(range) {
            return this.doc.remove(range);
          };
          EditSession2.prototype.removeFullLines = function(firstRow, lastRow) {
            return this.doc.removeFullLines(firstRow, lastRow);
          };
          EditSession2.prototype.undoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
              return;
            this.$fromUndo = true;
            for (var i2 = deltas.length - 1; i2 != -1; i2--) {
              var delta = deltas[i2];
              if (delta.action == "insert" || delta.action == "remove") {
                this.doc.revertDelta(delta);
              } else if (delta.folds) {
                this.addFolds(delta.folds);
              }
            }
            if (!dontSelect && this.$undoSelect) {
              if (deltas.selectionBefore)
                this.selection.fromJSON(deltas.selectionBefore);
              else
                this.selection.setRange(this.$getUndoSelection(deltas, true));
            }
            this.$fromUndo = false;
          };
          EditSession2.prototype.redoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
              return;
            this.$fromUndo = true;
            for (var i2 = 0; i2 < deltas.length; i2++) {
              var delta = deltas[i2];
              if (delta.action == "insert" || delta.action == "remove") {
                this.doc.$safeApplyDelta(delta);
              }
            }
            if (!dontSelect && this.$undoSelect) {
              if (deltas.selectionAfter)
                this.selection.fromJSON(deltas.selectionAfter);
              else
                this.selection.setRange(this.$getUndoSelection(deltas, false));
            }
            this.$fromUndo = false;
          };
          EditSession2.prototype.setUndoSelect = function(enable) {
            this.$undoSelect = enable;
          };
          EditSession2.prototype.$getUndoSelection = function(deltas, isUndo) {
            function isInsert(delta2) {
              return isUndo ? delta2.action !== "insert" : delta2.action === "insert";
            }
            var range, point;
            for (var i2 = 0; i2 < deltas.length; i2++) {
              var delta = deltas[i2];
              if (!delta.start)
                continue;
              if (!range) {
                if (isInsert(delta)) {
                  range = Range.fromPoints(delta.start, delta.end);
                } else {
                  range = Range.fromPoints(delta.start, delta.start);
                }
                continue;
              }
              if (isInsert(delta)) {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                  range.setStart(point);
                }
                point = delta.end;
                if (range.compare(point.row, point.column) == 1) {
                  range.setEnd(point);
                }
              } else {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                  range = Range.fromPoints(delta.start, delta.start);
                }
              }
            }
            return range;
          };
          EditSession2.prototype.replace = function(range, text) {
            return this.doc.replace(range, text);
          };
          EditSession2.prototype.moveText = function(fromRange, toPosition, copy) {
            var text = this.getTextRange(fromRange);
            var folds = this.getFoldsInRange(fromRange);
            var toRange = Range.fromPoints(toPosition, toPosition);
            if (!copy) {
              this.remove(fromRange);
              var rowDiff = fromRange.start.row - fromRange.end.row;
              var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
              if (collDiff) {
                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                  toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                  toRange.end.column += collDiff;
              }
              if (rowDiff && toRange.start.row >= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
              }
            }
            toRange.end = this.insert(toRange.start, text);
            if (folds.length) {
              var oldStart = fromRange.start;
              var newStart = toRange.start;
              var rowDiff = newStart.row - oldStart.row;
              var collDiff = newStart.column - oldStart.column;
              this.addFolds(folds.map(function(x2) {
                x2 = x2.clone();
                if (x2.start.row == oldStart.row)
                  x2.start.column += collDiff;
                if (x2.end.row == oldStart.row)
                  x2.end.column += collDiff;
                x2.start.row += rowDiff;
                x2.end.row += rowDiff;
                return x2;
              }));
            }
            return toRange;
          };
          EditSession2.prototype.indentRows = function(startRow, endRow, indentString) {
            indentString = indentString.replace(/\t/g, this.getTabString());
            for (var row = startRow; row <= endRow; row++)
              this.doc.insertInLine({ row, column: 0 }, indentString);
          };
          EditSession2.prototype.outdentRows = function(range) {
            var rowRange = range.collapseRows();
            var deleteRange = new Range(0, 0, 0, 0);
            var size = this.getTabSize();
            for (var i2 = rowRange.start.row; i2 <= rowRange.end.row; ++i2) {
              var line = this.getLine(i2);
              deleteRange.start.row = i2;
              deleteRange.end.row = i2;
              for (var j = 0; j < size; ++j)
                if (line.charAt(j) != " ")
                  break;
              if (j < size && line.charAt(j) == "	") {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
              } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
              }
              this.remove(deleteRange);
            }
          };
          EditSession2.prototype.$moveLines = function(firstRow, lastRow, dir) {
            firstRow = this.getRowFoldStart(firstRow);
            lastRow = this.getRowFoldEnd(lastRow);
            if (dir < 0) {
              var row = this.getRowFoldStart(firstRow + dir);
              if (row < 0)
                return 0;
              var diff = row - firstRow;
            } else if (dir > 0) {
              var row = this.getRowFoldEnd(lastRow + dir);
              if (row > this.doc.getLength() - 1)
                return 0;
              var diff = row - lastRow;
            } else {
              firstRow = this.$clipRowToDocument(firstRow);
              lastRow = this.$clipRowToDocument(lastRow);
              var diff = lastRow - firstRow + 1;
            }
            var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
            var folds = this.getFoldsInRange(range).map(function(x2) {
              x2 = x2.clone();
              x2.start.row += diff;
              x2.end.row += diff;
              return x2;
            });
            var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
            this.doc.insertFullLines(firstRow + diff, lines);
            folds.length && this.addFolds(folds);
            return diff;
          };
          EditSession2.prototype.moveLinesUp = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, -1);
          };
          EditSession2.prototype.moveLinesDown = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 1);
          };
          EditSession2.prototype.duplicateLines = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 0);
          };
          EditSession2.prototype.$clipRowToDocument = function(row) {
            return Math.max(0, Math.min(row, this.doc.getLength() - 1));
          };
          EditSession2.prototype.$clipColumnToRow = function(row, column) {
            if (column < 0)
              return 0;
            return Math.min(this.doc.getLine(row).length, column);
          };
          EditSession2.prototype.$clipPositionToDocument = function(row, column) {
            column = Math.max(0, column);
            if (row < 0) {
              row = 0;
              column = 0;
            } else {
              var len = this.doc.getLength();
              if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len - 1).length;
              } else {
                column = Math.min(this.doc.getLine(row).length, column);
              }
            }
            return {
              row,
              column
            };
          };
          EditSession2.prototype.$clipRangeToDocument = function(range) {
            if (range.start.row < 0) {
              range.start.row = 0;
              range.start.column = 0;
            } else {
              range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
            }
            var len = this.doc.getLength() - 1;
            if (range.end.row > len) {
              range.end.row = len;
              range.end.column = this.doc.getLine(len).length;
            } else {
              range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
            }
            return range;
          };
          EditSession2.prototype.setUseWrapMode = function(useWrapMode) {
            if (useWrapMode != this.$useWrapMode) {
              this.$useWrapMode = useWrapMode;
              this.$modified = true;
              this.$resetRowCache(0);
              if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array(len);
                this.$updateWrapData(0, len - 1);
              }
              this._signal("changeWrapMode");
            }
          };
          EditSession2.prototype.getUseWrapMode = function() {
            return this.$useWrapMode;
          };
          EditSession2.prototype.setWrapLimitRange = function(min, max) {
            if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
              this.$wrapLimitRange = { min, max };
              this.$modified = true;
              this.$bidiHandler.markAsDirty();
              if (this.$useWrapMode)
                this._signal("changeWrapMode");
            }
          };
          EditSession2.prototype.adjustWrapLimit = function(desiredLimit, $printMargin) {
            var limits = this.$wrapLimitRange;
            if (limits.max < 0)
              limits = { min: $printMargin, max: $printMargin };
            var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
            if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
              this.$wrapLimit = wrapLimit;
              this.$modified = true;
              if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal("changeWrapLimit");
              }
              return true;
            }
            return false;
          };
          EditSession2.prototype.$constrainWrapLimit = function(wrapLimit, min, max) {
            if (min)
              wrapLimit = Math.max(min, wrapLimit);
            if (max)
              wrapLimit = Math.min(max, wrapLimit);
            return wrapLimit;
          };
          EditSession2.prototype.getWrapLimit = function() {
            return this.$wrapLimit;
          };
          EditSession2.prototype.setWrapLimit = function(limit) {
            this.setWrapLimitRange(limit, limit);
          };
          EditSession2.prototype.getWrapLimitRange = function() {
            return {
              min: this.$wrapLimitRange.min,
              max: this.$wrapLimitRange.max
            };
          };
          EditSession2.prototype.$updateInternalDataOnChange = function(delta) {
            var useWrapMode = this.$useWrapMode;
            var action = delta.action;
            var start = delta.start;
            var end = delta.end;
            var firstRow = start.row;
            var lastRow = end.row;
            var len = lastRow - firstRow;
            var removedFolds = null;
            this.$updating = true;
            if (len != 0) {
              if (action === "remove") {
                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                  foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                  foldLine.shiftRow(-len);
                  var foldLineBefore = this.getFoldLine(firstRow);
                  if (foldLineBefore && foldLineBefore !== foldLine) {
                    foldLineBefore.merge(foldLine);
                    foldLine = foldLineBefore;
                  }
                  idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx < foldLines.length; idx++) {
                  var foldLine = foldLines[idx];
                  if (foldLine.start.row >= end.row) {
                    foldLine.shiftRow(-len);
                  }
                }
                lastRow = firstRow;
              } else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                arr.splice.apply(arr, args);
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                  var cmp = foldLine.range.compareInside(start.row, start.column);
                  if (cmp == 0) {
                    foldLine = foldLine.split(start.row, start.column);
                    if (foldLine) {
                      foldLine.shiftRow(len);
                      foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                    }
                  } else if (cmp == -1) {
                    foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                    foldLine.shiftRow(len);
                  }
                  idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx < foldLines.length; idx++) {
                  var foldLine = foldLines[idx];
                  if (foldLine.start.row >= firstRow) {
                    foldLine.shiftRow(len);
                  }
                }
              }
            } else {
              len = Math.abs(delta.start.column - delta.end.column);
              if (action === "remove") {
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                len = -len;
              }
              var foldLine = this.getFoldLine(firstRow);
              if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
              }
            }
            if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
              console.error("doc.getLength() and $wrapData.length have to be the same!");
            }
            this.$updating = false;
            if (useWrapMode)
              this.$updateWrapData(firstRow, lastRow);
            else
              this.$updateRowLengthCache(firstRow, lastRow);
            return removedFolds;
          };
          EditSession2.prototype.$updateRowLengthCache = function(firstRow, lastRow, b2) {
            this.$rowLengthCache[firstRow] = null;
            this.$rowLengthCache[lastRow] = null;
          };
          EditSession2.prototype.$updateWrapData = function(firstRow, lastRow) {
            var lines = this.doc.getAllLines();
            var tabSize = this.getTabSize();
            var wrapData = this.$wrapData;
            var wrapLimit = this.$wrapLimit;
            var tokens;
            var foldLine;
            var row = firstRow;
            lastRow = Math.min(lastRow, lines.length - 1);
            while (row <= lastRow) {
              foldLine = this.getFoldLine(row, foldLine);
              if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row++;
              } else {
                tokens = [];
                foldLine.walk((function(placeholder, row2, column, lastColumn) {
                  var walkTokens;
                  if (placeholder != null) {
                    walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                    walkTokens[0] = PLACEHOLDER_START;
                    for (var i2 = 1; i2 < walkTokens.length; i2++) {
                      walkTokens[i2] = PLACEHOLDER_BODY;
                    }
                  } else {
                    walkTokens = this.$getDisplayTokens(lines[row2].substring(lastColumn, column), tokens.length);
                  }
                  tokens = tokens.concat(walkTokens);
                }).bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
              }
            }
          };
          EditSession2.prototype.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
            if (tokens.length == 0) {
              return [];
            }
            var splits = [];
            var displayLength = tokens.length;
            var lastSplit = 0, lastDocSplit = 0;
            var isCode = this.$wrapAsCode;
            var indentedSoftWrap = this.$indentedSoftWrap;
            var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8) || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
            function getWrapIndent() {
              var indentation = 0;
              if (maxIndent === 0)
                return indentation;
              if (indentedSoftWrap) {
                for (var i2 = 0; i2 < tokens.length; i2++) {
                  var token = tokens[i2];
                  if (token == SPACE)
                    indentation += 1;
                  else if (token == TAB)
                    indentation += tabSize;
                  else if (token == TAB_SPACE)
                    continue;
                  else
                    break;
                }
              }
              if (isCode && indentedSoftWrap !== false)
                indentation += tabSize;
              return Math.min(indentation, maxIndent);
            }
            function addSplit(screenPos) {
              var len = screenPos - lastSplit;
              for (var i2 = lastSplit; i2 < screenPos; i2++) {
                var ch = tokens[i2];
                if (ch === 12 || ch === 2)
                  len -= 1;
              }
              if (!splits.length) {
                indent = getWrapIndent();
                splits.indent = indent;
              }
              lastDocSplit += len;
              splits.push(lastDocSplit);
              lastSplit = screenPos;
            }
            var indent = 0;
            while (displayLength - lastSplit > wrapLimit - indent) {
              var split2 = lastSplit + wrapLimit - indent;
              if (tokens[split2 - 1] >= SPACE && tokens[split2] >= SPACE) {
                addSplit(split2);
                continue;
              }
              if (tokens[split2] == PLACEHOLDER_START || tokens[split2] == PLACEHOLDER_BODY) {
                for (split2; split2 != lastSplit - 1; split2--) {
                  if (tokens[split2] == PLACEHOLDER_START) {
                    break;
                  }
                }
                if (split2 > lastSplit) {
                  addSplit(split2);
                  continue;
                }
                split2 = lastSplit + wrapLimit;
                for (split2; split2 < tokens.length; split2++) {
                  if (tokens[split2] != PLACEHOLDER_BODY) {
                    break;
                  }
                }
                if (split2 == tokens.length) {
                  break;
                }
                addSplit(split2);
                continue;
              }
              var minSplit = Math.max(split2 - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
              while (split2 > minSplit && tokens[split2] < PLACEHOLDER_START) {
                split2--;
              }
              if (isCode) {
                while (split2 > minSplit && tokens[split2] < PLACEHOLDER_START) {
                  split2--;
                }
                while (split2 > minSplit && tokens[split2] == PUNCTUATION) {
                  split2--;
                }
              } else {
                while (split2 > minSplit && tokens[split2] < SPACE) {
                  split2--;
                }
              }
              if (split2 > minSplit) {
                addSplit(++split2);
                continue;
              }
              split2 = lastSplit + wrapLimit;
              if (tokens[split2] == CHAR_EXT)
                split2--;
              addSplit(split2 - indent);
            }
            return splits;
          };
          EditSession2.prototype.$getDisplayTokens = function(str, offset) {
            var arr = [];
            var tabSize;
            offset = offset || 0;
            for (var i2 = 0; i2 < str.length; i2++) {
              var c2 = str.charCodeAt(i2);
              if (c2 == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                  arr.push(TAB_SPACE);
                }
              } else if (c2 == 32) {
                arr.push(SPACE);
              } else if (c2 > 39 && c2 < 48 || c2 > 57 && c2 < 64) {
                arr.push(PUNCTUATION);
              } else if (c2 >= 4352 && isFullWidth(c2)) {
                arr.push(CHAR, CHAR_EXT);
              } else {
                arr.push(CHAR);
              }
            }
            return arr;
          };
          EditSession2.prototype.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn == 0)
              return [0, 0];
            if (maxScreenColumn == null)
              maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;
            var c2, column;
            for (column = 0; column < str.length; column++) {
              c2 = str.charCodeAt(column);
              if (c2 == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
              } else if (c2 >= 4352 && isFullWidth(c2)) {
                screenColumn += 2;
              } else {
                screenColumn += 1;
              }
              if (screenColumn > maxScreenColumn) {
                break;
              }
            }
            return [screenColumn, column];
          };
          EditSession2.prototype.getRowLength = function(row) {
            var h3 = 1;
            if (this.lineWidgets)
              h3 += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            if (!this.$useWrapMode || !this.$wrapData[row])
              return h3;
            else
              return this.$wrapData[row].length + h3;
          };
          EditSession2.prototype.getRowLineCount = function(row) {
            if (!this.$useWrapMode || !this.$wrapData[row]) {
              return 1;
            } else {
              return this.$wrapData[row].length + 1;
            }
          };
          EditSession2.prototype.getRowWrapIndent = function(screenRow) {
            if (this.$useWrapMode) {
              var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
              var splits = this.$wrapData[pos.row];
              return splits.length && splits[0] < pos.column ? splits.indent : 0;
            } else {
              return 0;
            }
          };
          EditSession2.prototype.getScreenLastRowColumn = function(screenRow) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            return this.documentToScreenColumn(pos.row, pos.column);
          };
          EditSession2.prototype.getDocumentLastRowColumn = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.getScreenLastRowColumn(screenRow);
          };
          EditSession2.prototype.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
          };
          EditSession2.prototype.getRowSplitData = function(row) {
            if (!this.$useWrapMode) {
              return void 0;
            } else {
              return this.$wrapData[row];
            }
          };
          EditSession2.prototype.getScreenTabSize = function(screenColumn) {
            return this.$tabSize - (screenColumn % this.$tabSize | 0);
          };
          EditSession2.prototype.screenToDocumentRow = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).row;
          };
          EditSession2.prototype.screenToDocumentColumn = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).column;
          };
          EditSession2.prototype.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {
            if (screenRow < 0)
              return { row: 0, column: 0 };
            var line;
            var docRow = 0;
            var docColumn = 0;
            var column;
            var row = 0;
            var rowLength = 0;
            var rowCache = this.$screenRowCache;
            var i2 = this.$getRowCacheIndex(rowCache, screenRow);
            var l = rowCache.length;
            if (l && i2 >= 0) {
              var row = rowCache[i2];
              var docRow = this.$docRowCache[i2];
              var doCache = screenRow > rowCache[l - 1];
            } else {
              var doCache = !l;
            }
            var maxRow = this.getLength() - 1;
            var foldLine = this.getNextFoldLine(docRow);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (row <= screenRow) {
              rowLength = this.getRowLength(docRow);
              if (row + rowLength > screenRow || docRow >= maxRow) {
                break;
              } else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                  docRow = foldLine.end.row + 1;
                  foldLine = this.getNextFoldLine(docRow, foldLine);
                  foldStart = foldLine ? foldLine.start.row : Infinity;
                }
              }
              if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
              }
            }
            if (foldLine && foldLine.start.row <= docRow) {
              line = this.getFoldDisplayLine(foldLine);
              docRow = foldLine.start.row;
            } else if (row + rowLength <= screenRow || docRow > maxRow) {
              return {
                row: maxRow,
                column: this.getLine(maxRow).length
              };
            } else {
              line = this.getLine(docRow);
              foldLine = null;
            }
            var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
            if (this.$useWrapMode) {
              var splits = this.$wrapData[docRow];
              if (splits) {
                column = splits[splitIndex];
                if (splitIndex > 0 && splits.length) {
                  wrapIndent = splits.indent;
                  docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                  line = line.substring(docColumn);
                }
              }
            }
            if (offsetX !== void 0 && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
              screenColumn = this.$bidiHandler.offsetToCol(offsetX);
            docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
            if (this.$useWrapMode && docColumn >= column)
              docColumn = column - 1;
            if (foldLine)
              return foldLine.idxToPosition(docColumn);
            return { row: docRow, column: docColumn };
          };
          EditSession2.prototype.documentToScreenPosition = function(docRow, docColumn) {
            if (typeof docColumn === "undefined")
              var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
            else
              pos = this.$clipPositionToDocument(docRow, docColumn);
            docRow = pos.row;
            docColumn = pos.column;
            var screenRow = 0;
            var foldStartRow = null;
            var fold = null;
            fold = this.getFoldAt(docRow, docColumn, 1);
            if (fold) {
              docRow = fold.start.row;
              docColumn = fold.start.column;
            }
            var rowEnd, row = 0;
            var rowCache = this.$docRowCache;
            var i2 = this.$getRowCacheIndex(rowCache, docRow);
            var l = rowCache.length;
            if (l && i2 >= 0) {
              var row = rowCache[i2];
              var screenRow = this.$screenRowCache[i2];
              var doCache = docRow > rowCache[l - 1];
            } else {
              var doCache = !l;
            }
            var foldLine = this.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (row < docRow) {
              if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                  break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              } else {
                rowEnd = row + 1;
              }
              screenRow += this.getRowLength(row);
              row = rowEnd;
              if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
              }
            }
            var textLine = "";
            if (foldLine && row >= foldStart) {
              textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
              foldStartRow = foldLine.start.row;
            } else {
              textLine = this.getLine(docRow).substring(0, docColumn);
              foldStartRow = docRow;
            }
            var wrapIndent = 0;
            if (this.$useWrapMode) {
              var wrapRow = this.$wrapData[foldStartRow];
              if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length >= wrapRow[screenRowOffset]) {
                  screenRow++;
                  screenRowOffset++;
                }
                textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
              }
            }
            if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)
              screenRow += this.lineWidgets[row].rowsAbove;
            return {
              row: screenRow,
              column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
            };
          };
          EditSession2.prototype.documentToScreenColumn = function(row, docColumn) {
            return this.documentToScreenPosition(row, docColumn).column;
          };
          EditSession2.prototype.documentToScreenRow = function(docRow, docColumn) {
            return this.documentToScreenPosition(docRow, docColumn).row;
          };
          EditSession2.prototype.getScreenLength = function() {
            var screenRows = 0;
            var fold = null;
            if (!this.$useWrapMode) {
              screenRows = this.getLength();
              var foldData = this.$foldData;
              for (var i2 = 0; i2 < foldData.length; i2++) {
                fold = foldData[i2];
                screenRows -= fold.end.row - fold.start.row;
              }
            } else {
              var lastRow = this.$wrapData.length;
              var row = 0, i2 = 0;
              var fold = this.$foldData[i2++];
              var foldStart = fold ? fold.start.row : Infinity;
              while (row < lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row++;
                if (row > foldStart) {
                  row = fold.end.row + 1;
                  fold = this.$foldData[i2++];
                  foldStart = fold ? fold.start.row : Infinity;
                }
              }
            }
            if (this.lineWidgets)
              screenRows += this.$getWidgetScreenLength();
            return screenRows;
          };
          EditSession2.prototype.$setFontMetrics = function(fm) {
            if (!this.$enableVarChar)
              return;
            this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
              if (maxScreenColumn === 0)
                return [0, 0];
              if (!maxScreenColumn)
                maxScreenColumn = Infinity;
              screenColumn = screenColumn || 0;
              var c2, column;
              for (column = 0; column < str.length; column++) {
                c2 = str.charAt(column);
                if (c2 === "	") {
                  screenColumn += this.getScreenTabSize(screenColumn);
                } else {
                  screenColumn += fm.getCharacterWidth(c2);
                }
                if (screenColumn > maxScreenColumn) {
                  break;
                }
              }
              return [screenColumn, column];
            };
          };
          EditSession2.prototype.destroy = function() {
            if (!this.destroyed) {
              this.bgTokenizer.setDocument(null);
              this.bgTokenizer.cleanup();
              this.destroyed = true;
            }
            this.$stopWorker();
            this.removeAllListeners();
            if (this.doc) {
              this.doc.off("change", this.$onChange);
            }
            this.selection.detach();
          };
          return EditSession2;
        }()
      );
      EditSession.$uid = 0;
      EditSession.prototype.$modes = config.$modes;
      EditSession.prototype.getValue = EditSession.prototype.toString;
      EditSession.prototype.$defaultUndoManager = {
        undo: function() {
        },
        redo: function() {
        },
        hasUndo: function() {
        },
        hasRedo: function() {
        },
        reset: function() {
        },
        add: function() {
        },
        addSelection: function() {
        },
        startNewGroup: function() {
        },
        addSession: function() {
        }
      };
      EditSession.prototype.$overwrite = false;
      EditSession.prototype.$mode = null;
      EditSession.prototype.$modeId = null;
      EditSession.prototype.$scrollTop = 0;
      EditSession.prototype.$scrollLeft = 0;
      EditSession.prototype.$wrapLimit = 80;
      EditSession.prototype.$useWrapMode = false;
      EditSession.prototype.$wrapLimitRange = {
        min: null,
        max: null
      };
      EditSession.prototype.lineWidgets = null;
      EditSession.prototype.isFullWidth = isFullWidth;
      oop.implement(EditSession.prototype, EventEmitter);
      var CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;
      function isFullWidth(c2) {
        if (c2 < 4352)
          return false;
        return c2 >= 4352 && c2 <= 4447 || c2 >= 4515 && c2 <= 4519 || c2 >= 4602 && c2 <= 4607 || c2 >= 9001 && c2 <= 9002 || c2 >= 11904 && c2 <= 11929 || c2 >= 11931 && c2 <= 12019 || c2 >= 12032 && c2 <= 12245 || c2 >= 12272 && c2 <= 12283 || c2 >= 12288 && c2 <= 12350 || c2 >= 12353 && c2 <= 12438 || c2 >= 12441 && c2 <= 12543 || c2 >= 12549 && c2 <= 12589 || c2 >= 12593 && c2 <= 12686 || c2 >= 12688 && c2 <= 12730 || c2 >= 12736 && c2 <= 12771 || c2 >= 12784 && c2 <= 12830 || c2 >= 12832 && c2 <= 12871 || c2 >= 12880 && c2 <= 13054 || c2 >= 13056 && c2 <= 19903 || c2 >= 19968 && c2 <= 42124 || c2 >= 42128 && c2 <= 42182 || c2 >= 43360 && c2 <= 43388 || c2 >= 44032 && c2 <= 55203 || c2 >= 55216 && c2 <= 55238 || c2 >= 55243 && c2 <= 55291 || c2 >= 63744 && c2 <= 64255 || c2 >= 65040 && c2 <= 65049 || c2 >= 65072 && c2 <= 65106 || c2 >= 65108 && c2 <= 65126 || c2 >= 65128 && c2 <= 65131 || c2 >= 65281 && c2 <= 65376 || c2 >= 65504 && c2 <= 65510;
      }
      require2("./edit_session/folding").Folding.call(EditSession.prototype);
      require2("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
      config.defineOptions(EditSession.prototype, "session", {
        wrap: {
          set: function(value) {
            if (!value || value == "off")
              value = false;
            else if (value == "free")
              value = true;
            else if (value == "printMargin")
              value = -1;
            else if (typeof value == "string")
              value = parseInt(value, 10) || false;
            if (this.$wrap == value)
              return;
            this.$wrap = value;
            if (!value) {
              this.setUseWrapMode(false);
            } else {
              var col = typeof value == "number" ? value : null;
              this.setWrapLimitRange(col, col);
              this.setUseWrapMode(true);
            }
          },
          get: function() {
            if (this.getUseWrapMode()) {
              if (this.$wrap == -1)
                return "printMargin";
              if (!this.getWrapLimitRange().min)
                return "free";
              return this.$wrap;
            }
            return "off";
          },
          handlesSet: true
        },
        wrapMethod: {
          set: function(val) {
            val = val == "auto" ? this.$mode.type != "text" : val != "text";
            if (val != this.$wrapAsCode) {
              this.$wrapAsCode = val;
              if (this.$useWrapMode) {
                this.$useWrapMode = false;
                this.setUseWrapMode(true);
              }
            }
          },
          initialValue: "auto"
        },
        indentedSoftWrap: {
          set: function() {
            if (this.$useWrapMode) {
              this.$useWrapMode = false;
              this.setUseWrapMode(true);
            }
          },
          initialValue: true
        },
        firstLineNumber: {
          set: function() {
            this._signal("changeBreakpoint");
          },
          initialValue: 1
        },
        useWorker: {
          set: function(useWorker) {
            this.$useWorker = useWorker;
            this.$stopWorker();
            if (useWorker)
              this.$startWorker();
          },
          initialValue: true
        },
        useSoftTabs: { initialValue: true },
        tabSize: {
          set: function(tabSize) {
            tabSize = parseInt(tabSize);
            if (tabSize > 0 && this.$tabSize !== tabSize) {
              this.$modified = true;
              this.$rowLengthCache = [];
              this.$tabSize = tabSize;
              this._signal("changeTabSize");
            }
          },
          initialValue: 4,
          handlesSet: true
        },
        navigateWithinSoftTabs: { initialValue: false },
        foldStyle: {
          set: function(val) {
            this.setFoldStyle(val);
          },
          handlesSet: true
        },
        overwrite: {
          set: function(val) {
            this._signal("changeOverwrite");
          },
          initialValue: false
        },
        newLineMode: {
          set: function(val) {
            this.doc.setNewLineMode(val);
          },
          get: function() {
            return this.doc.getNewLineMode();
          },
          handlesSet: true
        },
        mode: {
          set: function(val) {
            this.setMode(val);
          },
          get: function() {
            return this.$modeId;
          },
          handlesSet: true
        }
      });
      exports3.EditSession = EditSession;
    });
    ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(require2, exports3, module3) {
      var lang = require2("./lib/lang");
      var oop = require2("./lib/oop");
      var Range = require2("./range").Range;
      var Search = (
        /** @class */
        function() {
          function Search2() {
            this.$options = {};
          }
          Search2.prototype.set = function(options) {
            oop.mixin(this.$options, options);
            return this;
          };
          Search2.prototype.getOptions = function() {
            return lang.copyObject(this.$options);
          };
          Search2.prototype.setOptions = function(options) {
            this.$options = options;
          };
          Search2.prototype.find = function(session) {
            var options = this.$options;
            var iterator = this.$matchIterator(session, options);
            if (!iterator)
              return false;
            var firstRange = null;
            iterator.forEach(function(sr, sc, er, ec) {
              firstRange = new Range(sr, sc, er, ec);
              if (sc == ec && options.start && options.start.start && options.skipCurrent != false && firstRange.isEqual(options.start)) {
                firstRange = null;
                return false;
              }
              return true;
            });
            return firstRange;
          };
          Search2.prototype.findAll = function(session) {
            var options = this.$options;
            if (!options.needle)
              return [];
            this.$assembleRegExp(options);
            var range = options.range;
            var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
            var ranges = [];
            var re2 = options.re;
            if (options.$isMultiLine) {
              var len = re2.length;
              var maxRow = lines.length - len;
              var prevRange;
              outer: for (var row = re2.offset || 0; row <= maxRow; row++) {
                for (var j = 0; j < len; j++)
                  if (lines[row + j].search(re2[j]) == -1)
                    continue outer;
                var startLine = lines[row];
                var line = lines[row + len - 1];
                var startIndex = startLine.length - startLine.match(re2[0])[0].length;
                var endIndex = line.match(re2[len - 1])[0].length;
                if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                  continue;
                }
                ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
                if (len > 2)
                  row = row + len - 2;
              }
            } else {
              for (var i2 = 0; i2 < lines.length; i2++) {
                var matches2 = lang.getMatchOffsets(lines[i2], re2);
                for (var j = 0; j < matches2.length; j++) {
                  var match2 = matches2[j];
                  ranges.push(new Range(i2, match2.offset, i2, match2.offset + match2.length));
                }
              }
            }
            if (range) {
              var startColumn = range.start.column;
              var endColumn = range.end.column;
              var i2 = 0, j = ranges.length - 1;
              while (i2 < j && ranges[i2].start.column < startColumn && ranges[i2].start.row == 0)
                i2++;
              var endRow = range.end.row - range.start.row;
              while (i2 < j && ranges[j].end.column > endColumn && ranges[j].end.row == endRow)
                j--;
              ranges = ranges.slice(i2, j + 1);
              for (i2 = 0, j = ranges.length; i2 < j; i2++) {
                ranges[i2].start.row += range.start.row;
                ranges[i2].end.row += range.start.row;
              }
            }
            return ranges;
          };
          Search2.prototype.replace = function(input, replacement) {
            var options = this.$options;
            var re2 = this.$assembleRegExp(options);
            if (options.$isMultiLine)
              return replacement;
            if (!re2)
              return;
            var match2 = re2.exec(input);
            if (!match2 || match2[0].length != input.length)
              return null;
            replacement = input.replace(re2, replacement);
            if (options.preserveCase) {
              replacement = replacement.split("");
              for (var i2 = Math.min(input.length, input.length); i2--; ) {
                var ch = input[i2];
                if (ch && ch.toLowerCase() != ch)
                  replacement[i2] = replacement[i2].toUpperCase();
                else
                  replacement[i2] = replacement[i2].toLowerCase();
              }
              replacement = replacement.join("");
            }
            return replacement;
          };
          Search2.prototype.$assembleRegExp = function(options, $disableFakeMultiline) {
            if (options.needle instanceof RegExp)
              return options.re = options.needle;
            var needle = options.needle;
            if (!options.needle)
              return options.re = false;
            if (!options.regExp)
              needle = lang.escapeRegExp(needle);
            if (options.wholeWord)
              needle = addWordBoundary(needle, options);
            var modifier = options.caseSensitive ? "gm" : "gmi";
            options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
            if (options.$isMultiLine)
              return options.re = this.$assembleMultilineRegExp(needle, modifier);
            try {
              var re2 = new RegExp(needle, modifier);
            } catch (e2) {
              re2 = false;
            }
            return options.re = re2;
          };
          Search2.prototype.$assembleMultilineRegExp = function(needle, modifier) {
            var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
            var re2 = [];
            for (var i2 = 0; i2 < parts.length; i2++)
              try {
                re2.push(new RegExp(parts[i2], modifier));
              } catch (e2) {
                return false;
              }
            return re2;
          };
          Search2.prototype.$matchIterator = function(session, options) {
            var re2 = this.$assembleRegExp(options);
            if (!re2)
              return false;
            var backwards = options.backwards == true;
            var skipCurrent = options.skipCurrent != false;
            var range = options.range;
            var start = options.start;
            if (!start)
              start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
            if (start.start)
              start = start[skipCurrent != backwards ? "end" : "start"];
            var firstRow = range ? range.start.row : 0;
            var lastRow = range ? range.end.row : session.getLength() - 1;
            if (backwards) {
              var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                  return;
                for (row--; row >= firstRow; row--)
                  if (forEachInLine(row, Number.MAX_VALUE, callback))
                    return;
                if (options.wrap == false)
                  return;
                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                  if (forEachInLine(row, Number.MAX_VALUE, callback))
                    return;
              };
            } else {
              var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                  return;
                for (row = row + 1; row <= lastRow; row++)
                  if (forEachInLine(row, 0, callback))
                    return;
                if (options.wrap == false)
                  return;
                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                  if (forEachInLine(row, 0, callback))
                    return;
              };
            }
            if (options.$isMultiLine) {
              var len = re2.length;
              var forEachInLine = function(row, offset, callback) {
                var startRow = backwards ? row - len + 1 : row;
                if (startRow < 0 || startRow + len > session.getLength())
                  return;
                var line = session.getLine(startRow);
                var startIndex = line.search(re2[0]);
                if (!backwards && startIndex < offset || startIndex === -1)
                  return;
                for (var i2 = 1; i2 < len; i2++) {
                  line = session.getLine(startRow + i2);
                  if (line.search(re2[i2]) == -1)
                    return;
                }
                var endIndex = line.match(re2[len - 1])[0].length;
                if (backwards && endIndex > offset)
                  return;
                if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                  return true;
              };
            } else if (backwards) {
              var forEachInLine = function(row, endIndex, callback) {
                var line = session.getLine(row);
                var matches2 = [];
                var m3, last = 0;
                re2.lastIndex = 0;
                while (m3 = re2.exec(line)) {
                  var length = m3[0].length;
                  last = m3.index;
                  if (!length) {
                    if (last >= line.length)
                      break;
                    re2.lastIndex = last += 1;
                  }
                  if (m3.index + length > endIndex)
                    break;
                  matches2.push(m3.index, length);
                }
                for (var i2 = matches2.length - 1; i2 >= 0; i2 -= 2) {
                  var column = matches2[i2 - 1];
                  var length = matches2[i2];
                  if (callback(row, column, row, column + length))
                    return true;
                }
              };
            } else {
              var forEachInLine = function(row, startIndex, callback) {
                var line = session.getLine(row);
                var last;
                var m3;
                re2.lastIndex = startIndex;
                while (m3 = re2.exec(line)) {
                  var length = m3[0].length;
                  last = m3.index;
                  if (callback(row, last, row, last + length))
                    return true;
                  if (!length) {
                    re2.lastIndex = last += 1;
                    if (last >= line.length)
                      return false;
                  }
                }
              };
            }
            return { forEach };
          };
          return Search2;
        }()
      );
      function addWordBoundary(needle, options) {
        function wordBoundary(c2) {
          if (/\w/.test(c2) || options.regExp)
            return "\\b";
          return "";
        }
        return wordBoundary(needle[0]) + needle + wordBoundary(needle[needle.length - 1]);
      }
      exports3.Search = Search;
    });
    ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require2, exports3, module3) {
      var keyUtil = require2("../lib/keys");
      var useragent = require2("../lib/useragent");
      var KEY_MODS = keyUtil.KEY_MODS;
      function HashHandler(config, platform) {
        this.platform = platform || (useragent.isMac ? "mac" : "win");
        this.commands = {};
        this.commandKeyBinding = {};
        this.addCommands(config);
        this.$singleCommand = true;
      }
      function MultiHashHandler(config, platform) {
        HashHandler.call(this, config, platform);
        this.$singleCommand = false;
      }
      MultiHashHandler.prototype = HashHandler.prototype;
      (function() {
        this.addCommand = function(command) {
          if (this.commands[command.name])
            this.removeCommand(command);
          this.commands[command.name] = command;
          if (command.bindKey)
            this._buildKeyHash(command);
        };
        this.removeCommand = function(command, keepCommand) {
          var name = command && (typeof command === "string" ? command : command.name);
          command = this.commands[name];
          if (!keepCommand)
            delete this.commands[name];
          var ckb = this.commandKeyBinding;
          for (var keyId in ckb) {
            var cmdGroup = ckb[keyId];
            if (cmdGroup == command) {
              delete ckb[keyId];
            } else if (Array.isArray(cmdGroup)) {
              var i2 = cmdGroup.indexOf(command);
              if (i2 != -1) {
                cmdGroup.splice(i2, 1);
                if (cmdGroup.length == 1)
                  ckb[keyId] = cmdGroup[0];
              }
            }
          }
        };
        this.bindKey = function(key, command, position) {
          if (typeof key == "object" && key) {
            if (position == void 0)
              position = key.position;
            key = key[this.platform];
          }
          if (!key)
            return;
          if (typeof command == "function")
            return this.addCommand({ exec: command, bindKey: key, name: command.name || key });
          key.split("|").forEach(function(keyPart) {
            var chain = "";
            if (keyPart.indexOf(" ") != -1) {
              var parts = keyPart.split(/\s+/);
              keyPart = parts.pop();
              parts.forEach(function(keyPart2) {
                var binding2 = this.parseKeys(keyPart2);
                var id2 = KEY_MODS[binding2.hashId] + binding2.key;
                chain += (chain ? " " : "") + id2;
                this._addCommandToBinding(chain, "chainKeys");
              }, this);
              chain += " ";
            }
            var binding = this.parseKeys(keyPart);
            var id = KEY_MODS[binding.hashId] + binding.key;
            this._addCommandToBinding(chain + id, command, position);
          }, this);
        };
        function getPosition(command) {
          return typeof command == "object" && command.bindKey && command.bindKey.position || (command.isDefault ? -100 : 0);
        }
        this._addCommandToBinding = function(keyId, command, position) {
          var ckb = this.commandKeyBinding, i2;
          if (!command) {
            delete ckb[keyId];
          } else if (!ckb[keyId] || this.$singleCommand) {
            ckb[keyId] = command;
          } else {
            if (!Array.isArray(ckb[keyId])) {
              ckb[keyId] = [ckb[keyId]];
            } else if ((i2 = ckb[keyId].indexOf(command)) != -1) {
              ckb[keyId].splice(i2, 1);
            }
            if (typeof position != "number") {
              position = getPosition(command);
            }
            var commands = ckb[keyId];
            for (i2 = 0; i2 < commands.length; i2++) {
              var other = commands[i2];
              var otherPos = getPosition(other);
              if (otherPos > position)
                break;
            }
            commands.splice(i2, 0, command);
          }
        };
        this.addCommands = function(commands) {
          commands && Object.keys(commands).forEach(function(name) {
            var command = commands[name];
            if (!command)
              return;
            if (typeof command === "string")
              return this.bindKey(command, name);
            if (typeof command === "function")
              command = { exec: command };
            if (typeof command !== "object")
              return;
            if (!command.name)
              command.name = name;
            this.addCommand(command);
          }, this);
        };
        this.removeCommands = function(commands) {
          Object.keys(commands).forEach(function(name) {
            this.removeCommand(commands[name]);
          }, this);
        };
        this.bindKeys = function(keyList) {
          Object.keys(keyList).forEach(function(key) {
            this.bindKey(key, keyList[key]);
          }, this);
        };
        this._buildKeyHash = function(command) {
          this.bindKey(command.bindKey, command);
        };
        this.parseKeys = function(keys) {
          var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x2) {
            return x2;
          });
          var key = parts.pop();
          var keyCode = keyUtil[key];
          if (keyUtil.FUNCTION_KEYS[keyCode])
            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
          else if (!parts.length)
            return { key, hashId: -1 };
          else if (parts.length == 1 && parts[0] == "shift")
            return { key: key.toUpperCase(), hashId: -1 };
          var hashId = 0;
          for (var i2 = parts.length; i2--; ) {
            var modifier = keyUtil.KEY_MODS[parts[i2]];
            if (modifier == null) {
              if (typeof console != "undefined")
                console.error("invalid modifier " + parts[i2] + " in " + keys);
              return false;
            }
            hashId |= modifier;
          }
          return { key, hashId };
        };
        this.findKeyCommand = function findKeyCommand(hashId, keyString) {
          var key = KEY_MODS[hashId] + keyString;
          return this.commandKeyBinding[key];
        };
        this.handleKeyboard = function(data, hashId, keyString, keyCode) {
          if (keyCode < 0)
            return;
          var key = KEY_MODS[hashId] + keyString;
          var command = this.commandKeyBinding[key];
          if (data.$keyChain) {
            data.$keyChain += " " + key;
            command = this.commandKeyBinding[data.$keyChain] || command;
          }
          if (command) {
            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
              data.$keyChain = data.$keyChain || key;
              return { command: "null" };
            }
          }
          if (data.$keyChain) {
            if ((!hashId || hashId == 4) && keyString.length == 1)
              data.$keyChain = data.$keyChain.slice(0, -key.length - 1);
            else if (hashId == -1 || keyCode > 0)
              data.$keyChain = "";
          }
          return { command };
        };
        this.getStatusText = function(editor, data) {
          return data.$keyChain || "";
        };
      }).call(HashHandler.prototype);
      exports3.HashHandler = HashHandler;
      exports3.MultiHashHandler = MultiHashHandler;
    });
    ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d3, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d4[p] = b3[p];
          };
          return extendStatics(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var oop = require2("../lib/oop");
      var MultiHashHandler = require2("../keyboard/hash_handler").MultiHashHandler;
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var CommandManager = (
        /** @class */
        function(_super) {
          __extends(CommandManager2, _super);
          function CommandManager2(platform, commands) {
            var _this = _super.call(this, commands, platform) || this;
            _this.byName = _this.commands;
            _this.setDefaultHandler("exec", function(e2) {
              if (!e2.args) {
                return e2.command.exec(e2.editor, {}, e2.event, true);
              }
              return e2.command.exec(e2.editor, e2.args, e2.event, false);
            });
            return _this;
          }
          CommandManager2.prototype.exec = function(command, editor, args) {
            if (Array.isArray(command)) {
              for (var i2 = command.length; i2--; ) {
                if (this.exec(command[i2], editor, args))
                  return true;
              }
              return false;
            }
            if (typeof command === "string")
              command = this.commands[command];
            if (!command)
              return false;
            if (editor && editor.$readOnly && !command.readOnly)
              return false;
            if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))
              return false;
            var e2 = { editor, command, args };
            e2.returnValue = this._emit("exec", e2);
            this._signal("afterExec", e2);
            return e2.returnValue === false ? false : true;
          };
          CommandManager2.prototype.toggleRecording = function(editor) {
            if (this.$inReplay)
              return;
            editor && editor._emit("changeStatus");
            if (this.recording) {
              this.macro.pop();
              this.off("exec", this.$addCommandToMacro);
              if (!this.macro.length)
                this.macro = this.oldMacro;
              return this.recording = false;
            }
            if (!this.$addCommandToMacro) {
              this.$addCommandToMacro = (function(e2) {
                this.macro.push([e2.command, e2.args]);
              }).bind(this);
            }
            this.oldMacro = this.macro;
            this.macro = [];
            this.on("exec", this.$addCommandToMacro);
            return this.recording = true;
          };
          CommandManager2.prototype.replay = function(editor) {
            if (this.$inReplay || !this.macro)
              return;
            if (this.recording)
              return this.toggleRecording(editor);
            try {
              this.$inReplay = true;
              this.macro.forEach(function(x2) {
                if (typeof x2 == "string")
                  this.exec(x2, editor);
                else
                  this.exec(x2[0], editor, x2[1]);
              }, this);
            } finally {
              this.$inReplay = false;
            }
          };
          CommandManager2.prototype.trimMacro = function(m3) {
            return m3.map(function(x2) {
              if (typeof x2[0] != "string")
                x2[0] = x2[0].name;
              if (!x2[1])
                x2 = x2[0];
              return x2;
            });
          };
          return CommandManager2;
        }(MultiHashHandler)
      );
      oop.implement(CommandManager.prototype, EventEmitter);
      exports3.CommandManager = CommandManager;
    });
    ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function(require2, exports3, module3) {
      var lang = require2("../lib/lang");
      var config = require2("../config");
      var Range = require2("../range").Range;
      function bindKey(win, mac) {
        return { win, mac };
      }
      exports3.commands = [
        {
          name: "showSettingsMenu",
          description: "Show settings menu",
          bindKey: bindKey("Ctrl-,", "Command-,"),
          exec: function(editor) {
            config.loadModule("ace/ext/settings_menu", function(module4) {
              module4.init(editor);
              editor.showSettingsMenu();
            });
          },
          readOnly: true
        },
        {
          name: "goToNextError",
          description: "Go to next error",
          bindKey: bindKey("Alt-E", "F4"),
          exec: function(editor) {
            config.loadModule("ace/ext/error_marker", function(module4) {
              module4.showErrorMarker(editor, 1);
            });
          },
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "goToPreviousError",
          description: "Go to previous error",
          bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
          exec: function(editor) {
            config.loadModule("ace/ext/error_marker", function(module4) {
              module4.showErrorMarker(editor, -1);
            });
          },
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "selectall",
          description: "Select all",
          bindKey: bindKey("Ctrl-A", "Command-A"),
          exec: function(editor) {
            editor.selectAll();
          },
          readOnly: true
        },
        {
          name: "centerselection",
          description: "Center selection",
          bindKey: bindKey(null, "Ctrl-L"),
          exec: function(editor) {
            editor.centerSelection();
          },
          readOnly: true
        },
        {
          name: "gotoline",
          description: "Go to line...",
          bindKey: bindKey("Ctrl-L", "Command-L"),
          exec: function(editor, line) {
            if (typeof line === "number" && !isNaN(line))
              editor.gotoLine(line);
            editor.prompt({ $type: "gotoLine" });
          },
          readOnly: true
        },
        {
          name: "fold",
          bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
          exec: function(editor) {
            editor.session.toggleFold(false);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "unfold",
          bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
          exec: function(editor) {
            editor.session.toggleFold(true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "toggleFoldWidget",
          description: "Toggle fold widget",
          bindKey: bindKey("F2", "F2"),
          exec: function(editor) {
            editor.session.toggleFoldWidget();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "toggleParentFoldWidget",
          description: "Toggle parent fold widget",
          bindKey: bindKey("Alt-F2", "Alt-F2"),
          exec: function(editor) {
            editor.session.toggleFoldWidget(true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "foldall",
          description: "Fold all",
          bindKey: bindKey(null, "Ctrl-Command-Option-0"),
          exec: function(editor) {
            editor.session.foldAll();
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "foldAllComments",
          description: "Fold all comments",
          bindKey: bindKey(null, "Ctrl-Command-Option-0"),
          exec: function(editor) {
            editor.session.foldAllComments();
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "foldOther",
          description: "Fold other",
          bindKey: bindKey("Alt-0", "Command-Option-0"),
          exec: function(editor) {
            editor.session.foldAll();
            editor.session.unfold(editor.selection.getAllRanges());
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "unfoldall",
          description: "Unfold all",
          bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
          exec: function(editor) {
            editor.session.unfold();
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "findnext",
          description: "Find next",
          bindKey: bindKey("Ctrl-K", "Command-G"),
          exec: function(editor) {
            editor.findNext();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "findprevious",
          description: "Find previous",
          bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
          exec: function(editor) {
            editor.findPrevious();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "selectOrFindNext",
          description: "Select or find next",
          bindKey: bindKey("Alt-K", "Ctrl-G"),
          exec: function(editor) {
            if (editor.selection.isEmpty())
              editor.selection.selectWord();
            else
              editor.findNext();
          },
          readOnly: true
        },
        {
          name: "selectOrFindPrevious",
          description: "Select or find previous",
          bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
          exec: function(editor) {
            if (editor.selection.isEmpty())
              editor.selection.selectWord();
            else
              editor.findPrevious();
          },
          readOnly: true
        },
        {
          name: "find",
          description: "Find",
          bindKey: bindKey("Ctrl-F", "Command-F"),
          exec: function(editor) {
            config.loadModule("ace/ext/searchbox", function(e2) {
              e2.Search(editor);
            });
          },
          readOnly: true
        },
        {
          name: "overwrite",
          description: "Overwrite",
          bindKey: "Insert",
          exec: function(editor) {
            editor.toggleOverwrite();
          },
          readOnly: true
        },
        {
          name: "selecttostart",
          description: "Select to start",
          bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
          exec: function(editor) {
            editor.getSelection().selectFileStart();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "gotostart",
          description: "Go to start",
          bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
          exec: function(editor) {
            editor.navigateFileStart();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "selectup",
          description: "Select up",
          bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
          exec: function(editor) {
            editor.getSelection().selectUp();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "golineup",
          description: "Go line up",
          bindKey: bindKey("Up", "Up|Ctrl-P"),
          exec: function(editor, args) {
            editor.navigateUp(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selecttoend",
          description: "Select to end",
          bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
          exec: function(editor) {
            editor.getSelection().selectFileEnd();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "gotoend",
          description: "Go to end",
          bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
          exec: function(editor) {
            editor.navigateFileEnd();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "selectdown",
          description: "Select down",
          bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
          exec: function(editor) {
            editor.getSelection().selectDown();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "golinedown",
          description: "Go line down",
          bindKey: bindKey("Down", "Down|Ctrl-N"),
          exec: function(editor, args) {
            editor.navigateDown(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectwordleft",
          description: "Select word left",
          bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
          exec: function(editor) {
            editor.getSelection().selectWordLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotowordleft",
          description: "Go to word left",
          bindKey: bindKey("Ctrl-Left", "Option-Left"),
          exec: function(editor) {
            editor.navigateWordLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selecttolinestart",
          description: "Select to line start",
          bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
          exec: function(editor) {
            editor.getSelection().selectLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotolinestart",
          description: "Go to line start",
          bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
          exec: function(editor) {
            editor.navigateLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectleft",
          description: "Select left",
          bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
          exec: function(editor) {
            editor.getSelection().selectLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotoleft",
          description: "Go to left",
          bindKey: bindKey("Left", "Left|Ctrl-B"),
          exec: function(editor, args) {
            editor.navigateLeft(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectwordright",
          description: "Select word right",
          bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
          exec: function(editor) {
            editor.getSelection().selectWordRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotowordright",
          description: "Go to word right",
          bindKey: bindKey("Ctrl-Right", "Option-Right"),
          exec: function(editor) {
            editor.navigateWordRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selecttolineend",
          description: "Select to line end",
          bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
          exec: function(editor) {
            editor.getSelection().selectLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotolineend",
          description: "Go to line end",
          bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
          exec: function(editor) {
            editor.navigateLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectright",
          description: "Select right",
          bindKey: bindKey("Shift-Right", "Shift-Right"),
          exec: function(editor) {
            editor.getSelection().selectRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotoright",
          description: "Go to right",
          bindKey: bindKey("Right", "Right|Ctrl-F"),
          exec: function(editor, args) {
            editor.navigateRight(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectpagedown",
          description: "Select page down",
          bindKey: "Shift-PageDown",
          exec: function(editor) {
            editor.selectPageDown();
          },
          readOnly: true
        },
        {
          name: "pagedown",
          description: "Page down",
          bindKey: bindKey(null, "Option-PageDown"),
          exec: function(editor) {
            editor.scrollPageDown();
          },
          readOnly: true
        },
        {
          name: "gotopagedown",
          description: "Go to page down",
          bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
          exec: function(editor) {
            editor.gotoPageDown();
          },
          readOnly: true
        },
        {
          name: "selectpageup",
          description: "Select page up",
          bindKey: "Shift-PageUp",
          exec: function(editor) {
            editor.selectPageUp();
          },
          readOnly: true
        },
        {
          name: "pageup",
          description: "Page up",
          bindKey: bindKey(null, "Option-PageUp"),
          exec: function(editor) {
            editor.scrollPageUp();
          },
          readOnly: true
        },
        {
          name: "gotopageup",
          description: "Go to page up",
          bindKey: "PageUp",
          exec: function(editor) {
            editor.gotoPageUp();
          },
          readOnly: true
        },
        {
          name: "scrollup",
          description: "Scroll up",
          bindKey: bindKey("Ctrl-Up", null),
          exec: function(e2) {
            e2.renderer.scrollBy(0, -2 * e2.renderer.layerConfig.lineHeight);
          },
          readOnly: true
        },
        {
          name: "scrolldown",
          description: "Scroll down",
          bindKey: bindKey("Ctrl-Down", null),
          exec: function(e2) {
            e2.renderer.scrollBy(0, 2 * e2.renderer.layerConfig.lineHeight);
          },
          readOnly: true
        },
        {
          name: "selectlinestart",
          description: "Select line start",
          bindKey: "Shift-Home",
          exec: function(editor) {
            editor.getSelection().selectLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectlineend",
          description: "Select line end",
          bindKey: "Shift-End",
          exec: function(editor) {
            editor.getSelection().selectLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "togglerecording",
          description: "Toggle recording",
          bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
          exec: function(editor) {
            editor.commands.toggleRecording(editor);
          },
          readOnly: true
        },
        {
          name: "replaymacro",
          description: "Replay macro",
          bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
          exec: function(editor) {
            editor.commands.replay(editor);
          },
          readOnly: true
        },
        {
          name: "jumptomatching",
          description: "Jump to matching",
          bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
          exec: function(editor) {
            editor.jumpToMatching();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "selecttomatching",
          description: "Select to matching",
          bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
          exec: function(editor) {
            editor.jumpToMatching(true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "expandToMatching",
          description: "Expand to matching",
          bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
          exec: function(editor) {
            editor.jumpToMatching(true, true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "passKeysToBrowser",
          description: "Pass keys to browser",
          bindKey: bindKey(null, null),
          exec: function() {
          },
          passEvent: true,
          readOnly: true
        },
        {
          name: "copy",
          description: "Copy",
          exec: function(editor) {
          },
          readOnly: true
        },
        {
          name: "cut",
          description: "Cut",
          exec: function(editor) {
            var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();
            var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();
            editor._emit("cut", range);
            if (!range.isEmpty())
              editor.session.remove(range);
            editor.clearSelection();
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "paste",
          description: "Paste",
          exec: function(editor, args) {
            editor.$handlePaste(args);
          },
          scrollIntoView: "cursor"
        },
        {
          name: "removeline",
          description: "Remove line",
          bindKey: bindKey("Ctrl-D", "Command-D"),
          exec: function(editor) {
            editor.removeLines();
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEachLine"
        },
        {
          name: "duplicateSelection",
          description: "Duplicate selection",
          bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
          exec: function(editor) {
            editor.duplicateSelection();
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "sortlines",
          description: "Sort lines",
          bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
          exec: function(editor) {
            editor.sortLines();
          },
          scrollIntoView: "selection",
          multiSelectAction: "forEachLine"
        },
        {
          name: "togglecomment",
          description: "Toggle comment",
          bindKey: bindKey("Ctrl-/", "Command-/"),
          exec: function(editor) {
            editor.toggleCommentLines();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "selectionPart"
        },
        {
          name: "toggleBlockComment",
          description: "Toggle block comment",
          bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
          exec: function(editor) {
            editor.toggleBlockComment();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "selectionPart"
        },
        {
          name: "modifyNumberUp",
          description: "Modify number up",
          bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
          exec: function(editor) {
            editor.modifyNumber(1);
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "modifyNumberDown",
          description: "Modify number down",
          bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
          exec: function(editor) {
            editor.modifyNumber(-1);
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "replace",
          description: "Replace",
          bindKey: bindKey("Ctrl-H", "Command-Option-F"),
          exec: function(editor) {
            config.loadModule("ace/ext/searchbox", function(e2) {
              e2.Search(editor, true);
            });
          }
        },
        {
          name: "undo",
          description: "Undo",
          bindKey: bindKey("Ctrl-Z", "Command-Z"),
          exec: function(editor) {
            editor.undo();
          }
        },
        {
          name: "redo",
          description: "Redo",
          bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
          exec: function(editor) {
            editor.redo();
          }
        },
        {
          name: "copylinesup",
          description: "Copy lines up",
          bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
          exec: function(editor) {
            editor.copyLinesUp();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "movelinesup",
          description: "Move lines up",
          bindKey: bindKey("Alt-Up", "Option-Up"),
          exec: function(editor) {
            editor.moveLinesUp();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "copylinesdown",
          description: "Copy lines down",
          bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
          exec: function(editor) {
            editor.copyLinesDown();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "movelinesdown",
          description: "Move lines down",
          bindKey: bindKey("Alt-Down", "Option-Down"),
          exec: function(editor) {
            editor.moveLinesDown();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "del",
          description: "Delete",
          bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
          exec: function(editor) {
            editor.remove("right");
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "backspace",
          description: "Backspace",
          bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
          exec: function(editor) {
            editor.remove("left");
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "cut_or_delete",
          description: "Cut or delete",
          bindKey: bindKey("Shift-Delete", null),
          exec: function(editor) {
            if (editor.selection.isEmpty()) {
              editor.remove("left");
            } else {
              return false;
            }
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolinestart",
          description: "Remove to line start",
          bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
          exec: function(editor) {
            editor.removeToLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolineend",
          description: "Remove to line end",
          bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
          exec: function(editor) {
            editor.removeToLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolinestarthard",
          description: "Remove to line start hard",
          bindKey: bindKey("Ctrl-Shift-Backspace", null),
          exec: function(editor) {
            var range = editor.selection.getRange();
            range.start.column = 0;
            editor.session.remove(range);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolineendhard",
          description: "Remove to line end hard",
          bindKey: bindKey("Ctrl-Shift-Delete", null),
          exec: function(editor) {
            var range = editor.selection.getRange();
            range.end.column = Number.MAX_VALUE;
            editor.session.remove(range);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removewordleft",
          description: "Remove word left",
          bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
          exec: function(editor) {
            editor.removeWordLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removewordright",
          description: "Remove word right",
          bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
          exec: function(editor) {
            editor.removeWordRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "outdent",
          description: "Outdent",
          bindKey: bindKey("Shift-Tab", "Shift-Tab"),
          exec: function(editor) {
            editor.blockOutdent();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "selectionPart"
        },
        {
          name: "indent",
          description: "Indent",
          bindKey: bindKey("Tab", "Tab"),
          exec: function(editor) {
            editor.indent();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "selectionPart"
        },
        {
          name: "blockoutdent",
          description: "Block outdent",
          bindKey: bindKey("Ctrl-[", "Ctrl-["),
          exec: function(editor) {
            editor.blockOutdent();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "selectionPart"
        },
        {
          name: "blockindent",
          description: "Block indent",
          bindKey: bindKey("Ctrl-]", "Ctrl-]"),
          exec: function(editor) {
            editor.blockIndent();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "selectionPart"
        },
        {
          name: "insertstring",
          description: "Insert string",
          exec: function(editor, str) {
            editor.insert(str);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "inserttext",
          description: "Insert text",
          exec: function(editor, args) {
            editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "splitline",
          description: "Split line",
          bindKey: bindKey(null, "Ctrl-O"),
          exec: function(editor) {
            editor.splitLine();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "transposeletters",
          description: "Transpose letters",
          bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
          exec: function(editor) {
            editor.transposeLetters();
          },
          multiSelectAction: function(editor) {
            editor.transposeSelections(1);
          },
          scrollIntoView: "cursor"
        },
        {
          name: "touppercase",
          description: "To uppercase",
          bindKey: bindKey("Ctrl-U", "Ctrl-U"),
          exec: function(editor) {
            editor.toUpperCase();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "tolowercase",
          description: "To lowercase",
          bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
          exec: function(editor) {
            editor.toLowerCase();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "autoindent",
          description: "Auto Indent",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            editor.autoIndent();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "animate"
        },
        {
          name: "expandtoline",
          description: "Expand to line",
          bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
          exec: function(editor) {
            var range = editor.selection.getRange();
            range.start.column = range.end.column = 0;
            range.end.row++;
            editor.selection.setRange(range, false);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "openlink",
          bindKey: bindKey("Ctrl+F3", "F3"),
          exec: function(editor) {
            editor.openLink();
          }
        },
        {
          name: "joinlines",
          description: "Join lines",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            var isBackwards = editor.selection.isBackwards();
            var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
            var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
            var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
            var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
            var selectedCount = selectedText.replace(/\n\s*/, " ").length;
            var insertLine = editor.session.doc.getLine(selectionStart.row);
            for (var i3 = selectionStart.row + 1; i3 <= selectionEnd.row + 1; i3++) {
              var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i3)));
              if (curLine.length !== 0) {
                curLine = " " + curLine;
              }
              insertLine += curLine;
            }
            if (selectionEnd.row + 1 < editor.session.doc.getLength() - 1) {
              insertLine += editor.session.doc.getNewLineCharacter();
            }
            editor.clearSelection();
            editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
            if (selectedCount > 0) {
              editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
              editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
            } else {
              firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? firstLineEndCol + 1 : firstLineEndCol;
              editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
            }
          },
          multiSelectAction: "forEach",
          readOnly: true
        },
        {
          name: "invertSelection",
          description: "Invert selection",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            var endRow = editor.session.doc.getLength() - 1;
            var endCol = editor.session.doc.getLine(endRow).length;
            var ranges = editor.selection.rangeList.ranges;
            var newRanges = [];
            if (ranges.length < 1) {
              ranges = [editor.selection.getRange()];
            }
            for (var i3 = 0; i3 < ranges.length; i3++) {
              if (i3 == ranges.length - 1) {
                if (!(ranges[i3].end.row === endRow && ranges[i3].end.column === endCol)) {
                  newRanges.push(new Range(ranges[i3].end.row, ranges[i3].end.column, endRow, endCol));
                }
              }
              if (i3 === 0) {
                if (!(ranges[i3].start.row === 0 && ranges[i3].start.column === 0)) {
                  newRanges.push(new Range(0, 0, ranges[i3].start.row, ranges[i3].start.column));
                }
              } else {
                newRanges.push(new Range(ranges[i3 - 1].end.row, ranges[i3 - 1].end.column, ranges[i3].start.row, ranges[i3].start.column));
              }
            }
            editor.exitMultiSelectMode();
            editor.clearSelection();
            for (var i3 = 0; i3 < newRanges.length; i3++) {
              editor.selection.addRange(newRanges[i3], false);
            }
          },
          readOnly: true,
          scrollIntoView: "none"
        },
        {
          name: "addLineAfter",
          description: "Add new line after the current line",
          exec: function(editor) {
            editor.selection.clearSelection();
            editor.navigateLineEnd();
            editor.insert("\n");
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "addLineBefore",
          description: "Add new line before the current line",
          exec: function(editor) {
            editor.selection.clearSelection();
            var cursor = editor.getCursorPosition();
            editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
            editor.insert("\n");
            if (cursor.row === 0)
              editor.navigateUp();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "openCommandPallete",
          description: "Open command palette",
          bindKey: bindKey("F1", "F1"),
          exec: function(editor) {
            editor.prompt({ $type: "commands" });
          },
          readOnly: true
        },
        {
          name: "modeSelect",
          description: "Change language mode...",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            editor.prompt({ $type: "modes" });
          },
          readOnly: true
        }
      ];
      for (var i2 = 1; i2 < 9; i2++) {
        exports3.commands.push({
          name: "foldToLevel" + i2,
          description: "Fold To Level " + i2,
          level: i2,
          exec: function(editor) {
            editor.session.foldToLevel(this.level);
          },
          scrollIntoView: "center",
          readOnly: true
        });
      }
    });
    ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports3, module3) {
      var dom = require2("./lib/dom");
      var LineWidgets = (
        /** @class */
        function() {
          function LineWidgets2(session) {
            this.session = session;
            this.session.widgetManager = this;
            this.session.getRowLength = this.getRowLength;
            this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
            this.updateOnChange = this.updateOnChange.bind(this);
            this.renderWidgets = this.renderWidgets.bind(this);
            this.measureWidgets = this.measureWidgets.bind(this);
            this.session._changedWidgets = [];
            this.$onChangeEditor = this.$onChangeEditor.bind(this);
            this.session.on("change", this.updateOnChange);
            this.session.on("changeFold", this.updateOnFold);
            this.session.on("changeEditor", this.$onChangeEditor);
          }
          LineWidgets2.prototype.getRowLength = function(row) {
            var h3;
            if (this.lineWidgets)
              h3 = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            else
              h3 = 0;
            if (!this.$useWrapMode || !this.$wrapData[row]) {
              return 1 + h3;
            } else {
              return this.$wrapData[row].length + 1 + h3;
            }
          };
          LineWidgets2.prototype.$getWidgetScreenLength = function() {
            var screenRows = 0;
            this.lineWidgets.forEach(function(w2) {
              if (w2 && w2.rowCount && !w2.hidden)
                screenRows += w2.rowCount;
            });
            return screenRows;
          };
          LineWidgets2.prototype.$onChangeEditor = function(e2) {
            this.attach(e2.editor);
          };
          LineWidgets2.prototype.attach = function(editor) {
            if (editor && editor.widgetManager && editor.widgetManager != this)
              editor.widgetManager.detach();
            if (this.editor == editor)
              return;
            this.detach();
            this.editor = editor;
            if (editor) {
              editor.widgetManager = this;
              editor.renderer.on("beforeRender", this.measureWidgets);
              editor.renderer.on("afterRender", this.renderWidgets);
            }
          };
          LineWidgets2.prototype.detach = function(e2) {
            var editor = this.editor;
            if (!editor)
              return;
            this.editor = null;
            editor.widgetManager = null;
            editor.renderer.off("beforeRender", this.measureWidgets);
            editor.renderer.off("afterRender", this.renderWidgets);
            var lineWidgets = this.session.lineWidgets;
            lineWidgets && lineWidgets.forEach(function(w2) {
              if (w2 && w2.el && w2.el.parentNode) {
                w2._inDocument = false;
                w2.el.parentNode.removeChild(w2.el);
              }
            });
          };
          LineWidgets2.prototype.updateOnFold = function(e2, session) {
            var lineWidgets = session.lineWidgets;
            if (!lineWidgets || !e2.action)
              return;
            var fold = e2.data;
            var start = fold.start.row;
            var end = fold.end.row;
            var hide = e2.action == "add";
            for (var i2 = start + 1; i2 < end; i2++) {
              if (lineWidgets[i2])
                lineWidgets[i2].hidden = hide;
            }
            if (lineWidgets[end]) {
              if (hide) {
                if (!lineWidgets[start])
                  lineWidgets[start] = lineWidgets[end];
                else
                  lineWidgets[end].hidden = hide;
              } else {
                if (lineWidgets[start] == lineWidgets[end])
                  lineWidgets[start] = void 0;
                lineWidgets[end].hidden = hide;
              }
            }
          };
          LineWidgets2.prototype.updateOnChange = function(delta) {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;
            if (len === 0) ;
            else if (delta.action == "remove") {
              var removed = lineWidgets.splice(startRow + 1, len);
              if (!lineWidgets[startRow] && removed[removed.length - 1]) {
                lineWidgets[startRow] = removed.pop();
              }
              removed.forEach(function(w2) {
                w2 && this.removeLineWidget(w2);
              }, this);
              this.$updateRows();
            } else {
              var args = new Array(len);
              if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
                if (delta.start.column > lineWidgets[startRow].column)
                  startRow++;
              }
              args.unshift(startRow, 0);
              lineWidgets.splice.apply(lineWidgets, args);
              this.$updateRows();
            }
          };
          LineWidgets2.prototype.$updateRows = function() {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var noWidgets = true;
            lineWidgets.forEach(function(w2, i2) {
              if (w2) {
                noWidgets = false;
                w2.row = i2;
                while (w2.$oldWidget) {
                  w2.$oldWidget.row = i2;
                  w2 = w2.$oldWidget;
                }
              }
            });
            if (noWidgets)
              this.session.lineWidgets = null;
          };
          LineWidgets2.prototype.$registerLineWidget = function(w2) {
            if (!this.session.lineWidgets)
              this.session.lineWidgets = new Array(this.session.getLength());
            var old = this.session.lineWidgets[w2.row];
            if (old) {
              w2.$oldWidget = old;
              if (old.el && old.el.parentNode) {
                old.el.parentNode.removeChild(old.el);
                old._inDocument = false;
              }
            }
            this.session.lineWidgets[w2.row] = w2;
            return w2;
          };
          LineWidgets2.prototype.addLineWidget = function(w2) {
            this.$registerLineWidget(w2);
            w2.session = this.session;
            if (!this.editor)
              return w2;
            var renderer = this.editor.renderer;
            if (w2.html && !w2.el) {
              w2.el = dom.createElement("div");
              w2.el.innerHTML = w2.html;
            }
            if (w2.text && !w2.el) {
              w2.el = dom.createElement("div");
              w2.el.textContent = w2.text;
            }
            if (w2.el) {
              dom.addCssClass(w2.el, "ace_lineWidgetContainer");
              if (w2.className) {
                dom.addCssClass(w2.el, w2.className);
              }
              w2.el.style.position = "absolute";
              w2.el.style.zIndex = 5;
              renderer.container.appendChild(w2.el);
              w2._inDocument = true;
              if (!w2.coverGutter) {
                w2.el.style.zIndex = 3;
              }
              if (w2.pixelHeight == null) {
                w2.pixelHeight = w2.el.offsetHeight;
              }
            }
            if (w2.rowCount == null) {
              w2.rowCount = w2.pixelHeight / renderer.layerConfig.lineHeight;
            }
            var fold = this.session.getFoldAt(w2.row, 0);
            w2.$fold = fold;
            if (fold) {
              var lineWidgets = this.session.lineWidgets;
              if (w2.row == fold.end.row && !lineWidgets[fold.start.row])
                lineWidgets[fold.start.row] = w2;
              else
                w2.hidden = true;
            }
            this.session._emit("changeFold", { data: { start: { row: w2.row } } });
            this.$updateRows();
            this.renderWidgets(null, renderer);
            this.onWidgetChanged(w2);
            return w2;
          };
          LineWidgets2.prototype.removeLineWidget = function(w2) {
            w2._inDocument = false;
            w2.session = null;
            if (w2.el && w2.el.parentNode)
              w2.el.parentNode.removeChild(w2.el);
            if (w2.editor && w2.editor.destroy)
              try {
                w2.editor.destroy();
              } catch (e2) {
              }
            if (this.session.lineWidgets) {
              var w1 = this.session.lineWidgets[w2.row];
              if (w1 == w2) {
                this.session.lineWidgets[w2.row] = w2.$oldWidget;
                if (w2.$oldWidget)
                  this.onWidgetChanged(w2.$oldWidget);
              } else {
                while (w1) {
                  if (w1.$oldWidget == w2) {
                    w1.$oldWidget = w2.$oldWidget;
                    break;
                  }
                  w1 = w1.$oldWidget;
                }
              }
            }
            this.session._emit("changeFold", { data: { start: { row: w2.row } } });
            this.$updateRows();
          };
          LineWidgets2.prototype.getWidgetsAtRow = function(row) {
            var lineWidgets = this.session.lineWidgets;
            var w2 = lineWidgets && lineWidgets[row];
            var list = [];
            while (w2) {
              list.push(w2);
              w2 = w2.$oldWidget;
            }
            return list;
          };
          LineWidgets2.prototype.onWidgetChanged = function(w2) {
            this.session._changedWidgets.push(w2);
            this.editor && this.editor.renderer.updateFull();
          };
          LineWidgets2.prototype.measureWidgets = function(e2, renderer) {
            var changedWidgets = this.session._changedWidgets;
            var config = renderer.layerConfig;
            if (!changedWidgets || !changedWidgets.length)
              return;
            var min = Infinity;
            for (var i2 = 0; i2 < changedWidgets.length; i2++) {
              var w2 = changedWidgets[i2];
              if (!w2 || !w2.el)
                continue;
              if (w2.session != this.session)
                continue;
              if (!w2._inDocument) {
                if (this.session.lineWidgets[w2.row] != w2)
                  continue;
                w2._inDocument = true;
                renderer.container.appendChild(w2.el);
              }
              w2.h = w2.el.offsetHeight;
              if (!w2.fixedWidth) {
                w2.w = w2.el.offsetWidth;
                w2.screenWidth = Math.ceil(w2.w / config.characterWidth);
              }
              var rowCount = w2.h / config.lineHeight;
              if (w2.coverLine) {
                rowCount -= this.session.getRowLineCount(w2.row);
                if (rowCount < 0)
                  rowCount = 0;
              }
              if (w2.rowCount != rowCount) {
                w2.rowCount = rowCount;
                if (w2.row < min)
                  min = w2.row;
              }
            }
            if (min != Infinity) {
              this.session._emit("changeFold", { data: { start: { row: min } } });
              this.session.lineWidgetWidth = null;
            }
            this.session._changedWidgets = [];
          };
          LineWidgets2.prototype.renderWidgets = function(e2, renderer) {
            var config = renderer.layerConfig;
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var first = Math.min(this.firstRow, config.firstRow);
            var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
            while (first > 0 && !lineWidgets[first])
              first--;
            this.firstRow = config.firstRow;
            this.lastRow = config.lastRow;
            renderer.$cursorLayer.config = config;
            for (var i2 = first; i2 <= last; i2++) {
              var w2 = lineWidgets[i2];
              if (!w2 || !w2.el)
                continue;
              if (w2.hidden) {
                w2.el.style.top = -100 - (w2.pixelHeight || 0) + "px";
                continue;
              }
              if (!w2._inDocument) {
                w2._inDocument = true;
                renderer.container.appendChild(w2.el);
              }
              var top = renderer.$cursorLayer.getPixelPosition({ row: i2, column: 0 }, true).top;
              if (!w2.coverLine)
                top += config.lineHeight * this.session.getRowLineCount(w2.row);
              w2.el.style.top = top - config.offset + "px";
              var left = w2.coverGutter ? 0 : renderer.gutterWidth;
              if (!w2.fixedWidth)
                left -= renderer.scrollLeft;
              w2.el.style.left = left + "px";
              if (w2.fullWidth && w2.screenWidth) {
                w2.el.style.minWidth = config.width + 2 * config.padding + "px";
              }
              if (w2.fixedWidth) {
                w2.el.style.right = renderer.scrollBar.getWidth() + "px";
              } else {
                w2.el.style.right = "";
              }
            }
          };
          return LineWidgets2;
        }()
      );
      exports3.LineWidgets = LineWidgets;
    });
    ace.define("ace/editor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator", "ace/line_widgets", "ace/clipboard", "ace/lib/keys"], function(require2, exports3, module3) {
      var __values = this && this.__values || function(o) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o[s3], i2 = 0;
        if (m3) return m3.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i2 >= o.length) o = void 0;
            return { value: o && o[i2++], done: !o };
          }
        };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var lang = require2("./lib/lang");
      var useragent = require2("./lib/useragent");
      var TextInput = require2("./keyboard/textinput").TextInput;
      var MouseHandler = require2("./mouse/mouse_handler").MouseHandler;
      var FoldHandler = require2("./mouse/fold_handler").FoldHandler;
      var KeyBinding = require2("./keyboard/keybinding").KeyBinding;
      var EditSession = require2("./edit_session").EditSession;
      var Search = require2("./search").Search;
      var Range = require2("./range").Range;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var CommandManager = require2("./commands/command_manager").CommandManager;
      var defaultCommands = require2("./commands/default_commands").commands;
      var config = require2("./config");
      var TokenIterator = require2("./token_iterator").TokenIterator;
      var LineWidgets = require2("./line_widgets").LineWidgets;
      var clipboard = require2("./clipboard");
      var keys = require2("./lib/keys");
      var Editor = (
        /** @class */
        function() {
          function Editor2(renderer, session, options) {
            this.$toDestroy = [];
            var container = renderer.getContainerElement();
            this.container = container;
            this.renderer = renderer;
            this.id = "editor" + ++Editor2.$uid;
            this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
            if (typeof document == "object") {
              this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
              this.renderer.textarea = this.textInput.getElement();
              this.$mouseHandler = new MouseHandler(this);
              new FoldHandler(this);
            }
            this.keyBinding = new KeyBinding(this);
            this.$search = new Search().set({
              wrap: true
            });
            this.$historyTracker = this.$historyTracker.bind(this);
            this.commands.on("exec", this.$historyTracker);
            this.$initOperationListeners();
            this._$emitInputEvent = lang.delayedCall((function() {
              this._signal("input", {});
              if (this.session && !this.session.destroyed)
                this.session.bgTokenizer.scheduleStart();
            }).bind(this));
            this.on("change", function(_, _self) {
              _self._$emitInputEvent.schedule(31);
            });
            this.setSession(session || options && options.session || new EditSession(""));
            config.resetOptions(this);
            if (options)
              this.setOptions(options);
            config._signal("editor", this);
          }
          Editor2.prototype.$initOperationListeners = function() {
            this.commands.on("exec", this.startOperation.bind(this), true);
            this.commands.on("afterExec", this.endOperation.bind(this), true);
            this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
            this.on("change", (function() {
              if (!this.curOp) {
                this.startOperation();
                this.curOp.selectionBefore = this.$lastSel;
              }
              this.curOp.docChanged = true;
            }).bind(this), true);
            this.on("changeSelection", (function() {
              if (!this.curOp) {
                this.startOperation();
                this.curOp.selectionBefore = this.$lastSel;
              }
              this.curOp.selectionChanged = true;
            }).bind(this), true);
          };
          Editor2.prototype.startOperation = function(commandEvent) {
            if (this.curOp) {
              if (!commandEvent || this.curOp.command)
                return;
              this.prevOp = this.curOp;
            }
            if (!commandEvent) {
              this.previousCommand = null;
              commandEvent = {};
            }
            this.$opResetTimer.schedule();
            this.curOp = this.session.curOp = {
              command: commandEvent.command || {},
              args: commandEvent.args,
              scrollTop: this.renderer.scrollTop
            };
            this.curOp.selectionBefore = this.selection.toJSON();
          };
          Editor2.prototype.endOperation = function(e2) {
            if (this.curOp && this.session) {
              if (e2 && e2.returnValue === false || !this.session)
                return this.curOp = null;
              if (e2 == true && this.curOp.command && this.curOp.command.name == "mouse")
                return;
              this._signal("beforeEndOperation");
              if (!this.curOp)
                return;
              var command = this.curOp.command;
              var scrollIntoView = command && command.scrollIntoView;
              if (scrollIntoView) {
                switch (scrollIntoView) {
                  case "center-animate":
                    scrollIntoView = "animate";
                  case "center":
                    this.renderer.scrollCursorIntoView(null, 0.5);
                    break;
                  case "animate":
                  case "cursor":
                    this.renderer.scrollCursorIntoView();
                    break;
                  case "selectionPart":
                    var range = this.selection.getRange();
                    var config2 = this.renderer.layerConfig;
                    if (range.start.row >= config2.lastRow || range.end.row <= config2.firstRow) {
                      this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                    }
                    break;
                }
                if (scrollIntoView == "animate")
                  this.renderer.animateScrolling(this.curOp.scrollTop);
              }
              var sel = this.selection.toJSON();
              this.curOp.selectionAfter = sel;
              this.$lastSel = this.selection.toJSON();
              this.session.getUndoManager().addSelection(sel);
              this.prevOp = this.curOp;
              this.curOp = null;
            }
          };
          Editor2.prototype.$historyTracker = function(e2) {
            if (!this.$mergeUndoDeltas)
              return;
            var prev = this.prevOp;
            var mergeableCommands = this.$mergeableCommands;
            var shouldMerge = prev.command && e2.command.name == prev.command.name;
            if (e2.command.name == "insertstring") {
              var text = e2.args;
              if (this.mergeNextCommand === void 0)
                this.mergeNextCommand = true;
              shouldMerge = shouldMerge && this.mergeNextCommand && (!/\s/.test(text) || /\s/.test(prev.args));
              this.mergeNextCommand = true;
            } else {
              shouldMerge = shouldMerge && mergeableCommands.indexOf(e2.command.name) !== -1;
            }
            if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2e3) {
              shouldMerge = false;
            }
            if (shouldMerge)
              this.session.mergeUndoDeltas = true;
            else if (mergeableCommands.indexOf(e2.command.name) !== -1)
              this.sequenceStartTime = Date.now();
          };
          Editor2.prototype.setKeyboardHandler = function(keyboardHandler, cb) {
            if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
              this.$keybindingId = keyboardHandler;
              var _self = this;
              config.loadModule(["keybinding", keyboardHandler], function(module4) {
                if (_self.$keybindingId == keyboardHandler)
                  _self.keyBinding.setKeyboardHandler(module4 && module4.handler);
                cb && cb();
              });
            } else {
              this.$keybindingId = null;
              this.keyBinding.setKeyboardHandler(keyboardHandler);
              cb && cb();
            }
          };
          Editor2.prototype.getKeyboardHandler = function() {
            return this.keyBinding.getKeyboardHandler();
          };
          Editor2.prototype.setSession = function(session) {
            if (this.session == session)
              return;
            if (this.curOp)
              this.endOperation();
            this.curOp = {};
            var oldSession = this.session;
            if (oldSession) {
              this.session.off("change", this.$onDocumentChange);
              this.session.off("changeMode", this.$onChangeMode);
              this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
              this.session.off("changeTabSize", this.$onChangeTabSize);
              this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
              this.session.off("changeWrapMode", this.$onChangeWrapMode);
              this.session.off("changeFold", this.$onChangeFold);
              this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
              this.session.off("changeBackMarker", this.$onChangeBackMarker);
              this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
              this.session.off("changeAnnotation", this.$onChangeAnnotation);
              this.session.off("changeOverwrite", this.$onCursorChange);
              this.session.off("changeScrollTop", this.$onScrollTopChange);
              this.session.off("changeScrollLeft", this.$onScrollLeftChange);
              var selection = this.session.getSelection();
              selection.off("changeCursor", this.$onCursorChange);
              selection.off("changeSelection", this.$onSelectionChange);
            }
            this.session = session;
            if (session) {
              this.$onDocumentChange = this.onDocumentChange.bind(this);
              session.on("change", this.$onDocumentChange);
              this.renderer.setSession(session);
              this.$onChangeMode = this.onChangeMode.bind(this);
              session.on("changeMode", this.$onChangeMode);
              this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
              session.on("tokenizerUpdate", this.$onTokenizerUpdate);
              this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
              session.on("changeTabSize", this.$onChangeTabSize);
              this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
              session.on("changeWrapLimit", this.$onChangeWrapLimit);
              this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
              session.on("changeWrapMode", this.$onChangeWrapMode);
              this.$onChangeFold = this.onChangeFold.bind(this);
              session.on("changeFold", this.$onChangeFold);
              this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
              this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
              this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
              this.session.on("changeBackMarker", this.$onChangeBackMarker);
              this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
              this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
              this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
              this.session.on("changeAnnotation", this.$onChangeAnnotation);
              this.$onCursorChange = this.onCursorChange.bind(this);
              this.session.on("changeOverwrite", this.$onCursorChange);
              this.$onScrollTopChange = this.onScrollTopChange.bind(this);
              this.session.on("changeScrollTop", this.$onScrollTopChange);
              this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
              this.session.on("changeScrollLeft", this.$onScrollLeftChange);
              this.selection = session.getSelection();
              this.selection.on("changeCursor", this.$onCursorChange);
              this.$onSelectionChange = this.onSelectionChange.bind(this);
              this.selection.on("changeSelection", this.$onSelectionChange);
              this.onChangeMode();
              this.onCursorChange();
              this.onScrollTopChange();
              this.onScrollLeftChange();
              this.onSelectionChange();
              this.onChangeFrontMarker();
              this.onChangeBackMarker();
              this.onChangeBreakpoint();
              this.onChangeAnnotation();
              this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
              this.renderer.updateFull();
            } else {
              this.selection = null;
              this.renderer.setSession(session);
            }
            this._signal("changeSession", {
              session,
              oldSession
            });
            this.curOp = null;
            oldSession && oldSession._signal("changeEditor", { oldEditor: this });
            session && session._signal("changeEditor", { editor: this });
            if (session && !session.destroyed)
              session.bgTokenizer.scheduleStart();
          };
          Editor2.prototype.getSession = function() {
            return this.session;
          };
          Editor2.prototype.setValue = function(val, cursorPos) {
            this.session.doc.setValue(val);
            if (!cursorPos)
              this.selectAll();
            else if (cursorPos == 1)
              this.navigateFileEnd();
            else if (cursorPos == -1)
              this.navigateFileStart();
            return val;
          };
          Editor2.prototype.getValue = function() {
            return this.session.getValue();
          };
          Editor2.prototype.getSelection = function() {
            return this.selection;
          };
          Editor2.prototype.resize = function(force) {
            this.renderer.onResize(force);
          };
          Editor2.prototype.setTheme = function(theme, cb) {
            this.renderer.setTheme(theme, cb);
          };
          Editor2.prototype.getTheme = function() {
            return this.renderer.getTheme();
          };
          Editor2.prototype.setStyle = function(style) {
            this.renderer.setStyle(style);
          };
          Editor2.prototype.unsetStyle = function(style) {
            this.renderer.unsetStyle(style);
          };
          Editor2.prototype.getFontSize = function() {
            return this.getOption("fontSize") || dom.computedStyle(this.container).fontSize;
          };
          Editor2.prototype.setFontSize = function(size) {
            this.setOption("fontSize", size);
          };
          Editor2.prototype.$highlightBrackets = function() {
            if (this.$highlightPending) {
              return;
            }
            var self2 = this;
            this.$highlightPending = true;
            setTimeout(function() {
              self2.$highlightPending = false;
              var session = self2.session;
              if (!session || session.destroyed)
                return;
              if (session.$bracketHighlight) {
                session.$bracketHighlight.markerIds.forEach(function(id) {
                  session.removeMarker(id);
                });
                session.$bracketHighlight = null;
              }
              var pos = self2.getCursorPosition();
              var handler = self2.getKeyboardHandler();
              var isBackwards = handler && handler.$getDirectionForHighlight && handler.$getDirectionForHighlight(self2);
              var ranges = session.getMatchingBracketRanges(pos, isBackwards);
              if (!ranges) {
                var iterator = new TokenIterator(session, pos.row, pos.column);
                var token = iterator.getCurrentToken();
                if (token && /\b(?:tag-open|tag-name)/.test(token.type)) {
                  var tagNamesRanges = session.getMatchingTags(pos);
                  if (tagNamesRanges)
                    ranges = [tagNamesRanges.openTagName, tagNamesRanges.closeTagName];
                }
              }
              if (!ranges && session.$mode.getMatching)
                ranges = session.$mode.getMatching(self2.session);
              if (!ranges) {
                if (self2.getHighlightIndentGuides())
                  self2.renderer.$textLayer.$highlightIndentGuide();
                return;
              }
              var markerType = "ace_bracket";
              if (!Array.isArray(ranges)) {
                ranges = [ranges];
              } else if (ranges.length == 1) {
                markerType = "ace_error_bracket";
              }
              if (ranges.length == 2) {
                if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)
                  ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];
                else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)
                  ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];
              }
              session.$bracketHighlight = {
                ranges,
                markerIds: ranges.map(function(range) {
                  return session.addMarker(range, markerType, "text");
                })
              };
              if (self2.getHighlightIndentGuides())
                self2.renderer.$textLayer.$highlightIndentGuide();
            }, 50);
          };
          Editor2.prototype.focus = function() {
            this.textInput.focus();
          };
          Editor2.prototype.isFocused = function() {
            return this.textInput.isFocused();
          };
          Editor2.prototype.blur = function() {
            this.textInput.blur();
          };
          Editor2.prototype.onFocus = function(e2) {
            if (this.$isFocused)
              return;
            this.$isFocused = true;
            this.renderer.showCursor();
            this.renderer.visualizeFocus();
            this._emit("focus", e2);
          };
          Editor2.prototype.onBlur = function(e2) {
            if (!this.$isFocused)
              return;
            this.$isFocused = false;
            this.renderer.hideCursor();
            this.renderer.visualizeBlur();
            this._emit("blur", e2);
          };
          Editor2.prototype.$cursorChange = function() {
            this.renderer.updateCursor();
            this.$highlightBrackets();
            this.$updateHighlightActiveLine();
          };
          Editor2.prototype.onDocumentChange = function(delta) {
            var wrap2 = this.session.$useWrapMode;
            var lastRow = delta.start.row == delta.end.row ? delta.end.row : Infinity;
            this.renderer.updateLines(delta.start.row, lastRow, wrap2);
            this._signal("change", delta);
            this.$cursorChange();
          };
          Editor2.prototype.onTokenizerUpdate = function(e2) {
            var rows = e2.data;
            this.renderer.updateLines(rows.first, rows.last);
          };
          Editor2.prototype.onScrollTopChange = function() {
            this.renderer.scrollToY(this.session.getScrollTop());
          };
          Editor2.prototype.onScrollLeftChange = function() {
            this.renderer.scrollToX(this.session.getScrollLeft());
          };
          Editor2.prototype.onCursorChange = function() {
            this.$cursorChange();
            this._signal("changeSelection");
          };
          Editor2.prototype.$updateHighlightActiveLine = function() {
            var session = this.getSession();
            var highlight;
            if (this.$highlightActiveLine) {
              if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
                highlight = this.getCursorPosition();
              if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())
                highlight = false;
              if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                highlight = false;
            }
            if (session.$highlightLineMarker && !highlight) {
              session.removeMarker(session.$highlightLineMarker.id);
              session.$highlightLineMarker = null;
            } else if (!session.$highlightLineMarker && highlight) {
              var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
              range.id = session.addMarker(range, "ace_active-line", "screenLine");
              session.$highlightLineMarker = range;
            } else if (highlight) {
              session.$highlightLineMarker.start.row = highlight.row;
              session.$highlightLineMarker.end.row = highlight.row;
              session.$highlightLineMarker.start.column = highlight.column;
              session._signal("changeBackMarker");
            }
          };
          Editor2.prototype.onSelectionChange = function(e2) {
            var session = this.session;
            if (session.$selectionMarker) {
              session.removeMarker(session.$selectionMarker);
            }
            session.$selectionMarker = null;
            if (!this.selection.isEmpty()) {
              var range = this.selection.getRange();
              var style = this.getSelectionStyle();
              session.$selectionMarker = session.addMarker(range, "ace_selection", style);
            } else {
              this.$updateHighlightActiveLine();
            }
            var re2 = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
            this.session.highlight(re2);
            this._signal("changeSelection");
          };
          Editor2.prototype.$getSelectionHighLightRegexp = function() {
            var session = this.session;
            var selection = this.getSelectionRange();
            if (selection.isEmpty() || selection.isMultiLine())
              return;
            var startColumn = selection.start.column;
            var endColumn = selection.end.column;
            var line = session.getLine(selection.start.row);
            var needle = line.substring(startColumn, endColumn);
            if (needle.length > 5e3 || !/[\w\d]/.test(needle))
              return;
            var re2 = this.$search.$assembleRegExp({
              wholeWord: true,
              caseSensitive: true,
              needle
            });
            var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
            if (!re2.test(wordWithBoundary))
              return;
            return re2;
          };
          Editor2.prototype.onChangeFrontMarker = function() {
            this.renderer.updateFrontMarkers();
          };
          Editor2.prototype.onChangeBackMarker = function() {
            this.renderer.updateBackMarkers();
          };
          Editor2.prototype.onChangeBreakpoint = function() {
            this.renderer.updateBreakpoints();
          };
          Editor2.prototype.onChangeAnnotation = function() {
            this.renderer.setAnnotations(this.session.getAnnotations());
          };
          Editor2.prototype.onChangeMode = function(e2) {
            this.renderer.updateText();
            this._emit("changeMode", e2);
          };
          Editor2.prototype.onChangeWrapLimit = function() {
            this.renderer.updateFull();
          };
          Editor2.prototype.onChangeWrapMode = function() {
            this.renderer.onResize(true);
          };
          Editor2.prototype.onChangeFold = function() {
            this.$updateHighlightActiveLine();
            this.renderer.updateFull();
          };
          Editor2.prototype.getSelectedText = function() {
            return this.session.getTextRange(this.getSelectionRange());
          };
          Editor2.prototype.getCopyText = function() {
            var text = this.getSelectedText();
            var nl = this.session.doc.getNewLineCharacter();
            var copyLine = false;
            if (!text && this.$copyWithEmptySelection) {
              copyLine = true;
              var ranges = this.selection.getAllRanges();
              for (var i2 = 0; i2 < ranges.length; i2++) {
                var range = ranges[i2];
                if (i2 && ranges[i2 - 1].start.row == range.start.row)
                  continue;
                text += this.session.getLine(range.start.row) + nl;
              }
            }
            var e2 = { text };
            this._signal("copy", e2);
            clipboard.lineMode = copyLine ? e2.text : false;
            return e2.text;
          };
          Editor2.prototype.onCopy = function() {
            this.commands.exec("copy", this);
          };
          Editor2.prototype.onCut = function() {
            this.commands.exec("cut", this);
          };
          Editor2.prototype.onPaste = function(text, event) {
            var e2 = { text, event };
            this.commands.exec("paste", this, e2);
          };
          Editor2.prototype.$handlePaste = function(e2) {
            if (typeof e2 == "string")
              e2 = { text: e2 };
            this._signal("paste", e2);
            var text = e2.text;
            var lineMode = text === clipboard.lineMode;
            var session = this.session;
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
              if (lineMode)
                session.insert({ row: this.selection.lead.row, column: 0 }, text);
              else
                this.insert(text);
            } else if (lineMode) {
              this.selection.rangeList.ranges.forEach(function(range2) {
                session.insert({ row: range2.start.row, column: 0 }, text);
              });
            } else {
              var lines = text.split(/\r\n|\r|\n/);
              var ranges = this.selection.rangeList.ranges;
              var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
              if (lines.length != ranges.length || isFullLine)
                return this.commands.exec("insertstring", this, text);
              for (var i2 = ranges.length; i2--; ) {
                var range = ranges[i2];
                if (!range.isEmpty())
                  session.remove(range);
                session.insert(range.start, lines[i2]);
              }
            }
          };
          Editor2.prototype.execCommand = function(command, args) {
            return this.commands.exec(command, this, args);
          };
          Editor2.prototype.insert = function(text, pasted) {
            var session = this.session;
            var mode = session.getMode();
            var cursor = this.getCursorPosition();
            if (this.getBehavioursEnabled() && !pasted) {
              var transform = mode.transformAction(session.getState(cursor.row), "insertion", this, session, text);
              if (transform) {
                if (text !== transform.text) {
                  if (!this.inVirtualSelectionMode) {
                    this.session.mergeUndoDeltas = false;
                    this.mergeNextCommand = false;
                  }
                }
                text = transform.text;
              }
            }
            if (text == "	")
              text = this.session.getTabString();
            if (!this.selection.isEmpty()) {
              var range = this.getSelectionRange();
              cursor = this.session.remove(range);
              this.clearSelection();
            } else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
              var range = new Range.fromPoints(cursor, cursor);
              range.end.column += text.length;
              this.session.remove(range);
            }
            if (text == "\n" || text == "\r\n") {
              var line = session.getLine(cursor.row);
              if (cursor.column > line.search(/\S|$/)) {
                var d3 = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d3);
              }
            }
            this.clearSelection();
            var start = cursor.column;
            var lineState = session.getState(cursor.row);
            var line = session.getLine(cursor.row);
            var shouldOutdent = mode.checkOutdent(lineState, line, text);
            session.insert(cursor, text);
            if (transform && transform.selection) {
              if (transform.selection.length == 2) {
                this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
              } else {
                this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
              }
            }
            if (this.$enableAutoIndent) {
              if (session.getDocument().isNewLine(text)) {
                var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
                session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);
              }
              if (shouldOutdent)
                mode.autoOutdent(lineState, session, cursor.row);
            }
          };
          Editor2.prototype.autoIndent = function() {
            var session = this.session;
            var mode = session.getMode();
            var startRow, endRow;
            if (this.selection.isEmpty()) {
              startRow = 0;
              endRow = session.doc.getLength() - 1;
            } else {
              var selectedRange = this.getSelectionRange();
              startRow = selectedRange.start.row;
              endRow = selectedRange.end.row;
            }
            var prevLineState = "";
            var prevLine = "";
            var lineIndent = "";
            var line, currIndent, range;
            var tab = session.getTabString();
            for (var row = startRow; row <= endRow; row++) {
              if (row > 0) {
                prevLineState = session.getState(row - 1);
                prevLine = session.getLine(row - 1);
                lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);
              }
              line = session.getLine(row);
              currIndent = mode.$getIndent(line);
              if (lineIndent !== currIndent) {
                if (currIndent.length > 0) {
                  range = new Range(row, 0, row, currIndent.length);
                  session.remove(range);
                }
                if (lineIndent.length > 0) {
                  session.insert({ row, column: 0 }, lineIndent);
                }
              }
              mode.autoOutdent(prevLineState, session, row);
            }
          };
          Editor2.prototype.onTextInput = function(text, composition) {
            if (!composition)
              return this.keyBinding.onTextInput(text);
            this.startOperation({ command: { name: "insertstring" } });
            var applyComposition = this.applyComposition.bind(this, text, composition);
            if (this.selection.rangeCount)
              this.forEachSelection(applyComposition);
            else
              applyComposition();
            this.endOperation();
          };
          Editor2.prototype.applyComposition = function(text, composition) {
            if (composition.extendLeft || composition.extendRight) {
              var r = this.selection.getRange();
              r.start.column -= composition.extendLeft;
              r.end.column += composition.extendRight;
              if (r.start.column < 0) {
                r.start.row--;
                r.start.column += this.session.getLine(r.start.row).length + 1;
              }
              this.selection.setRange(r);
              if (!text && !r.isEmpty())
                this.remove();
            }
            if (text || !this.selection.isEmpty())
              this.insert(text, true);
            if (composition.restoreStart || composition.restoreEnd) {
              var r = this.selection.getRange();
              r.start.column -= composition.restoreStart;
              r.end.column -= composition.restoreEnd;
              this.selection.setRange(r);
            }
          };
          Editor2.prototype.onCommandKey = function(e2, hashId, keyCode) {
            return this.keyBinding.onCommandKey(e2, hashId, keyCode);
          };
          Editor2.prototype.setOverwrite = function(overwrite) {
            this.session.setOverwrite(overwrite);
          };
          Editor2.prototype.getOverwrite = function() {
            return this.session.getOverwrite();
          };
          Editor2.prototype.toggleOverwrite = function() {
            this.session.toggleOverwrite();
          };
          Editor2.prototype.setScrollSpeed = function(speed) {
            this.setOption("scrollSpeed", speed);
          };
          Editor2.prototype.getScrollSpeed = function() {
            return this.getOption("scrollSpeed");
          };
          Editor2.prototype.setDragDelay = function(dragDelay) {
            this.setOption("dragDelay", dragDelay);
          };
          Editor2.prototype.getDragDelay = function() {
            return this.getOption("dragDelay");
          };
          Editor2.prototype.setSelectionStyle = function(val) {
            this.setOption("selectionStyle", val);
          };
          Editor2.prototype.getSelectionStyle = function() {
            return this.getOption("selectionStyle");
          };
          Editor2.prototype.setHighlightActiveLine = function(shouldHighlight) {
            this.setOption("highlightActiveLine", shouldHighlight);
          };
          Editor2.prototype.getHighlightActiveLine = function() {
            return this.getOption("highlightActiveLine");
          };
          Editor2.prototype.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
          };
          Editor2.prototype.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
          };
          Editor2.prototype.setHighlightSelectedWord = function(shouldHighlight) {
            this.setOption("highlightSelectedWord", shouldHighlight);
          };
          Editor2.prototype.getHighlightSelectedWord = function() {
            return this.$highlightSelectedWord;
          };
          Editor2.prototype.setAnimatedScroll = function(shouldAnimate) {
            this.renderer.setAnimatedScroll(shouldAnimate);
          };
          Editor2.prototype.getAnimatedScroll = function() {
            return this.renderer.getAnimatedScroll();
          };
          Editor2.prototype.setShowInvisibles = function(showInvisibles) {
            this.renderer.setShowInvisibles(showInvisibles);
          };
          Editor2.prototype.getShowInvisibles = function() {
            return this.renderer.getShowInvisibles();
          };
          Editor2.prototype.setDisplayIndentGuides = function(display) {
            this.renderer.setDisplayIndentGuides(display);
          };
          Editor2.prototype.getDisplayIndentGuides = function() {
            return this.renderer.getDisplayIndentGuides();
          };
          Editor2.prototype.setHighlightIndentGuides = function(highlight) {
            this.renderer.setHighlightIndentGuides(highlight);
          };
          Editor2.prototype.getHighlightIndentGuides = function() {
            return this.renderer.getHighlightIndentGuides();
          };
          Editor2.prototype.setShowPrintMargin = function(showPrintMargin) {
            this.renderer.setShowPrintMargin(showPrintMargin);
          };
          Editor2.prototype.getShowPrintMargin = function() {
            return this.renderer.getShowPrintMargin();
          };
          Editor2.prototype.setPrintMarginColumn = function(showPrintMargin) {
            this.renderer.setPrintMarginColumn(showPrintMargin);
          };
          Editor2.prototype.getPrintMarginColumn = function() {
            return this.renderer.getPrintMarginColumn();
          };
          Editor2.prototype.setReadOnly = function(readOnly) {
            this.setOption("readOnly", readOnly);
          };
          Editor2.prototype.getReadOnly = function() {
            return this.getOption("readOnly");
          };
          Editor2.prototype.setBehavioursEnabled = function(enabled) {
            this.setOption("behavioursEnabled", enabled);
          };
          Editor2.prototype.getBehavioursEnabled = function() {
            return this.getOption("behavioursEnabled");
          };
          Editor2.prototype.setWrapBehavioursEnabled = function(enabled) {
            this.setOption("wrapBehavioursEnabled", enabled);
          };
          Editor2.prototype.getWrapBehavioursEnabled = function() {
            return this.getOption("wrapBehavioursEnabled");
          };
          Editor2.prototype.setShowFoldWidgets = function(show) {
            this.setOption("showFoldWidgets", show);
          };
          Editor2.prototype.getShowFoldWidgets = function() {
            return this.getOption("showFoldWidgets");
          };
          Editor2.prototype.setFadeFoldWidgets = function(fade) {
            this.setOption("fadeFoldWidgets", fade);
          };
          Editor2.prototype.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
          };
          Editor2.prototype.remove = function(dir) {
            if (this.selection.isEmpty()) {
              if (dir == "left")
                this.selection.selectLeft();
              else
                this.selection.selectRight();
            }
            var range = this.getSelectionRange();
            if (this.getBehavioursEnabled()) {
              var session = this.session;
              var state = session.getState(range.start.row);
              var new_range = session.getMode().transformAction(state, "deletion", this, session, range);
              if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == "\n") {
                  var line = session.getLine(range.end.row);
                  if (/^\s+$/.test(line)) {
                    range.end.column = line.length;
                  }
                }
              }
              if (new_range)
                range = new_range;
            }
            this.session.remove(range);
            this.clearSelection();
          };
          Editor2.prototype.removeWordRight = function() {
            if (this.selection.isEmpty())
              this.selection.selectWordRight();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          Editor2.prototype.removeWordLeft = function() {
            if (this.selection.isEmpty())
              this.selection.selectWordLeft();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          Editor2.prototype.removeToLineStart = function() {
            if (this.selection.isEmpty())
              this.selection.selectLineStart();
            if (this.selection.isEmpty())
              this.selection.selectLeft();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          Editor2.prototype.removeToLineEnd = function() {
            if (this.selection.isEmpty())
              this.selection.selectLineEnd();
            var range = this.getSelectionRange();
            if (range.start.column == range.end.column && range.start.row == range.end.row) {
              range.end.column = 0;
              range.end.row++;
            }
            this.session.remove(range);
            this.clearSelection();
          };
          Editor2.prototype.splitLine = function() {
            if (!this.selection.isEmpty()) {
              this.session.remove(this.getSelectionRange());
              this.clearSelection();
            }
            var cursor = this.getCursorPosition();
            this.insert("\n");
            this.moveCursorToPosition(cursor);
          };
          Editor2.prototype.setGhostText = function(text, position) {
            if (!this.session.widgetManager) {
              this.session.widgetManager = new LineWidgets(this.session);
              this.session.widgetManager.attach(this);
            }
            this.renderer.setGhostText(text, position);
          };
          Editor2.prototype.removeGhostText = function() {
            if (!this.session.widgetManager)
              return;
            this.renderer.removeGhostText();
          };
          Editor2.prototype.transposeLetters = function() {
            if (!this.selection.isEmpty()) {
              return;
            }
            var cursor = this.getCursorPosition();
            var column = cursor.column;
            if (column === 0)
              return;
            var line = this.session.getLine(cursor.row);
            var swap, range;
            if (column < line.length) {
              swap = line.charAt(column) + line.charAt(column - 1);
              range = new Range(cursor.row, column - 1, cursor.row, column + 1);
            } else {
              swap = line.charAt(column - 1) + line.charAt(column - 2);
              range = new Range(cursor.row, column - 2, cursor.row, column);
            }
            this.session.replace(range, swap);
            this.session.selection.moveToPosition(range.end);
          };
          Editor2.prototype.toLowerCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
              this.selection.selectWord();
            }
            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toLowerCase());
            this.selection.setSelectionRange(originalRange);
          };
          Editor2.prototype.toUpperCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
              this.selection.selectWord();
            }
            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toUpperCase());
            this.selection.setSelectionRange(originalRange);
          };
          Editor2.prototype.indent = function() {
            var session = this.session;
            var range = this.getSelectionRange();
            if (range.start.row < range.end.row) {
              var rows = this.$getSelectedRows();
              session.indentRows(rows.first, rows.last, "	");
              return;
            } else if (range.start.column < range.end.column) {
              var text = session.getTextRange(range);
              if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "	");
                return;
              }
            }
            var line = session.getLine(range.start.row);
            var position = range.start;
            var size = session.getTabSize();
            var column = session.documentToScreenColumn(position.row, position.column);
            if (this.session.getUseSoftTabs()) {
              var count = size - column % size;
              var indentString = lang.stringRepeat(" ", count);
            } else {
              var count = column % size;
              while (line[range.start.column - 1] == " " && count) {
                range.start.column--;
                count--;
              }
              this.selection.setSelectionRange(range);
              indentString = "	";
            }
            return this.insert(indentString);
          };
          Editor2.prototype.blockIndent = function() {
            var rows = this.$getSelectedRows();
            this.session.indentRows(rows.first, rows.last, "	");
          };
          Editor2.prototype.blockOutdent = function() {
            var selection = this.session.getSelection();
            this.session.outdentRows(selection.getRange());
          };
          Editor2.prototype.sortLines = function() {
            var rows = this.$getSelectedRows();
            var session = this.session;
            var lines = [];
            for (var i2 = rows.first; i2 <= rows.last; i2++)
              lines.push(session.getLine(i2));
            lines.sort(function(a3, b2) {
              if (a3.toLowerCase() < b2.toLowerCase())
                return -1;
              if (a3.toLowerCase() > b2.toLowerCase())
                return 1;
              return 0;
            });
            var deleteRange = new Range(0, 0, 0, 0);
            for (var i2 = rows.first; i2 <= rows.last; i2++) {
              var line = session.getLine(i2);
              deleteRange.start.row = i2;
              deleteRange.end.row = i2;
              deleteRange.end.column = line.length;
              session.replace(deleteRange, lines[i2 - rows.first]);
            }
          };
          Editor2.prototype.toggleCommentLines = function() {
            var state = this.session.getState(this.getCursorPosition().row);
            var rows = this.$getSelectedRows();
            this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
          };
          Editor2.prototype.toggleBlockComment = function() {
            var cursor = this.getCursorPosition();
            var state = this.session.getState(cursor.row);
            var range = this.getSelectionRange();
            this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
          };
          Editor2.prototype.getNumberAt = function(row, column) {
            var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
            _numberRx.lastIndex = 0;
            var s3 = this.session.getLine(row);
            while (_numberRx.lastIndex < column) {
              var m3 = _numberRx.exec(s3);
              if (m3.index <= column && m3.index + m3[0].length >= column) {
                var number = {
                  value: m3[0],
                  start: m3.index,
                  end: m3.index + m3[0].length
                };
                return number;
              }
            }
            return null;
          };
          Editor2.prototype.modifyNumber = function(amount) {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            var charRange = new Range(row, column - 1, row, column);
            var c2 = this.session.getTextRange(charRange);
            if (!isNaN(parseFloat(c2)) && isFinite(c2)) {
              var nr = this.getNumberAt(row, column);
              if (nr) {
                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;
                var t2 = parseFloat(nr.value);
                t2 *= Math.pow(10, decimals);
                if (fp !== nr.end && column < fp) {
                  amount *= Math.pow(10, nr.end - column - 1);
                } else {
                  amount *= Math.pow(10, nr.end - column);
                }
                t2 += amount;
                t2 /= Math.pow(10, decimals);
                var nnr = t2.toFixed(decimals);
                var replaceRange = new Range(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);
                this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
              }
            } else {
              this.toggleWord();
            }
          };
          Editor2.prototype.toggleWord = function() {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            this.selection.selectWord();
            var currentState = this.getSelectedText();
            var currWordStart = this.selection.getWordRange().start.column;
            var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, "$1 ").split(/\s/);
            var delta = column - currWordStart - 1;
            if (delta < 0)
              delta = 0;
            var curLength = 0, itLength = 0;
            var that = this;
            if (currentState.match(/[A-Za-z0-9_]+/)) {
              wordParts.forEach(function(item3, i3) {
                itLength = curLength + item3.length;
                if (delta >= curLength && delta <= itLength) {
                  currentState = item3;
                  that.selection.clearSelection();
                  that.moveCursorTo(row, curLength + currWordStart);
                  that.selection.selectTo(row, itLength + currWordStart);
                }
                curLength = itLength;
              });
            }
            var wordPairs = this.$toggleWordPairs;
            var reg;
            for (var i2 = 0; i2 < wordPairs.length; i2++) {
              var item2 = wordPairs[i2];
              for (var j = 0; j <= 1; j++) {
                var negate = +!j;
                var firstCondition = currentState.match(new RegExp("^\\s?_?(" + lang.escapeRegExp(item2[j]) + ")\\s?$", "i"));
                if (firstCondition) {
                  var secondCondition = currentState.match(new RegExp("([_]|^|\\s)(" + lang.escapeRegExp(firstCondition[1]) + ")($|\\s)", "g"));
                  if (secondCondition) {
                    reg = currentState.replace(new RegExp(lang.escapeRegExp(item2[j]), "i"), function(result) {
                      var res = item2[negate];
                      if (result.toUpperCase() == result) {
                        res = res.toUpperCase();
                      } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
                        res = res.substr(0, 0) + item2[negate].charAt(0).toUpperCase() + res.substr(1);
                      }
                      return res;
                    });
                    this.insert(reg);
                    reg = "";
                  }
                }
              }
            }
          };
          Editor2.prototype.findLinkAt = function(row, column) {
            var e_1, _a2;
            var line = this.session.getLine(row);
            var wordParts = line.split(/((?:https?|ftp):\/\/[\S]+)/);
            var columnPosition = column;
            if (columnPosition < 0)
              columnPosition = 0;
            var previousPosition = 0, currentPosition = 0, match2;
            try {
              for (var wordParts_1 = __values(wordParts), wordParts_1_1 = wordParts_1.next(); !wordParts_1_1.done; wordParts_1_1 = wordParts_1.next()) {
                var item2 = wordParts_1_1.value;
                currentPosition = previousPosition + item2.length;
                if (columnPosition >= previousPosition && columnPosition <= currentPosition) {
                  if (item2.match(/((?:https?|ftp):\/\/[\S]+)/)) {
                    match2 = item2.replace(/[\s:.,'";}\]]+$/, "");
                    break;
                  }
                }
                previousPosition = currentPosition;
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (wordParts_1_1 && !wordParts_1_1.done && (_a2 = wordParts_1.return)) _a2.call(wordParts_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            return match2;
          };
          Editor2.prototype.openLink = function() {
            var cursor = this.selection.getCursor();
            var url = this.findLinkAt(cursor.row, cursor.column);
            if (url)
              window.open(url, "_blank");
            return url != null;
          };
          Editor2.prototype.removeLines = function() {
            var rows = this.$getSelectedRows();
            this.session.removeFullLines(rows.first, rows.last);
            this.clearSelection();
          };
          Editor2.prototype.duplicateSelection = function() {
            var sel = this.selection;
            var doc = this.session;
            var range = sel.getRange();
            var reverse = sel.isBackwards();
            if (range.isEmpty()) {
              var row = range.start.row;
              doc.duplicateLines(row, row);
            } else {
              var point = reverse ? range.start : range.end;
              var endPoint = doc.insert(point, doc.getTextRange(range), false);
              range.start = point;
              range.end = endPoint;
              sel.setSelectionRange(range, reverse);
            }
          };
          Editor2.prototype.moveLinesDown = function() {
            this.$moveLines(1, false);
          };
          Editor2.prototype.moveLinesUp = function() {
            this.$moveLines(-1, false);
          };
          Editor2.prototype.moveText = function(range, toPosition, copy) {
            return this.session.moveText(range, toPosition, copy);
          };
          Editor2.prototype.copyLinesUp = function() {
            this.$moveLines(-1, true);
          };
          Editor2.prototype.copyLinesDown = function() {
            this.$moveLines(1, true);
          };
          Editor2.prototype.$moveLines = function(dir, copy) {
            var rows, moved;
            var selection = this.selection;
            if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
              var range = selection.toOrientedRange();
              rows = this.$getSelectedRows(range);
              moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
              if (copy && dir == -1)
                moved = 0;
              range.moveBy(moved, 0);
              selection.fromOrientedRange(range);
            } else {
              var ranges = selection.rangeList.ranges;
              selection.rangeList.detach(this.session);
              this.inVirtualSelectionMode = true;
              var diff = 0;
              var totalDiff = 0;
              var l = ranges.length;
              for (var i2 = 0; i2 < l; i2++) {
                var rangeIndex = i2;
                ranges[i2].moveBy(diff, 0);
                rows = this.$getSelectedRows(ranges[i2]);
                var first = rows.first;
                var last = rows.last;
                while (++i2 < l) {
                  if (totalDiff)
                    ranges[i2].moveBy(totalDiff, 0);
                  var subRows = this.$getSelectedRows(ranges[i2]);
                  if (copy && subRows.first != last)
                    break;
                  else if (!copy && subRows.first > last + 1)
                    break;
                  last = subRows.last;
                }
                i2--;
                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                if (copy && dir == -1)
                  rangeIndex = i2 + 1;
                while (rangeIndex <= i2) {
                  ranges[rangeIndex].moveBy(diff, 0);
                  rangeIndex++;
                }
                if (!copy)
                  diff = 0;
                totalDiff += diff;
              }
              selection.fromOrientedRange(selection.ranges[0]);
              selection.rangeList.attach(this.session);
              this.inVirtualSelectionMode = false;
            }
          };
          Editor2.prototype.$getSelectedRows = function(range) {
            range = (range || this.getSelectionRange()).collapseRows();
            return {
              first: this.session.getRowFoldStart(range.start.row),
              last: this.session.getRowFoldEnd(range.end.row)
            };
          };
          Editor2.prototype.onCompositionStart = function(compositionState) {
            this.renderer.showComposition(compositionState);
          };
          Editor2.prototype.onCompositionUpdate = function(text) {
            this.renderer.setCompositionText(text);
          };
          Editor2.prototype.onCompositionEnd = function() {
            this.renderer.hideComposition();
          };
          Editor2.prototype.getFirstVisibleRow = function() {
            return this.renderer.getFirstVisibleRow();
          };
          Editor2.prototype.getLastVisibleRow = function() {
            return this.renderer.getLastVisibleRow();
          };
          Editor2.prototype.isRowVisible = function(row) {
            return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
          };
          Editor2.prototype.isRowFullyVisible = function(row) {
            return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
          };
          Editor2.prototype.$getVisibleRowCount = function() {
            return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
          };
          Editor2.prototype.$moveByPage = function(dir, select2) {
            var renderer = this.renderer;
            var config2 = this.renderer.layerConfig;
            var rows = dir * Math.floor(config2.height / config2.lineHeight);
            if (select2 === true) {
              this.selection.$moveSelection(function() {
                this.moveCursorBy(rows, 0);
              });
            } else if (select2 === false) {
              this.selection.moveCursorBy(rows, 0);
              this.selection.clearSelection();
            }
            var scrollTop = renderer.scrollTop;
            renderer.scrollBy(0, rows * config2.lineHeight);
            if (select2 != null)
              renderer.scrollCursorIntoView(null, 0.5);
            renderer.animateScrolling(scrollTop);
          };
          Editor2.prototype.selectPageDown = function() {
            this.$moveByPage(1, true);
          };
          Editor2.prototype.selectPageUp = function() {
            this.$moveByPage(-1, true);
          };
          Editor2.prototype.gotoPageDown = function() {
            this.$moveByPage(1, false);
          };
          Editor2.prototype.gotoPageUp = function() {
            this.$moveByPage(-1, false);
          };
          Editor2.prototype.scrollPageDown = function() {
            this.$moveByPage(1);
          };
          Editor2.prototype.scrollPageUp = function() {
            this.$moveByPage(-1);
          };
          Editor2.prototype.scrollToRow = function(row) {
            this.renderer.scrollToRow(row);
          };
          Editor2.prototype.scrollToLine = function(line, center, animate, callback) {
            this.renderer.scrollToLine(line, center, animate, callback);
          };
          Editor2.prototype.centerSelection = function() {
            var range = this.getSelectionRange();
            var pos = {
              row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
              column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
            };
            this.renderer.alignCursor(pos, 0.5);
          };
          Editor2.prototype.getCursorPosition = function() {
            return this.selection.getCursor();
          };
          Editor2.prototype.getCursorPositionScreen = function() {
            return this.session.documentToScreenPosition(this.getCursorPosition());
          };
          Editor2.prototype.getSelectionRange = function() {
            return this.selection.getRange();
          };
          Editor2.prototype.selectAll = function() {
            this.selection.selectAll();
          };
          Editor2.prototype.clearSelection = function() {
            this.selection.clearSelection();
          };
          Editor2.prototype.moveCursorTo = function(row, column) {
            this.selection.moveCursorTo(row, column);
          };
          Editor2.prototype.moveCursorToPosition = function(pos) {
            this.selection.moveCursorToPosition(pos);
          };
          Editor2.prototype.jumpToMatching = function(select2, expand) {
            var cursor = this.getCursorPosition();
            var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
            var prevToken = iterator.getCurrentToken();
            var tokenCount = 0;
            if (prevToken && prevToken.type.indexOf("tag-name") !== -1) {
              prevToken = iterator.stepBackward();
            }
            var token = prevToken || iterator.stepForward();
            if (!token)
              return;
            var matchType;
            var found = false;
            var depth = {};
            var i2 = cursor.column - token.start;
            var bracketType;
            var brackets = {
              ")": "(",
              "(": "(",
              "]": "[",
              "[": "[",
              "{": "{",
              "}": "{"
            };
            do {
              if (token.value.match(/[{}()\[\]]/g)) {
                for (; i2 < token.value.length && !found; i2++) {
                  if (!brackets[token.value[i2]]) {
                    continue;
                  }
                  bracketType = brackets[token.value[i2]] + "." + token.type.replace("rparen", "lparen");
                  if (isNaN(depth[bracketType])) {
                    depth[bracketType] = 0;
                  }
                  switch (token.value[i2]) {
                    case "(":
                    case "[":
                    case "{":
                      depth[bracketType]++;
                      break;
                    case ")":
                    case "]":
                    case "}":
                      depth[bracketType]--;
                      if (depth[bracketType] === -1) {
                        matchType = "bracket";
                        found = true;
                      }
                      break;
                  }
                }
              } else if (token.type.indexOf("tag-name") !== -1) {
                if (isNaN(depth[token.value])) {
                  depth[token.value] = 0;
                }
                if (prevToken.value === "<" && tokenCount > 1) {
                  depth[token.value]++;
                } else if (prevToken.value === "</") {
                  depth[token.value]--;
                }
                if (depth[token.value] === -1) {
                  matchType = "tag";
                  found = true;
                }
              }
              if (!found) {
                prevToken = token;
                tokenCount++;
                token = iterator.stepForward();
                i2 = 0;
              }
            } while (token && !found);
            if (!matchType)
              return;
            var range, pos;
            if (matchType === "bracket") {
              range = this.session.getBracketRange(cursor);
              if (!range) {
                range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i2 - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i2 - 1);
                pos = range.start;
                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                  range = this.session.getBracketRange(pos);
              }
            } else if (matchType === "tag") {
              if (!token || token.type.indexOf("tag-name") === -1)
                return;
              range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
              if (range.compare(cursor.row, cursor.column) === 0) {
                var tagsRanges = this.session.getMatchingTags(cursor);
                if (tagsRanges) {
                  if (tagsRanges.openTag.contains(cursor.row, cursor.column)) {
                    range = tagsRanges.closeTag;
                    pos = range.start;
                  } else {
                    range = tagsRanges.openTag;
                    if (tagsRanges.closeTag.start.row === cursor.row && tagsRanges.closeTag.start.column === cursor.column)
                      pos = range.end;
                    else
                      pos = range.start;
                  }
                }
              }
              pos = pos || range.start;
            }
            pos = range && range.cursor || pos;
            if (pos) {
              if (select2) {
                if (range && expand) {
                  this.selection.setRange(range);
                } else if (range && range.isEqual(this.getSelectionRange())) {
                  this.clearSelection();
                } else {
                  this.selection.selectTo(pos.row, pos.column);
                }
              } else {
                this.selection.moveTo(pos.row, pos.column);
              }
            }
          };
          Editor2.prototype.gotoLine = function(lineNumber, column, animate) {
            this.selection.clearSelection();
            this.session.unfold({ row: lineNumber - 1, column: column || 0 });
            this.exitMultiSelectMode && this.exitMultiSelectMode();
            this.moveCursorTo(lineNumber - 1, column || 0);
            if (!this.isRowFullyVisible(lineNumber - 1))
              this.scrollToLine(lineNumber - 1, true, animate);
          };
          Editor2.prototype.navigateTo = function(row, column) {
            this.selection.moveTo(row, column);
          };
          Editor2.prototype.navigateUp = function(times) {
            if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
              var selectionStart = this.selection.anchor.getPosition();
              return this.moveCursorToPosition(selectionStart);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(-times || -1, 0);
          };
          Editor2.prototype.navigateDown = function(times) {
            if (this.selection.isMultiLine() && this.selection.isBackwards()) {
              var selectionEnd = this.selection.anchor.getPosition();
              return this.moveCursorToPosition(selectionEnd);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(times || 1, 0);
          };
          Editor2.prototype.navigateLeft = function(times) {
            if (!this.selection.isEmpty()) {
              var selectionStart = this.getSelectionRange().start;
              this.moveCursorToPosition(selectionStart);
            } else {
              times = times || 1;
              while (times--) {
                this.selection.moveCursorLeft();
              }
            }
            this.clearSelection();
          };
          Editor2.prototype.navigateRight = function(times) {
            if (!this.selection.isEmpty()) {
              var selectionEnd = this.getSelectionRange().end;
              this.moveCursorToPosition(selectionEnd);
            } else {
              times = times || 1;
              while (times--) {
                this.selection.moveCursorRight();
              }
            }
            this.clearSelection();
          };
          Editor2.prototype.navigateLineStart = function() {
            this.selection.moveCursorLineStart();
            this.clearSelection();
          };
          Editor2.prototype.navigateLineEnd = function() {
            this.selection.moveCursorLineEnd();
            this.clearSelection();
          };
          Editor2.prototype.navigateFileEnd = function() {
            this.selection.moveCursorFileEnd();
            this.clearSelection();
          };
          Editor2.prototype.navigateFileStart = function() {
            this.selection.moveCursorFileStart();
            this.clearSelection();
          };
          Editor2.prototype.navigateWordRight = function() {
            this.selection.moveCursorWordRight();
            this.clearSelection();
          };
          Editor2.prototype.navigateWordLeft = function() {
            this.selection.moveCursorWordLeft();
            this.clearSelection();
          };
          Editor2.prototype.replace = function(replacement, options) {
            if (options)
              this.$search.set(options);
            var range = this.$search.find(this.session);
            var replaced = 0;
            if (!range)
              return replaced;
            if (this.$tryReplace(range, replacement)) {
              replaced = 1;
            }
            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);
            return replaced;
          };
          Editor2.prototype.replaceAll = function(replacement, options) {
            if (options) {
              this.$search.set(options);
            }
            var ranges = this.$search.findAll(this.session);
            var replaced = 0;
            if (!ranges.length)
              return replaced;
            var selection = this.getSelectionRange();
            this.selection.moveTo(0, 0);
            for (var i2 = ranges.length - 1; i2 >= 0; --i2) {
              if (this.$tryReplace(ranges[i2], replacement)) {
                replaced++;
              }
            }
            this.selection.setSelectionRange(selection);
            return replaced;
          };
          Editor2.prototype.$tryReplace = function(range, replacement) {
            var input = this.session.getTextRange(range);
            replacement = this.$search.replace(input, replacement);
            if (replacement !== null) {
              range.end = this.session.replace(range, replacement);
              return range;
            } else {
              return null;
            }
          };
          Editor2.prototype.getLastSearchOptions = function() {
            return this.$search.getOptions();
          };
          Editor2.prototype.find = function(needle, options, animate) {
            if (!options)
              options = {};
            if (typeof needle == "string" || needle instanceof RegExp)
              options.needle = needle;
            else if (typeof needle == "object")
              oop.mixin(options, needle);
            var range = this.selection.getRange();
            if (options.needle == null) {
              needle = this.session.getTextRange(range) || this.$search.$options.needle;
              if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
              }
              this.$search.set({ needle });
            }
            this.$search.set(options);
            if (!options.start)
              this.$search.set({ start: range });
            var newRange = this.$search.find(this.session);
            if (options.preventScroll)
              return newRange;
            if (newRange) {
              this.revealRange(newRange, animate);
              return newRange;
            }
            if (options.backwards)
              range.start = range.end;
            else
              range.end = range.start;
            this.selection.setRange(range);
          };
          Editor2.prototype.findNext = function(options, animate) {
            this.find({ skipCurrent: true, backwards: false }, options, animate);
          };
          Editor2.prototype.findPrevious = function(options, animate) {
            this.find(options, { skipCurrent: true, backwards: true }, animate);
          };
          Editor2.prototype.revealRange = function(range, animate) {
            this.session.unfold(range);
            this.selection.setSelectionRange(range);
            var scrollTop = this.renderer.scrollTop;
            this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
            if (animate !== false)
              this.renderer.animateScrolling(scrollTop);
          };
          Editor2.prototype.undo = function() {
            this.session.getUndoManager().undo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
          };
          Editor2.prototype.redo = function() {
            this.session.getUndoManager().redo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
          };
          Editor2.prototype.destroy = function() {
            if (this.$toDestroy) {
              this.$toDestroy.forEach(function(el) {
                el.destroy();
              });
              this.$toDestroy = null;
            }
            if (this.$mouseHandler)
              this.$mouseHandler.destroy();
            this.renderer.destroy();
            this._signal("destroy", this);
            if (this.session)
              this.session.destroy();
            if (this._$emitInputEvent)
              this._$emitInputEvent.cancel();
            this.removeAllListeners();
          };
          Editor2.prototype.setAutoScrollEditorIntoView = function(enable) {
            if (!enable)
              return;
            var rect;
            var self2 = this;
            var shouldScroll = false;
            if (!this.$scrollAnchor)
              this.$scrollAnchor = document.createElement("div");
            var scrollAnchor = this.$scrollAnchor;
            scrollAnchor.style.cssText = "position:absolute";
            this.container.insertBefore(scrollAnchor, this.container.firstChild);
            var onChangeSelection = this.on("changeSelection", function() {
              shouldScroll = true;
            });
            var onBeforeRender = this.renderer.on("beforeRender", function() {
              if (shouldScroll)
                rect = self2.renderer.container.getBoundingClientRect();
            });
            var onAfterRender = this.renderer.on("afterRender", function() {
              if (shouldScroll && rect && (self2.isFocused() || self2.searchBox && self2.searchBox.isFocused())) {
                var renderer = self2.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config2 = renderer.layerConfig;
                var top = pos.top - config2.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                  shouldScroll = true;
                } else if (pos.top < config2.height && pos.top + rect.top + config2.lineHeight > window.innerHeight) {
                  shouldScroll = false;
                } else {
                  shouldScroll = null;
                }
                if (shouldScroll != null) {
                  scrollAnchor.style.top = top + "px";
                  scrollAnchor.style.left = pos.left + "px";
                  scrollAnchor.style.height = config2.lineHeight + "px";
                  scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
              }
            });
            this.setAutoScrollEditorIntoView = function(enable2) {
              if (enable2)
                return;
              delete this.setAutoScrollEditorIntoView;
              this.off("changeSelection", onChangeSelection);
              this.renderer.off("afterRender", onAfterRender);
              this.renderer.off("beforeRender", onBeforeRender);
            };
          };
          Editor2.prototype.$resetCursorStyle = function() {
            var style = this.$cursorStyle || "ace";
            var cursorLayer = this.renderer.$cursorLayer;
            if (!cursorLayer)
              return;
            cursorLayer.setSmoothBlinking(/smooth/.test(style));
            cursorLayer.isBlinking = !this.$readOnly && style != "wide";
            dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
          };
          Editor2.prototype.prompt = function(message, options, callback) {
            var editor = this;
            config.loadModule("ace/ext/prompt", function(module4) {
              module4.prompt(editor, message, options, callback);
            });
          };
          return Editor2;
        }()
      );
      Editor.$uid = 0;
      Editor.prototype.curOp = null;
      Editor.prototype.prevOp = {};
      Editor.prototype.$mergeableCommands = ["backspace", "del", "insertstring"];
      Editor.prototype.$toggleWordPairs = [
        ["first", "last"],
        ["true", "false"],
        ["yes", "no"],
        ["width", "height"],
        ["top", "bottom"],
        ["right", "left"],
        ["on", "off"],
        ["x", "y"],
        ["get", "set"],
        ["max", "min"],
        ["horizontal", "vertical"],
        ["show", "hide"],
        ["add", "remove"],
        ["up", "down"],
        ["before", "after"],
        ["even", "odd"],
        ["in", "out"],
        ["inside", "outside"],
        ["next", "previous"],
        ["increase", "decrease"],
        ["attach", "detach"],
        ["&&", "||"],
        ["==", "!="]
      ];
      oop.implement(Editor.prototype, EventEmitter);
      config.defineOptions(Editor.prototype, "editor", {
        selectionStyle: {
          set: function(style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", { data: style });
          },
          initialValue: "line"
        },
        highlightActiveLine: {
          set: function() {
            this.$updateHighlightActiveLine();
          },
          initialValue: true
        },
        highlightSelectedWord: {
          set: function(shouldHighlight) {
            this.$onSelectionChange();
          },
          initialValue: true
        },
        readOnly: {
          set: function(readOnly) {
            this.textInput.setReadOnly(readOnly);
            this.$resetCursorStyle();
          },
          initialValue: false
        },
        copyWithEmptySelection: {
          set: function(value) {
            this.textInput.setCopyWithEmptySelection(value);
          },
          initialValue: false
        },
        cursorStyle: {
          set: function(val) {
            this.$resetCursorStyle();
          },
          values: ["ace", "slim", "smooth", "wide"],
          initialValue: "ace"
        },
        mergeUndoDeltas: {
          values: [false, true, "always"],
          initialValue: true
        },
        behavioursEnabled: { initialValue: true },
        wrapBehavioursEnabled: { initialValue: true },
        enableAutoIndent: { initialValue: true },
        autoScrollEditorIntoView: {
          set: function(val) {
            this.setAutoScrollEditorIntoView(val);
          }
        },
        keyboardHandler: {
          set: function(val) {
            this.setKeyboardHandler(val);
          },
          get: function() {
            return this.$keybindingId;
          },
          handlesSet: true
        },
        value: {
          set: function(val) {
            this.session.setValue(val);
          },
          get: function() {
            return this.getValue();
          },
          handlesSet: true,
          hidden: true
        },
        session: {
          set: function(val) {
            this.setSession(val);
          },
          get: function() {
            return this.session;
          },
          handlesSet: true,
          hidden: true
        },
        showLineNumbers: {
          set: function(show) {
            this.renderer.$gutterLayer.setShowLineNumbers(show);
            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
            if (show && this.$relativeLineNumbers)
              relativeNumberRenderer.attach(this);
            else
              relativeNumberRenderer.detach(this);
          },
          initialValue: true
        },
        relativeLineNumbers: {
          set: function(value) {
            if (this.$showLineNumbers && value)
              relativeNumberRenderer.attach(this);
            else
              relativeNumberRenderer.detach(this);
          }
        },
        placeholder: {
          set: function(message) {
            if (!this.$updatePlaceholder) {
              this.$updatePlaceholder = (function() {
                var value = this.session && (this.renderer.$composition || this.getValue());
                if (value && this.renderer.placeholderNode) {
                  this.renderer.off("afterRender", this.$updatePlaceholder);
                  dom.removeCssClass(this.container, "ace_hasPlaceholder");
                  this.renderer.placeholderNode.remove();
                  this.renderer.placeholderNode = null;
                } else if (!value && !this.renderer.placeholderNode) {
                  this.renderer.on("afterRender", this.$updatePlaceholder);
                  dom.addCssClass(this.container, "ace_hasPlaceholder");
                  var el = dom.createElement("div");
                  el.className = "ace_placeholder";
                  el.textContent = this.$placeholder || "";
                  this.renderer.placeholderNode = el;
                  this.renderer.content.appendChild(this.renderer.placeholderNode);
                } else if (!value && this.renderer.placeholderNode) {
                  this.renderer.placeholderNode.textContent = this.$placeholder || "";
                }
              }).bind(this);
              this.on("input", this.$updatePlaceholder);
            }
            this.$updatePlaceholder();
          }
        },
        enableKeyboardAccessibility: {
          set: function(value) {
            var blurCommand = {
              name: "blurTextInput",
              description: "Set focus to the editor content div to allow tabbing through the page",
              bindKey: "Esc",
              exec: function(editor) {
                editor.blur();
                editor.renderer.content.focus();
              },
              readOnly: true
            };
            var focusOnEnterKeyup = function(e2) {
              if (e2.target == this.renderer.content && e2.keyCode === keys["enter"]) {
                e2.stopPropagation();
                e2.preventDefault();
                this.focus();
              }
            };
            var keyboardFocusClassName = "ace_keyboard-focus";
            if (value) {
              this.textInput.getElement().setAttribute("tabindex", -1);
              this.renderer.content.setAttribute("tabindex", 0);
              this.renderer.content.classList.add(keyboardFocusClassName);
              this.renderer.content.setAttribute("aria-label", "Editor, press Enter key to start editing, press Escape key to exit");
              this.renderer.content.addEventListener("keyup", focusOnEnterKeyup.bind(this));
              this.commands.addCommand(blurCommand);
            } else {
              this.textInput.getElement().setAttribute("tabindex", 0);
              this.renderer.content.setAttribute("tabindex", -1);
              this.renderer.content.classList.remove(keyboardFocusClassName);
              this.renderer.content.setAttribute("aria-label", "");
              this.renderer.content.removeEventListener("keyup", focusOnEnterKeyup.bind(this));
              this.commands.removeCommand(blurCommand);
            }
          },
          initialValue: false
        },
        customScrollbar: "renderer",
        hScrollBarAlwaysVisible: "renderer",
        vScrollBarAlwaysVisible: "renderer",
        highlightGutterLine: "renderer",
        animatedScroll: "renderer",
        showInvisibles: "renderer",
        showPrintMargin: "renderer",
        printMarginColumn: "renderer",
        printMargin: "renderer",
        fadeFoldWidgets: "renderer",
        showFoldWidgets: "renderer",
        displayIndentGuides: "renderer",
        highlightIndentGuides: "renderer",
        showGutter: "renderer",
        fontSize: "renderer",
        fontFamily: "renderer",
        maxLines: "renderer",
        minLines: "renderer",
        scrollPastEnd: "renderer",
        fixedWidthGutter: "renderer",
        theme: "renderer",
        hasCssTransforms: "renderer",
        maxPixelHeight: "renderer",
        useTextareaForIME: "renderer",
        useResizeObserver: "renderer",
        useSvgGutterIcons: "renderer",
        showFoldedAnnotations: "renderer",
        scrollSpeed: "$mouseHandler",
        dragDelay: "$mouseHandler",
        dragEnabled: "$mouseHandler",
        focusTimeout: "$mouseHandler",
        tooltipFollowsMouse: "$mouseHandler",
        firstLineNumber: "session",
        overwrite: "session",
        newLineMode: "session",
        useWorker: "session",
        useSoftTabs: "session",
        navigateWithinSoftTabs: "session",
        tabSize: "session",
        wrap: "session",
        indentedSoftWrap: "session",
        foldStyle: "session",
        mode: "session"
      });
      var relativeNumberRenderer = {
        getText: function(session, row) {
          return (Math.abs(session.selection.lead.row - row) || row + 1 + (row < 9 ? "·" : "")) + "";
        },
        getWidth: function(session, lastLineNumber, config2) {
          return Math.max(lastLineNumber.toString().length, (config2.lastRow + 1).toString().length, 2) * config2.characterWidth;
        },
        update: function(e2, editor) {
          editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);
        },
        attach: function(editor) {
          editor.renderer.$gutterLayer.$renderer = this;
          editor.on("changeSelection", this.update);
          this.update(null, editor);
        },
        detach: function(editor) {
          if (editor.renderer.$gutterLayer.$renderer == this)
            editor.renderer.$gutterLayer.$renderer = null;
          editor.off("changeSelection", this.update);
          this.update(null, editor);
        }
      };
      exports3.Editor = Editor;
    });
    ace.define("ace/undomanager", ["require", "exports", "module", "ace/range"], function(require2, exports3, module3) {
      var UndoManager = (
        /** @class */
        function() {
          function UndoManager2() {
            this.$maxRev = 0;
            this.$fromUndo = false;
            this.$undoDepth = Infinity;
            this.reset();
          }
          UndoManager2.prototype.addSession = function(session) {
            this.$session = session;
          };
          UndoManager2.prototype.add = function(delta, allowMerge, session) {
            if (this.$fromUndo)
              return;
            if (delta == this.$lastDelta)
              return;
            if (!this.$keepRedoStack)
              this.$redoStack.length = 0;
            if (allowMerge === false || !this.lastDeltas) {
              this.lastDeltas = [];
              var undoStackLength = this.$undoStack.length;
              if (undoStackLength > this.$undoDepth - 1) {
                this.$undoStack.splice(0, undoStackLength - this.$undoDepth + 1);
              }
              this.$undoStack.push(this.lastDeltas);
              delta.id = this.$rev = ++this.$maxRev;
            }
            if (delta.action == "remove" || delta.action == "insert")
              this.$lastDelta = delta;
            this.lastDeltas.push(delta);
          };
          UndoManager2.prototype.addSelection = function(selection, rev) {
            this.selections.push({
              value: selection,
              rev: rev || this.$rev
            });
          };
          UndoManager2.prototype.startNewGroup = function() {
            this.lastDeltas = null;
            return this.$rev;
          };
          UndoManager2.prototype.markIgnored = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
            var stack = this.$undoStack;
            for (var i2 = stack.length; i2--; ) {
              var delta = stack[i2][0];
              if (delta.id <= from)
                break;
              if (delta.id < to)
                delta.ignore = true;
            }
            this.lastDeltas = null;
          };
          UndoManager2.prototype.getSelection = function(rev, after) {
            var stack = this.selections;
            for (var i2 = stack.length; i2--; ) {
              var selection = stack[i2];
              if (selection.rev < rev) {
                if (after)
                  selection = stack[i2 + 1];
                return selection;
              }
            }
          };
          UndoManager2.prototype.getRevision = function() {
            return this.$rev;
          };
          UndoManager2.prototype.getDeltas = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
            var stack = this.$undoStack;
            var end = null, start = 0;
            for (var i2 = stack.length; i2--; ) {
              var delta = stack[i2][0];
              if (delta.id < to && !end)
                end = i2 + 1;
              if (delta.id <= from) {
                start = i2 + 1;
                break;
              }
            }
            return stack.slice(start, end);
          };
          UndoManager2.prototype.getChangedRanges = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
          };
          UndoManager2.prototype.getChangedLines = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
          };
          UndoManager2.prototype.undo = function(session, dontSelect) {
            this.lastDeltas = null;
            var stack = this.$undoStack;
            if (!rearrangeUndoStack(stack, stack.length))
              return;
            if (!session)
              session = this.$session;
            if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)
              this.$redoStack = [];
            this.$fromUndo = true;
            var deltaSet = stack.pop();
            var undoSelectionRange = null;
            if (deltaSet) {
              undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
              this.$redoStack.push(deltaSet);
              this.$syncRev();
            }
            this.$fromUndo = false;
            return undoSelectionRange;
          };
          UndoManager2.prototype.redo = function(session, dontSelect) {
            this.lastDeltas = null;
            if (!session)
              session = this.$session;
            this.$fromUndo = true;
            if (this.$redoStackBaseRev != this.$rev) {
              var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
              rebaseRedoStack(this.$redoStack, diff);
              this.$redoStackBaseRev = this.$rev;
              this.$redoStack.forEach(function(x2) {
                x2[0].id = ++this.$maxRev;
              }, this);
            }
            var deltaSet = this.$redoStack.pop();
            var redoSelectionRange = null;
            if (deltaSet) {
              redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
              this.$undoStack.push(deltaSet);
              this.$syncRev();
            }
            this.$fromUndo = false;
            return redoSelectionRange;
          };
          UndoManager2.prototype.$syncRev = function() {
            var stack = this.$undoStack;
            var nextDelta = stack[stack.length - 1];
            var id = nextDelta && nextDelta[0].id || 0;
            this.$redoStackBaseRev = id;
            this.$rev = id;
          };
          UndoManager2.prototype.reset = function() {
            this.lastDeltas = null;
            this.$lastDelta = null;
            this.$undoStack = [];
            this.$redoStack = [];
            this.$rev = 0;
            this.mark = 0;
            this.$redoStackBaseRev = this.$rev;
            this.selections = [];
          };
          UndoManager2.prototype.canUndo = function() {
            return this.$undoStack.length > 0;
          };
          UndoManager2.prototype.canRedo = function() {
            return this.$redoStack.length > 0;
          };
          UndoManager2.prototype.bookmark = function(rev) {
            if (rev == void 0)
              rev = this.$rev;
            this.mark = rev;
          };
          UndoManager2.prototype.isAtBookmark = function() {
            return this.$rev === this.mark;
          };
          UndoManager2.prototype.toJSON = function() {
          };
          UndoManager2.prototype.fromJSON = function() {
          };
          UndoManager2.prototype.$prettyPrint = function(delta) {
            if (delta)
              return stringifyDelta(delta);
            return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
          };
          return UndoManager2;
        }()
      );
      UndoManager.prototype.hasUndo = UndoManager.prototype.canUndo;
      UndoManager.prototype.hasRedo = UndoManager.prototype.canRedo;
      UndoManager.prototype.isClean = UndoManager.prototype.isAtBookmark;
      UndoManager.prototype.markClean = UndoManager.prototype.bookmark;
      function rearrangeUndoStack(stack, pos) {
        for (var i2 = pos; i2--; ) {
          var deltaSet = stack[i2];
          if (deltaSet && !deltaSet[0].ignore) {
            while (i2 < pos - 1) {
              var swapped = swapGroups(stack[i2], stack[i2 + 1]);
              stack[i2] = swapped[0];
              stack[i2 + 1] = swapped[1];
              i2++;
            }
            return true;
          }
        }
      }
      var Range = require2("./range").Range;
      var cmp = Range.comparePoints;
      Range.comparePoints;
      function clonePos(pos) {
        return { row: pos.row, column: pos.column };
      }
      function cloneDelta(d3) {
        return {
          start: clonePos(d3.start),
          end: clonePos(d3.end),
          action: d3.action,
          lines: d3.lines.slice()
        };
      }
      function stringifyDelta(d3) {
        d3 = d3 || this;
        if (Array.isArray(d3)) {
          return d3.map(stringifyDelta).join("\n");
        }
        var type = "";
        if (d3.action) {
          type = d3.action == "insert" ? "+" : "-";
          type += "[" + d3.lines + "]";
        } else if (d3.value) {
          if (Array.isArray(d3.value)) {
            type = d3.value.map(stringifyRange).join("\n");
          } else {
            type = stringifyRange(d3.value);
          }
        }
        if (d3.start) {
          type += stringifyRange(d3);
        }
        if (d3.id || d3.rev) {
          type += "	(" + (d3.id || d3.rev) + ")";
        }
        return type;
      }
      function stringifyRange(r) {
        return r.start.row + ":" + r.start.column + "=>" + r.end.row + ":" + r.end.column;
      }
      function swap(d1, d22) {
        var i1 = d1.action == "insert";
        var i2 = d22.action == "insert";
        if (i1 && i2) {
          if (cmp(d22.start, d1.end) >= 0) {
            shift(d22, d1, -1);
          } else if (cmp(d22.start, d1.start) <= 0) {
            shift(d1, d22, 1);
          } else {
            return null;
          }
        } else if (i1 && !i2) {
          if (cmp(d22.start, d1.end) >= 0) {
            shift(d22, d1, -1);
          } else if (cmp(d22.end, d1.start) <= 0) {
            shift(d1, d22, -1);
          } else {
            return null;
          }
        } else if (!i1 && i2) {
          if (cmp(d22.start, d1.start) >= 0) {
            shift(d22, d1, 1);
          } else if (cmp(d22.start, d1.start) <= 0) {
            shift(d1, d22, 1);
          } else {
            return null;
          }
        } else if (!i1 && !i2) {
          if (cmp(d22.start, d1.start) >= 0) {
            shift(d22, d1, 1);
          } else if (cmp(d22.end, d1.start) <= 0) {
            shift(d1, d22, -1);
          } else {
            return null;
          }
        }
        return [d22, d1];
      }
      function swapGroups(ds1, ds2) {
        for (var i2 = ds1.length; i2--; ) {
          for (var j = 0; j < ds2.length; j++) {
            if (!swap(ds1[i2], ds2[j])) {
              while (i2 < ds1.length) {
                while (j--) {
                  swap(ds2[j], ds1[i2]);
                }
                j = ds2.length;
                i2++;
              }
              return [ds1, ds2];
            }
          }
        }
        ds1.selectionBefore = ds2.selectionBefore = ds1.selectionAfter = ds2.selectionAfter = null;
        return [ds2, ds1];
      }
      function xform(d1, c1) {
        var i1 = d1.action == "insert";
        var i2 = c1.action == "insert";
        if (i1 && i2) {
          if (cmp(d1.start, c1.start) < 0) {
            shift(c1, d1, 1);
          } else {
            shift(d1, c1, 1);
          }
        } else if (i1 && !i2) {
          if (cmp(d1.start, c1.end) >= 0) {
            shift(d1, c1, -1);
          } else if (cmp(d1.start, c1.start) <= 0) {
            shift(c1, d1, 1);
          } else {
            shift(d1, Range.fromPoints(c1.start, d1.start), -1);
            shift(c1, d1, 1);
          }
        } else if (!i1 && i2) {
          if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
          } else if (cmp(c1.start, d1.start) <= 0) {
            shift(d1, c1, 1);
          } else {
            shift(c1, Range.fromPoints(d1.start, c1.start), -1);
            shift(d1, c1, 1);
          }
        } else if (!i1 && !i2) {
          if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
          } else if (cmp(c1.end, d1.start) <= 0) {
            shift(d1, c1, -1);
          } else {
            var before, after;
            if (cmp(d1.start, c1.start) < 0) {
              before = d1;
              d1 = splitDelta(d1, c1.start);
            }
            if (cmp(d1.end, c1.end) > 0) {
              after = splitDelta(d1, c1.end);
            }
            shiftPos(c1.end, d1.start, d1.end, -1);
            if (after && !before) {
              d1.lines = after.lines;
              d1.start = after.start;
              d1.end = after.end;
              after = d1;
            }
            return [c1, before, after].filter(Boolean);
          }
        }
        return [c1, d1];
      }
      function shift(d1, d22, dir) {
        shiftPos(d1.start, d22.start, d22.end, dir);
        shiftPos(d1.end, d22.start, d22.end, dir);
      }
      function shiftPos(pos, start, end, dir) {
        if (pos.row == (dir == 1 ? start : end).row) {
          pos.column += dir * (end.column - start.column);
        }
        pos.row += dir * (end.row - start.row);
      }
      function splitDelta(c2, pos) {
        var lines = c2.lines;
        var end = c2.end;
        c2.end = clonePos(pos);
        var rowsBefore = c2.end.row - c2.start.row;
        var otherLines = lines.splice(rowsBefore, lines.length);
        var col = rowsBefore ? pos.column : pos.column - c2.start.column;
        lines.push(otherLines[0].substring(0, col));
        otherLines[0] = otherLines[0].substr(col);
        var rest = {
          start: clonePos(pos),
          end,
          lines: otherLines,
          action: c2.action
        };
        return rest;
      }
      function moveDeltasByOne(redoStack, d3) {
        d3 = cloneDelta(d3);
        for (var j = redoStack.length; j--; ) {
          var deltaSet = redoStack[j];
          for (var i2 = 0; i2 < deltaSet.length; i2++) {
            var x2 = deltaSet[i2];
            var xformed = xform(x2, d3);
            d3 = xformed[0];
            if (xformed.length != 2) {
              if (xformed[2]) {
                deltaSet.splice(i2 + 1, 1, xformed[1], xformed[2]);
                i2++;
              } else if (!xformed[1]) {
                deltaSet.splice(i2, 1);
                i2--;
              }
            }
          }
          if (!deltaSet.length) {
            redoStack.splice(j, 1);
          }
        }
        return redoStack;
      }
      function rebaseRedoStack(redoStack, deltaSets) {
        for (var i2 = 0; i2 < deltaSets.length; i2++) {
          var deltas = deltaSets[i2];
          for (var j = 0; j < deltas.length; j++) {
            moveDeltasByOne(redoStack, deltas[j]);
          }
        }
      }
      exports3.UndoManager = UndoManager;
    });
    ace.define("ace/layer/lines", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports3, module3) {
      var dom = require2("../lib/dom");
      var Lines = (
        /** @class */
        function() {
          function Lines2(element, canvasHeight) {
            this.element = element;
            this.canvasHeight = canvasHeight || 5e5;
            this.element.style.height = this.canvasHeight * 2 + "px";
            this.cells = [];
            this.cellCache = [];
            this.$offsetCoefficient = 0;
          }
          Lines2.prototype.moveContainer = function(config) {
            dom.translate(this.element, 0, -(config.firstRowScreen * config.lineHeight % this.canvasHeight) - config.offset * this.$offsetCoefficient);
          };
          Lines2.prototype.pageChanged = function(oldConfig, newConfig) {
            return Math.floor(oldConfig.firstRowScreen * oldConfig.lineHeight / this.canvasHeight) !== Math.floor(newConfig.firstRowScreen * newConfig.lineHeight / this.canvasHeight);
          };
          Lines2.prototype.computeLineTop = function(row, config, session) {
            var screenTop = config.firstRowScreen * config.lineHeight;
            var screenPage = Math.floor(screenTop / this.canvasHeight);
            var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
            return lineTop - screenPage * this.canvasHeight;
          };
          Lines2.prototype.computeLineHeight = function(row, config, session) {
            return config.lineHeight * session.getRowLineCount(row);
          };
          Lines2.prototype.getLength = function() {
            return this.cells.length;
          };
          Lines2.prototype.get = function(index) {
            return this.cells[index];
          };
          Lines2.prototype.shift = function() {
            this.$cacheCell(this.cells.shift());
          };
          Lines2.prototype.pop = function() {
            this.$cacheCell(this.cells.pop());
          };
          Lines2.prototype.push = function(cell) {
            if (Array.isArray(cell)) {
              this.cells.push.apply(this.cells, cell);
              var fragment = dom.createFragment(this.element);
              for (var i2 = 0; i2 < cell.length; i2++) {
                fragment.appendChild(cell[i2].element);
              }
              this.element.appendChild(fragment);
            } else {
              this.cells.push(cell);
              this.element.appendChild(cell.element);
            }
          };
          Lines2.prototype.unshift = function(cell) {
            if (Array.isArray(cell)) {
              this.cells.unshift.apply(this.cells, cell);
              var fragment = dom.createFragment(this.element);
              for (var i2 = 0; i2 < cell.length; i2++) {
                fragment.appendChild(cell[i2].element);
              }
              if (this.element.firstChild)
                this.element.insertBefore(fragment, this.element.firstChild);
              else
                this.element.appendChild(fragment);
            } else {
              this.cells.unshift(cell);
              this.element.insertAdjacentElement("afterbegin", cell.element);
            }
          };
          Lines2.prototype.last = function() {
            if (this.cells.length)
              return this.cells[this.cells.length - 1];
            else
              return null;
          };
          Lines2.prototype.$cacheCell = function(cell) {
            if (!cell)
              return;
            cell.element.remove();
            this.cellCache.push(cell);
          };
          Lines2.prototype.createCell = function(row, config, session, initElement) {
            var cell = this.cellCache.pop();
            if (!cell) {
              var element = dom.createElement("div");
              if (initElement)
                initElement(element);
              this.element.appendChild(element);
              cell = {
                element,
                text: "",
                row
              };
            }
            cell.row = row;
            return cell;
          };
          return Lines2;
        }()
      );
      exports3.Lines = Lines;
    });
    ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/layer/lines"], function(require2, exports3, module3) {
      var dom = require2("../lib/dom");
      var oop = require2("../lib/oop");
      var lang = require2("../lib/lang");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var Lines = require2("./lines").Lines;
      var Gutter = (
        /** @class */
        function() {
          function Gutter2(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_gutter-layer";
            parentEl.appendChild(this.element);
            this.setShowFoldWidgets(this.$showFoldWidgets);
            this.gutterWidth = 0;
            this.$annotations = [];
            this.$updateAnnotations = this.$updateAnnotations.bind(this);
            this.$lines = new Lines(this.element);
            this.$lines.$offsetCoefficient = 1;
          }
          Gutter2.prototype.setSession = function(session) {
            if (this.session)
              this.session.off("change", this.$updateAnnotations);
            this.session = session;
            if (session)
              session.on("change", this.$updateAnnotations);
          };
          Gutter2.prototype.addGutterDecoration = function(row, className) {
            if (window.console)
              console.warn && console.warn("deprecated use session.addGutterDecoration");
            this.session.addGutterDecoration(row, className);
          };
          Gutter2.prototype.removeGutterDecoration = function(row, className) {
            if (window.console)
              console.warn && console.warn("deprecated use session.removeGutterDecoration");
            this.session.removeGutterDecoration(row, className);
          };
          Gutter2.prototype.setAnnotations = function(annotations) {
            this.$annotations = [];
            for (var i2 = 0; i2 < annotations.length; i2++) {
              var annotation = annotations[i2];
              var row = annotation.row;
              var rowInfo = this.$annotations[row];
              if (!rowInfo)
                rowInfo = this.$annotations[row] = { text: [], type: [] };
              var annoText = annotation.text;
              var annoType = annotation.type;
              annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
              if (rowInfo.text.indexOf(annoText) === -1) {
                rowInfo.text.push(annoText);
                rowInfo.type.push(annoType);
              }
              var className = annotation.className;
              if (className)
                rowInfo.className = className;
              else if (annoType == "error")
                rowInfo.className = " ace_error";
              else if (annoType == "warning" && rowInfo.className != " ace_error")
                rowInfo.className = " ace_warning";
              else if (annoType == "info" && !rowInfo.className)
                rowInfo.className = " ace_info";
            }
          };
          Gutter2.prototype.$updateAnnotations = function(delta) {
            if (!this.$annotations.length)
              return;
            var firstRow = delta.start.row;
            var len = delta.end.row - firstRow;
            if (len === 0) ;
            else if (delta.action == "remove") {
              this.$annotations.splice(firstRow, len + 1, null);
            } else {
              var args = new Array(len + 1);
              args.unshift(firstRow, 1);
              this.$annotations.splice.apply(this.$annotations, args);
            }
          };
          Gutter2.prototype.update = function(config) {
            this.config = config;
            var session = this.session;
            var firstRow = config.firstRow;
            var lastRow = Math.min(
              config.lastRow + config.gutterOffset,
              // needed to compensate for hor scollbar
              session.getLength() - 1
            );
            this.oldLastRow = lastRow;
            this.config = config;
            this.$lines.moveContainer(config);
            this.$updateCursorRow();
            var fold = session.getNextFoldLine(firstRow);
            var foldStart = fold ? fold.start.row : Infinity;
            var cell = null;
            var index = -1;
            var row = firstRow;
            while (true) {
              if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
              }
              if (row > lastRow) {
                while (this.$lines.getLength() > index + 1)
                  this.$lines.pop();
                break;
              }
              cell = this.$lines.get(++index);
              if (cell) {
                cell.row = row;
              } else {
                cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                this.$lines.push(cell);
              }
              this.$renderCell(cell, config, fold, row);
              row++;
            }
            this._signal("afterRender");
            this.$updateGutterWidth(config);
          };
          Gutter2.prototype.$updateGutterWidth = function(config) {
            var session = this.session;
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            var firstLineNumber = session.$firstLineNumber;
            var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
            if (this.$fixedWidth || session.$useWrapMode)
              lastLineText = session.getLength() + firstLineNumber - 1;
            var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineText, config) : lastLineText.toString().length * config.characterWidth;
            var padding = this.$padding || this.$computePadding();
            gutterWidth += padding.left + padding.right;
            if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
              this.gutterWidth = gutterWidth;
              this.element.parentNode.style.width = this.element.style.width = Math.ceil(this.gutterWidth) + "px";
              this._signal("changeGutterWidth", gutterWidth);
            }
          };
          Gutter2.prototype.$updateCursorRow = function() {
            if (!this.$highlightGutterLine)
              return;
            var position = this.session.selection.getCursor();
            if (this.$cursorRow === position.row)
              return;
            this.$cursorRow = position.row;
          };
          Gutter2.prototype.updateLineHighlight = function() {
            if (!this.$highlightGutterLine)
              return;
            var row = this.session.selection.cursor.row;
            this.$cursorRow = row;
            if (this.$cursorCell && this.$cursorCell.row == row)
              return;
            if (this.$cursorCell)
              this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
            var cells = this.$lines.cells;
            this.$cursorCell = null;
            for (var i2 = 0; i2 < cells.length; i2++) {
              var cell = cells[i2];
              if (cell.row >= this.$cursorRow) {
                if (cell.row > this.$cursorRow) {
                  var fold = this.session.getFoldLine(this.$cursorRow);
                  if (i2 > 0 && fold && fold.start.row == cells[i2 - 1].row)
                    cell = cells[i2 - 1];
                  else
                    break;
                }
                cell.element.className = "ace_gutter-active-line " + cell.element.className;
                this.$cursorCell = cell;
                break;
              }
            }
          };
          Gutter2.prototype.scrollLines = function(config) {
            var oldConfig = this.config;
            this.config = config;
            this.$updateCursorRow();
            if (this.$lines.pageChanged(oldConfig, config))
              return this.update(config);
            this.$lines.moveContainer(config);
            var lastRow = Math.min(
              config.lastRow + config.gutterOffset,
              // needed to compensate for hor scollbar
              this.session.getLength() - 1
            );
            var oldLastRow = this.oldLastRow;
            this.oldLastRow = lastRow;
            if (!oldConfig || oldLastRow < config.firstRow)
              return this.update(config);
            if (lastRow < oldConfig.firstRow)
              return this.update(config);
            if (oldConfig.firstRow < config.firstRow)
              for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
                this.$lines.shift();
            if (oldLastRow > lastRow)
              for (var row = this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row > 0; row--)
                this.$lines.pop();
            if (config.firstRow < oldConfig.firstRow) {
              this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
            }
            if (lastRow > oldLastRow) {
              this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
            }
            this.updateLineHighlight();
            this._signal("afterRender");
            this.$updateGutterWidth(config);
          };
          Gutter2.prototype.$renderLines = function(config, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > lastRow)
                break;
              var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
              this.$renderCell(cell, config, foldLine, row);
              fragment.push(cell);
              row++;
            }
            return fragment;
          };
          Gutter2.prototype.$renderCell = function(cell, config, fold, row) {
            var element = cell.element;
            var session = this.session;
            var textNode = element.childNodes[0];
            var foldWidget = element.childNodes[1];
            var annotationNode = element.childNodes[2];
            var firstLineNumber = session.$firstLineNumber;
            var breakpoints = session.$breakpoints;
            var decorations = session.$decorations;
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
            var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
            var lineHeight = config.lineHeight + "px";
            var className = this.$useSvgGutterIcons ? "ace_gutter-cell_svg-icons " : "ace_gutter-cell ";
            var iconClassName = this.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
            if (this.$highlightGutterLine) {
              if (row == this.$cursorRow || fold && row < this.$cursorRow && row >= foldStart && this.$cursorRow <= fold.end.row) {
                className += "ace_gutter-active-line ";
                if (this.$cursorCell != cell) {
                  if (this.$cursorCell)
                    this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
                  this.$cursorCell = cell;
                }
              }
            }
            if (breakpoints[row])
              className += breakpoints[row];
            if (decorations[row])
              className += decorations[row];
            if (this.$annotations[row] && row !== foldStart)
              className += this.$annotations[row].className;
            if (element.className != className)
              element.className = className;
            if (foldWidgets) {
              var c2 = foldWidgets[row];
              if (c2 == null)
                c2 = foldWidgets[row] = session.getFoldWidget(row);
            }
            if (c2) {
              var className = "ace_fold-widget ace_" + c2;
              if (c2 == "start" && row == foldStart && row < fold.end.row) {
                className += " ace_closed";
                var foldAnnotationClass;
                var annotationInFold = false;
                for (var i2 = row + 1; i2 <= fold.end.row; i2++) {
                  if (!this.$annotations[i2])
                    continue;
                  if (this.$annotations[i2].className === " ace_error") {
                    annotationInFold = true;
                    foldAnnotationClass = " ace_error_fold";
                    break;
                  }
                  if (this.$annotations[i2].className === " ace_warning") {
                    annotationInFold = true;
                    foldAnnotationClass = " ace_warning_fold";
                    continue;
                  }
                }
                element.className += foldAnnotationClass;
              } else
                className += " ace_open";
              if (foldWidget.className != className)
                foldWidget.className = className;
              dom.setStyle(foldWidget.style, "height", lineHeight);
              dom.setStyle(foldWidget.style, "display", "inline-block");
            } else {
              if (foldWidget) {
                dom.setStyle(foldWidget.style, "display", "none");
              }
            }
            if (annotationInFold && this.$showFoldedAnnotations) {
              annotationNode.className = iconClassName;
              annotationNode.className += foldAnnotationClass;
              dom.setStyle(annotationNode.style, "height", lineHeight);
              dom.setStyle(annotationNode.style, "display", "block");
            } else if (this.$annotations[row]) {
              annotationNode.className = iconClassName;
              if (this.$useSvgGutterIcons)
                annotationNode.className += this.$annotations[row].className;
              else
                element.classList.add(this.$annotations[row].className.replace(" ", ""));
              dom.setStyle(annotationNode.style, "height", lineHeight);
              dom.setStyle(annotationNode.style, "display", "block");
            } else {
              dom.setStyle(annotationNode.style, "display", "none");
            }
            var text = (gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber).toString();
            if (text !== textNode.data) {
              textNode.data = text;
            }
            dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config, session) + "px");
            dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config, session) + "px");
            cell.text = text;
            return cell;
          };
          Gutter2.prototype.setHighlightGutterLine = function(highlightGutterLine) {
            this.$highlightGutterLine = highlightGutterLine;
          };
          Gutter2.prototype.setShowLineNumbers = function(show) {
            this.$renderer = !show && {
              getWidth: function() {
                return 0;
              },
              getText: function() {
                return "";
              }
            };
          };
          Gutter2.prototype.getShowLineNumbers = function() {
            return this.$showLineNumbers;
          };
          Gutter2.prototype.setShowFoldWidgets = function(show) {
            if (show)
              dom.addCssClass(this.element, "ace_folding-enabled");
            else
              dom.removeCssClass(this.element, "ace_folding-enabled");
            this.$showFoldWidgets = show;
            this.$padding = null;
          };
          Gutter2.prototype.getShowFoldWidgets = function() {
            return this.$showFoldWidgets;
          };
          Gutter2.prototype.$computePadding = function() {
            if (!this.element.firstChild)
              return { left: 0, right: 0 };
            var style = dom.computedStyle(this.element.firstChild);
            this.$padding = {};
            this.$padding.left = (parseInt(style.borderLeftWidth) || 0) + (parseInt(style.paddingLeft) || 0) + 1;
            this.$padding.right = (parseInt(style.borderRightWidth) || 0) + (parseInt(style.paddingRight) || 0);
            return this.$padding;
          };
          Gutter2.prototype.getRegion = function(point) {
            var padding = this.$padding || this.$computePadding();
            var rect = this.element.getBoundingClientRect();
            if (point.x < padding.left + rect.left)
              return "markers";
            if (this.$showFoldWidgets && point.x > rect.right - padding.right)
              return "foldWidgets";
          };
          return Gutter2;
        }()
      );
      Gutter.prototype.$fixedWidth = false;
      Gutter.prototype.$highlightGutterLine = true;
      Gutter.prototype.$renderer = "";
      Gutter.prototype.$showLineNumbers = true;
      Gutter.prototype.$showFoldWidgets = true;
      oop.implement(Gutter.prototype, EventEmitter);
      function onCreateCell(element) {
        var textNode = document.createTextNode("");
        element.appendChild(textNode);
        var foldWidget = dom.createElement("span");
        element.appendChild(foldWidget);
        var annotationNode = dom.createElement("span");
        element.appendChild(annotationNode);
        return element;
      }
      exports3.Gutter = Gutter;
    });
    ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function(require2, exports3, module3) {
      var Range = require2("../range").Range;
      var dom = require2("../lib/dom");
      var Marker = (
        /** @class */
        function() {
          function Marker2(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_marker-layer";
            parentEl.appendChild(this.element);
          }
          Marker2.prototype.setPadding = function(padding) {
            this.$padding = padding;
          };
          Marker2.prototype.setSession = function(session) {
            this.session = session;
          };
          Marker2.prototype.setMarkers = function(markers) {
            this.markers = markers;
          };
          Marker2.prototype.elt = function(className, css2) {
            var x2 = this.i != -1 && this.element.childNodes[this.i];
            if (!x2) {
              x2 = document.createElement("div");
              this.element.appendChild(x2);
              this.i = -1;
            } else {
              this.i++;
            }
            x2.style.cssText = css2;
            x2.className = className;
          };
          Marker2.prototype.update = function(config) {
            if (!config)
              return;
            this.config = config;
            this.i = 0;
            var html3;
            for (var key in this.markers) {
              var marker = this.markers[key];
              if (!marker.range) {
                marker.update(html3, this, this.session, config);
                continue;
              }
              var range = marker.range.clipRows(config.firstRow, config.lastRow);
              if (range.isEmpty())
                continue;
              range = range.toScreenRange(this.session);
              if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = this.$padding + range.start.column * config.characterWidth;
                marker.renderer(html3, range, left, top, config);
              } else if (marker.type == "fullLine") {
                this.drawFullLineMarker(html3, range, marker.clazz, config);
              } else if (marker.type == "screenLine") {
                this.drawScreenLineMarker(html3, range, marker.clazz, config);
              } else if (range.isMultiLine()) {
                if (marker.type == "text")
                  this.drawTextMarker(html3, range, marker.clazz, config);
                else
                  this.drawMultiLineMarker(html3, range, marker.clazz, config);
              } else {
                this.drawSingleLineMarker(html3, range, marker.clazz + " ace_start ace_br15", config);
              }
            }
            if (this.i != -1) {
              while (this.i < this.element.childElementCount)
                this.element.removeChild(this.element.lastChild);
            }
          };
          Marker2.prototype.$getTop = function(row, layerConfig) {
            return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
          };
          Marker2.prototype.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
            var session = this.session;
            var start = range.start.row;
            var end = range.end.row;
            var row = start;
            var prev = 0;
            var curr = 0;
            var next = session.getScreenLastRowColumn(row);
            var lineRange = new Range(row, range.start.column, row, curr);
            for (; row <= end; row++) {
              lineRange.start.row = lineRange.end.row = row;
              lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
              lineRange.end.column = next;
              prev = curr;
              curr = next;
              next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
              this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? " ace_start" : "") + " ace_br" + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
            }
          };
          Marker2.prototype.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var padding = this.$padding;
            var height = config.lineHeight;
            var top = this.$getTop(range.start.row, config);
            var left = padding + range.start.column * config.characterWidth;
            extraStyle = extraStyle || "";
            if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
              var range1 = range.clone();
              range1.end.row = range1.start.row;
              range1.end.column = this.session.getLine(range1.start.row).length;
              this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
            } else {
              this.elt(clazz + " ace_br1 ace_start", "height:" + height + "px;right:0;top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
            }
            if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
              var range1 = range.clone();
              range1.start.row = range1.end.row;
              range1.start.column = 0;
              this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
            } else {
              top = this.$getTop(range.end.row, config);
              var width = range.end.column * config.characterWidth;
              this.elt(clazz + " ace_br12", "height:" + height + "px;width:" + width + "px;top:" + top + "px;left:" + padding + "px;" + (extraStyle || ""));
            }
            height = (range.end.row - range.start.row - 1) * config.lineHeight;
            if (height <= 0)
              return;
            top = this.$getTop(range.start.row + 1, config);
            var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
            this.elt(clazz + (radiusClass ? " ace_br" + radiusClass : ""), "height:" + height + "px;right:0;top:" + top + "px;left:" + padding + "px;" + (extraStyle || ""));
          };
          Marker2.prototype.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            if (this.session.$bidiHandler.isBidiRow(range.start.row))
              return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
            var height = config.lineHeight;
            var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
            var top = this.$getTop(range.start.row, config);
            var left = this.$padding + range.start.column * config.characterWidth;
            this.elt(clazz, "height:" + height + "px;width:" + width + "px;top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
          };
          Marker2.prototype.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
            var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);
            selections.forEach(function(selection) {
              this.elt(clazz, "height:" + height + "px;width:" + (selection.width + (extraLength || 0)) + "px;top:" + top + "px;left:" + (padding + selection.left) + "px;" + (extraStyle || ""));
            }, this);
          };
          Marker2.prototype.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;
            if (range.start.row != range.end.row)
              height += this.$getTop(range.end.row, config) - top;
            this.elt(clazz, "height:" + height + "px;top:" + top + "px;left:0;right:0;" + (extraStyle || ""));
          };
          Marker2.prototype.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;
            this.elt(clazz, "height:" + height + "px;top:" + top + "px;left:0;right:0;" + (extraStyle || ""));
          };
          return Marker2;
        }()
      );
      Marker.prototype.$padding = 0;
      function getBorderClass(tl, tr, br, bl) {
        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
      }
      exports3.Marker = Marker;
    });
    ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/layer/lines", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      var oop = require2("../lib/oop");
      var dom = require2("../lib/dom");
      var lang = require2("../lib/lang");
      var Lines = require2("./lines").Lines;
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var Text2 = (
        /** @class */
        function() {
          function Text3(parentEl) {
            this.dom = dom;
            this.element = this.dom.createElement("div");
            this.element.className = "ace_layer ace_text-layer";
            parentEl.appendChild(this.element);
            this.$updateEolChar = this.$updateEolChar.bind(this);
            this.$lines = new Lines(this.element);
          }
          Text3.prototype.$updateEolChar = function() {
            var doc = this.session.doc;
            var unixMode = doc.getNewLineCharacter() == "\n" && doc.getNewLineMode() != "windows";
            var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
            if (this.EOL_CHAR != EOL_CHAR) {
              this.EOL_CHAR = EOL_CHAR;
              return true;
            }
          };
          Text3.prototype.setPadding = function(padding) {
            this.$padding = padding;
            this.element.style.margin = "0 " + padding + "px";
          };
          Text3.prototype.getLineHeight = function() {
            return this.$fontMetrics.$characterSize.height || 0;
          };
          Text3.prototype.getCharacterWidth = function() {
            return this.$fontMetrics.$characterSize.width || 0;
          };
          Text3.prototype.$setFontMetrics = function(measure) {
            this.$fontMetrics = measure;
            this.$fontMetrics.on("changeCharacterSize", (function(e2) {
              this._signal("changeCharacterSize", e2);
            }).bind(this));
            this.$pollSizeChanges();
          };
          Text3.prototype.checkForSizeChanges = function() {
            this.$fontMetrics.checkForSizeChanges();
          };
          Text3.prototype.$pollSizeChanges = function() {
            return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
          };
          Text3.prototype.setSession = function(session) {
            this.session = session;
            if (session)
              this.$computeTabString();
          };
          Text3.prototype.setShowInvisibles = function(showInvisibles) {
            if (this.showInvisibles == showInvisibles)
              return false;
            this.showInvisibles = showInvisibles;
            if (typeof showInvisibles == "string") {
              this.showSpaces = /tab/i.test(showInvisibles);
              this.showTabs = /space/i.test(showInvisibles);
              this.showEOL = /eol/i.test(showInvisibles);
            } else {
              this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
            }
            this.$computeTabString();
            return true;
          };
          Text3.prototype.setDisplayIndentGuides = function(display) {
            if (this.displayIndentGuides == display)
              return false;
            this.displayIndentGuides = display;
            this.$computeTabString();
            return true;
          };
          Text3.prototype.setHighlightIndentGuides = function(highlight) {
            if (this.$highlightIndentGuides === highlight)
              return false;
            this.$highlightIndentGuides = highlight;
            return highlight;
          };
          Text3.prototype.$computeTabString = function() {
            var tabSize = this.session.getTabSize();
            this.tabSize = tabSize;
            var tabStr = this.$tabStrings = [0];
            for (var i2 = 1; i2 < tabSize + 1; i2++) {
              if (this.showTabs) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_tab";
                span.textContent = lang.stringRepeat(this.TAB_CHAR, i2);
                tabStr.push(span);
              } else {
                tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i2), this.element));
              }
            }
            if (this.displayIndentGuides) {
              this.$indentGuideRe = /\s\S| \t|\t |\s$/;
              var className = "ace_indent-guide";
              var spaceClass = this.showSpaces ? " ace_invisible ace_invisible_space" : "";
              var spaceContent = this.showSpaces ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize) : lang.stringRepeat(" ", this.tabSize);
              var tabClass = this.showTabs ? " ace_invisible ace_invisible_tab" : "";
              var tabContent = this.showTabs ? lang.stringRepeat(this.TAB_CHAR, this.tabSize) : spaceContent;
              var span = this.dom.createElement("span");
              span.className = className + spaceClass;
              span.textContent = spaceContent;
              this.$tabStrings[" "] = span;
              var span = this.dom.createElement("span");
              span.className = className + tabClass;
              span.textContent = tabContent;
              this.$tabStrings["	"] = span;
            }
          };
          Text3.prototype.updateLines = function(config, firstRow, lastRow) {
            if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
              return this.update(config);
            }
            this.config = config;
            var first = Math.max(firstRow, config.firstRow);
            var last = Math.min(lastRow, config.lastRow);
            var lineElements = this.element.childNodes;
            var lineElementsIdx = 0;
            for (var row = config.firstRow; row < first; row++) {
              var foldLine = this.session.getFoldLine(row);
              if (foldLine) {
                if (foldLine.containsRow(first)) {
                  first = foldLine.start.row;
                  break;
                } else {
                  row = foldLine.end.row;
                }
              }
              lineElementsIdx++;
            }
            var heightChanged = false;
            var row = first;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > last)
                break;
              var lineElement = lineElements[lineElementsIdx++];
              if (lineElement) {
                this.dom.removeChildren(lineElement);
                this.$renderLine(lineElement, row, row == foldStart ? foldLine : false);
                if (heightChanged)
                  lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + "px";
                var height = config.lineHeight * this.session.getRowLength(row) + "px";
                if (lineElement.style.height != height) {
                  heightChanged = true;
                  lineElement.style.height = height;
                }
              }
              row++;
            }
            if (heightChanged) {
              while (lineElementsIdx < this.$lines.cells.length) {
                var cell = this.$lines.cells[lineElementsIdx++];
                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + "px";
              }
            }
          };
          Text3.prototype.scrollLines = function(config) {
            var oldConfig = this.config;
            this.config = config;
            if (this.$lines.pageChanged(oldConfig, config))
              return this.update(config);
            this.$lines.moveContainer(config);
            var lastRow = config.lastRow;
            var oldLastRow = oldConfig ? oldConfig.lastRow : -1;
            if (!oldConfig || oldLastRow < config.firstRow)
              return this.update(config);
            if (lastRow < oldConfig.firstRow)
              return this.update(config);
            if (!oldConfig || oldConfig.lastRow < config.firstRow)
              return this.update(config);
            if (config.lastRow < oldConfig.firstRow)
              return this.update(config);
            if (oldConfig.firstRow < config.firstRow)
              for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
                this.$lines.shift();
            if (oldConfig.lastRow > config.lastRow)
              for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)
                this.$lines.pop();
            if (config.firstRow < oldConfig.firstRow) {
              this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
            }
            if (config.lastRow > oldConfig.lastRow) {
              this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
            }
            this.$highlightIndentGuide();
          };
          Text3.prototype.$renderLinesFragment = function(config, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > lastRow)
                break;
              var line = this.$lines.createCell(row, config, this.session);
              var lineEl = line.element;
              this.dom.removeChildren(lineEl);
              dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config, this.session) + "px");
              dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config, this.session) + "px");
              this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);
              if (this.$useLineGroups()) {
                lineEl.className = "ace_line_group";
              } else {
                lineEl.className = "ace_line";
              }
              fragment.push(line);
              row++;
            }
            return fragment;
          };
          Text3.prototype.update = function(config) {
            this.$lines.moveContainer(config);
            this.config = config;
            var firstRow = config.firstRow;
            var lastRow = config.lastRow;
            var lines = this.$lines;
            while (lines.getLength())
              lines.pop();
            lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
          };
          Text3.prototype.$renderToken = function(parent, screenColumn, token, value) {
            var self2 = this;
            var re2 = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;
            var valueFragment = this.dom.createFragment(this.element);
            var m3;
            var i2 = 0;
            while (m3 = re2.exec(value)) {
              var tab = m3[1];
              var simpleSpace = m3[2];
              var controlCharacter = m3[3];
              var cjkSpace = m3[4];
              var cjk = m3[5];
              if (!self2.showSpaces && simpleSpace)
                continue;
              var before = i2 != m3.index ? value.slice(i2, m3.index) : "";
              i2 = m3.index + m3[0].length;
              if (before) {
                valueFragment.appendChild(this.dom.createTextNode(before, this.element));
              }
              if (tab) {
                var tabSize = self2.session.getScreenTabSize(screenColumn + m3.index);
                valueFragment.appendChild(self2.$tabStrings[tabSize].cloneNode(true));
                screenColumn += tabSize - 1;
              } else if (simpleSpace) {
                if (self2.showSpaces) {
                  var span = this.dom.createElement("span");
                  span.className = "ace_invisible ace_invisible_space";
                  span.textContent = lang.stringRepeat(self2.SPACE_CHAR, simpleSpace.length);
                  valueFragment.appendChild(span);
                } else {
                  valueFragment.appendChild(this.com.createTextNode(simpleSpace, this.element));
                }
              } else if (controlCharacter) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_space ace_invalid";
                span.textContent = lang.stringRepeat(self2.SPACE_CHAR, controlCharacter.length);
                valueFragment.appendChild(span);
              } else if (cjkSpace) {
                screenColumn += 1;
                var span = this.dom.createElement("span");
                span.style.width = self2.config.characterWidth * 2 + "px";
                span.className = self2.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                span.textContent = self2.showSpaces ? self2.SPACE_CHAR : cjkSpace;
                valueFragment.appendChild(span);
              } else if (cjk) {
                screenColumn += 1;
                var span = this.dom.createElement("span");
                span.style.width = self2.config.characterWidth * 2 + "px";
                span.className = "ace_cjk";
                span.textContent = cjk;
                valueFragment.appendChild(span);
              }
            }
            valueFragment.appendChild(this.dom.createTextNode(i2 ? value.slice(i2) : value, this.element));
            if (!this.$textToken[token.type]) {
              var classes = "ace_" + token.type.replace(/\./g, " ace_");
              var span = this.dom.createElement("span");
              if (token.type == "fold")
                span.style.width = token.value.length * this.config.characterWidth + "px";
              span.className = classes;
              span.appendChild(valueFragment);
              parent.appendChild(span);
            } else {
              parent.appendChild(valueFragment);
            }
            return screenColumn + value.length;
          };
          Text3.prototype.renderIndentGuide = function(parent, value, max) {
            var cols = value.search(this.$indentGuideRe);
            if (cols <= 0 || cols >= max)
              return value;
            if (value[0] == " ") {
              cols -= cols % this.tabSize;
              var count = cols / this.tabSize;
              for (var i2 = 0; i2 < count; i2++) {
                parent.appendChild(this.$tabStrings[" "].cloneNode(true));
              }
              this.$highlightIndentGuide();
              return value.substr(cols);
            } else if (value[0] == "	") {
              for (var i2 = 0; i2 < cols; i2++) {
                parent.appendChild(this.$tabStrings["	"].cloneNode(true));
              }
              this.$highlightIndentGuide();
              return value.substr(cols);
            }
            this.$highlightIndentGuide();
            return value;
          };
          Text3.prototype.$highlightIndentGuide = function() {
            if (!this.$highlightIndentGuides || !this.displayIndentGuides)
              return;
            this.$highlightIndentGuideMarker = {
              indentLevel: void 0,
              start: void 0,
              end: void 0,
              dir: void 0
            };
            var lines = this.session.doc.$lines;
            if (!lines)
              return;
            var cursor = this.session.selection.getCursor();
            var initialIndent = /^\s*/.exec(this.session.doc.getLine(cursor.row))[0].length;
            var elementIndentLevel = Math.floor(initialIndent / this.tabSize);
            this.$highlightIndentGuideMarker = {
              indentLevel: elementIndentLevel,
              start: cursor.row
            };
            var bracketHighlight = this.session.$bracketHighlight;
            if (bracketHighlight) {
              var ranges = this.session.$bracketHighlight.ranges;
              for (var i2 = 0; i2 < ranges.length; i2++) {
                if (cursor.row !== ranges[i2].start.row) {
                  this.$highlightIndentGuideMarker.end = ranges[i2].start.row;
                  if (cursor.row > ranges[i2].start.row) {
                    this.$highlightIndentGuideMarker.dir = -1;
                  } else {
                    this.$highlightIndentGuideMarker.dir = 1;
                  }
                  break;
                }
              }
            }
            if (!this.$highlightIndentGuideMarker.end) {
              if (lines[cursor.row] !== "" && cursor.column === lines[cursor.row].length) {
                this.$highlightIndentGuideMarker.dir = 1;
                for (var i2 = cursor.row + 1; i2 < lines.length; i2++) {
                  var line = lines[i2];
                  var currentIndent = /^\s*/.exec(line)[0].length;
                  if (line !== "") {
                    this.$highlightIndentGuideMarker.end = i2;
                    if (currentIndent <= initialIndent)
                      break;
                  }
                }
              }
            }
            this.$renderHighlightIndentGuide();
          };
          Text3.prototype.$clearActiveIndentGuide = function() {
            var cells = this.$lines.cells;
            for (var i2 = 0; i2 < cells.length; i2++) {
              var cell = cells[i2];
              var childNodes = cell.element.childNodes;
              if (childNodes.length > 0) {
                for (var j = 0; j < childNodes.length; j++) {
                  if (childNodes[j].classList && childNodes[j].classList.contains("ace_indent-guide-active")) {
                    childNodes[j].classList.remove("ace_indent-guide-active");
                    break;
                  }
                }
              }
            }
          };
          Text3.prototype.$setIndentGuideActive = function(cell, indentLevel) {
            var line = this.session.doc.getLine(cell.row);
            if (line !== "") {
              var childNodes = cell.element.childNodes;
              if (childNodes) {
                var node = childNodes[indentLevel - 1];
                if (node && node.classList && node.classList.contains("ace_indent-guide"))
                  node.classList.add("ace_indent-guide-active");
              }
            }
          };
          Text3.prototype.$renderHighlightIndentGuide = function() {
            if (!this.$lines)
              return;
            var cells = this.$lines.cells;
            this.$clearActiveIndentGuide();
            var indentLevel = this.$highlightIndentGuideMarker.indentLevel;
            if (indentLevel !== 0) {
              if (this.$highlightIndentGuideMarker.dir === 1) {
                for (var i2 = 0; i2 < cells.length; i2++) {
                  var cell = cells[i2];
                  if (this.$highlightIndentGuideMarker.end && cell.row >= this.$highlightIndentGuideMarker.start + 1) {
                    if (cell.row >= this.$highlightIndentGuideMarker.end)
                      break;
                    this.$setIndentGuideActive(cell, indentLevel);
                  }
                }
              } else {
                for (var i2 = cells.length - 1; i2 >= 0; i2--) {
                  var cell = cells[i2];
                  if (this.$highlightIndentGuideMarker.end && cell.row < this.$highlightIndentGuideMarker.start) {
                    if (cell.row <= this.$highlightIndentGuideMarker.end)
                      break;
                    this.$setIndentGuideActive(cell, indentLevel);
                  }
                }
              }
            }
          };
          Text3.prototype.$createLineElement = function(parent) {
            var lineEl = this.dom.createElement("div");
            lineEl.className = "ace_line";
            lineEl.style.height = this.config.lineHeight + "px";
            return lineEl;
          };
          Text3.prototype.$renderWrappedLine = function(parent, tokens, splits) {
            var chars = 0;
            var split2 = 0;
            var splitChars = splits[0];
            var screenColumn = 0;
            var lineEl = this.$createLineElement();
            parent.appendChild(lineEl);
            for (var i2 = 0; i2 < tokens.length; i2++) {
              var token = tokens[i2];
              var value = token.value;
              if (i2 == 0 && this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(lineEl, value, splitChars);
                if (!value)
                  continue;
                chars -= value.length;
              }
              if (chars + value.length < splitChars) {
                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                chars += value.length;
              } else {
                while (chars + value.length >= splitChars) {
                  screenColumn = this.$renderToken(lineEl, screenColumn, token, value.substring(0, splitChars - chars));
                  value = value.substring(splitChars - chars);
                  chars = splitChars;
                  lineEl = this.$createLineElement();
                  parent.appendChild(lineEl);
                  lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat(" ", splits.indent), this.element));
                  split2++;
                  screenColumn = 0;
                  splitChars = splits[split2] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                  chars += value.length;
                  screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                }
              }
            }
            if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)
              this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
          };
          Text3.prototype.$renderSimpleLine = function(parent, tokens) {
            var screenColumn = 0;
            for (var i2 = 0; i2 < tokens.length; i2++) {
              var token = tokens[i2];
              var value = token.value;
              if (i2 == 0 && this.displayIndentGuides) {
                value = this.renderIndentGuide(parent, value);
                if (!value)
                  continue;
              }
              if (screenColumn + value.length > this.MAX_LINE_LENGTH)
                return this.$renderOverflowMessage(parent, screenColumn, token, value);
              screenColumn = this.$renderToken(parent, screenColumn, token, value);
            }
          };
          Text3.prototype.$renderOverflowMessage = function(parent, screenColumn, token, value, hide) {
            token && this.$renderToken(parent, screenColumn, token, value.slice(0, this.MAX_LINE_LENGTH - screenColumn));
            var overflowEl = this.dom.createElement("span");
            overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
            overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";
            parent.appendChild(overflowEl);
          };
          Text3.prototype.$renderLine = function(parent, row, foldLine) {
            if (!foldLine && foldLine != false)
              foldLine = this.session.getFoldLine(row);
            if (foldLine)
              var tokens = this.$getFoldLineTokens(row, foldLine);
            else
              var tokens = this.session.getTokens(row);
            var lastLineEl = parent;
            if (tokens.length) {
              var splits = this.session.getRowSplitData(row);
              if (splits && splits.length) {
                this.$renderWrappedLine(parent, tokens, splits);
                var lastLineEl = parent.lastChild;
              } else {
                var lastLineEl = parent;
                if (this.$useLineGroups()) {
                  lastLineEl = this.$createLineElement();
                  parent.appendChild(lastLineEl);
                }
                this.$renderSimpleLine(lastLineEl, tokens);
              }
            } else if (this.$useLineGroups()) {
              lastLineEl = this.$createLineElement();
              parent.appendChild(lastLineEl);
            }
            if (this.showEOL && lastLineEl) {
              if (foldLine)
                row = foldLine.end.row;
              var invisibleEl = this.dom.createElement("span");
              invisibleEl.className = "ace_invisible ace_invisible_eol";
              invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;
              lastLineEl.appendChild(invisibleEl);
            }
          };
          Text3.prototype.$getFoldLineTokens = function(row, foldLine) {
            var session = this.session;
            var renderTokens = [];
            function addTokens(tokens2, from, to) {
              var idx = 0, col = 0;
              while (col + tokens2[idx].value.length < from) {
                col += tokens2[idx].value.length;
                idx++;
                if (idx == tokens2.length)
                  return;
              }
              if (col != from) {
                var value = tokens2[idx].value.substring(from - col);
                if (value.length > to - from)
                  value = value.substring(0, to - from);
                renderTokens.push({
                  type: tokens2[idx].type,
                  value
                });
                col = from + value.length;
                idx += 1;
              }
              while (col < to && idx < tokens2.length) {
                var value = tokens2[idx].value;
                if (value.length + col > to) {
                  renderTokens.push({
                    type: tokens2[idx].type,
                    value: value.substring(0, to - col)
                  });
                } else
                  renderTokens.push(tokens2[idx]);
                col += value.length;
                idx += 1;
              }
            }
            var tokens = session.getTokens(row);
            foldLine.walk(function(placeholder, row2, column, lastColumn, isNewRow) {
              if (placeholder != null) {
                renderTokens.push({
                  type: "fold",
                  value: placeholder
                });
              } else {
                if (isNewRow)
                  tokens = session.getTokens(row2);
                if (tokens.length)
                  addTokens(tokens, lastColumn, column);
              }
            }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
            return renderTokens;
          };
          Text3.prototype.$useLineGroups = function() {
            return this.session.getUseWrapMode();
          };
          return Text3;
        }()
      );
      Text2.prototype.$textToken = {
        "text": true,
        "rparen": true,
        "lparen": true
      };
      Text2.prototype.EOF_CHAR = "¶";
      Text2.prototype.EOL_CHAR_LF = "¬";
      Text2.prototype.EOL_CHAR_CRLF = "¤";
      Text2.prototype.EOL_CHAR = Text2.prototype.EOL_CHAR_LF;
      Text2.prototype.TAB_CHAR = "—";
      Text2.prototype.SPACE_CHAR = "·";
      Text2.prototype.$padding = 0;
      Text2.prototype.MAX_LINE_LENGTH = 1e4;
      Text2.prototype.showInvisibles = false;
      Text2.prototype.showSpaces = false;
      Text2.prototype.showTabs = false;
      Text2.prototype.showEOL = false;
      Text2.prototype.displayIndentGuides = true;
      Text2.prototype.$highlightIndentGuides = true;
      Text2.prototype.$tabStrings = [];
      Text2.prototype.destroy = {};
      Text2.prototype.onChangeTabSize = Text2.prototype.$computeTabString;
      oop.implement(Text2.prototype, EventEmitter);
      exports3.Text = Text2;
    });
    ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports3, module3) {
      var dom = require2("../lib/dom");
      var Cursor = (
        /** @class */
        function() {
          function Cursor2(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_cursor-layer";
            parentEl.appendChild(this.element);
            this.isVisible = false;
            this.isBlinking = true;
            this.blinkInterval = 1e3;
            this.smoothBlinking = false;
            this.cursors = [];
            this.cursor = this.addCursor();
            dom.addCssClass(this.element, "ace_hidden-cursors");
            this.$updateCursors = this.$updateOpacity.bind(this);
          }
          Cursor2.prototype.$updateOpacity = function(val) {
            var cursors = this.cursors;
            for (var i2 = cursors.length; i2--; )
              dom.setStyle(cursors[i2].style, "opacity", val ? "" : "0");
          };
          Cursor2.prototype.$startCssAnimation = function() {
            var cursors = this.cursors;
            for (var i2 = cursors.length; i2--; )
              cursors[i2].style.animationDuration = this.blinkInterval + "ms";
            this.$isAnimating = true;
            setTimeout((function() {
              if (this.$isAnimating) {
                dom.addCssClass(this.element, "ace_animate-blinking");
              }
            }).bind(this));
          };
          Cursor2.prototype.$stopCssAnimation = function() {
            this.$isAnimating = false;
            dom.removeCssClass(this.element, "ace_animate-blinking");
          };
          Cursor2.prototype.setPadding = function(padding) {
            this.$padding = padding;
          };
          Cursor2.prototype.setSession = function(session) {
            this.session = session;
          };
          Cursor2.prototype.setBlinking = function(blinking) {
            if (blinking != this.isBlinking) {
              this.isBlinking = blinking;
              this.restartTimer();
            }
          };
          Cursor2.prototype.setBlinkInterval = function(blinkInterval) {
            if (blinkInterval != this.blinkInterval) {
              this.blinkInterval = blinkInterval;
              this.restartTimer();
            }
          };
          Cursor2.prototype.setSmoothBlinking = function(smoothBlinking) {
            if (smoothBlinking != this.smoothBlinking) {
              this.smoothBlinking = smoothBlinking;
              dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
              this.$updateCursors(true);
              this.restartTimer();
            }
          };
          Cursor2.prototype.addCursor = function() {
            var el = dom.createElement("div");
            el.className = "ace_cursor";
            this.element.appendChild(el);
            this.cursors.push(el);
            return el;
          };
          Cursor2.prototype.removeCursor = function() {
            if (this.cursors.length > 1) {
              var el = this.cursors.pop();
              el.parentNode.removeChild(el);
              return el;
            }
          };
          Cursor2.prototype.hideCursor = function() {
            this.isVisible = false;
            dom.addCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
          };
          Cursor2.prototype.showCursor = function() {
            this.isVisible = true;
            dom.removeCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
          };
          Cursor2.prototype.restartTimer = function() {
            var update = this.$updateCursors;
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
            this.$stopCssAnimation();
            if (this.smoothBlinking) {
              this.$isSmoothBlinking = false;
              dom.removeCssClass(this.element, "ace_smooth-blinking");
            }
            update(true);
            if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
              this.$stopCssAnimation();
              return;
            }
            if (this.smoothBlinking) {
              this.$isSmoothBlinking = true;
              setTimeout((function() {
                if (this.$isSmoothBlinking) {
                  dom.addCssClass(this.element, "ace_smooth-blinking");
                }
              }).bind(this));
            }
            if (dom.HAS_CSS_ANIMATION) {
              this.$startCssAnimation();
            } else {
              var blink = (function() {
                this.timeoutId = setTimeout(function() {
                  update(false);
                }, 0.6 * this.blinkInterval);
              }).bind(this);
              this.intervalId = setInterval(function() {
                update(true);
                blink();
              }, this.blinkInterval);
              blink();
            }
          };
          Cursor2.prototype.getPixelPosition = function(position, onScreen) {
            if (!this.config || !this.session)
              return { left: 0, top: 0 };
            if (!position)
              position = this.session.selection.getCursor();
            var pos = this.session.documentToScreenPosition(position);
            var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row) ? this.session.$bidiHandler.getPosLeft(pos.column) : pos.column * this.config.characterWidth);
            var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
            return { left: cursorLeft, top: cursorTop };
          };
          Cursor2.prototype.isCursorInView = function(pixelPos, config) {
            return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;
          };
          Cursor2.prototype.update = function(config) {
            this.config = config;
            var selections = this.session.$selectionMarkers;
            var i2 = 0, cursorIndex = 0;
            if (selections === void 0 || selections.length === 0) {
              selections = [{ cursor: null }];
            }
            for (var i2 = 0, n = selections.length; i2 < n; i2++) {
              var pixelPos = this.getPixelPosition(selections[i2].cursor, true);
              if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i2 > 1) {
                continue;
              }
              var element = this.cursors[cursorIndex++] || this.addCursor();
              var style = element.style;
              if (!this.drawCursor) {
                if (!this.isCursorInView(pixelPos, config)) {
                  dom.setStyle(style, "display", "none");
                } else {
                  dom.setStyle(style, "display", "block");
                  dom.translate(element, pixelPos.left, pixelPos.top);
                  dom.setStyle(style, "width", Math.round(config.characterWidth) + "px");
                  dom.setStyle(style, "height", config.lineHeight + "px");
                }
              } else {
                this.drawCursor(element, pixelPos, config, selections[i2], this.session);
              }
            }
            while (this.cursors.length > cursorIndex)
              this.removeCursor();
            var overwrite = this.session.getOverwrite();
            this.$setOverwrite(overwrite);
            this.$pixelPos = pixelPos;
            this.restartTimer();
          };
          Cursor2.prototype.$setOverwrite = function(overwrite) {
            if (overwrite != this.overwrite) {
              this.overwrite = overwrite;
              if (overwrite)
                dom.addCssClass(this.element, "ace_overwrite-cursors");
              else
                dom.removeCssClass(this.element, "ace_overwrite-cursors");
            }
          };
          Cursor2.prototype.destroy = function() {
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
          };
          return Cursor2;
        }()
      );
      Cursor.prototype.$padding = 0;
      Cursor.prototype.drawCursor = null;
      exports3.Cursor = Cursor;
    });
    ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d3, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d4[p] = b3[p];
          };
          return extendStatics(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var event = require2("./lib/event");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var MAX_SCROLL_H = 32768;
      var Scrollbar = (
        /** @class */
        function() {
          function Scrollbar2(parent, classSuffix) {
            this.element = dom.createElement("div");
            this.element.className = "ace_scrollbar ace_scrollbar" + classSuffix;
            this.inner = dom.createElement("div");
            this.inner.className = "ace_scrollbar-inner";
            this.inner.textContent = " ";
            this.element.appendChild(this.inner);
            parent.appendChild(this.element);
            this.setVisible(false);
            this.skipEvent = false;
            event.addListener(this.element, "scroll", this.onScroll.bind(this));
            event.addListener(this.element, "mousedown", event.preventDefault);
          }
          Scrollbar2.prototype.setVisible = function(isVisible) {
            this.element.style.display = isVisible ? "" : "none";
            this.isVisible = isVisible;
            this.coeff = 1;
          };
          return Scrollbar2;
        }()
      );
      oop.implement(Scrollbar.prototype, EventEmitter);
      var VScrollBar = (
        /** @class */
        function(_super) {
          __extends(VScrollBar2, _super);
          function VScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-v") || this;
            _this.scrollTop = 0;
            _this.scrollHeight = 0;
            renderer.$scrollbarWidth = _this.width = dom.scrollbarWidth(parent.ownerDocument);
            _this.inner.style.width = _this.element.style.width = (_this.width || 15) + 5 + "px";
            _this.$minWidth = 0;
            return _this;
          }
          VScrollBar2.prototype.onScroll = function() {
            if (!this.skipEvent) {
              this.scrollTop = this.element.scrollTop;
              if (this.coeff != 1) {
                var h3 = this.element.clientHeight / this.scrollHeight;
                this.scrollTop = this.scrollTop * (1 - h3) / (this.coeff - h3);
              }
              this._emit("scroll", { data: this.scrollTop });
            }
            this.skipEvent = false;
          };
          VScrollBar2.prototype.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
          };
          VScrollBar2.prototype.setHeight = function(height) {
            this.element.style.height = height + "px";
          };
          VScrollBar2.prototype.setScrollHeight = function(height) {
            this.scrollHeight = height;
            if (height > MAX_SCROLL_H) {
              this.coeff = MAX_SCROLL_H / height;
              height = MAX_SCROLL_H;
            } else if (this.coeff != 1) {
              this.coeff = 1;
            }
            this.inner.style.height = height + "px";
          };
          VScrollBar2.prototype.setScrollTop = function(scrollTop) {
            if (this.scrollTop != scrollTop) {
              this.skipEvent = true;
              this.scrollTop = scrollTop;
              this.element.scrollTop = scrollTop * this.coeff;
            }
          };
          return VScrollBar2;
        }(Scrollbar)
      );
      VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
      var HScrollBar = (
        /** @class */
        function(_super) {
          __extends(HScrollBar2, _super);
          function HScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-h") || this;
            _this.scrollLeft = 0;
            _this.height = renderer.$scrollbarWidth;
            _this.inner.style.height = _this.element.style.height = (_this.height || 15) + 5 + "px";
            return _this;
          }
          HScrollBar2.prototype.onScroll = function() {
            if (!this.skipEvent) {
              this.scrollLeft = this.element.scrollLeft;
              this._emit("scroll", { data: this.scrollLeft });
            }
            this.skipEvent = false;
          };
          HScrollBar2.prototype.getHeight = function() {
            return this.isVisible ? this.height : 0;
          };
          HScrollBar2.prototype.setWidth = function(width) {
            this.element.style.width = width + "px";
          };
          HScrollBar2.prototype.setInnerWidth = function(width) {
            this.inner.style.width = width + "px";
          };
          HScrollBar2.prototype.setScrollWidth = function(width) {
            this.inner.style.width = width + "px";
          };
          HScrollBar2.prototype.setScrollLeft = function(scrollLeft) {
            if (this.scrollLeft != scrollLeft) {
              this.skipEvent = true;
              this.scrollLeft = this.element.scrollLeft = scrollLeft;
            }
          };
          return HScrollBar2;
        }(Scrollbar)
      );
      exports3.ScrollBar = VScrollBar;
      exports3.ScrollBarV = VScrollBar;
      exports3.ScrollBarH = HScrollBar;
      exports3.VScrollBar = VScrollBar;
      exports3.HScrollBar = HScrollBar;
    });
    ace.define("ace/scrollbar_custom", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      var __extends = this && this.__extends || /* @__PURE__ */ function() {
        var extendStatics = function(d3, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d4[p] = b3[p];
          };
          return extendStatics(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      }();
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var event = require2("./lib/event");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      dom.importCssString(".ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{\n  position: absolute;\n  background: rgba(128, 128, 128, 0.6);\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border: 1px solid #bbb;\n  border-radius: 2px;\n  z-index: 8;\n}\n.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {\n  position: absolute;\n  z-index: 6;\n  background: none;\n  overflow: hidden!important;\n}\n.ace_editor>.ace_sb-v {\n  z-index: 6;\n  right: 0;\n  top: 0;\n  width: 12px;\n}\n.ace_editor>.ace_sb-v div {\n  z-index: 8;\n  right: 0;\n  width: 100%;\n}\n.ace_editor>.ace_sb-h {\n  bottom: 0;\n  left: 0;\n  height: 12px;\n}\n.ace_editor>.ace_sb-h div {\n  bottom: 0;\n  height: 100%;\n}\n.ace_editor>.ace_sb_grabbed {\n  z-index: 8;\n  background: #000;\n}", "ace_scrollbar.css", false);
      var ScrollBar = (
        /** @class */
        function() {
          function ScrollBar2(parent, classSuffix) {
            this.element = dom.createElement("div");
            this.element.className = "ace_sb" + classSuffix;
            this.inner = dom.createElement("div");
            this.inner.className = "";
            this.element.appendChild(this.inner);
            this.VScrollWidth = 12;
            this.HScrollHeight = 12;
            parent.appendChild(this.element);
            this.setVisible(false);
            this.skipEvent = false;
            event.addMultiMouseDownListener(this.element, [500, 300, 300], this, "onMouseDown");
          }
          ScrollBar2.prototype.setVisible = function(isVisible) {
            this.element.style.display = isVisible ? "" : "none";
            this.isVisible = isVisible;
            this.coeff = 1;
          };
          return ScrollBar2;
        }()
      );
      oop.implement(ScrollBar.prototype, EventEmitter);
      var VScrollBar = (
        /** @class */
        function(_super) {
          __extends(VScrollBar2, _super);
          function VScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-v") || this;
            _this.scrollTop = 0;
            _this.scrollHeight = 0;
            _this.parent = parent;
            _this.width = _this.VScrollWidth;
            _this.renderer = renderer;
            _this.inner.style.width = _this.element.style.width = (_this.width || 15) + "px";
            _this.$minWidth = 0;
            return _this;
          }
          VScrollBar2.prototype.onMouseDown = function(eType, e2) {
            if (eType !== "mousedown")
              return;
            if (event.getButton(e2) !== 0 || e2.detail === 2) {
              return;
            }
            if (e2.target === this.inner) {
              var self2 = this;
              var mousePageY = e2.clientY;
              var onMouseMove = function(e3) {
                mousePageY = e3.clientY;
              };
              var onMouseUp = function() {
                clearInterval(timerId);
              };
              var startY = e2.clientY;
              var startTop = this.thumbTop;
              var onScrollInterval = function() {
                if (mousePageY === void 0)
                  return;
                var scrollTop = self2.scrollTopFromThumbTop(startTop + mousePageY - startY);
                if (scrollTop === self2.scrollTop)
                  return;
                self2._emit("scroll", { data: scrollTop });
              };
              event.capture(this.inner, onMouseMove, onMouseUp);
              var timerId = setInterval(onScrollInterval, 20);
              return event.preventDefault(e2);
            }
            var top = e2.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;
            this._emit("scroll", { data: this.scrollTopFromThumbTop(top) });
            return event.preventDefault(e2);
          };
          VScrollBar2.prototype.getHeight = function() {
            return this.height;
          };
          VScrollBar2.prototype.scrollTopFromThumbTop = function(thumbTop) {
            var scrollTop = thumbTop * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);
            scrollTop = scrollTop >> 0;
            if (scrollTop < 0) {
              scrollTop = 0;
            } else if (scrollTop > this.pageHeight - this.viewHeight) {
              scrollTop = this.pageHeight - this.viewHeight;
            }
            return scrollTop;
          };
          VScrollBar2.prototype.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
          };
          VScrollBar2.prototype.setHeight = function(height) {
            this.height = Math.max(0, height);
            this.slideHeight = this.height;
            this.viewHeight = this.height;
            this.setScrollHeight(this.pageHeight, true);
          };
          VScrollBar2.prototype.setScrollHeight = function(height, force) {
            if (this.pageHeight === height && !force)
              return;
            this.pageHeight = height;
            this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight;
            if (this.thumbHeight > this.slideHeight)
              this.thumbHeight = this.slideHeight;
            if (this.thumbHeight < 15)
              this.thumbHeight = 15;
            this.inner.style.height = this.thumbHeight + "px";
            if (this.scrollTop > this.pageHeight - this.viewHeight) {
              this.scrollTop = this.pageHeight - this.viewHeight;
              if (this.scrollTop < 0)
                this.scrollTop = 0;
              this._emit("scroll", { data: this.scrollTop });
            }
          };
          VScrollBar2.prototype.setScrollTop = function(scrollTop) {
            this.scrollTop = scrollTop;
            if (scrollTop < 0)
              scrollTop = 0;
            this.thumbTop = scrollTop * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight);
            this.inner.style.top = this.thumbTop + "px";
          };
          return VScrollBar2;
        }(ScrollBar)
      );
      VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
      var HScrollBar = (
        /** @class */
        function(_super) {
          __extends(HScrollBar2, _super);
          function HScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-h") || this;
            _this.scrollLeft = 0;
            _this.scrollWidth = 0;
            _this.height = _this.HScrollHeight;
            _this.inner.style.height = _this.element.style.height = (_this.height || 12) + "px";
            _this.renderer = renderer;
            return _this;
          }
          HScrollBar2.prototype.onMouseDown = function(eType, e2) {
            if (eType !== "mousedown")
              return;
            if (event.getButton(e2) !== 0 || e2.detail === 2) {
              return;
            }
            if (e2.target === this.inner) {
              var self2 = this;
              var mousePageX = e2.clientX;
              var onMouseMove = function(e3) {
                mousePageX = e3.clientX;
              };
              var onMouseUp = function() {
                clearInterval(timerId);
              };
              var startX = e2.clientX;
              var startLeft = this.thumbLeft;
              var onScrollInterval = function() {
                if (mousePageX === void 0)
                  return;
                var scrollLeft = self2.scrollLeftFromThumbLeft(startLeft + mousePageX - startX);
                if (scrollLeft === self2.scrollLeft)
                  return;
                self2._emit("scroll", { data: scrollLeft });
              };
              event.capture(this.inner, onMouseMove, onMouseUp);
              var timerId = setInterval(onScrollInterval, 20);
              return event.preventDefault(e2);
            }
            var left = e2.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;
            this._emit("scroll", { data: this.scrollLeftFromThumbLeft(left) });
            return event.preventDefault(e2);
          };
          HScrollBar2.prototype.getHeight = function() {
            return this.isVisible ? this.height : 0;
          };
          HScrollBar2.prototype.scrollLeftFromThumbLeft = function(thumbLeft) {
            var scrollLeft = thumbLeft * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);
            scrollLeft = scrollLeft >> 0;
            if (scrollLeft < 0) {
              scrollLeft = 0;
            } else if (scrollLeft > this.pageWidth - this.viewWidth) {
              scrollLeft = this.pageWidth - this.viewWidth;
            }
            return scrollLeft;
          };
          HScrollBar2.prototype.setWidth = function(width) {
            this.width = Math.max(0, width);
            this.element.style.width = this.width + "px";
            this.slideWidth = this.width;
            this.viewWidth = this.width;
            this.setScrollWidth(this.pageWidth, true);
          };
          HScrollBar2.prototype.setScrollWidth = function(width, force) {
            if (this.pageWidth === width && !force)
              return;
            this.pageWidth = width;
            this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth;
            if (this.thumbWidth > this.slideWidth)
              this.thumbWidth = this.slideWidth;
            if (this.thumbWidth < 15)
              this.thumbWidth = 15;
            this.inner.style.width = this.thumbWidth + "px";
            if (this.scrollLeft > this.pageWidth - this.viewWidth) {
              this.scrollLeft = this.pageWidth - this.viewWidth;
              if (this.scrollLeft < 0)
                this.scrollLeft = 0;
              this._emit("scroll", { data: this.scrollLeft });
            }
          };
          HScrollBar2.prototype.setScrollLeft = function(scrollLeft) {
            this.scrollLeft = scrollLeft;
            if (scrollLeft < 0)
              scrollLeft = 0;
            this.thumbLeft = scrollLeft * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth);
            this.inner.style.left = this.thumbLeft + "px";
          };
          return HScrollBar2;
        }(ScrollBar)
      );
      HScrollBar.prototype.setInnerWidth = HScrollBar.prototype.setScrollWidth;
      exports3.ScrollBar = VScrollBar;
      exports3.ScrollBarV = VScrollBar;
      exports3.ScrollBarH = HScrollBar;
      exports3.VScrollBar = VScrollBar;
      exports3.HScrollBar = HScrollBar;
    });
    ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function(require2, exports3, module3) {
      var event = require2("./lib/event");
      var RenderLoop = (
        /** @class */
        function() {
          function RenderLoop2(onRender, win) {
            this.onRender = onRender;
            this.pending = false;
            this.changes = 0;
            this.$recursionLimit = 2;
            this.window = win || window;
            var _self = this;
            this._flush = function(ts) {
              _self.pending = false;
              var changes = _self.changes;
              if (changes) {
                event.blockIdle(100);
                _self.changes = 0;
                _self.onRender(changes);
              }
              if (_self.changes) {
                if (_self.$recursionLimit-- < 0)
                  return;
                _self.schedule();
              } else {
                _self.$recursionLimit = 2;
              }
            };
          }
          RenderLoop2.prototype.schedule = function(change) {
            this.changes = this.changes | change;
            if (this.changes && !this.pending) {
              event.nextFrame(this._flush);
              this.pending = true;
            }
          };
          RenderLoop2.prototype.clear = function(change) {
            var changes = this.changes;
            this.changes = 0;
            return changes;
          };
          return RenderLoop2;
        }()
      );
      exports3.RenderLoop = RenderLoop;
    });
    ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/event", "ace/lib/useragent", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      var oop = require2("../lib/oop");
      var dom = require2("../lib/dom");
      var lang = require2("../lib/lang");
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var CHAR_COUNT = 512;
      var USE_OBSERVER = typeof ResizeObserver == "function";
      var L2 = 200;
      var FontMetrics = (
        /** @class */
        function() {
          function FontMetrics2(parentEl) {
            this.el = dom.createElement("div");
            this.$setMeasureNodeStyles(this.el.style, true);
            this.$main = dom.createElement("div");
            this.$setMeasureNodeStyles(this.$main.style);
            this.$measureNode = dom.createElement("div");
            this.$setMeasureNodeStyles(this.$measureNode.style);
            this.el.appendChild(this.$main);
            this.el.appendChild(this.$measureNode);
            parentEl.appendChild(this.el);
            this.$measureNode.textContent = lang.stringRepeat("X", CHAR_COUNT);
            this.$characterSize = { width: 0, height: 0 };
            if (USE_OBSERVER)
              this.$addObserver();
            else
              this.checkForSizeChanges();
          }
          FontMetrics2.prototype.$setMeasureNodeStyles = function(style, isRoot) {
            style.width = style.height = "auto";
            style.left = style.top = "0px";
            style.visibility = "hidden";
            style.position = "absolute";
            style.whiteSpace = "pre";
            if (useragent.isIE < 8) {
              style["font-family"] = "inherit";
            } else {
              style.font = "inherit";
            }
            style.overflow = isRoot ? "hidden" : "visible";
          };
          FontMetrics2.prototype.checkForSizeChanges = function(size) {
            if (size === void 0)
              size = this.$measureSizes();
            if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
              this.$measureNode.style.fontWeight = "bold";
              var boldSize = this.$measureSizes();
              this.$measureNode.style.fontWeight = "";
              this.$characterSize = size;
              this.charSizes = /* @__PURE__ */ Object.create(null);
              this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
              this._emit("changeCharacterSize", { data: size });
            }
          };
          FontMetrics2.prototype.$addObserver = function() {
            var self2 = this;
            this.$observer = new window.ResizeObserver(function(e2) {
              self2.checkForSizeChanges();
            });
            this.$observer.observe(this.$measureNode);
          };
          FontMetrics2.prototype.$pollSizeChanges = function() {
            if (this.$pollSizeChangesTimer || this.$observer)
              return this.$pollSizeChangesTimer;
            var self2 = this;
            return this.$pollSizeChangesTimer = event.onIdle(function cb() {
              self2.checkForSizeChanges();
              event.onIdle(cb, 500);
            }, 500);
          };
          FontMetrics2.prototype.setPolling = function(val) {
            if (val) {
              this.$pollSizeChanges();
            } else if (this.$pollSizeChangesTimer) {
              clearInterval(this.$pollSizeChangesTimer);
              this.$pollSizeChangesTimer = 0;
            }
          };
          FontMetrics2.prototype.$measureSizes = function(node) {
            var size = {
              height: (node || this.$measureNode).clientHeight,
              width: (node || this.$measureNode).clientWidth / CHAR_COUNT
            };
            if (size.width === 0 || size.height === 0)
              return null;
            return size;
          };
          FontMetrics2.prototype.$measureCharWidth = function(ch) {
            this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);
            var rect = this.$main.getBoundingClientRect();
            return rect.width / CHAR_COUNT;
          };
          FontMetrics2.prototype.getCharacterWidth = function(ch) {
            var w2 = this.charSizes[ch];
            if (w2 === void 0) {
              w2 = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
            }
            return w2;
          };
          FontMetrics2.prototype.destroy = function() {
            clearInterval(this.$pollSizeChangesTimer);
            if (this.$observer)
              this.$observer.disconnect();
            if (this.el && this.el.parentNode)
              this.el.parentNode.removeChild(this.el);
          };
          FontMetrics2.prototype.$getZoom = function(element) {
            if (!element || !element.parentElement)
              return 1;
            return (window.getComputedStyle(element).zoom || 1) * this.$getZoom(element.parentElement);
          };
          FontMetrics2.prototype.$initTransformMeasureNodes = function() {
            var t2 = function(t3, l) {
              return ["div", {
                style: "position: absolute;top:" + t3 + "px;left:" + l + "px;"
              }];
            };
            this.els = dom.buildDom([t2(0, 0), t2(L2, 0), t2(0, L2), t2(L2, L2)], this.el);
          };
          FontMetrics2.prototype.transformCoordinates = function(clientPos, elPos) {
            if (clientPos) {
              var zoom = this.$getZoom(this.el);
              clientPos = mul(1 / zoom, clientPos);
            }
            function solve(l1, l2, r) {
              var det = l1[1] * l2[0] - l1[0] * l2[1];
              return [
                (-l2[1] * r[0] + l2[0] * r[1]) / det,
                (+l1[1] * r[0] - l1[0] * r[1]) / det
              ];
            }
            function sub(a4, b3) {
              return [a4[0] - b3[0], a4[1] - b3[1]];
            }
            function add(a4, b3) {
              return [a4[0] + b3[0], a4[1] + b3[1]];
            }
            function mul(a4, b3) {
              return [a4 * b3[0], a4 * b3[1]];
            }
            if (!this.els)
              this.$initTransformMeasureNodes();
            function p(el) {
              var r = el.getBoundingClientRect();
              return [r.left, r.top];
            }
            var a3 = p(this.els[0]);
            var b2 = p(this.els[1]);
            var c2 = p(this.els[2]);
            var d3 = p(this.els[3]);
            var h3 = solve(sub(d3, b2), sub(d3, c2), sub(add(b2, c2), add(d3, a3)));
            var m1 = mul(1 + h3[0], sub(b2, a3));
            var m22 = mul(1 + h3[1], sub(c2, a3));
            if (elPos) {
              var x2 = elPos;
              var k2 = h3[0] * x2[0] / L2 + h3[1] * x2[1] / L2 + 1;
              var ut = add(mul(x2[0], m1), mul(x2[1], m22));
              return add(mul(1 / k2 / L2, ut), a3);
            }
            var u2 = sub(clientPos, a3);
            var f = solve(sub(m1, mul(h3[0], u2)), sub(m22, mul(h3[1], u2)), u2);
            return mul(L2, f);
          };
          return FontMetrics2;
        }()
      );
      FontMetrics.prototype.$characterSize = { width: 0, height: 0 };
      oop.implement(FontMetrics.prototype, EventEmitter);
      exports3.FontMetrics = FontMetrics;
    });
    ace.define("ace/css/editor.css", ["require", "exports", "module"], function(require2, exports3, module3) {
      module3.exports = `
.ace_br1 {border-top-left-radius    : 3px;}
.ace_br2 {border-top-right-radius   : 3px;}
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}
.ace_br4 {border-bottom-right-radius: 3px;}
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}
.ace_br8 {border-bottom-left-radius : 3px;}
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}


.ace_editor {
    position: relative;
    overflow: hidden;
    padding: 0;
    font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Source Code Pro', 'source-code-pro', monospace;
    direction: ltr;
    text-align: left;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}

.ace_scroller {
    position: absolute;
    overflow: hidden;
    top: 0;
    bottom: 0;
    background-color: inherit;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: text;
}

.ace_content {
    position: absolute;
    box-sizing: border-box;
    min-width: 100%;
    contain: style size layout;
    font-variant-ligatures: no-common-ligatures;
}

.ace_keyboard-focus:focus {
    box-shadow: inset 0 0 0 2px #5E9ED6;
    outline: none;
}

.ace_dragging .ace_scroller:before{
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    content: '';
    background: rgba(250, 250, 250, 0.01);
    z-index: 1000;
}
.ace_dragging.ace_dark .ace_scroller:before{
    background: rgba(0, 0, 0, 0.01);
}

.ace_gutter {
    position: absolute;
    overflow : hidden;
    width: auto;
    top: 0;
    bottom: 0;
    left: 0;
    cursor: default;
    z-index: 4;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    contain: style size layout;
}

.ace_gutter-active-line {
    position: absolute;
    left: 0;
    right: 0;
}

.ace_scroller.ace_scroll-left:after {
    content: "";
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;
    pointer-events: none;
}

.ace_gutter-cell, .ace_gutter-cell_svg-icons {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding-left: 19px;
    padding-right: 6px;
    background-repeat: no-repeat;
}

.ace_gutter-cell_svg-icons .ace_icon_svg {
    margin-left: -14px;
    float: left;
}

.ace_gutter-cell .ace_icon {
    margin-left: -18px;
    float: left;
}

.ace_gutter-cell.ace_error, .ace_icon.ace_error, .ace_icon.ace_error_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_warning, .ace_icon.ace_warning, .ace_icon.ace_warning_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_info, .ace_icon.ace_info {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");
    background-repeat: no-repeat;
    background-position: 2px center;
}
.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");
}

.ace_icon_svg.ace_error {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+");
    background-color: crimson;
}
.ace_icon_svg.ace_warning {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: darkorange;
}
.ace_icon_svg.ace_info {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: royalblue;
}

.ace_icon_svg.ace_error_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSI+CiAgPHBhdGggZD0ibSAxOC45Mjk4NTEsNy44Mjk4MDc2IGMgMC4xNDYzNTMsNi4zMzc0NjA0IC02LjMyMzE0Nyw3Ljc3Nzg0NDQgLTcuNDc3OTEyLDcuNzc3ODQ0NCAtMi4xMDcyNzI2LC0wLjEyODc1IDUuMTE3Njc4LDAuMzU2MjQ5IDUuMDUxNjk4LC03Ljg3MDA2MTggLTAuNjA0NjcyLC04LjAwMzk3MzQ5IC03LjA3NzI3MDYsLTcuNTYzMTE4OSAtNC44NTczLC03LjQzMDM5NTU2IDEuNjA2LC0wLjExNTE0MjI1IDYuODk3NDg1LDEuMjYyNTQ1OTYgNy4yODM1MTQsNy41MjI2MTI5NiB6IiBmaWxsPSJjcmltc29uIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibSA4LjExNDc1NjIsMi4wNTI5ODI4IGMgMy4zNDkxNjk4LDAgNi4wNjQxMzI4LDIuNjc2ODYyNyA2LjA2NDEzMjgsNS45Nzg5NTMgMCwzLjMwMjExMjIgLTIuNzE0OTYzLDUuOTc4OTIwMiAtNi4wNjQxMzI4LDUuOTc4OTIwMiAtMy4zNDkxNDczLDAgLTYuMDY0MTc3MiwtMi42NzY4MDggLTYuMDY0MTc3MiwtNS45Nzg5MjAyIDAuMDA1MzksLTMuMjk5ODg2MSAyLjcxNzI2NTYsLTUuOTczNjQwOCA2LjA2NDE3NzIsLTUuOTc4OTUzIHogbSAwLC0xLjczNTgyNzE5IGMgLTQuMzIxNDgzNiwwIC03LjgyNDc0MDM4LDMuNDU0MDE4NDkgLTcuODI0NzQwMzgsNy43MTQ3ODAxOSAwLDQuMjYwNzI4MiAzLjUwMzI1Njc4LDcuNzE0NzQ1MiA3LjgyNDc0MDM4LDcuNzE0NzQ1MiA0LjMyMTQ0OTgsMCA3LjgyNDY5OTgsLTMuNDU0MDE3IDcuODI0Njk5OCwtNy43MTQ3NDUyIDAsLTIuMDQ2MDkxNCAtMC44MjQzOTIsLTQuMDA4MzY3MiAtMi4yOTE3NTYsLTUuNDU1MTc0NiBDIDEyLjE4MDIyNSwxLjEyOTk2NDggMTAuMTkwMDEzLDAuMzE3MTU1NjEgOC4xMTQ3NTYyLDAuMzE3MTU1NjEgWiBNIDYuOTM3NDU2Myw4LjI0MDU5ODUgNC42NzE4Njg1LDEwLjQ4NTg1MiA2LjAwODY4MTQsMTEuODc2NzI4IDguMzE3MDAzNSw5LjYwMDc5MTEgMTAuNjI1MzM3LDExLjg3NjcyOCAxMS45NjIxMzgsMTAuNDg1ODUyIDkuNjk2NTUwOCw4LjI0MDU5ODUgMTEuOTYyMTM4LDYuMDA2ODA2NiAxMC41NzMyNDYsNC42Mzc0MzM1IDguMzE3MDAzNSw2Ljg3MzQyOTcgNi4wNjA3NjA3LDQuNjM3NDMzNSA0LjY3MTg2ODUsNi4wMDY4MDY2IFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");
    background-color: crimson;
}
.ace_icon_svg.ace_warning_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC43NzY5IDE0LjczMzdMOC42NTE5MiAyLjQ4MzY5QzguMzI5NDYgMS44Mzg3NyA3LjQwOTEzIDEuODM4NzcgNy4wODY2NyAyLjQ4MzY5TDAuOTYxNjY5IDE0LjczMzdDMC42NzA3NzUgMTUuMzE1NSAxLjA5MzgzIDE2IDEuNzQ0MjkgMTZIMTMuOTk0M0MxNC42NDQ4IDE2IDE1LjA2NzggMTUuMzE1NSAxNC43NzY5IDE0LjczMzdaTTMuMTYwMDcgMTQuMjVMNy44NjkyOSA0LjgzMTU2TDEyLjU3ODUgMTQuMjVIMy4xNjAwN1pNOC43NDQyOSAxMS42MjVWMTMuMzc1SDYuOTk0MjlWMTEuNjI1SDguNzQ0MjlaTTYuOTk0MjkgMTAuNzVWNy4yNUg4Ljc0NDI5VjEwLjc1SDYuOTk0MjlaIiBmaWxsPSIjRUM3MjExIi8+CjxwYXRoIGQ9Ik0xMS4xOTkxIDIuOTUyMzhDMTAuODgwOSAyLjMxNDY3IDEwLjM1MzcgMS44MDUyNiA5LjcwNTUgMS41MDlMMTEuMDQxIDEuMDY5NzhDMTEuNjg4MyAwLjk0OTgxNCAxMi4zMzcgMS4yNzI2MyAxMi42MzE3IDEuODYxNDFMMTcuNjEzNiAxMS44MTYxQzE4LjM1MjcgMTMuMjkyOSAxNy41OTM4IDE1LjA4MDQgMTYuMDE4IDE1LjU3NDVDMTYuNDA0NCAxNC40NTA3IDE2LjMyMzEgMTMuMjE4OCAxNS43OTI0IDEyLjE1NTVMMTEuMTk5MSAyLjk1MjM4WiIgZmlsbD0iI0VDNzIxMSIvPgo8L3N2Zz4=");
    background-color: darkorange;
}

.ace_scrollbar {
    contain: strict;
    position: absolute;
    right: 0;
    bottom: 0;
    z-index: 6;
}

.ace_scrollbar-inner {
    position: absolute;
    cursor: text;
    left: 0;
    top: 0;
}

.ace_scrollbar-v{
    overflow-x: hidden;
    overflow-y: scroll;
    top: 0;
}

.ace_scrollbar-h {
    overflow-x: scroll;
    overflow-y: hidden;
    left: 0;
}

.ace_print-margin {
    position: absolute;
    height: 100%;
}

.ace_text-input {
    position: absolute;
    z-index: 0;
    width: 0.5em;
    height: 1em;
    opacity: 0;
    background: transparent;
    -moz-appearance: none;
    appearance: none;
    border: none;
    resize: none;
    outline: none;
    overflow: hidden;
    font: inherit;
    padding: 0 1px;
    margin: 0 -1px;
    contain: strict;
    -ms-user-select: text;
    -moz-user-select: text;
    -webkit-user-select: text;
    user-select: text;
    /*with \`pre-line\` chrome inserts &nbsp; instead of space*/
    white-space: pre!important;
}
.ace_text-input.ace_composition {
    background: transparent;
    color: inherit;
    z-index: 1000;
    opacity: 1;
}
.ace_composition_placeholder { color: transparent }
.ace_composition_marker { 
    border-bottom: 1px solid;
    position: absolute;
    border-radius: 0;
    margin-top: 1px;
}

[ace_nocontext=true] {
    transform: none!important;
    filter: none!important;
    clip-path: none!important;
    mask : none!important;
    contain: none!important;
    perspective: none!important;
    mix-blend-mode: initial!important;
    z-index: auto;
}

.ace_layer {
    z-index: 1;
    position: absolute;
    overflow: hidden;
    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/
    word-wrap: normal;
    white-space: pre;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
    /* setting pointer-events: auto; on node under the mouse, which changes
        during scroll, will break mouse wheel scrolling in Safari */
    pointer-events: none;
}

.ace_gutter-layer {
    position: relative;
    width: auto;
    text-align: right;
    pointer-events: auto;
    height: 1000000px;
    contain: style size layout;
}

.ace_text-layer {
    font: inherit !important;
    position: absolute;
    height: 1000000px;
    width: 1000000px;
    contain: style size layout;
}

.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {
    contain: style size layout;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
}

.ace_hidpi .ace_text-layer,
.ace_hidpi .ace_gutter-layer,
.ace_hidpi .ace_content,
.ace_hidpi .ace_gutter {
    contain: strict;
}
.ace_hidpi .ace_text-layer > .ace_line, 
.ace_hidpi .ace_text-layer > .ace_line_group {
    contain: strict;
}

.ace_cjk {
    display: inline-block;
    text-align: center;
}

.ace_cursor-layer {
    z-index: 4;
}

.ace_cursor {
    z-index: 4;
    position: absolute;
    box-sizing: border-box;
    border-left: 2px solid;
    /* workaround for smooth cursor repaintng whole screen in chrome */
    transform: translatez(0);
}

.ace_multiselect .ace_cursor {
    border-left-width: 1px;
}

.ace_slim-cursors .ace_cursor {
    border-left-width: 1px;
}

.ace_overwrite-cursors .ace_cursor {
    border-left-width: 0;
    border-bottom: 1px solid;
}

.ace_hidden-cursors .ace_cursor {
    opacity: 0.2;
}

.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {
    opacity: 0;
}

.ace_smooth-blinking .ace_cursor {
    transition: opacity 0.18s;
}

.ace_animate-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: step-end;
    animation-name: blink-ace-animate;
    animation-iteration-count: infinite;
}

.ace_animate-blinking.ace_smooth-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: ease-in-out;
    animation-name: blink-ace-animate-smooth;
}
    
@keyframes blink-ace-animate {
    from, to { opacity: 1; }
    60% { opacity: 0; }
}

@keyframes blink-ace-animate-smooth {
    from, to { opacity: 1; }
    45% { opacity: 1; }
    60% { opacity: 0; }
    85% { opacity: 0; }
}

.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {
    position: absolute;
    z-index: 3;
}

.ace_marker-layer .ace_selection {
    position: absolute;
    z-index: 5;
}

.ace_marker-layer .ace_bracket {
    position: absolute;
    z-index: 6;
}

.ace_marker-layer .ace_error_bracket {
    position: absolute;
    border-bottom: 1px solid #DE5555;
    border-radius: 0;
}

.ace_marker-layer .ace_active-line {
    position: absolute;
    z-index: 2;
}

.ace_marker-layer .ace_selected-word {
    position: absolute;
    z-index: 4;
    box-sizing: border-box;
}

.ace_line .ace_fold {
    box-sizing: border-box;

    display: inline-block;
    height: 11px;
    margin-top: -2px;
    vertical-align: middle;

    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");
    background-repeat: no-repeat, repeat-x;
    background-position: center center, top left;
    color: transparent;

    border: 1px solid black;
    border-radius: 2px;

    cursor: pointer;
    pointer-events: auto;
}

.ace_dark .ace_fold {
}

.ace_fold:hover{
    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");
}

.ace_tooltip {
    background-color: #f5f5f5;
    border: 1px solid gray;
    border-radius: 1px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    color: black;
    max-width: 100%;
    padding: 3px 4px;
    position: fixed;
    z-index: 999999;
    box-sizing: border-box;
    cursor: default;
    white-space: pre;
    word-wrap: break-word;
    line-height: normal;
    font-style: normal;
    font-weight: normal;
    letter-spacing: normal;
    pointer-events: none;
}

.ace_tooltip.ace_dark {
    background-color: #636363;
    color: #fff;
}

.ace_tooltip:focus {
    outline: 1px solid #5E9ED6;
}

.ace_icon {
    display: inline-block;
    width: 18px;
    vertical-align: top;
}

.ace_icon_svg {
    display: inline-block;
    width: 12px;
    vertical-align: top;
    -webkit-mask-repeat: no-repeat;
    -webkit-mask-size: 12px;
    -webkit-mask-position: center;
}

.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {
    padding-right: 13px;
}

.ace_fold-widget {
    box-sizing: border-box;

    margin: 0 -12px 0 1px;
    display: none;
    width: 11px;
    vertical-align: top;

    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: center;

    border-radius: 3px;
    
    border: 1px solid transparent;
    cursor: pointer;
}

.ace_folding-enabled .ace_fold-widget {
    display: inline-block;   
}

.ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");
}

.ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");
}

.ace_fold-widget:hover {
    border: 1px solid rgba(0, 0, 0, 0.3);
    background-color: rgba(255, 255, 255, 0.2);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);
}

.ace_fold-widget:active {
    border: 1px solid rgba(0, 0, 0, 0.4);
    background-color: rgba(0, 0, 0, 0.05);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
}
/**
 * Dark version for fold widgets
 */
.ace_dark .ace_fold-widget {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");
}
.ace_dark .ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget:hover {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
    background-color: rgba(255, 255, 255, 0.1);
}
.ace_dark .ace_fold-widget:active {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
}

.ace_inline_button {
    border: 1px solid lightgray;
    display: inline-block;
    margin: -1px 8px;
    padding: 0 5px;
    pointer-events: auto;
    cursor: pointer;
}
.ace_inline_button:hover {
    border-color: gray;
    background: rgba(200,200,200,0.2);
    display: inline-block;
    pointer-events: auto;
}

.ace_fold-widget.ace_invalid {
    background-color: #FFB4B4;
    border-color: #DE5555;
}

.ace_fade-fold-widgets .ace_fold-widget {
    transition: opacity 0.4s ease 0.05s;
    opacity: 0;
}

.ace_fade-fold-widgets:hover .ace_fold-widget {
    transition: opacity 0.05s ease 0.05s;
    opacity:1;
}

.ace_underline {
    text-decoration: underline;
}

.ace_bold {
    font-weight: bold;
}

.ace_nobold .ace_bold {
    font-weight: normal;
}

.ace_italic {
    font-style: italic;
}


.ace_error-marker {
    background-color: rgba(255, 0, 0,0.2);
    position: absolute;
    z-index: 9;
}

.ace_highlight-marker {
    background-color: rgba(255, 255, 0,0.2);
    position: absolute;
    z-index: 8;
}

.ace_mobile-menu {
    position: absolute;
    line-height: 1.5;
    border-radius: 4px;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    background: white;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #dcdcdc;
    color: black;
}
.ace_dark > .ace_mobile-menu {
    background: #333;
    color: #ccc;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #444;

}
.ace_mobile-button {
    padding: 2px;
    cursor: pointer;
    overflow: hidden;
}
.ace_mobile-button:hover {
    background-color: #eee;
    opacity:1;
}
.ace_mobile-button:active {
    background-color: #ddd;
}

.ace_placeholder {
    font-family: arial;
    transform: scale(0.9);
    transform-origin: left;
    white-space: pre;
    opacity: 0.7;
    margin: 0 10px;
}

.ace_ghost_text {
    opacity: 0.5;
    font-style: italic;
    white-space: pre;
}`;
    });
    ace.define("ace/layer/decorators", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      var dom = require2("../lib/dom");
      var oop = require2("../lib/oop");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var Decorator = (
        /** @class */
        function() {
          function Decorator2(parent, renderer) {
            this.canvas = dom.createElement("canvas");
            this.renderer = renderer;
            this.pixelRatio = 1;
            this.maxHeight = renderer.layerConfig.maxHeight;
            this.lineHeight = renderer.layerConfig.lineHeight;
            this.canvasHeight = parent.parent.scrollHeight;
            this.heightRatio = this.canvasHeight / this.maxHeight;
            this.canvasWidth = parent.width;
            this.minDecorationHeight = 2 * this.pixelRatio | 0;
            this.halfMinDecorationHeight = this.minDecorationHeight / 2 | 0;
            this.canvas.width = this.canvasWidth;
            this.canvas.height = this.canvasHeight;
            this.canvas.style.top = "0px";
            this.canvas.style.right = "0px";
            this.canvas.style.zIndex = "7px";
            this.canvas.style.position = "absolute";
            this.colors = {};
            this.colors.dark = {
              "error": "rgba(255, 18, 18, 1)",
              "warning": "rgba(18, 136, 18, 1)",
              "info": "rgba(18, 18, 136, 1)"
            };
            this.colors.light = {
              "error": "rgb(255,51,51)",
              "warning": "rgb(32,133,72)",
              "info": "rgb(35,68,138)"
            };
            parent.element.appendChild(this.canvas);
          }
          Decorator2.prototype.$updateDecorators = function(config) {
            var colors = this.renderer.theme.isDark === true ? this.colors.dark : this.colors.light;
            if (config) {
              this.maxHeight = config.maxHeight;
              this.lineHeight = config.lineHeight;
              this.canvasHeight = config.height;
              var allLineHeight = (config.lastRow + 1) * this.lineHeight;
              if (allLineHeight < this.canvasHeight) {
                this.heightRatio = 1;
              } else {
                this.heightRatio = this.canvasHeight / this.maxHeight;
              }
            }
            var ctx = this.canvas.getContext("2d");
            function compare2(a3, b2) {
              if (a3.priority < b2.priority)
                return -1;
              if (a3.priority > b2.priority)
                return 1;
              return 0;
            }
            var annotations = this.renderer.session.$annotations;
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            if (annotations) {
              var priorities = {
                "info": 1,
                "warning": 2,
                "error": 3
              };
              annotations.forEach(function(item2) {
                item2.priority = priorities[item2.type] || null;
              });
              annotations = annotations.sort(compare2);
              var foldData = this.renderer.session.$foldData;
              for (var i2 = 0; i2 < annotations.length; i2++) {
                var row = annotations[i2].row;
                var compensateFold = this.compensateFoldRows(row, foldData);
                var currentY = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);
                var y1 = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);
                var y22 = Math.round(((row - compensateFold) * this.lineHeight + this.lineHeight) * this.heightRatio);
                var height = y22 - y1;
                if (height < this.minDecorationHeight) {
                  var yCenter = (y1 + y22) / 2 | 0;
                  if (yCenter < this.halfMinDecorationHeight) {
                    yCenter = this.halfMinDecorationHeight;
                  } else if (yCenter + this.halfMinDecorationHeight > this.canvasHeight) {
                    yCenter = this.canvasHeight - this.halfMinDecorationHeight;
                  }
                  y1 = Math.round(yCenter - this.halfMinDecorationHeight);
                  y22 = Math.round(yCenter + this.halfMinDecorationHeight);
                }
                ctx.fillStyle = colors[annotations[i2].type] || null;
                ctx.fillRect(0, currentY, this.canvasWidth, y22 - y1);
              }
            }
            var cursor = this.renderer.session.selection.getCursor();
            if (cursor) {
              var compensateFold = this.compensateFoldRows(cursor.row, foldData);
              var currentY = Math.round((cursor.row - compensateFold) * this.lineHeight * this.heightRatio);
              ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
              ctx.fillRect(0, currentY, this.canvasWidth, 2);
            }
          };
          Decorator2.prototype.compensateFoldRows = function(row, foldData) {
            var compensateFold = 0;
            if (foldData && foldData.length > 0) {
              for (var j = 0; j < foldData.length; j++) {
                if (row > foldData[j].start.row && row < foldData[j].end.row) {
                  compensateFold += row - foldData[j].start.row;
                } else if (row >= foldData[j].end.row) {
                  compensateFold += foldData[j].end.row - foldData[j].start.row;
                }
              }
            }
            return compensateFold;
          };
          return Decorator2;
        }()
      );
      oop.implement(Decorator.prototype, EventEmitter);
      exports3.Decorator = Decorator;
    });
    ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/config", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/scrollbar_custom", "ace/scrollbar_custom", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter", "ace/css/editor.css", "ace/layer/decorators", "ace/lib/useragent"], function(require2, exports3, module3) {
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var lang = require2("./lib/lang");
      var config = require2("./config");
      var GutterLayer = require2("./layer/gutter").Gutter;
      var MarkerLayer = require2("./layer/marker").Marker;
      var TextLayer = require2("./layer/text").Text;
      var CursorLayer = require2("./layer/cursor").Cursor;
      var HScrollBar = require2("./scrollbar").HScrollBar;
      var VScrollBar = require2("./scrollbar").VScrollBar;
      var HScrollBarCustom = require2("./scrollbar_custom").HScrollBar;
      var VScrollBarCustom = require2("./scrollbar_custom").VScrollBar;
      var RenderLoop = require2("./renderloop").RenderLoop;
      var FontMetrics = require2("./layer/font_metrics").FontMetrics;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var editorCss = require2("./css/editor.css");
      var Decorator = require2("./layer/decorators").Decorator;
      var useragent = require2("./lib/useragent");
      dom.importCssString(editorCss, "ace_editor.css", false);
      var VirtualRenderer = (
        /** @class */
        function() {
          function VirtualRenderer2(container, theme) {
            var _self = this;
            this.container = container || dom.createElement("div");
            dom.addCssClass(this.container, "ace_editor");
            if (dom.HI_DPI)
              dom.addCssClass(this.container, "ace_hidpi");
            this.setTheme(theme);
            if (config.get("useStrictCSP") == null)
              config.set("useStrictCSP", false);
            this.$gutter = dom.createElement("div");
            this.$gutter.className = "ace_gutter";
            this.container.appendChild(this.$gutter);
            this.$gutter.setAttribute("aria-hidden", true);
            this.scroller = dom.createElement("div");
            this.scroller.className = "ace_scroller";
            this.container.appendChild(this.scroller);
            this.content = dom.createElement("div");
            this.content.className = "ace_content";
            this.scroller.appendChild(this.content);
            this.$gutterLayer = new GutterLayer(this.$gutter);
            this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
            this.$markerBack = new MarkerLayer(this.content);
            var textLayer = this.$textLayer = new TextLayer(this.content);
            this.canvas = textLayer.element;
            this.$markerFront = new MarkerLayer(this.content);
            this.$cursorLayer = new CursorLayer(this.content);
            this.$horizScroll = false;
            this.$vScroll = false;
            this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
            this.scrollBarH = new HScrollBar(this.container, this);
            this.scrollBarV.on("scroll", function(e2) {
              if (!_self.$scrollAnimation)
                _self.session.setScrollTop(e2.data - _self.scrollMargin.top);
            });
            this.scrollBarH.on("scroll", function(e2) {
              if (!_self.$scrollAnimation)
                _self.session.setScrollLeft(e2.data - _self.scrollMargin.left);
            });
            this.scrollTop = 0;
            this.scrollLeft = 0;
            this.cursorPos = {
              row: 0,
              column: 0
            };
            this.$fontMetrics = new FontMetrics(this.container);
            this.$textLayer.$setFontMetrics(this.$fontMetrics);
            this.$textLayer.on("changeCharacterSize", function(e2) {
              _self.updateCharacterSize();
              _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
              _self._signal("changeCharacterSize", e2);
            });
            this.$size = {
              width: 0,
              height: 0,
              scrollerHeight: 0,
              scrollerWidth: 0,
              $dirty: true
            };
            this.layerConfig = {
              width: 1,
              padding: 0,
              firstRow: 0,
              firstRowScreen: 0,
              lastRow: 0,
              lineHeight: 0,
              characterWidth: 0,
              minHeight: 1,
              maxHeight: 1,
              offset: 0,
              height: 1,
              gutterOffset: 1
            };
            this.scrollMargin = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
              v: 0,
              h: 0
            };
            this.margin = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
              v: 0,
              h: 0
            };
            this.$keepTextAreaAtCursor = !useragent.isIOS;
            this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
            this.$loop.schedule(this.CHANGE_FULL);
            this.updateCharacterSize();
            this.setPadding(4);
            this.$addResizeObserver();
            config.resetOptions(this);
            config._signal("renderer", this);
          }
          VirtualRenderer2.prototype.updateCharacterSize = function() {
            if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
              this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
              this.setStyle("ace_nobold", !this.$allowBoldFonts);
            }
            this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
            this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
            this.$updatePrintMargin();
            dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
          };
          VirtualRenderer2.prototype.setSession = function(session) {
            if (this.session)
              this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
            this.session = session;
            if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
              session.setScrollTop(-this.scrollMargin.top);
            this.$cursorLayer.setSession(session);
            this.$markerBack.setSession(session);
            this.$markerFront.setSession(session);
            this.$gutterLayer.setSession(session);
            this.$textLayer.setSession(session);
            if (!session)
              return;
            this.$loop.schedule(this.CHANGE_FULL);
            this.session.$setFontMetrics(this.$fontMetrics);
            this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
            this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
            this.onChangeNewLineMode();
            this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
          };
          VirtualRenderer2.prototype.updateLines = function(firstRow, lastRow, force) {
            if (lastRow === void 0)
              lastRow = Infinity;
            if (!this.$changedLines) {
              this.$changedLines = {
                firstRow,
                lastRow
              };
            } else {
              if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;
              if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
            }
            if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
              if (force)
                this.$changedLines.lastRow = this.layerConfig.lastRow;
              else
                return;
            }
            if (this.$changedLines.firstRow > this.layerConfig.lastRow)
              return;
            this.$loop.schedule(this.CHANGE_LINES);
          };
          VirtualRenderer2.prototype.onChangeNewLineMode = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
            this.$textLayer.$updateEolChar();
            this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
          };
          VirtualRenderer2.prototype.onChangeTabSize = function() {
            this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
            this.$textLayer.onChangeTabSize();
          };
          VirtualRenderer2.prototype.updateText = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
          };
          VirtualRenderer2.prototype.updateFull = function(force) {
            if (force)
              this.$renderChanges(this.CHANGE_FULL, true);
            else
              this.$loop.schedule(this.CHANGE_FULL);
          };
          VirtualRenderer2.prototype.updateFontSize = function() {
            this.$textLayer.checkForSizeChanges();
          };
          VirtualRenderer2.prototype.$updateSizeAsync = function() {
            if (this.$loop.pending)
              this.$size.$dirty = true;
            else
              this.onResize();
          };
          VirtualRenderer2.prototype.onResize = function(force, gutterWidth, width, height) {
            if (this.resizing > 2)
              return;
            else if (this.resizing > 0)
              this.resizing++;
            else
              this.resizing = force ? 1 : 0;
            var el = this.container;
            if (!height)
              height = el.clientHeight || el.scrollHeight;
            if (!width)
              width = el.clientWidth || el.scrollWidth;
            var changes = this.$updateCachedSize(force, gutterWidth, width, height);
            if (this.$resizeTimer)
              this.$resizeTimer.cancel();
            if (!this.$size.scrollerHeight || !width && !height)
              return this.resizing = 0;
            if (force)
              this.$gutterLayer.$padding = null;
            if (force)
              this.$renderChanges(changes | this.$changes, true);
            else
              this.$loop.schedule(changes | this.$changes);
            if (this.resizing)
              this.resizing = 0;
            this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
            if (this.$customScrollbar) {
              this.$updateCustomScrollbar(true);
            }
          };
          VirtualRenderer2.prototype.$updateCachedSize = function(force, gutterWidth, width, height) {
            height -= this.$extraHeight || 0;
            var changes = 0;
            var size = this.$size;
            var oldSize = {
              width: size.width,
              height: size.height,
              scrollerHeight: size.scrollerHeight,
              scrollerWidth: size.scrollerWidth
            };
            if (height && (force || size.height != height)) {
              size.height = height;
              changes |= this.CHANGE_SIZE;
              size.scrollerHeight = size.height;
              if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();
              this.scrollBarV.setHeight(size.scrollerHeight);
              this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
              changes = changes | this.CHANGE_SCROLL;
            }
            if (width && (force || size.width != width)) {
              changes |= this.CHANGE_SIZE;
              size.width = width;
              if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
              this.gutterWidth = gutterWidth;
              dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
              dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
              size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
              dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");
              var right = this.scrollBarV.getWidth() + "px";
              dom.setStyle(this.scrollBarH.element.style, "right", right);
              dom.setStyle(this.scroller.style, "right", right);
              dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());
              this.scrollBarH.setWidth(size.scrollerWidth);
              if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {
                changes |= this.CHANGE_FULL;
              }
            }
            size.$dirty = !width || !height;
            if (changes)
              this._signal("resize", oldSize);
            return changes;
          };
          VirtualRenderer2.prototype.onGutterResize = function(width) {
            var gutterWidth = this.$showGutter ? width : 0;
            if (gutterWidth != this.gutterWidth)
              this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
            if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
              this.$loop.schedule(this.CHANGE_FULL);
            } else if (this.$size.$dirty) {
              this.$loop.schedule(this.CHANGE_FULL);
            } else {
              this.$computeLayerConfig();
            }
          };
          VirtualRenderer2.prototype.adjustWrapLimit = function() {
            var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
            var limit = Math.floor(availableWidth / this.characterWidth);
            return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
          };
          VirtualRenderer2.prototype.setAnimatedScroll = function(shouldAnimate) {
            this.setOption("animatedScroll", shouldAnimate);
          };
          VirtualRenderer2.prototype.getAnimatedScroll = function() {
            return this.$animatedScroll;
          };
          VirtualRenderer2.prototype.setShowInvisibles = function(showInvisibles) {
            this.setOption("showInvisibles", showInvisibles);
            this.session.$bidiHandler.setShowInvisibles(showInvisibles);
          };
          VirtualRenderer2.prototype.getShowInvisibles = function() {
            return this.getOption("showInvisibles");
          };
          VirtualRenderer2.prototype.getDisplayIndentGuide = function() {
            return this.getOption("displayIndentGuides");
          };
          VirtualRenderer2.prototype.setDisplayIndentGuides = function(display) {
            this.setOption("displayIndentGuides", display);
          };
          VirtualRenderer2.prototype.getHighlightIndentGuides = function() {
            return this.getOption("highlightIndentGuides");
          };
          VirtualRenderer2.prototype.setHighlightIndentGuides = function(highlight) {
            this.setOption("highlightIndentGuides", highlight);
          };
          VirtualRenderer2.prototype.setShowPrintMargin = function(showPrintMargin) {
            this.setOption("showPrintMargin", showPrintMargin);
          };
          VirtualRenderer2.prototype.getShowPrintMargin = function() {
            return this.getOption("showPrintMargin");
          };
          VirtualRenderer2.prototype.setPrintMarginColumn = function(showPrintMargin) {
            this.setOption("printMarginColumn", showPrintMargin);
          };
          VirtualRenderer2.prototype.getPrintMarginColumn = function() {
            return this.getOption("printMarginColumn");
          };
          VirtualRenderer2.prototype.getShowGutter = function() {
            return this.getOption("showGutter");
          };
          VirtualRenderer2.prototype.setShowGutter = function(show) {
            return this.setOption("showGutter", show);
          };
          VirtualRenderer2.prototype.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
          };
          VirtualRenderer2.prototype.setFadeFoldWidgets = function(show) {
            this.setOption("fadeFoldWidgets", show);
          };
          VirtualRenderer2.prototype.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
          };
          VirtualRenderer2.prototype.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
          };
          VirtualRenderer2.prototype.$updatePrintMargin = function() {
            if (!this.$showPrintMargin && !this.$printMarginEl)
              return;
            if (!this.$printMarginEl) {
              var containerEl = dom.createElement("div");
              containerEl.className = "ace_layer ace_print-margin-layer";
              this.$printMarginEl = dom.createElement("div");
              this.$printMarginEl.className = "ace_print-margin";
              containerEl.appendChild(this.$printMarginEl);
              this.content.insertBefore(containerEl, this.content.firstChild);
            }
            var style = this.$printMarginEl.style;
            style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
            style.visibility = this.$showPrintMargin ? "visible" : "hidden";
            if (this.session && this.session.$wrap == -1)
              this.adjustWrapLimit();
          };
          VirtualRenderer2.prototype.getContainerElement = function() {
            return this.container;
          };
          VirtualRenderer2.prototype.getMouseEventTarget = function() {
            return this.scroller;
          };
          VirtualRenderer2.prototype.getTextAreaContainer = function() {
            return this.container;
          };
          VirtualRenderer2.prototype.$moveTextAreaToCursor = function() {
            if (this.$isMousePressed)
              return;
            var style = this.textarea.style;
            var composition = this.$composition;
            if (!this.$keepTextAreaAtCursor && !composition) {
              dom.translate(this.textarea, -100, 0);
              return;
            }
            var pixelPos = this.$cursorLayer.$pixelPos;
            if (!pixelPos)
              return;
            if (composition && composition.markerRange)
              pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);
            var config2 = this.layerConfig;
            var posTop = pixelPos.top;
            var posLeft = pixelPos.left;
            posTop -= config2.offset;
            var h3 = composition && composition.useTextareaForIME || useragent.isMobile ? this.lineHeight : 1;
            if (posTop < 0 || posTop > config2.height - h3) {
              dom.translate(this.textarea, 0, 0);
              return;
            }
            var w2 = 1;
            var maxTop = this.$size.height - h3;
            if (!composition) {
              posTop += this.lineHeight;
            } else {
              if (composition.useTextareaForIME) {
                var val = this.textarea.value;
                w2 = this.characterWidth * this.session.$getStringScreenWidth(val)[0];
              } else {
                posTop += this.lineHeight + 2;
              }
            }
            posLeft -= this.scrollLeft;
            if (posLeft > this.$size.scrollerWidth - w2)
              posLeft = this.$size.scrollerWidth - w2;
            posLeft += this.gutterWidth + this.margin.left;
            dom.setStyle(style, "height", h3 + "px");
            dom.setStyle(style, "width", w2 + "px");
            dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w2), Math.min(posTop, maxTop));
          };
          VirtualRenderer2.prototype.getFirstVisibleRow = function() {
            return this.layerConfig.firstRow;
          };
          VirtualRenderer2.prototype.getFirstFullyVisibleRow = function() {
            return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
          };
          VirtualRenderer2.prototype.getLastFullyVisibleRow = function() {
            var config2 = this.layerConfig;
            var lastRow = config2.lastRow;
            var top = this.session.documentToScreenRow(lastRow, 0) * config2.lineHeight;
            if (top - this.session.getScrollTop() > config2.height - config2.lineHeight)
              return lastRow - 1;
            return lastRow;
          };
          VirtualRenderer2.prototype.getLastVisibleRow = function() {
            return this.layerConfig.lastRow;
          };
          VirtualRenderer2.prototype.setPadding = function(padding) {
            this.$padding = padding;
            this.$textLayer.setPadding(padding);
            this.$cursorLayer.setPadding(padding);
            this.$markerFront.setPadding(padding);
            this.$markerBack.setPadding(padding);
            this.$loop.schedule(this.CHANGE_FULL);
            this.$updatePrintMargin();
          };
          VirtualRenderer2.prototype.setScrollMargin = function(top, bottom, left, right) {
            var sm = this.scrollMargin;
            sm.top = top | 0;
            sm.bottom = bottom | 0;
            sm.right = right | 0;
            sm.left = left | 0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            if (sm.top && this.scrollTop <= 0 && this.session)
              this.session.setScrollTop(-sm.top);
            this.updateFull();
          };
          VirtualRenderer2.prototype.setMargin = function(top, bottom, left, right) {
            var sm = this.margin;
            sm.top = top | 0;
            sm.bottom = bottom | 0;
            sm.right = right | 0;
            sm.left = left | 0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
            this.updateFull();
          };
          VirtualRenderer2.prototype.getHScrollBarAlwaysVisible = function() {
            return this.$hScrollBarAlwaysVisible;
          };
          VirtualRenderer2.prototype.setHScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
          };
          VirtualRenderer2.prototype.getVScrollBarAlwaysVisible = function() {
            return this.$vScrollBarAlwaysVisible;
          };
          VirtualRenderer2.prototype.setVScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
          };
          VirtualRenderer2.prototype.$updateScrollBarV = function() {
            var scrollHeight = this.layerConfig.maxHeight;
            var scrollerHeight = this.$size.scrollerHeight;
            if (!this.$maxLines && this.$scrollPastEnd) {
              scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
              if (this.scrollTop > scrollHeight - scrollerHeight) {
                scrollHeight = this.scrollTop + scrollerHeight;
                this.scrollBarV.scrollTop = null;
              }
            }
            this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
            this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
          };
          VirtualRenderer2.prototype.$updateScrollBarH = function() {
            this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
            this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
          };
          VirtualRenderer2.prototype.freeze = function() {
            this.$frozen = true;
          };
          VirtualRenderer2.prototype.unfreeze = function() {
            this.$frozen = false;
          };
          VirtualRenderer2.prototype.$renderChanges = function(changes, force) {
            if (this.$changes) {
              changes |= this.$changes;
              this.$changes = 0;
            }
            if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
              this.$changes |= changes;
              return;
            }
            if (this.$size.$dirty) {
              this.$changes |= changes;
              return this.onResize(true);
            }
            if (!this.lineHeight) {
              this.$textLayer.checkForSizeChanges();
            }
            this._signal("beforeRender", changes);
            if (this.session && this.session.$bidiHandler)
              this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
            var config2 = this.layerConfig;
            if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
              changes |= this.$computeLayerConfig() | this.$loop.clear();
              if (config2.firstRow != this.layerConfig.firstRow && config2.firstRowScreen == this.layerConfig.firstRowScreen) {
                var st = this.scrollTop + (config2.firstRow - Math.max(this.layerConfig.firstRow, 0)) * this.lineHeight;
                if (st > 0) {
                  this.scrollTop = st;
                  changes = changes | this.CHANGE_SCROLL;
                  changes |= this.$computeLayerConfig() | this.$loop.clear();
                }
              }
              config2 = this.layerConfig;
              this.$updateScrollBarV();
              if (changes & this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();
              dom.translate(this.content, -this.scrollLeft, -config2.offset);
              var width = config2.width + 2 * this.$padding + "px";
              var height = config2.minHeight + "px";
              dom.setStyle(this.content.style, "width", width);
              dom.setStyle(this.content.style, "height", height);
            }
            if (changes & this.CHANGE_H_SCROLL) {
              dom.translate(this.content, -this.scrollLeft, -config2.offset);
              this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
            }
            if (changes & this.CHANGE_FULL) {
              this.$changedLines = null;
              this.$textLayer.update(config2);
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
              this.$markerBack.update(config2);
              this.$markerFront.update(config2);
              this.$cursorLayer.update(config2);
              this.$moveTextAreaToCursor();
              this._signal("afterRender", changes);
              return;
            }
            if (changes & this.CHANGE_SCROLL) {
              this.$changedLines = null;
              if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(config2);
              else
                this.$textLayer.scrollLines(config2);
              if (this.$showGutter) {
                if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)
                  this.$gutterLayer.update(config2);
                else
                  this.$gutterLayer.scrollLines(config2);
              }
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
              this.$markerBack.update(config2);
              this.$markerFront.update(config2);
              this.$cursorLayer.update(config2);
              this.$moveTextAreaToCursor();
              this._signal("afterRender", changes);
              return;
            }
            if (changes & this.CHANGE_TEXT) {
              this.$changedLines = null;
              this.$textLayer.update(config2);
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            } else if (changes & this.CHANGE_LINES) {
              if (this.$updateLines() || changes & this.CHANGE_GUTTER && this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            } else if (changes & this.CHANGE_CURSOR) {
              if (this.$highlightGutterLine)
                this.$gutterLayer.updateLineHighlight(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            }
            if (changes & this.CHANGE_CURSOR) {
              this.$cursorLayer.update(config2);
              this.$moveTextAreaToCursor();
            }
            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
              this.$markerFront.update(config2);
            }
            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
              this.$markerBack.update(config2);
            }
            this._signal("afterRender", changes);
          };
          VirtualRenderer2.prototype.$autosize = function() {
            var height = this.session.getScreenLength() * this.lineHeight;
            var maxHeight = this.$maxLines * this.lineHeight;
            var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
            if (this.$horizScroll)
              desiredHeight += this.scrollBarH.getHeight();
            if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
              desiredHeight = this.$maxPixelHeight;
            var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
            var vScroll = !hideScrollbars && height > maxHeight;
            if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
              if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
              }
              var w2 = this.container.clientWidth;
              this.container.style.height = desiredHeight + "px";
              this.$updateCachedSize(true, this.$gutterWidth, w2, desiredHeight);
              this.desiredHeight = desiredHeight;
              this._signal("autosize");
            }
          };
          VirtualRenderer2.prototype.$computeLayerConfig = function() {
            var session = this.session;
            var size = this.$size;
            var hideScrollbars = size.height <= 2 * this.lineHeight;
            var screenLines = this.session.getScreenLength();
            var maxHeight = screenLines * this.lineHeight;
            var longestLine = this.$getLongestLine();
            var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
            var hScrollChanged = this.$horizScroll !== horizScroll;
            if (hScrollChanged) {
              this.$horizScroll = horizScroll;
              this.scrollBarH.setVisible(horizScroll);
            }
            var vScrollBefore = this.$vScroll;
            if (this.$maxLines && this.lineHeight > 1)
              this.$autosize();
            var minHeight = size.scrollerHeight + this.lineHeight;
            var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
            maxHeight += scrollPastEnd;
            var sm = this.scrollMargin;
            this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
            this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
            var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
            var vScrollChanged = vScrollBefore !== vScroll;
            if (vScrollChanged) {
              this.$vScroll = vScroll;
              this.scrollBarV.setVisible(vScroll);
            }
            var offset = this.scrollTop % this.lineHeight;
            var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
            var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
            var lastRow = firstRow + lineCount;
            var firstRowScreen, firstRowHeight;
            var lineHeight = this.lineHeight;
            firstRow = session.screenToDocumentRow(firstRow, 0);
            var foldLine = session.getFoldLine(firstRow);
            if (foldLine) {
              firstRow = foldLine.start.row;
            }
            firstRowScreen = session.documentToScreenRow(firstRow, 0);
            firstRowHeight = session.getRowLength(firstRow) * lineHeight;
            lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
            minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
            offset = this.scrollTop - firstRowScreen * lineHeight;
            var changes = 0;
            if (this.layerConfig.width != longestLine || hScrollChanged)
              changes = this.CHANGE_H_SCROLL;
            if (hScrollChanged || vScrollChanged) {
              changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
              this._signal("scrollbarVisibilityChanged");
              if (vScrollChanged)
                longestLine = this.$getLongestLine();
            }
            this.layerConfig = {
              width: longestLine,
              padding: this.$padding,
              firstRow,
              firstRowScreen,
              lastRow,
              lineHeight,
              characterWidth: this.characterWidth,
              minHeight,
              maxHeight,
              offset,
              gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
              height: this.$size.scrollerHeight
            };
            if (this.session.$bidiHandler)
              this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);
            return changes;
          };
          VirtualRenderer2.prototype.$updateLines = function() {
            if (!this.$changedLines)
              return;
            var firstRow = this.$changedLines.firstRow;
            var lastRow = this.$changedLines.lastRow;
            this.$changedLines = null;
            var layerConfig = this.layerConfig;
            if (firstRow > layerConfig.lastRow + 1) {
              return;
            }
            if (lastRow < layerConfig.firstRow) {
              return;
            }
            if (lastRow === Infinity) {
              if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
              this.$textLayer.update(layerConfig);
              return;
            }
            this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
            return true;
          };
          VirtualRenderer2.prototype.$getLongestLine = function() {
            var charCount = this.session.getScreenWidth();
            if (this.showInvisibles && !this.session.$useWrapMode)
              charCount += 1;
            if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)
              charCount = this.$textLayer.MAX_LINE_LENGTH + 30;
            return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
          };
          VirtualRenderer2.prototype.updateFrontMarkers = function() {
            this.$markerFront.setMarkers(this.session.getMarkers(true));
            this.$loop.schedule(this.CHANGE_MARKER_FRONT);
          };
          VirtualRenderer2.prototype.updateBackMarkers = function() {
            this.$markerBack.setMarkers(this.session.getMarkers());
            this.$loop.schedule(this.CHANGE_MARKER_BACK);
          };
          VirtualRenderer2.prototype.addGutterDecoration = function(row, className) {
            this.$gutterLayer.addGutterDecoration(row, className);
          };
          VirtualRenderer2.prototype.removeGutterDecoration = function(row, className) {
            this.$gutterLayer.removeGutterDecoration(row, className);
          };
          VirtualRenderer2.prototype.updateBreakpoints = function(rows) {
            this.$loop.schedule(this.CHANGE_GUTTER);
          };
          VirtualRenderer2.prototype.setAnnotations = function(annotations) {
            this.$gutterLayer.setAnnotations(annotations);
            this.$loop.schedule(this.CHANGE_GUTTER);
          };
          VirtualRenderer2.prototype.updateCursor = function() {
            this.$loop.schedule(this.CHANGE_CURSOR);
          };
          VirtualRenderer2.prototype.hideCursor = function() {
            this.$cursorLayer.hideCursor();
          };
          VirtualRenderer2.prototype.showCursor = function() {
            this.$cursorLayer.showCursor();
          };
          VirtualRenderer2.prototype.scrollSelectionIntoView = function(anchor, lead, offset) {
            this.scrollCursorIntoView(anchor, offset);
            this.scrollCursorIntoView(lead, offset);
          };
          VirtualRenderer2.prototype.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
            if (this.$size.scrollerHeight === 0)
              return;
            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var newLeft = pos.left;
            var newTop = pos.top;
            var topMargin = $viewMargin && $viewMargin.top || 0;
            var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
            if (this.$scrollAnimation) {
              this.$stopAnimation = true;
            }
            var currentTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
            if (currentTop + topMargin > newTop) {
              if (offset && currentTop + topMargin > newTop + this.lineHeight)
                newTop -= offset * this.$size.scrollerHeight;
              if (newTop === 0)
                newTop = -this.scrollMargin.top;
              this.session.setScrollTop(newTop);
            } else if (currentTop + this.$size.scrollerHeight - bottomMargin < newTop + this.lineHeight) {
              if (offset && currentTop + this.$size.scrollerHeight - bottomMargin < newTop - this.lineHeight)
                newTop += offset * this.$size.scrollerHeight;
              this.session.setScrollTop(newTop + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
            }
            var currentLeft = this.scrollLeft;
            var twoCharsWidth = 2 * this.layerConfig.characterWidth;
            if (newLeft - twoCharsWidth < currentLeft) {
              newLeft -= twoCharsWidth;
              if (newLeft < this.$padding + twoCharsWidth) {
                newLeft = -this.scrollMargin.left;
              }
              this.session.setScrollLeft(newLeft);
            } else {
              newLeft += twoCharsWidth;
              if (currentLeft + this.$size.scrollerWidth < newLeft + this.characterWidth) {
                this.session.setScrollLeft(Math.round(newLeft + this.characterWidth - this.$size.scrollerWidth));
              } else if (currentLeft <= this.$padding && newLeft - currentLeft < this.characterWidth) {
                this.session.setScrollLeft(0);
              }
            }
          };
          VirtualRenderer2.prototype.getScrollTop = function() {
            return this.session.getScrollTop();
          };
          VirtualRenderer2.prototype.getScrollLeft = function() {
            return this.session.getScrollLeft();
          };
          VirtualRenderer2.prototype.getScrollTopRow = function() {
            return this.scrollTop / this.lineHeight;
          };
          VirtualRenderer2.prototype.getScrollBottomRow = function() {
            return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
          };
          VirtualRenderer2.prototype.scrollToRow = function(row) {
            this.session.setScrollTop(row * this.lineHeight);
          };
          VirtualRenderer2.prototype.alignCursor = function(cursor, alignment) {
            if (typeof cursor == "number")
              cursor = { row: cursor, column: 0 };
            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var h3 = this.$size.scrollerHeight - this.lineHeight;
            var offset = pos.top - h3 * (alignment || 0);
            this.session.setScrollTop(offset);
            return offset;
          };
          VirtualRenderer2.prototype.$calcSteps = function(fromValue, toValue) {
            var i2 = 0;
            var l = this.STEPS;
            var steps = [];
            var func = function(t2, x_min, dx) {
              return dx * (Math.pow(t2 - 1, 3) + 1) + x_min;
            };
            for (i2 = 0; i2 < l; ++i2)
              steps.push(func(i2 / this.STEPS, fromValue, toValue - fromValue));
            return steps;
          };
          VirtualRenderer2.prototype.scrollToLine = function(line, center, animate, callback) {
            var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });
            var offset = pos.top;
            if (center)
              offset -= this.$size.scrollerHeight / 2;
            var initialScroll = this.scrollTop;
            this.session.setScrollTop(offset);
            if (animate !== false)
              this.animateScrolling(initialScroll, callback);
          };
          VirtualRenderer2.prototype.animateScrolling = function(fromValue, callback) {
            var toValue = this.scrollTop;
            if (!this.$animatedScroll)
              return;
            var _self = this;
            if (fromValue == toValue)
              return;
            if (this.$scrollAnimation) {
              var oldSteps = this.$scrollAnimation.steps;
              if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                  return;
              }
            }
            var steps = _self.$calcSteps(fromValue, toValue);
            this.$scrollAnimation = { from: fromValue, to: toValue, steps };
            clearInterval(this.$timer);
            _self.session.setScrollTop(steps.shift());
            _self.session.$scrollTop = toValue;
            function endAnimation() {
              _self.$timer = clearInterval(_self.$timer);
              _self.$scrollAnimation = null;
              _self.$stopAnimation = false;
              callback && callback();
            }
            this.$timer = setInterval(function() {
              if (_self.$stopAnimation) {
                endAnimation();
                return;
              }
              if (!_self.session)
                return clearInterval(_self.$timer);
              if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
              } else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
              } else {
                endAnimation();
              }
            }, 10);
          };
          VirtualRenderer2.prototype.scrollToY = function(scrollTop) {
            if (this.scrollTop !== scrollTop) {
              this.$loop.schedule(this.CHANGE_SCROLL);
              this.scrollTop = scrollTop;
            }
          };
          VirtualRenderer2.prototype.scrollToX = function(scrollLeft) {
            if (this.scrollLeft !== scrollLeft)
              this.scrollLeft = scrollLeft;
            this.$loop.schedule(this.CHANGE_H_SCROLL);
          };
          VirtualRenderer2.prototype.scrollTo = function(x2, y3) {
            this.session.setScrollTop(y3);
            this.session.setScrollLeft(x2);
          };
          VirtualRenderer2.prototype.scrollBy = function(deltaX, deltaY) {
            deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
            deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
          };
          VirtualRenderer2.prototype.isScrollableBy = function(deltaX, deltaY) {
            if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
              return true;
            if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
              return true;
            if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
              return true;
            if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right)
              return true;
          };
          VirtualRenderer2.prototype.pixelToScreenCoordinates = function(x2, y3) {
            var canvasPos;
            if (this.$hasCssTransforms) {
              canvasPos = { top: 0, left: 0 };
              var p = this.$fontMetrics.transformCoordinates([x2, y3]);
              x2 = p[1] - this.gutterWidth - this.margin.left;
              y3 = p[0];
            } else {
              canvasPos = this.scroller.getBoundingClientRect();
            }
            var offsetX = x2 + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var row = Math.floor((y3 + this.scrollTop - canvasPos.top) / this.lineHeight);
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
            return { row, column: col, side: offset - col > 0 ? 1 : -1, offsetX };
          };
          VirtualRenderer2.prototype.screenToTextCoordinates = function(x2, y3) {
            var canvasPos;
            if (this.$hasCssTransforms) {
              canvasPos = { top: 0, left: 0 };
              var p = this.$fontMetrics.transformCoordinates([x2, y3]);
              x2 = p[1] - this.gutterWidth - this.margin.left;
              y3 = p[0];
            } else {
              canvasPos = this.scroller.getBoundingClientRect();
            }
            var offsetX = x2 + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
            var row = Math.floor((y3 + this.scrollTop - canvasPos.top) / this.lineHeight);
            return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
          };
          VirtualRenderer2.prototype.textToScreenCoordinates = function(row, column) {
            var canvasPos = this.scroller.getBoundingClientRect();
            var pos = this.session.documentToScreenPosition(row, column);
            var x2 = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row) ? this.session.$bidiHandler.getPosLeft(pos.column) : Math.round(pos.column * this.characterWidth));
            var y3 = pos.row * this.lineHeight;
            return {
              pageX: canvasPos.left + x2 - this.scrollLeft,
              pageY: canvasPos.top + y3 - this.scrollTop
            };
          };
          VirtualRenderer2.prototype.visualizeFocus = function() {
            dom.addCssClass(this.container, "ace_focus");
          };
          VirtualRenderer2.prototype.visualizeBlur = function() {
            dom.removeCssClass(this.container, "ace_focus");
          };
          VirtualRenderer2.prototype.showComposition = function(composition) {
            this.$composition = composition;
            if (!composition.cssText) {
              composition.cssText = this.textarea.style.cssText;
            }
            if (composition.useTextareaForIME == void 0)
              composition.useTextareaForIME = this.$useTextareaForIME;
            if (this.$useTextareaForIME) {
              dom.addCssClass(this.textarea, "ace_composition");
              this.textarea.style.cssText = "";
              this.$moveTextAreaToCursor();
              this.$cursorLayer.element.style.display = "none";
            } else {
              composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
            }
          };
          VirtualRenderer2.prototype.setCompositionText = function(text) {
            var cursor = this.session.selection.cursor;
            this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
            this.$moveTextAreaToCursor();
          };
          VirtualRenderer2.prototype.hideComposition = function() {
            if (!this.$composition)
              return;
            if (this.$composition.markerId)
              this.session.removeMarker(this.$composition.markerId);
            dom.removeCssClass(this.textarea, "ace_composition");
            this.textarea.style.cssText = this.$composition.cssText;
            var cursor = this.session.selection.cursor;
            this.removeExtraToken(cursor.row, cursor.column);
            this.$composition = null;
            this.$cursorLayer.element.style.display = "";
          };
          VirtualRenderer2.prototype.setGhostText = function(text, position) {
            var cursor = this.session.selection.cursor;
            var insertPosition = position || { row: cursor.row, column: cursor.column };
            this.removeGhostText();
            var textLines = text.split("\n");
            this.addToken(textLines[0], "ghost_text", insertPosition.row, insertPosition.column);
            this.$ghostText = {
              text,
              position: {
                row: insertPosition.row,
                column: insertPosition.column
              }
            };
            if (textLines.length > 1) {
              this.$ghostTextWidget = {
                text: textLines.slice(1).join("\n"),
                row: insertPosition.row,
                column: insertPosition.column,
                className: "ace_ghost_text"
              };
              this.session.widgetManager.addLineWidget(this.$ghostTextWidget);
            }
          };
          VirtualRenderer2.prototype.removeGhostText = function() {
            if (!this.$ghostText)
              return;
            var position = this.$ghostText.position;
            this.removeExtraToken(position.row, position.column);
            if (this.$ghostTextWidget) {
              this.session.widgetManager.removeLineWidget(this.$ghostTextWidget);
              this.$ghostTextWidget = null;
            }
            this.$ghostText = null;
          };
          VirtualRenderer2.prototype.addToken = function(text, type, row, column) {
            var session = this.session;
            session.bgTokenizer.lines[row] = null;
            var newToken = { type, value: text };
            var tokens = session.getTokens(row);
            if (column == null || !tokens.length) {
              tokens.push(newToken);
            } else {
              var l = 0;
              for (var i2 = 0; i2 < tokens.length; i2++) {
                var token = tokens[i2];
                l += token.value.length;
                if (column <= l) {
                  var diff = token.value.length - (l - column);
                  var before = token.value.slice(0, diff);
                  var after = token.value.slice(diff);
                  tokens.splice(i2, 1, { type: token.type, value: before }, newToken, { type: token.type, value: after });
                  break;
                }
              }
            }
            this.updateLines(row, row);
          };
          VirtualRenderer2.prototype.removeExtraToken = function(row, column) {
            this.session.bgTokenizer.lines[row] = null;
            this.updateLines(row, row);
          };
          VirtualRenderer2.prototype.setTheme = function(theme, cb) {
            var _self = this;
            this.$themeId = theme;
            _self._dispatchEvent("themeChange", { theme });
            if (!theme || typeof theme == "string") {
              var moduleName = theme || this.$options.theme.initialValue;
              config.loadModule(["theme", moduleName], afterLoad);
            } else {
              afterLoad(theme);
            }
            function afterLoad(module4) {
              if (_self.$themeId != theme)
                return cb && cb();
              if (!module4 || !module4.cssClass)
                throw new Error("couldn't load module " + theme + " or it didn't call define");
              if (module4.$id)
                _self.$themeId = module4.$id;
              dom.importCssString(module4.cssText, module4.cssClass, _self.container);
              if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);
              var padding = "padding" in module4 ? module4.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
              if (_self.$padding && padding != _self.$padding)
                _self.setPadding(padding);
              _self.$theme = module4.cssClass;
              _self.theme = module4;
              dom.addCssClass(_self.container, module4.cssClass);
              dom.setCssClass(_self.container, "ace_dark", module4.isDark);
              if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
              }
              _self._dispatchEvent("themeLoaded", { theme: module4 });
              cb && cb();
            }
          };
          VirtualRenderer2.prototype.getTheme = function() {
            return this.$themeId;
          };
          VirtualRenderer2.prototype.setStyle = function(style, include) {
            dom.setCssClass(this.container, style, include !== false);
          };
          VirtualRenderer2.prototype.unsetStyle = function(style) {
            dom.removeCssClass(this.container, style);
          };
          VirtualRenderer2.prototype.setCursorStyle = function(style) {
            dom.setStyle(this.scroller.style, "cursor", style);
          };
          VirtualRenderer2.prototype.setMouseCursor = function(cursorStyle) {
            dom.setStyle(this.scroller.style, "cursor", cursorStyle);
          };
          VirtualRenderer2.prototype.attachToShadowRoot = function() {
            dom.importCssString(editorCss, "ace_editor.css", this.container);
          };
          VirtualRenderer2.prototype.destroy = function() {
            this.freeze();
            this.$fontMetrics.destroy();
            this.$cursorLayer.destroy();
            this.removeAllListeners();
            this.container.textContent = "";
            this.setOption("useResizeObserver", false);
          };
          VirtualRenderer2.prototype.$updateCustomScrollbar = function(val) {
            var _self = this;
            this.$horizScroll = this.$vScroll = null;
            this.scrollBarV.element.remove();
            this.scrollBarH.element.remove();
            if (this.$scrollDecorator) {
              delete this.$scrollDecorator;
            }
            if (val === true) {
              this.scrollBarV = new VScrollBarCustom(this.container, this);
              this.scrollBarH = new HScrollBarCustom(this.container, this);
              this.scrollBarV.setHeight(this.$size.scrollerHeight);
              this.scrollBarH.setWidth(this.$size.scrollerWidth);
              this.scrollBarV.addEventListener("scroll", function(e2) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollTop(e2.data - _self.scrollMargin.top);
              });
              this.scrollBarH.addEventListener("scroll", function(e2) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollLeft(e2.data - _self.scrollMargin.left);
              });
              this.$scrollDecorator = new Decorator(this.scrollBarV, this);
              this.$scrollDecorator.$updateDecorators();
            } else {
              this.scrollBarV = new VScrollBar(this.container, this);
              this.scrollBarH = new HScrollBar(this.container, this);
              this.scrollBarV.addEventListener("scroll", function(e2) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollTop(e2.data - _self.scrollMargin.top);
              });
              this.scrollBarH.addEventListener("scroll", function(e2) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollLeft(e2.data - _self.scrollMargin.left);
              });
            }
          };
          VirtualRenderer2.prototype.$addResizeObserver = function() {
            if (!window.ResizeObserver || this.$resizeObserver)
              return;
            var self2 = this;
            this.$resizeTimer = lang.delayedCall(function() {
              if (!self2.destroyed)
                self2.onResize();
            }, 50);
            this.$resizeObserver = new window.ResizeObserver(function(e2) {
              var w2 = e2[0].contentRect.width;
              var h3 = e2[0].contentRect.height;
              if (Math.abs(self2.$size.width - w2) > 1 || Math.abs(self2.$size.height - h3) > 1) {
                self2.$resizeTimer.delay();
              } else {
                self2.$resizeTimer.cancel();
              }
            });
            this.$resizeObserver.observe(this.container);
          };
          return VirtualRenderer2;
        }()
      );
      VirtualRenderer.prototype.CHANGE_CURSOR = 1;
      VirtualRenderer.prototype.CHANGE_MARKER = 2;
      VirtualRenderer.prototype.CHANGE_GUTTER = 4;
      VirtualRenderer.prototype.CHANGE_SCROLL = 8;
      VirtualRenderer.prototype.CHANGE_LINES = 16;
      VirtualRenderer.prototype.CHANGE_TEXT = 32;
      VirtualRenderer.prototype.CHANGE_SIZE = 64;
      VirtualRenderer.prototype.CHANGE_MARKER_BACK = 128;
      VirtualRenderer.prototype.CHANGE_MARKER_FRONT = 256;
      VirtualRenderer.prototype.CHANGE_FULL = 512;
      VirtualRenderer.prototype.CHANGE_H_SCROLL = 1024;
      VirtualRenderer.prototype.$changes = 0;
      VirtualRenderer.prototype.$padding = null;
      VirtualRenderer.prototype.$frozen = false;
      VirtualRenderer.prototype.STEPS = 8;
      oop.implement(VirtualRenderer.prototype, EventEmitter);
      config.defineOptions(VirtualRenderer.prototype, "renderer", {
        useResizeObserver: {
          set: function(value) {
            if (!value && this.$resizeObserver) {
              this.$resizeObserver.disconnect();
              this.$resizeTimer.cancel();
              this.$resizeTimer = this.$resizeObserver = null;
            } else if (value && !this.$resizeObserver) {
              this.$addResizeObserver();
            }
          }
        },
        animatedScroll: { initialValue: false },
        showInvisibles: {
          set: function(value) {
            if (this.$textLayer.setShowInvisibles(value))
              this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: false
        },
        showPrintMargin: {
          set: function() {
            this.$updatePrintMargin();
          },
          initialValue: true
        },
        printMarginColumn: {
          set: function() {
            this.$updatePrintMargin();
          },
          initialValue: 80
        },
        printMargin: {
          set: function(val) {
            if (typeof val == "number")
              this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
          },
          get: function() {
            return this.$showPrintMargin && this.$printMarginColumn;
          }
        },
        showGutter: {
          set: function(show) {
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
          },
          initialValue: true
        },
        useSvgGutterIcons: {
          set: function(value) {
            this.$gutterLayer.$useSvgGutterIcons = value;
          },
          initialValue: false
        },
        showFoldedAnnotations: {
          set: function(value) {
            this.$gutterLayer.$showFoldedAnnotations = value;
          },
          initialValue: false
        },
        fadeFoldWidgets: {
          set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
          },
          initialValue: false
        },
        showFoldWidgets: {
          set: function(show) {
            this.$gutterLayer.setShowFoldWidgets(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
          },
          initialValue: true
        },
        displayIndentGuides: {
          set: function(show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
              this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: true
        },
        highlightIndentGuides: {
          set: function(show) {
            if (this.$textLayer.setHighlightIndentGuides(show) == true) {
              this.$textLayer.$highlightIndentGuide();
            } else {
              this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);
            }
          },
          initialValue: true
        },
        highlightGutterLine: {
          set: function(shouldHighlight) {
            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
            this.$loop.schedule(this.CHANGE_GUTTER);
          },
          initialValue: true
        },
        hScrollBarAlwaysVisible: {
          set: function(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
              this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        vScrollBarAlwaysVisible: {
          set: function(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
              this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        fontSize: {
          set: function(size) {
            if (typeof size == "number")
              size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
          },
          initialValue: 12
        },
        fontFamily: {
          set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
          }
        },
        maxLines: {
          set: function(val) {
            this.updateFull();
          }
        },
        minLines: {
          set: function(val) {
            if (!(this.$minLines < 562949953421311))
              this.$minLines = 0;
            this.updateFull();
          }
        },
        maxPixelHeight: {
          set: function(val) {
            this.updateFull();
          },
          initialValue: 0
        },
        scrollPastEnd: {
          set: function(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
              return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: 0,
          handlesSet: true
        },
        fixedWidthGutter: {
          set: function(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
          }
        },
        customScrollbar: {
          set: function(val) {
            this.$updateCustomScrollbar(val);
          },
          initialValue: false
        },
        theme: {
          set: function(val) {
            this.setTheme(val);
          },
          get: function() {
            return this.$themeId || this.theme;
          },
          initialValue: "./theme/textmate",
          handlesSet: true
        },
        hasCssTransforms: {},
        useTextareaForIME: {
          initialValue: !useragent.isMobile && !useragent.isIE
        }
      });
      exports3.VirtualRenderer = VirtualRenderer;
    });
    ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function(require2, exports3, module3) {
      var oop = require2("../lib/oop");
      var net = require2("../lib/net");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var config = require2("../config");
      function $workerBlob(workerUrl) {
        var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
        try {
          return new Blob([script], { "type": "application/javascript" });
        } catch (e2) {
          var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
          var blobBuilder = new BlobBuilder();
          blobBuilder.append(script);
          return blobBuilder.getBlob("application/javascript");
        }
      }
      function createWorker(workerUrl) {
        if (typeof Worker == "undefined")
          return { postMessage: function() {
          }, terminate: function() {
          } };
        if (config.get("loadWorkerFromBlob")) {
          var blob = $workerBlob(workerUrl);
          var URL2 = window.URL || window.webkitURL;
          var blobURL = URL2.createObjectURL(blob);
          return new Worker(blobURL);
        }
        return new Worker(workerUrl);
      }
      var WorkerClient = function(worker) {
        if (!worker.postMessage)
          worker = this.$createWorkerFromOldConfig.apply(this, arguments);
        this.$worker = worker;
        this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.onMessage = this.onMessage.bind(this);
        this.callbackId = 1;
        this.callbacks = {};
        this.$worker.onmessage = this.onMessage;
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
          if (require2.nameToUrl && !require2.toUrl)
            require2.toUrl = require2.nameToUrl;
          if (config.get("packaged") || !require2.toUrl) {
            workerUrl = workerUrl || config.moduleUrl(mod, "worker");
          } else {
            var normalizePath = this.$normalizePath;
            workerUrl = workerUrl || normalizePath(require2.toUrl("ace/worker/worker.js", null, "_"));
            var tlns = {};
            topLevelNamespaces.forEach(function(ns) {
              tlns[ns] = normalizePath(require2.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
            });
          }
          this.$worker = createWorker(workerUrl);
          if (importScripts) {
            this.send("importScripts", importScripts);
          }
          this.$worker.postMessage({
            init: true,
            tlns,
            module: mod,
            classname
          });
          return this.$worker;
        };
        this.onMessage = function(e2) {
          var msg = e2.data;
          switch (msg.type) {
            case "event":
              this._signal(msg.name, { data: msg.data });
              break;
            case "call":
              var callback = this.callbacks[msg.id];
              if (callback) {
                callback(msg.data);
                delete this.callbacks[msg.id];
              }
              break;
            case "error":
              this.reportError(msg.data);
              break;
            case "log":
              window.console && console.log && console.log.apply(console, msg.data);
              break;
          }
        };
        this.reportError = function(err) {
          window.console && console.error && console.error(err);
        };
        this.$normalizePath = function(path) {
          return net.qualifyURL(path);
        };
        this.terminate = function() {
          this._signal("terminate", {});
          this.deltaQueue = null;
          this.$worker.terminate();
          this.$worker = null;
          if (this.$doc)
            this.$doc.off("change", this.changeListener);
          this.$doc = null;
        };
        this.send = function(cmd, args) {
          this.$worker.postMessage({ command: cmd, args });
        };
        this.call = function(cmd, args, callback) {
          if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
          }
          this.send(cmd, args);
        };
        this.emit = function(event, data) {
          try {
            if (data.data && data.data.err)
              data.data.err = { message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code };
            this.$worker && this.$worker.postMessage({ event, data: { data: data.data } });
          } catch (ex) {
            console.error(ex.stack);
          }
        };
        this.attachToDocument = function(doc) {
          if (this.$doc)
            this.terminate();
          this.$doc = doc;
          this.call("setValue", [doc.getValue()]);
          doc.on("change", this.changeListener, true);
        };
        this.changeListener = function(delta) {
          if (!this.deltaQueue) {
            this.deltaQueue = [];
            setTimeout(this.$sendDeltaQueue, 0);
          }
          if (delta.action == "insert")
            this.deltaQueue.push(delta.start, delta.lines);
          else
            this.deltaQueue.push(delta.start, delta.end);
        };
        this.$sendDeltaQueue = function() {
          var q2 = this.deltaQueue;
          if (!q2) return;
          this.deltaQueue = null;
          if (q2.length > 50 && q2.length > this.$doc.getLength() >> 1) {
            this.call("setValue", [this.$doc.getValue()]);
          } else
            this.emit("change", { data: q2 });
        };
      }).call(WorkerClient.prototype);
      var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
        var main = null;
        var emitSync = false;
        var sender = Object.create(EventEmitter);
        var messageBuffer = [];
        var workerClient = new WorkerClient({
          messageBuffer,
          terminate: function() {
          },
          postMessage: function(e2) {
            messageBuffer.push(e2);
            if (!main) return;
            if (emitSync)
              setTimeout(processNext);
            else
              processNext();
          }
        });
        workerClient.setEmitSync = function(val) {
          emitSync = val;
        };
        var processNext = function() {
          var msg = messageBuffer.shift();
          if (msg.command)
            main[msg.command].apply(main, msg.args);
          else if (msg.event)
            sender._signal(msg.event, msg.data);
        };
        sender.postMessage = function(msg) {
          workerClient.onMessage({ data: msg });
        };
        sender.callback = function(data, callbackId) {
          this.postMessage({ type: "call", id: callbackId, data });
        };
        sender.emit = function(name, data) {
          this.postMessage({ type: "event", name, data });
        };
        config.loadModule(["worker", mod], function(Main) {
          main = new Main[classname](sender);
          while (messageBuffer.length)
            processNext();
        });
        return workerClient;
      };
      exports3.UIWorkerClient = UIWorkerClient;
      exports3.WorkerClient = WorkerClient;
      exports3.createWorker = createWorker;
    });
    ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function(require2, exports3, module3) {
      var Range = require2("./range").Range;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var oop = require2("./lib/oop");
      var PlaceHolder = (
        /** @class */
        function() {
          function PlaceHolder2(session, length, pos, others, mainClass, othersClass) {
            var _self = this;
            this.length = length;
            this.session = session;
            this.doc = session.getDocument();
            this.mainClass = mainClass;
            this.othersClass = othersClass;
            this.$onUpdate = this.onUpdate.bind(this);
            this.doc.on("change", this.$onUpdate, true);
            this.$others = others;
            this.$onCursorChange = function() {
              setTimeout(function() {
                _self.onCursorChange();
              });
            };
            this.$pos = pos;
            var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || { length: -1 };
            this.$undoStackDepth = undoStack.length;
            this.setup();
            session.selection.on("changeCursor", this.$onCursorChange);
          }
          PlaceHolder2.prototype.setup = function() {
            var _self = this;
            var doc = this.doc;
            var session = this.session;
            this.selectionBefore = session.selection.toJSON();
            if (session.selection.inMultiSelectMode)
              session.selection.toSingleRange();
            this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
            var pos = this.pos;
            pos.$insertRight = true;
            pos.detach();
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
            this.others = [];
            this.$others.forEach(function(other) {
              var anchor = doc.createAnchor(other.row, other.column);
              anchor.$insertRight = true;
              anchor.detach();
              _self.others.push(anchor);
            });
            session.setUndoSelect(false);
          };
          PlaceHolder2.prototype.showOtherMarkers = function() {
            if (this.othersActive)
              return;
            var session = this.session;
            var _self = this;
            this.othersActive = true;
            this.others.forEach(function(anchor) {
              anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
            });
          };
          PlaceHolder2.prototype.hideOtherMarkers = function() {
            if (!this.othersActive)
              return;
            this.othersActive = false;
            for (var i2 = 0; i2 < this.others.length; i2++) {
              this.session.removeMarker(this.others[i2].markerId);
            }
          };
          PlaceHolder2.prototype.onUpdate = function(delta) {
            if (this.$updating)
              return this.updateAnchors(delta);
            var range = delta;
            if (range.start.row !== range.end.row)
              return;
            if (range.start.row !== this.pos.row)
              return;
            this.$updating = true;
            var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
            var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
            var distanceFromStart = range.start.column - this.pos.column;
            this.updateAnchors(delta);
            if (inMainRange)
              this.length += lengthDiff;
            if (inMainRange && !this.session.$fromUndo) {
              if (delta.action === "insert") {
                for (var i2 = this.others.length - 1; i2 >= 0; i2--) {
                  var otherPos = this.others[i2];
                  var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                  this.doc.insertMergedLines(newPos, delta.lines);
                }
              } else if (delta.action === "remove") {
                for (var i2 = this.others.length - 1; i2 >= 0; i2--) {
                  var otherPos = this.others[i2];
                  var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                  this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                }
              }
            }
            this.$updating = false;
            this.updateMarkers();
          };
          PlaceHolder2.prototype.updateAnchors = function(delta) {
            this.pos.onChange(delta);
            for (var i2 = this.others.length; i2--; )
              this.others[i2].onChange(delta);
            this.updateMarkers();
          };
          PlaceHolder2.prototype.updateMarkers = function() {
            if (this.$updating)
              return;
            var _self = this;
            var session = this.session;
            var updateMarker = function(pos, className) {
              session.removeMarker(pos.markerId);
              pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
            };
            updateMarker(this.pos, this.mainClass);
            for (var i2 = this.others.length; i2--; )
              updateMarker(this.others[i2], this.othersClass);
          };
          PlaceHolder2.prototype.onCursorChange = function(event) {
            if (this.$updating || !this.session)
              return;
            var pos = this.session.selection.getCursor();
            if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
              this.showOtherMarkers();
              this._emit("cursorEnter", event);
            } else {
              this.hideOtherMarkers();
              this._emit("cursorLeave", event);
            }
          };
          PlaceHolder2.prototype.detach = function() {
            this.session.removeMarker(this.pos && this.pos.markerId);
            this.hideOtherMarkers();
            this.doc.off("change", this.$onUpdate);
            this.session.selection.off("changeCursor", this.$onCursorChange);
            this.session.setUndoSelect(true);
            this.session = null;
          };
          PlaceHolder2.prototype.cancel = function() {
            if (this.$undoStackDepth === -1)
              return;
            var undoManager = this.session.getUndoManager();
            var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
            for (var i2 = 0; i2 < undosRequired; i2++) {
              undoManager.undo(this.session, true);
            }
            if (this.selectionBefore)
              this.session.selection.fromJSON(this.selectionBefore);
          };
          return PlaceHolder2;
        }()
      );
      oop.implement(PlaceHolder.prototype, EventEmitter);
      exports3.PlaceHolder = PlaceHolder;
    });
    ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require2, exports3, module3) {
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      function onMouseDown(e2) {
        var ev = e2.domEvent;
        var alt = ev.altKey;
        var shift = ev.shiftKey;
        var ctrl = ev.ctrlKey;
        var accel = e2.getAccelKey();
        var button2 = e2.getButton();
        if (ctrl && useragent.isMac)
          button2 = ev.button;
        if (e2.editor.inMultiSelectMode && button2 == 2) {
          e2.editor.textInput.onContextMenu(e2.domEvent);
          return;
        }
        if (!ctrl && !alt && !accel) {
          if (button2 === 0 && e2.editor.inMultiSelectMode)
            e2.editor.exitMultiSelectMode();
          return;
        }
        if (button2 !== 0)
          return;
        var editor = e2.editor;
        var selection = editor.selection;
        var isMultiSelect = editor.inMultiSelectMode;
        var pos = e2.getDocumentPosition();
        var cursor = selection.getCursor();
        var inSelection = e2.inSelection() || selection.isEmpty() && isSamePoint(pos, cursor);
        var mouseX = e2.x, mouseY = e2.y;
        var onMouseSelection = function(e3) {
          mouseX = e3.clientX;
          mouseY = e3.clientY;
        };
        var session = editor.session;
        var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
        var screenCursor = screenAnchor;
        var selectionMode;
        if (editor.$mouseHandler.$enableJumpToDef) {
          if (ctrl && alt || accel && alt)
            selectionMode = shift ? "block" : "add";
          else if (alt && editor.$blockSelectEnabled)
            selectionMode = "block";
        } else {
          if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift)
              return;
          } else if (alt && editor.$blockSelectEnabled) {
            selectionMode = "block";
          }
        }
        if (selectionMode && useragent.isMac && ev.ctrlKey) {
          editor.$mouseHandler.cancelContextMenu();
        }
        if (selectionMode == "add") {
          if (!isMultiSelect && inSelection)
            return;
          if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
          }
          var oldRange = selection.rangeList.rangeAtPoint(pos);
          editor.inVirtualSelectionMode = true;
          if (shift) {
            oldRange = null;
            range = selection.ranges[0] || range;
            editor.removeSelectionMarker(range);
          }
          editor.once("mouseup", function() {
            var tmpSel = selection.toOrientedRange();
            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
              selection.substractPoint(tmpSel.cursor);
            else {
              if (shift) {
                selection.substractPoint(range.cursor);
              } else if (range) {
                editor.removeSelectionMarker(range);
                selection.addRange(range);
              }
              selection.addRange(tmpSel);
            }
            editor.inVirtualSelectionMode = false;
          });
        } else if (selectionMode == "block") {
          e2.stop();
          editor.inVirtualSelectionMode = true;
          var initialRange;
          var rectSel = [];
          var blockSelect = function() {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor2 = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);
            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor2, selection.lead))
              return;
            screenCursor = newCursor;
            editor.selection.moveToPosition(cursor2);
            editor.renderer.scrollCursorIntoView();
            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
              rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
          };
          if (isMultiSelect && !accel) {
            selection.toSingleRange();
          } else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
          }
          if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);
          else
            selection.moveToPosition(pos);
          screenCursor = { row: -1, column: -1 };
          var onMouseSelectionEnd = function(e3) {
            blockSelect();
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
              rectSel = [selection.toOrientedRange()];
            if (initialRange) {
              editor.removeSelectionMarker(initialRange);
              selection.toSingleRange(initialRange);
            }
            for (var i2 = 0; i2 < rectSel.length; i2++)
              selection.addRange(rectSel[i2]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
          };
          var onSelectionInterval = blockSelect;
          event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
          var timerId = setInterval(function() {
            onSelectionInterval();
          }, 20);
          return e2.preventDefault();
        }
      }
      exports3.onMouseDown = onMouseDown;
    });
    ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function(require2, exports3, module3) {
      exports3.defaultCommands = [{
        name: "addCursorAbove",
        description: "Add cursor above",
        exec: function(editor) {
          editor.selectMoreLines(-1);
        },
        bindKey: { win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorBelow",
        description: "Add cursor below",
        exec: function(editor) {
          editor.selectMoreLines(1);
        },
        bindKey: { win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorAboveSkipCurrent",
        description: "Add cursor above (skip current)",
        exec: function(editor) {
          editor.selectMoreLines(-1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorBelowSkipCurrent",
        description: "Add cursor below (skip current)",
        exec: function(editor) {
          editor.selectMoreLines(1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectMoreBefore",
        description: "Select more before",
        exec: function(editor) {
          editor.selectMore(-1);
        },
        bindKey: { win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectMoreAfter",
        description: "Select more after",
        exec: function(editor) {
          editor.selectMore(1);
        },
        bindKey: { win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectNextBefore",
        description: "Select next before",
        exec: function(editor) {
          editor.selectMore(-1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectNextAfter",
        description: "Select next after",
        exec: function(editor) {
          editor.selectMore(1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "toggleSplitSelectionIntoLines",
        description: "Split selection into lines",
        exec: function(editor) {
          if (editor.multiSelect.rangeCount > 1)
            editor.multiSelect.joinSelections();
          else
            editor.multiSelect.splitIntoLines();
        },
        bindKey: { win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L" },
        readOnly: true
      }, {
        name: "splitSelectionIntoLines",
        description: "Split into lines",
        exec: function(editor) {
          editor.multiSelect.splitIntoLines();
        },
        readOnly: true
      }, {
        name: "alignCursors",
        description: "Align cursors",
        exec: function(editor) {
          editor.alignCursors();
        },
        bindKey: { win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A" },
        scrollIntoView: "cursor"
      }, {
        name: "findAll",
        description: "Find all",
        exec: function(editor) {
          editor.findAll();
        },
        bindKey: { win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G" },
        scrollIntoView: "cursor",
        readOnly: true
      }];
      exports3.multiSelectCommands = [{
        name: "singleSelection",
        description: "Single selection",
        bindKey: "esc",
        exec: function(editor) {
          editor.exitMultiSelectMode();
        },
        scrollIntoView: "cursor",
        readOnly: true,
        isAvailable: function(editor) {
          return editor && editor.inMultiSelectMode;
        }
      }];
      var HashHandler = require2("../keyboard/hash_handler").HashHandler;
      exports3.keyboardHandler = new HashHandler(exports3.multiSelectCommands);
    });
    ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function(require2, exports3, module3) {
      var RangeList = require2("./range_list").RangeList;
      var Range = require2("./range").Range;
      var Selection = require2("./selection").Selection;
      var onMouseDown = require2("./mouse/multi_select_handler").onMouseDown;
      var event = require2("./lib/event");
      var lang = require2("./lib/lang");
      var commands = require2("./commands/multi_select_commands");
      exports3.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
      var Search = require2("./search").Search;
      var search = new Search();
      function find(session, needle, dir) {
        search.$options.wrap = true;
        search.$options.needle = needle;
        search.$options.backwards = dir == -1;
        return search.find(session);
      }
      var EditSession = require2("./edit_session").EditSession;
      (function() {
        this.getSelectionMarkers = function() {
          return this.$selectionMarkers;
        };
      }).call(EditSession.prototype);
      (function() {
        this.ranges = null;
        this.rangeList = null;
        this.addRange = function(range, $blockChangeEvents) {
          if (!range)
            return;
          if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
              this.rangeList.removeAll();
              return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
          }
          if (!range.cursor)
            range.cursor = range.end;
          var removed = this.rangeList.add(range);
          this.$onAddRange(range);
          if (removed.length)
            this.$onRemoveRange(removed);
          if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
          }
          return $blockChangeEvents || this.fromOrientedRange(range);
        };
        this.toSingleRange = function(range) {
          range = range || this.ranges[0];
          var removed = this.rangeList.removeAll();
          if (removed.length)
            this.$onRemoveRange(removed);
          range && this.fromOrientedRange(range);
        };
        this.substractPoint = function(pos) {
          var removed = this.rangeList.substractPoint(pos);
          if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
          }
        };
        this.mergeOverlappingRanges = function() {
          var removed = this.rangeList.merge();
          if (removed.length)
            this.$onRemoveRange(removed);
        };
        this.$onAddRange = function(range) {
          this.rangeCount = this.rangeList.ranges.length;
          this.ranges.unshift(range);
          this._signal("addRange", { range });
        };
        this.$onRemoveRange = function(removed) {
          this.rangeCount = this.rangeList.ranges.length;
          if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
          }
          for (var i2 = removed.length; i2--; ) {
            var index = this.ranges.indexOf(removed[i2]);
            this.ranges.splice(index, 1);
          }
          this._signal("removeRange", { ranges: removed });
          if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
          }
          lastRange = lastRange || this.ranges[0];
          if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
        };
        this.$initRangeList = function() {
          if (this.rangeList)
            return;
          this.rangeList = new RangeList();
          this.ranges = [];
          this.rangeCount = 0;
        };
        this.getAllRanges = function() {
          return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
        };
        this.splitIntoLines = function() {
          var ranges = this.ranges.length ? this.ranges : [this.getRange()];
          var newRanges = [];
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var range = ranges[i2];
            var row = range.start.row;
            var endRow = range.end.row;
            if (row === endRow) {
              newRanges.push(range.clone());
            } else {
              newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
              while (++row < endRow)
                newRanges.push(this.getLineRange(row, true));
              newRanges.push(new Range(endRow, 0, endRow, range.end.column));
            }
            if (i2 == 0 && !this.isBackwards())
              newRanges = newRanges.reverse();
          }
          this.toSingleRange();
          for (var i2 = newRanges.length; i2--; )
            this.addRange(newRanges[i2]);
        };
        this.joinSelections = function() {
          var ranges = this.rangeList.ranges;
          var lastRange = ranges[ranges.length - 1];
          var range = Range.fromPoints(ranges[0].start, lastRange.end);
          this.toSingleRange();
          this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        };
        this.toggleBlockSelection = function() {
          if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);
            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
          } else {
            var cursor = this.session.documentToScreenPosition(this.cursor);
            var anchor = this.session.documentToScreenPosition(this.anchor);
            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
          }
        };
        this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
          var rectSel = [];
          var xBackwards = screenCursor.column < screenAnchor.column;
          if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
            var startOffsetX = screenCursor.offsetX;
            var endOffsetX = screenAnchor.offsetX;
          } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
            var startOffsetX = screenAnchor.offsetX;
            var endOffsetX = screenCursor.offsetX;
          }
          var yBackwards = screenCursor.row < screenAnchor.row;
          if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
          } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
          }
          if (startColumn < 0)
            startColumn = 0;
          if (startRow < 0)
            startRow = 0;
          if (startRow == endRow)
            includeEmptyLines = true;
          var docEnd;
          for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));
            if (range.isEmpty()) {
              if (docEnd && isSamePoint(range.end, docEnd))
                break;
              docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
          }
          if (yBackwards)
            rectSel.reverse();
          if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
              end--;
            if (end > 0) {
              var start = 0;
              while (rectSel[start].isEmpty())
                start++;
            }
            for (var i2 = end; i2 >= start; i2--) {
              if (rectSel[i2].isEmpty())
                rectSel.splice(i2, 1);
            }
          }
          return rectSel;
        };
      }).call(Selection.prototype);
      var Editor = require2("./editor").Editor;
      (function() {
        this.updateSelectionMarkers = function() {
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.addSelectionMarker = function(orientedRange) {
          if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;
          var style = this.getSelectionStyle();
          orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
          this.session.$selectionMarkers.push(orientedRange);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
          return orientedRange;
        };
        this.removeSelectionMarker = function(range) {
          if (!range.marker)
            return;
          this.session.removeMarker(range.marker);
          var index = this.session.$selectionMarkers.indexOf(range);
          if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        };
        this.removeSelectionMarkers = function(ranges) {
          var markerList = this.session.$selectionMarkers;
          for (var i2 = ranges.length; i2--; ) {
            var range = ranges[i2];
            if (!range.marker)
              continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
              markerList.splice(index, 1);
          }
          this.session.selectionMarkerCount = markerList.length;
        };
        this.$onAddRange = function(e2) {
          this.addSelectionMarker(e2.range);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onRemoveRange = function(e2) {
          this.removeSelectionMarkers(e2.ranges);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onMultiSelect = function(e2) {
          if (this.inMultiSelectMode)
            return;
          this.inMultiSelectMode = true;
          this.setStyle("ace_multiselect");
          this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
          this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onSingleSelect = function(e2) {
          if (this.session.multiSelect.inVirtualMode)
            return;
          this.inMultiSelectMode = false;
          this.unsetStyle("ace_multiselect");
          this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
          this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
          this._emit("changeSelection");
        };
        this.$onMultiSelectExec = function(e2) {
          var command = e2.command;
          var editor = e2.editor;
          if (!editor.multiSelect)
            return;
          if (!command.multiSelectAction) {
            var result = command.exec(editor, e2.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
          } else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e2.args);
          } else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e2.args, true);
          } else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e2.args || {});
          } else {
            result = command.multiSelectAction(editor, e2.args || {});
          }
          return result;
        };
        this.forEachSelection = function(cmd, args, options) {
          if (this.inVirtualSelectionMode)
            return;
          var keepOrder = options && options.keepOrder;
          var $byLines = options == true || options && options.$byLines;
          var session = this.session;
          var selection = this.selection;
          var rangeList = selection.rangeList;
          var ranges = (keepOrder ? selection : rangeList).ranges;
          var result;
          if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
          var reg = selection._eventRegistry;
          selection._eventRegistry = {};
          var tmpSel = new Selection(session);
          this.inVirtualSelectionMode = true;
          for (var i2 = ranges.length; i2--; ) {
            if ($byLines) {
              while (i2 > 0 && ranges[i2].start.row == ranges[i2 - 1].end.row)
                i2--;
            }
            tmpSel.fromOrientedRange(ranges[i2]);
            tmpSel.index = i2;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== void 0)
              result = cmdResult;
            tmpSel.toOrientedRange(ranges[i2]);
          }
          tmpSel.detach();
          this.selection = session.selection = selection;
          this.inVirtualSelectionMode = false;
          selection._eventRegistry = reg;
          selection.mergeOverlappingRanges();
          if (selection.ranges[0])
            selection.fromOrientedRange(selection.ranges[0]);
          var anim = this.renderer.$scrollAnimation;
          this.onCursorChange();
          this.onSelectionChange();
          if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);
          return result;
        };
        this.exitMultiSelectMode = function() {
          if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
          this.multiSelect.toSingleRange();
        };
        this.getSelectedText = function() {
          var text = "";
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i2 = 0; i2 < ranges.length; i2++) {
              buf.push(this.session.getTextRange(ranges[i2]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
              text = "";
          } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
          }
          return text;
        };
        this.$checkMultiselectChange = function(e2, anchor) {
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
              return;
            var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
            if (pos.row != anchor.row || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
              this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
            else
              this.multiSelect.mergeOverlappingRanges();
          }
        };
        this.findAll = function(needle, options, additive) {
          options = options || {};
          options.needle = needle || options.needle;
          if (options.needle == void 0) {
            var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
          }
          this.$search.set(options);
          var ranges = this.$search.findAll(this.session);
          if (!ranges.length)
            return 0;
          var selection = this.multiSelect;
          if (!additive)
            selection.toSingleRange(ranges[0]);
          for (var i2 = ranges.length; i2--; )
            selection.addRange(ranges[i2], true);
          if (range && selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);
          return ranges.length;
        };
        this.selectMoreLines = function(dir, skip) {
          var range = this.selection.toOrientedRange();
          var isBackwards = range.cursor == range.end;
          var screenLead = this.session.documentToScreenPosition(range.cursor);
          if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;
          var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
          if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
          } else {
            var anchor = lead;
          }
          if (isBackwards) {
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
          } else {
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
          }
          newRange.desiredColumn = screenLead.column;
          if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
          } else {
            if (skip)
              var toRemove = range.cursor;
          }
          this.selection.addRange(newRange);
          if (toRemove)
            this.selection.substractPoint(toRemove);
        };
        this.transposeSelections = function(dir) {
          var session = this.session;
          var sel = session.multiSelect;
          var all = sel.ranges;
          for (var i2 = all.length; i2--; ) {
            var range = all[i2];
            if (range.isEmpty()) {
              var tmp = session.getWordRange(range.start.row, range.start.column);
              range.start.row = tmp.start.row;
              range.start.column = tmp.start.column;
              range.end.row = tmp.end.row;
              range.end.column = tmp.end.column;
            }
          }
          sel.mergeOverlappingRanges();
          var words = [];
          for (var i2 = all.length; i2--; ) {
            var range = all[i2];
            words.unshift(session.getTextRange(range));
          }
          if (dir < 0)
            words.unshift(words.pop());
          else
            words.push(words.shift());
          for (var i2 = all.length; i2--; ) {
            var range = all[i2];
            var tmp = range.clone();
            session.replace(range, words[i2]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
          }
          sel.fromOrientedRange(sel.ranges[0]);
        };
        this.selectMore = function(dir, skip, stopAtFirst) {
          var session = this.session;
          var sel = session.multiSelect;
          var range = sel.toOrientedRange();
          if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
              return;
          }
          var needle = session.getTextRange(range);
          var newRange = find(session, needle, dir);
          if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.renderer.scrollCursorIntoView(null, 0.5);
          }
          if (skip)
            this.multiSelect.substractPoint(range.cursor);
        };
        this.alignCursors = function() {
          var session = this.session;
          var sel = session.multiSelect;
          var ranges = sel.ranges;
          var row = -1;
          var sameRowRanges = ranges.filter(function(r) {
            if (r.cursor.row == row)
              return true;
            row = r.cursor.row;
          });
          if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row, lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
              var max = this.session.getLength();
              var line;
              do {
                line = this.session.getLine(lr);
              } while (/[=:]/.test(line) && ++lr < max);
              do {
                line = this.session.getLine(fr);
              } while (/[=:]/.test(line) && --fr > 0);
              if (fr < 0)
                fr = 0;
              if (lr >= max)
                lr = max - 1;
            }
            var lines = this.session.removeFullLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.insert({ row: fr, column: 0 }, lines.join("\n") + "\n");
            if (!guessRange) {
              range.start.column = 0;
              range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
          } else {
            sameRowRanges.forEach(function(r) {
              sel.substractPoint(r.cursor);
            });
            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function(r) {
              var p = r.cursor;
              var line2 = session.getLine(p.row);
              var spaceOffset = line2.substr(p.column).search(/\S/g);
              if (spaceOffset == -1)
                spaceOffset = 0;
              if (p.column > maxCol)
                maxCol = p.column;
              if (spaceOffset < minSpace)
                minSpace = spaceOffset;
              return spaceOffset;
            });
            ranges.forEach(function(r, i2) {
              var p = r.cursor;
              var l = maxCol - p.column;
              var d3 = spaceOffsets[i2] - minSpace;
              if (l > d3)
                session.insert(p, lang.stringRepeat(" ", l - d3));
              else
                session.remove(new Range(p.row, p.column, p.row, p.column - l + d3));
              r.start.column = r.end.column = maxCol;
              r.start.row = r.end.row = p.row;
              r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
          }
        };
        this.$reAlignText = function(lines, forceLeft) {
          var isLeftAligned = true, isRightAligned = true;
          var startW, textW, endW;
          return lines.map(function(line) {
            var m3 = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m3)
              return [line];
            if (startW == null) {
              startW = m3[1].length;
              textW = m3[2].length;
              endW = m3[3].length;
              return m3;
            }
            if (startW + textW + endW != m3[1].length + m3[2].length + m3[3].length)
              isRightAligned = false;
            if (startW != m3[1].length)
              isLeftAligned = false;
            if (startW > m3[1].length)
              startW = m3[1].length;
            if (textW < m3[2].length)
              textW = m3[2].length;
            if (endW > m3[3].length)
              endW = m3[3].length;
            return m3;
          }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
          function spaces(n) {
            return lang.stringRepeat(" ", n);
          }
          function alignLeft(m3) {
            return !m3[2] ? m3[0] : spaces(startW) + m3[2] + spaces(textW - m3[2].length + endW) + m3[4].replace(/^([=:])\s+/, "$1 ");
          }
          function alignRight(m3) {
            return !m3[2] ? m3[0] : spaces(startW + textW - m3[2].length) + m3[2] + spaces(endW) + m3[4].replace(/^([=:])\s+/, "$1 ");
          }
          function unAlign(m3) {
            return !m3[2] ? m3[0] : spaces(startW) + m3[2] + spaces(endW) + m3[4].replace(/^([=:])\s+/, "$1 ");
          }
        };
      }).call(Editor.prototype);
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      exports3.onSessionChange = function(e2) {
        var session = e2.session;
        if (session && !session.multiSelect) {
          session.$selectionMarkers = [];
          session.selection.$initRangeList();
          session.multiSelect = session.selection;
        }
        this.multiSelect = session && session.multiSelect;
        var oldSession = e2.oldSession;
        if (oldSession) {
          oldSession.multiSelect.off("addRange", this.$onAddRange);
          oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
          oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
          oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
          oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
          oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
        }
        if (session) {
          session.multiSelect.on("addRange", this.$onAddRange);
          session.multiSelect.on("removeRange", this.$onRemoveRange);
          session.multiSelect.on("multiSelect", this.$onMultiSelect);
          session.multiSelect.on("singleSelect", this.$onSingleSelect);
          session.multiSelect.lead.on("change", this.$checkMultiselectChange);
          session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
        }
        if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
          if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
          else
            this.$onSingleSelect();
        }
      };
      function MultiSelect(editor) {
        if (editor.$multiselectOnSessionChange)
          return;
        editor.$onAddRange = editor.$onAddRange.bind(editor);
        editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
        editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
        editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
        editor.$multiselectOnSessionChange = exports3.onSessionChange.bind(editor);
        editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
        editor.$multiselectOnSessionChange(editor);
        editor.on("changeSession", editor.$multiselectOnSessionChange);
        editor.on("mousedown", onMouseDown);
        editor.commands.addCommands(commands.defaultCommands);
        addAltCursorListeners(editor);
      }
      function addAltCursorListeners(editor) {
        if (!editor.textInput)
          return;
        var el = editor.textInput.getElement();
        var altCursor = false;
        event.addListener(el, "keydown", function(e2) {
          var altDown = e2.keyCode == 18 && !(e2.ctrlKey || e2.shiftKey || e2.metaKey);
          if (editor.$blockSelectEnabled && altDown) {
            if (!altCursor) {
              editor.renderer.setMouseCursor("crosshair");
              altCursor = true;
            }
          } else if (altCursor) {
            reset();
          }
        }, editor);
        event.addListener(el, "keyup", reset, editor);
        event.addListener(el, "blur", reset, editor);
        function reset(e2) {
          if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
          }
        }
      }
      exports3.MultiSelect = MultiSelect;
      require2("./config").defineOptions(Editor.prototype, "editor", {
        enableMultiselect: {
          set: function(val) {
            MultiSelect(this);
            if (val) {
              this.on("changeSession", this.$multiselectOnSessionChange);
              this.on("mousedown", onMouseDown);
            } else {
              this.off("changeSession", this.$multiselectOnSessionChange);
              this.off("mousedown", onMouseDown);
            }
          },
          value: true
        },
        enableBlockSelect: {
          set: function(val) {
            this.$blockSelectEnabled = val;
          },
          value: true
        }
      });
    });
    ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function(require2, exports3, module3) {
      var Range = require2("../../range").Range;
      var FoldMode = exports3.FoldMode = function() {
      };
      (function() {
        this.foldingStartMarker = null;
        this.foldingStopMarker = null;
        this.getFoldWidget = function(session, foldStyle, row) {
          var line = session.getLine(row);
          if (this.foldingStartMarker.test(line))
            return "start";
          if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line))
            return "end";
          return "";
        };
        this.getFoldWidgetRange = function(session, foldStyle, row) {
          return null;
        };
        this.indentationBlock = function(session, row, column) {
          var re2 = /\S/;
          var line = session.getLine(row);
          var startLevel = line.search(re2);
          if (startLevel == -1)
            return;
          var startColumn = column || line.length;
          var maxRow = session.getLength();
          var startRow = row;
          var endRow = row;
          while (++row < maxRow) {
            var level = session.getLine(row).search(re2);
            if (level == -1)
              continue;
            if (level <= startLevel) {
              var token = session.getTokenAt(row, 0);
              if (!token || token.type !== "string")
                break;
            }
            endRow = row;
          }
          if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
          }
        };
        this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
          var start = { row, column: column + 1 };
          var end = session.$findClosingBracket(bracket, start, typeRe);
          if (!end)
            return;
          var fw = session.foldWidgets[end.row];
          if (fw == null)
            fw = session.getFoldWidget(end.row);
          if (fw == "start" && end.row > start.row) {
            end.row--;
            end.column = session.getLine(end.row).length;
          }
          return Range.fromPoints(start, end);
        };
        this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
          var end = { row, column };
          var start = session.$findOpeningBracket(bracket, end);
          if (!start)
            return;
          start.column++;
          end.column--;
          return Range.fromPoints(start, end);
        };
      }).call(FoldMode.prototype);
    });
    ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/line_widgets", "ace/lib/dom", "ace/range"], function(require2, exports3, module3) {
      var LineWidgets = require2("../line_widgets").LineWidgets;
      var dom = require2("../lib/dom");
      var Range = require2("../range").Range;
      function binarySearch(array, needle, comparator) {
        var first = 0;
        var last = array.length - 1;
        while (first <= last) {
          var mid = first + last >> 1;
          var c2 = comparator(needle, array[mid]);
          if (c2 > 0)
            first = mid + 1;
          else if (c2 < 0)
            last = mid - 1;
          else
            return mid;
        }
        return -(first + 1);
      }
      function findAnnotations(session, row, dir) {
        var annotations = session.getAnnotations().sort(Range.comparePoints);
        if (!annotations.length)
          return;
        var i2 = binarySearch(annotations, { row, column: -1 }, Range.comparePoints);
        if (i2 < 0)
          i2 = -i2 - 1;
        if (i2 >= annotations.length)
          i2 = dir > 0 ? 0 : annotations.length - 1;
        else if (i2 === 0 && dir < 0)
          i2 = annotations.length - 1;
        var annotation = annotations[i2];
        if (!annotation || !dir)
          return;
        if (annotation.row === row) {
          do {
            annotation = annotations[i2 += dir];
          } while (annotation && annotation.row === row);
          if (!annotation)
            return annotations.slice();
        }
        var matched = [];
        row = annotation.row;
        do {
          matched[dir < 0 ? "unshift" : "push"](annotation);
          annotation = annotations[i2 += dir];
        } while (annotation && annotation.row == row);
        return matched.length && matched;
      }
      exports3.showErrorMarker = function(editor, dir) {
        var session = editor.session;
        if (!session.widgetManager) {
          session.widgetManager = new LineWidgets(session);
          session.widgetManager.attach(editor);
        }
        var pos = editor.getCursorPosition();
        var row = pos.row;
        var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w3) {
          return w3.type == "errorMarker";
        })[0];
        if (oldWidget) {
          oldWidget.destroy();
        } else {
          row -= dir;
        }
        var annotations = findAnnotations(session, row, dir);
        var gutterAnno;
        if (annotations) {
          var annotation = annotations[0];
          pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
          pos.row = annotation.row;
          gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
        } else if (oldWidget) {
          return;
        } else {
          gutterAnno = {
            text: ["Looks good!"],
            className: "ace_ok"
          };
        }
        editor.session.unfold(pos.row);
        editor.selection.moveToPosition(pos);
        var w2 = {
          row: pos.row,
          fixedWidth: true,
          coverGutter: true,
          el: dom.createElement("div"),
          type: "errorMarker"
        };
        var el = w2.el.appendChild(dom.createElement("div"));
        var arrow = w2.el.appendChild(dom.createElement("div"));
        arrow.className = "error_widget_arrow " + gutterAnno.className;
        var left = editor.renderer.$cursorLayer.getPixelPosition(pos).left;
        arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
        w2.el.className = "error_widget_wrapper";
        el.className = "error_widget " + gutterAnno.className;
        el.innerHTML = gutterAnno.text.join("<br>");
        el.appendChild(dom.createElement("div"));
        var kb = function(_, hashId, keyString) {
          if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w2.destroy();
            return { command: "null" };
          }
        };
        w2.destroy = function() {
          if (editor.$mouseHandler.isMousePressed)
            return;
          editor.keyBinding.removeKeyboardHandler(kb);
          session.widgetManager.removeLineWidget(w2);
          editor.off("changeSelection", w2.destroy);
          editor.off("changeSession", w2.destroy);
          editor.off("mouseup", w2.destroy);
          editor.off("change", w2.destroy);
        };
        editor.keyBinding.addKeyboardHandler(kb);
        editor.on("changeSelection", w2.destroy);
        editor.on("changeSession", w2.destroy);
        editor.on("mouseup", w2.destroy);
        editor.on("change", w2.destroy);
        editor.session.widgetManager.addLineWidget(w2);
        w2.el.onmousedown = editor.focus.bind(editor);
        editor.renderer.scrollCursorIntoView(null, 0.5, { bottom: w2.el.offsetHeight });
      };
      dom.importCssString("\n    .error_widget_wrapper {\n        background: inherit;\n        color: inherit;\n        border:none\n    }\n    .error_widget {\n        border-top: solid 2px;\n        border-bottom: solid 2px;\n        margin: 5px 0;\n        padding: 10px 40px;\n        white-space: pre-wrap;\n    }\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\n        border-color: #ff5a5a\n    }\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\n        border-color: #F1D817\n    }\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\n        border-color: #5a5a5a\n    }\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\n        border-color: #5aaa5a\n    }\n    .error_widget_arrow {\n        position: absolute;\n        border: solid 5px;\n        border-top-color: transparent!important;\n        border-right-color: transparent!important;\n        border-left-color: transparent!important;\n        top: -5px;\n    }\n", "error_marker.css", false);
    });
    ace.define("ace/ace", ["require", "exports", "module", "ace/lib/dom", "ace/range", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config", "ace/loader_build"], function(require2, exports3, module3) {
      require2("./loader_build")(exports3);
      var dom = require2("./lib/dom");
      var Range = require2("./range").Range;
      var Editor = require2("./editor").Editor;
      var EditSession = require2("./edit_session").EditSession;
      var UndoManager = require2("./undomanager").UndoManager;
      var Renderer = require2("./virtual_renderer").VirtualRenderer;
      require2("./worker/worker_client");
      require2("./keyboard/hash_handler");
      require2("./placeholder");
      require2("./multi_select");
      require2("./mode/folding/fold_mode");
      require2("./theme/textmate");
      require2("./ext/error_marker");
      exports3.config = require2("./config");
      exports3.edit = function(el, options) {
        if (typeof el == "string") {
          var _id = el;
          el = document.getElementById(_id);
          if (!el)
            throw new Error("ace.edit can't find div #" + _id);
        }
        if (el && el.env && el.env.editor instanceof Editor)
          return el.env.editor;
        var value = "";
        if (el && /input|textarea/i.test(el.tagName)) {
          var oldNode = el;
          value = oldNode.value;
          el = dom.createElement("pre");
          oldNode.parentNode.replaceChild(el, oldNode);
        } else if (el) {
          value = el.textContent;
          el.innerHTML = "";
        }
        var doc = exports3.createEditSession(value);
        var editor = new Editor(new Renderer(el), doc, options);
        var env = {
          document: doc,
          editor,
          onResize: editor.resize.bind(editor, null)
        };
        if (oldNode)
          env.textarea = oldNode;
        editor.on("destroy", function() {
          env.editor.container.env = null;
        });
        editor.container.env = editor.env = env;
        return editor;
      };
      exports3.createEditSession = function(text, mode) {
        var doc = new EditSession(text, mode);
        doc.setUndoManager(new UndoManager());
        return doc;
      };
      exports3.Range = Range;
      exports3.Editor = Editor;
      exports3.EditSession = EditSession;
      exports3.UndoManager = UndoManager;
      exports3.VirtualRenderer = Renderer;
      exports3.version = exports3.config.version;
    });
    (function() {
      ace.require(["ace/ace"], function(a3) {
        if (a3) {
          a3.config.init(true);
          a3.define = ace.define;
        }
        if (!window.ace)
          window.ace = a3;
        for (var key in a3) if (a3.hasOwnProperty(key))
          window.ace[key] = a3[key];
        window.ace["default"] = window.ace;
        {
          module2.exports = window.ace;
        }
      });
    })();
  })(ace$1);
  return ace$1.exports;
}
requireAce();
ace.config.setModuleLoader("ace/ext/beautify", () => __vitePreload(() => import("./ext-beautify-DWqnKm8k.js").then((n) => n.e), true ? __vite__mapDeps([0,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/code_lens", () => __vitePreload(() => import("./ext-code_lens-DsaC1EjT.js").then((n) => n.e), true ? __vite__mapDeps([2,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/elastic_tabstops_lite", () => __vitePreload(() => import("./ext-elastic_tabstops_lite-DX3ywPtA.js").then((n) => n.e), true ? __vite__mapDeps([3,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/emmet", () => __vitePreload(() => import("./ext-emmet-CnoWAt-2.js").then((n) => n.e), true ? __vite__mapDeps([4,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/error_marker", () => __vitePreload(() => import("./ext-error_marker-DZ2T0BIS.js").then((n) => n.e), true ? __vite__mapDeps([5,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/hardwrap", () => __vitePreload(() => import("./ext-hardwrap-Da65JcNk.js").then((n) => n.e), true ? __vite__mapDeps([6,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/inline_autocomplete", () => __vitePreload(() => import("./ext-inline_autocomplete-DBBJW1fT.js").then((n) => n.e), true ? __vite__mapDeps([7,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/keyboard_menu", () => __vitePreload(() => import("./ext-keybinding_menu-SAZlcZNE.js").then((n) => n.e), true ? __vite__mapDeps([8,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/language_tools", () => __vitePreload(() => import("./ext-language_tools-BbdagSBI.js").then((n) => n.e), true ? __vite__mapDeps([9,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/linking", () => __vitePreload(() => import("./ext-linking-K4o5cNZj.js").then((n) => n.e), true ? __vite__mapDeps([10,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/modelist", () => __vitePreload(() => import("./ext-modelist-wzlvn3X3.js").then((n) => n.e), true ? __vite__mapDeps([11,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/options", () => __vitePreload(() => import("./ext-options-Diz2c6gk.js").then((n) => n.e), true ? __vite__mapDeps([12,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/prompt", () => __vitePreload(() => import("./ext-prompt-B5A3qxfC.js").then((n) => n.e), true ? __vite__mapDeps([13,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/rtl", () => __vitePreload(() => import("./ext-rtl-Do4fobcK.js").then((n) => n.e), true ? __vite__mapDeps([14,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/searchbox", () => __vitePreload(() => import("./ext-searchbox-d1yxE4lI.js").then((n) => n.e), true ? __vite__mapDeps([15,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/settings_menu", () => __vitePreload(() => import("./ext-settings_menu-5CbjMvUa.js").then((n) => n.e), true ? __vite__mapDeps([16,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/spellcheck", () => __vitePreload(() => import("./ext-spellcheck-CE-SUhdU.js").then((n) => n.e), true ? __vite__mapDeps([17,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/split", () => __vitePreload(() => import("./ext-split-D4CV93pz.js").then((n) => n.e), true ? __vite__mapDeps([18,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/static_highlight", () => __vitePreload(() => import("./ext-static_highlight-0iOh1XAy.js").then((n) => n.e), true ? __vite__mapDeps([19,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/statusbar", () => __vitePreload(() => import("./ext-statusbar-RhQqZ5ab.js").then((n) => n.e), true ? __vite__mapDeps([20,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/textarea", () => __vitePreload(() => import("./ext-textarea-DTNts59M.js").then((n) => n.e), true ? __vite__mapDeps([21,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/themelist", () => __vitePreload(() => import("./ext-themelist-BRnrF-lc.js").then((n) => n.e), true ? __vite__mapDeps([22,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/whitespace", () => __vitePreload(() => import("./ext-whitespace-C1TBg_0s.js").then((n) => n.e), true ? __vite__mapDeps([23,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/keyboard/emacs", () => __vitePreload(() => import("./keybinding-emacs-lNabNU60.js").then((n) => n.k), true ? __vite__mapDeps([24,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/keyboard/sublime", () => __vitePreload(() => import("./keybinding-sublime-BdxvbBQ0.js").then((n) => n.k), true ? __vite__mapDeps([25,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/keyboard/vim", () => __vitePreload(() => import("./keybinding-vim-CgQfxFow.js").then((n) => n.k), true ? __vite__mapDeps([26,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/keyboard/vscode", () => __vitePreload(() => import("./keybinding-vscode-6DOeRVNF.js").then((n) => n.k), true ? __vite__mapDeps([27,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/abap", () => __vitePreload(() => import("./mode-abap-CWdjZFJp.js").then((n) => n.m), true ? __vite__mapDeps([28,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/abc", () => __vitePreload(() => import("./mode-abc-Bojakf1Y.js").then((n) => n.m), true ? __vite__mapDeps([29,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/actionscript", () => __vitePreload(() => import("./mode-actionscript-BM5MG-QJ.js").then((n) => n.m), true ? __vite__mapDeps([30,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/ada", () => __vitePreload(() => import("./mode-ada-C-EpGN7L.js").then((n) => n.m), true ? __vite__mapDeps([31,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/alda", () => __vitePreload(() => import("./mode-alda-Ds4VxHxc.js").then((n) => n.m), true ? __vite__mapDeps([32,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/apache_conf", () => __vitePreload(() => import("./mode-apache_conf-Dit8FYLE.js").then((n) => n.m), true ? __vite__mapDeps([33,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/apex", () => __vitePreload(() => import("./mode-apex-CNLIiRqC.js").then((n) => n.m), true ? __vite__mapDeps([34,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/applescript", () => __vitePreload(() => import("./mode-applescript-BHLZ9YO7.js").then((n) => n.m), true ? __vite__mapDeps([35,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/aql", () => __vitePreload(() => import("./mode-aql-Bil53Oy5.js").then((n) => n.m), true ? __vite__mapDeps([36,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/asciidoc", () => __vitePreload(() => import("./mode-asciidoc-cvjwTxyc.js").then((n) => n.m), true ? __vite__mapDeps([37,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/asl", () => __vitePreload(() => import("./mode-asl-PYVuogWe.js").then((n) => n.m), true ? __vite__mapDeps([38,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/assembly_x86", () => __vitePreload(() => import("./mode-assembly_x86-CIpgPGW_.js").then((n) => n.m), true ? __vite__mapDeps([39,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/autohotkey", () => __vitePreload(() => import("./mode-autohotkey-DHT3dXMZ.js").then((n) => n.m), true ? __vite__mapDeps([40,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/batchfile", () => __vitePreload(() => import("./mode-batchfile-D-iIFTlF.js").then((n) => n.m), true ? __vite__mapDeps([41,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/bibtex", () => __vitePreload(() => import("./mode-bibtex-BaA8s57o.js").then((n) => n.m), true ? __vite__mapDeps([42,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/c9search", () => __vitePreload(() => import("./mode-c9search-DPL_O9Qb.js").then((n) => n.m), true ? __vite__mapDeps([43,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/c_cpp", () => __vitePreload(() => import("./mode-c_cpp-DCjjjDOx.js").then((n) => n.m), true ? __vite__mapDeps([44,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/cirru", () => __vitePreload(() => import("./mode-cirru-jkpomi4J.js").then((n) => n.m), true ? __vite__mapDeps([45,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/clojure", () => __vitePreload(() => import("./mode-clojure-CvddRejZ.js").then((n) => n.m), true ? __vite__mapDeps([46,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/cobol", () => __vitePreload(() => import("./mode-cobol-BrRCmj3Y.js").then((n) => n.m), true ? __vite__mapDeps([47,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/coffee", () => __vitePreload(() => import("./mode-coffee-BFDuAng_.js").then((n) => n.m), true ? __vite__mapDeps([48,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/coldfusion", () => __vitePreload(() => import("./mode-coldfusion-COTOPnia.js").then((n) => n.m), true ? __vite__mapDeps([49,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/crystal", () => __vitePreload(() => import("./mode-crystal-82RJdfwK.js").then((n) => n.m), true ? __vite__mapDeps([50,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/csharp", () => __vitePreload(() => import("./mode-csharp-W5JBEC41.js").then((n) => n.m), true ? __vite__mapDeps([51,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/csound_document", () => __vitePreload(() => import("./mode-csound_document-C_I_8b3j.js").then((n) => n.m), true ? __vite__mapDeps([52,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/csound_orchestra", () => __vitePreload(() => import("./mode-csound_orchestra-C_v_1Znf.js").then((n) => n.m), true ? __vite__mapDeps([53,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/csound_score", () => __vitePreload(() => import("./mode-csound_score-BnSCdY1l.js").then((n) => n.m), true ? __vite__mapDeps([54,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/csp", () => __vitePreload(() => import("./mode-csp-Dk5QHFa8.js").then((n) => n.m), true ? __vite__mapDeps([55,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/css", () => __vitePreload(() => import("./mode-css-Bw_dCJDy.js").then((n) => n.m), true ? __vite__mapDeps([56,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/curly", () => __vitePreload(() => import("./mode-curly-BRVUQMVY.js").then((n) => n.m), true ? __vite__mapDeps([57,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/d", () => __vitePreload(() => import("./mode-d-Be7tugki.js").then((n) => n.m), true ? __vite__mapDeps([58,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/dart", () => __vitePreload(() => import("./mode-dart-CdHnXzsT.js").then((n) => n.m), true ? __vite__mapDeps([59,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/diff", () => __vitePreload(() => import("./mode-diff-BOAnYXgM.js").then((n) => n.m), true ? __vite__mapDeps([60,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/django", () => __vitePreload(() => import("./mode-django-CSlg-k6U.js").then((n) => n.m), true ? __vite__mapDeps([61,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/dockerfile", () => __vitePreload(() => import("./mode-dockerfile-CDbdGGeK.js").then((n) => n.m), true ? __vite__mapDeps([62,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/dot", () => __vitePreload(() => import("./mode-dot-BYGzoTs3.js").then((n) => n.m), true ? __vite__mapDeps([63,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/drools", () => __vitePreload(() => import("./mode-drools-pjSwTJ2y.js").then((n) => n.m), true ? __vite__mapDeps([64,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/edifact", () => __vitePreload(() => import("./mode-edifact-CKydQZAi.js").then((n) => n.m), true ? __vite__mapDeps([65,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/eiffel", () => __vitePreload(() => import("./mode-eiffel-DFy9Bc-y.js").then((n) => n.m), true ? __vite__mapDeps([66,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/ejs", () => __vitePreload(() => import("./mode-ejs-m7qia6Vq.js").then((n) => n.m), true ? __vite__mapDeps([67,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/elixir", () => __vitePreload(() => import("./mode-elixir-DMCezUQE.js").then((n) => n.m), true ? __vite__mapDeps([68,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/elm", () => __vitePreload(() => import("./mode-elm-CaDXghYp.js").then((n) => n.m), true ? __vite__mapDeps([69,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/erlang", () => __vitePreload(() => import("./mode-erlang-Buvu6r6E.js").then((n) => n.m), true ? __vite__mapDeps([70,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/forth", () => __vitePreload(() => import("./mode-forth-DW5CTtBl.js").then((n) => n.m), true ? __vite__mapDeps([71,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/fortran", () => __vitePreload(() => import("./mode-fortran-DdTL8ajJ.js").then((n) => n.m), true ? __vite__mapDeps([72,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/fsharp", () => __vitePreload(() => import("./mode-fsharp-0xJ6QMiC.js").then((n) => n.m), true ? __vite__mapDeps([73,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/fsl", () => __vitePreload(() => import("./mode-fsl-GreR_qHY.js").then((n) => n.m), true ? __vite__mapDeps([74,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/ftl", () => __vitePreload(() => import("./mode-ftl-DzSqawYX.js").then((n) => n.m), true ? __vite__mapDeps([75,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/gcode", () => __vitePreload(() => import("./mode-gcode-M7fsSlCv.js").then((n) => n.m), true ? __vite__mapDeps([76,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/gherkin", () => __vitePreload(() => import("./mode-gherkin-uloBwdle.js").then((n) => n.m), true ? __vite__mapDeps([77,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/gitignore", () => __vitePreload(() => import("./mode-gitignore-DjC3FmDf.js").then((n) => n.m), true ? __vite__mapDeps([78,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/glsl", () => __vitePreload(() => import("./mode-glsl-BHi0t5ox.js").then((n) => n.m), true ? __vite__mapDeps([79,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/gobstones", () => __vitePreload(() => import("./mode-gobstones-C-Q2ewIZ.js").then((n) => n.m), true ? __vite__mapDeps([80,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/golang", () => __vitePreload(() => import("./mode-golang-BU_VSysM.js").then((n) => n.m), true ? __vite__mapDeps([81,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/graphqlschema", () => __vitePreload(() => import("./mode-graphqlschema-GoImzfQa.js").then((n) => n.m), true ? __vite__mapDeps([82,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/groovy", () => __vitePreload(() => import("./mode-groovy-B2KLSPUU.js").then((n) => n.m), true ? __vite__mapDeps([83,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/haml", () => __vitePreload(() => import("./mode-haml-yzpLKS0y.js").then((n) => n.m), true ? __vite__mapDeps([84,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/handlebars", () => __vitePreload(() => import("./mode-handlebars-DDZDizzv.js").then((n) => n.m), true ? __vite__mapDeps([85,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/haskell", () => __vitePreload(() => import("./mode-haskell-CsLK_TDf.js").then((n) => n.m), true ? __vite__mapDeps([86,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/haskell_cabal", () => __vitePreload(() => import("./mode-haskell_cabal-a6kz5-jy.js").then((n) => n.m), true ? __vite__mapDeps([87,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/haxe", () => __vitePreload(() => import("./mode-haxe-C82SS-ha.js").then((n) => n.m), true ? __vite__mapDeps([88,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/hjson", () => __vitePreload(() => import("./mode-hjson-BhDAeB1Y.js").then((n) => n.m), true ? __vite__mapDeps([89,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/html", () => __vitePreload(() => import("./mode-html-BVJkMLue.js").then((n) => n.m), true ? __vite__mapDeps([90,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/html_elixir", () => __vitePreload(() => import("./mode-html_elixir-HHDv243T.js").then((n) => n.m), true ? __vite__mapDeps([91,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/html_ruby", () => __vitePreload(() => import("./mode-html_ruby-CgfMz1Qv.js").then((n) => n.m), true ? __vite__mapDeps([92,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/ini", () => __vitePreload(() => import("./mode-ini-BQDfELDa.js").then((n) => n.m), true ? __vite__mapDeps([93,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/io", () => __vitePreload(() => import("./mode-io-Cs9AFM0G.js").then((n) => n.m), true ? __vite__mapDeps([94,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/ion", () => __vitePreload(() => import("./mode-ion-Cba77CjK.js").then((n) => n.m), true ? __vite__mapDeps([95,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/jack", () => __vitePreload(() => import("./mode-jack-Bi_TLFLn.js").then((n) => n.m), true ? __vite__mapDeps([96,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/jade", () => __vitePreload(() => import("./mode-jade-B6LtBcfj.js").then((n) => n.m), true ? __vite__mapDeps([97,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/java", () => __vitePreload(() => import("./mode-java-b0EFrfjQ.js").then((n) => n.m), true ? __vite__mapDeps([98,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/javascript", () => __vitePreload(() => import("./mode-javascript-xSZQDxHi.js").then((n) => n.m), true ? __vite__mapDeps([99,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/jexl", () => __vitePreload(() => import("./mode-jexl-BUzkb3Cr.js").then((n) => n.m), true ? __vite__mapDeps([100,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/json", () => __vitePreload(() => import("./mode-json-r4mBaCdi.js").then((n) => n.m), true ? __vite__mapDeps([101,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/json5", () => __vitePreload(() => import("./mode-json5-C7jS2D2z.js").then((n) => n.m), true ? __vite__mapDeps([102,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/jsoniq", () => __vitePreload(() => import("./mode-jsoniq-DGo6-NaS.js").then((n) => n.m), true ? __vite__mapDeps([103,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/jsp", () => __vitePreload(() => import("./mode-jsp-DGx7JcDB.js").then((n) => n.m), true ? __vite__mapDeps([104,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/jssm", () => __vitePreload(() => import("./mode-jssm-Cf5Di5SO.js").then((n) => n.m), true ? __vite__mapDeps([105,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/jsx", () => __vitePreload(() => import("./mode-jsx-x_zON0pc.js").then((n) => n.m), true ? __vite__mapDeps([106,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/julia", () => __vitePreload(() => import("./mode-julia-C_uFExbj.js").then((n) => n.m), true ? __vite__mapDeps([107,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/kotlin", () => __vitePreload(() => import("./mode-kotlin-B_LxMjlX.js").then((n) => n.m), true ? __vite__mapDeps([108,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/latex", () => __vitePreload(() => import("./mode-latex-ChNpGHR7.js").then((n) => n.m), true ? __vite__mapDeps([109,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/latte", () => __vitePreload(() => import("./mode-latte-CrI1gNTw.js").then((n) => n.m), true ? __vite__mapDeps([110,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/less", () => __vitePreload(() => import("./mode-less-3cIHBecx.js").then((n) => n.m), true ? __vite__mapDeps([111,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/liquid", () => __vitePreload(() => import("./mode-liquid-bdjnrw4S.js").then((n) => n.m), true ? __vite__mapDeps([112,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/lisp", () => __vitePreload(() => import("./mode-lisp-BnOMI0zg.js").then((n) => n.m), true ? __vite__mapDeps([113,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/livescript", () => __vitePreload(() => import("./mode-livescript-Da-tuWik.js").then((n) => n.m), true ? __vite__mapDeps([114,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/logiql", () => __vitePreload(() => import("./mode-logiql-D60LhQT8.js").then((n) => n.m), true ? __vite__mapDeps([115,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/logtalk", () => __vitePreload(() => import("./mode-logtalk-BCUKLGYU.js").then((n) => n.m), true ? __vite__mapDeps([116,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/lsl", () => __vitePreload(() => import("./mode-lsl-DoFS8qW2.js").then((n) => n.m), true ? __vite__mapDeps([117,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/lua", () => __vitePreload(() => import("./mode-lua-Bo0_OJBv.js").then((n) => n.m), true ? __vite__mapDeps([118,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/luapage", () => __vitePreload(() => import("./mode-luapage-DebxWWMh.js").then((n) => n.m), true ? __vite__mapDeps([119,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/lucene", () => __vitePreload(() => import("./mode-lucene-BTIbQypK.js").then((n) => n.m), true ? __vite__mapDeps([120,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/makefile", () => __vitePreload(() => import("./mode-makefile-CytO6Cim.js").then((n) => n.m), true ? __vite__mapDeps([121,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/markdown", () => __vitePreload(() => import("./mode-markdown-H4rxK8Oi.js").then((n) => n.m), true ? __vite__mapDeps([122,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/mask", () => __vitePreload(() => import("./mode-mask-CTLb-QyO.js").then((n) => n.m), true ? __vite__mapDeps([123,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/matlab", () => __vitePreload(() => import("./mode-matlab-aSFM2ESh.js").then((n) => n.m), true ? __vite__mapDeps([124,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/maze", () => __vitePreload(() => import("./mode-maze-B9VncRcO.js").then((n) => n.m), true ? __vite__mapDeps([125,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/mediawiki", () => __vitePreload(() => import("./mode-mediawiki-COUsS_rn.js").then((n) => n.m), true ? __vite__mapDeps([126,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/mel", () => __vitePreload(() => import("./mode-mel-BnUZZ5yv.js").then((n) => n.m), true ? __vite__mapDeps([127,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/mips", () => __vitePreload(() => import("./mode-mips-Bn_sYoC5.js").then((n) => n.m), true ? __vite__mapDeps([128,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/mixal", () => __vitePreload(() => import("./mode-mixal-Bz87pcrp.js").then((n) => n.m), true ? __vite__mapDeps([129,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/mushcode", () => __vitePreload(() => import("./mode-mushcode-C77Q17Az.js").then((n) => n.m), true ? __vite__mapDeps([130,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/mysql", () => __vitePreload(() => import("./mode-mysql-DNfNMeEH.js").then((n) => n.m), true ? __vite__mapDeps([131,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/nginx", () => __vitePreload(() => import("./mode-nginx-CDzfGUqd.js").then((n) => n.m), true ? __vite__mapDeps([132,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/nim", () => __vitePreload(() => import("./mode-nim-C6q1NbUw.js").then((n) => n.m), true ? __vite__mapDeps([133,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/nix", () => __vitePreload(() => import("./mode-nix-ConYnD5H.js").then((n) => n.m), true ? __vite__mapDeps([134,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/nsis", () => __vitePreload(() => import("./mode-nsis-DlN-DoAL.js").then((n) => n.m), true ? __vite__mapDeps([135,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/nunjucks", () => __vitePreload(() => import("./mode-nunjucks-TEOAJW3o.js").then((n) => n.m), true ? __vite__mapDeps([136,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/objectivec", () => __vitePreload(() => import("./mode-objectivec-Ey6hEK1I.js").then((n) => n.m), true ? __vite__mapDeps([137,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/ocaml", () => __vitePreload(() => import("./mode-ocaml-BSK4Q5Rs.js").then((n) => n.m), true ? __vite__mapDeps([138,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/partiql", () => __vitePreload(() => import("./mode-partiql-DmFAq0uG.js").then((n) => n.m), true ? __vite__mapDeps([139,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/pascal", () => __vitePreload(() => import("./mode-pascal-BTW3iz6H.js").then((n) => n.m), true ? __vite__mapDeps([140,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/perl", () => __vitePreload(() => import("./mode-perl-BioDCaAB.js").then((n) => n.m), true ? __vite__mapDeps([141,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/pgsql", () => __vitePreload(() => import("./mode-pgsql-DNuEdWUq.js").then((n) => n.m), true ? __vite__mapDeps([142,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/php", () => __vitePreload(() => import("./mode-php-DKMABCBZ.js").then((n) => n.m), true ? __vite__mapDeps([143,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/php_laravel_blade", () => __vitePreload(() => import("./mode-php_laravel_blade-DYDA1qd4.js").then((n) => n.m), true ? __vite__mapDeps([144,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/pig", () => __vitePreload(() => import("./mode-pig-CZk7Vnap.js").then((n) => n.m), true ? __vite__mapDeps([145,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/plain_text", () => __vitePreload(() => import("./mode-plain_text-BqvTdXlY.js").then((n) => n.m), true ? __vite__mapDeps([146,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/plsql", () => __vitePreload(() => import("./mode-plsql-Cj4ZLvtB.js").then((n) => n.m), true ? __vite__mapDeps([147,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/powershell", () => __vitePreload(() => import("./mode-powershell-CDo804uu.js").then((n) => n.m), true ? __vite__mapDeps([148,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/praat", () => __vitePreload(() => import("./mode-praat-DkS-ffWH.js").then((n) => n.m), true ? __vite__mapDeps([149,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/prisma", () => __vitePreload(() => import("./mode-prisma-qgFo8tPE.js").then((n) => n.m), true ? __vite__mapDeps([150,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/prolog", () => __vitePreload(() => import("./mode-prolog-CyWnsGuJ.js").then((n) => n.m), true ? __vite__mapDeps([151,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/properties", () => __vitePreload(() => import("./mode-properties-Ca39WIwt.js").then((n) => n.m), true ? __vite__mapDeps([152,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/protobuf", () => __vitePreload(() => import("./mode-protobuf-lCWZap3a.js").then((n) => n.m), true ? __vite__mapDeps([153,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/puppet", () => __vitePreload(() => import("./mode-puppet-CJAUwTXP.js").then((n) => n.m), true ? __vite__mapDeps([154,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/python", () => __vitePreload(() => import("./mode-python-D8KWuRGc.js").then((n) => n.m), true ? __vite__mapDeps([155,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/qml", () => __vitePreload(() => import("./mode-qml-Coo2kLWT.js").then((n) => n.m), true ? __vite__mapDeps([156,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/r", () => __vitePreload(() => import("./mode-r-B15jnayv.js").then((n) => n.m), true ? __vite__mapDeps([157,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/raku", () => __vitePreload(() => import("./mode-raku-CMGHCeDg.js").then((n) => n.m), true ? __vite__mapDeps([158,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/razor", () => __vitePreload(() => import("./mode-razor-BBRFf9pz.js").then((n) => n.m), true ? __vite__mapDeps([159,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/rdoc", () => __vitePreload(() => import("./mode-rdoc-C4lRvReu.js").then((n) => n.m), true ? __vite__mapDeps([160,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/red", () => __vitePreload(() => import("./mode-red-0ERRWJL1.js").then((n) => n.m), true ? __vite__mapDeps([161,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/redshift", () => __vitePreload(() => import("./mode-redshift-Cde38bVJ.js").then((n) => n.m), true ? __vite__mapDeps([162,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/rhtml", () => __vitePreload(() => import("./mode-rhtml-69A6i9O2.js").then((n) => n.m), true ? __vite__mapDeps([163,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/robot", () => __vitePreload(() => import("./mode-robot-DIfxeO_P.js").then((n) => n.m), true ? __vite__mapDeps([164,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/rst", () => __vitePreload(() => import("./mode-rst-DNuDkX3_.js").then((n) => n.m), true ? __vite__mapDeps([165,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/ruby", () => __vitePreload(() => import("./mode-ruby-CPy8xE2i.js").then((n) => n.m), true ? __vite__mapDeps([166,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/rust", () => __vitePreload(() => import("./mode-rust-C_ZVCM4U.js").then((n) => n.m), true ? __vite__mapDeps([167,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/sac", () => __vitePreload(() => import("./mode-sac-DBGCE-wY.js").then((n) => n.m), true ? __vite__mapDeps([168,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/sass", () => __vitePreload(() => import("./mode-sass-BiWt35Y8.js").then((n) => n.m), true ? __vite__mapDeps([169,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/scad", () => __vitePreload(() => import("./mode-scad-D5vPhBrJ.js").then((n) => n.m), true ? __vite__mapDeps([170,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/scala", () => __vitePreload(() => import("./mode-scala-Dprv3mH9.js").then((n) => n.m), true ? __vite__mapDeps([171,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/scheme", () => __vitePreload(() => import("./mode-scheme-CE7lfbvU.js").then((n) => n.m), true ? __vite__mapDeps([172,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/scrypt", () => __vitePreload(() => import("./mode-scrypt-C9dzH2yK.js").then((n) => n.m), true ? __vite__mapDeps([173,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/scss", () => __vitePreload(() => import("./mode-scss-DkgXrtwx.js").then((n) => n.m), true ? __vite__mapDeps([174,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/sh", () => __vitePreload(() => import("./mode-sh-DewzyMF0.js").then((n) => n.m), true ? __vite__mapDeps([175,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/sjs", () => __vitePreload(() => import("./mode-sjs-DOA6xRHA.js").then((n) => n.m), true ? __vite__mapDeps([176,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/slim", () => __vitePreload(() => import("./mode-slim-ivj5lVBg.js").then((n) => n.m), true ? __vite__mapDeps([177,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/smarty", () => __vitePreload(() => import("./mode-smarty-CmyoFfsE.js").then((n) => n.m), true ? __vite__mapDeps([178,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/smithy", () => __vitePreload(() => import("./mode-smithy-BDqmWMGw.js").then((n) => n.m), true ? __vite__mapDeps([179,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/snippets", () => __vitePreload(() => import("./mode-snippets-DA_M8_T7.js").then((n) => n.m), true ? __vite__mapDeps([180,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/soy_template", () => __vitePreload(() => import("./mode-soy_template-BLGHhsTq.js").then((n) => n.m), true ? __vite__mapDeps([181,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/space", () => __vitePreload(() => import("./mode-space-Dsrh7x7z.js").then((n) => n.m), true ? __vite__mapDeps([182,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/sparql", () => __vitePreload(() => import("./mode-sparql-da5YeyCd.js").then((n) => n.m), true ? __vite__mapDeps([183,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/sql", () => __vitePreload(() => import("./mode-sql-C6aT7e91.js").then((n) => n.m), true ? __vite__mapDeps([184,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/sqlserver", () => __vitePreload(() => import("./mode-sqlserver-Dzbs2NVX.js").then((n) => n.m), true ? __vite__mapDeps([185,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/stylus", () => __vitePreload(() => import("./mode-stylus-B3EFO71t.js").then((n) => n.m), true ? __vite__mapDeps([186,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/svg", () => __vitePreload(() => import("./mode-svg-OJUsz-UC.js").then((n) => n.m), true ? __vite__mapDeps([187,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/swift", () => __vitePreload(() => import("./mode-swift-D1a098aZ.js").then((n) => n.m), true ? __vite__mapDeps([188,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/tcl", () => __vitePreload(() => import("./mode-tcl-XH-r2LN5.js").then((n) => n.m), true ? __vite__mapDeps([189,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/terraform", () => __vitePreload(() => import("./mode-terraform-RwD-cyrN.js").then((n) => n.m), true ? __vite__mapDeps([190,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/tex", () => __vitePreload(() => import("./mode-tex-CkwOirfm.js").then((n) => n.m), true ? __vite__mapDeps([191,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/text", () => __vitePreload(() => import("./mode-text-D4cNLpwJ.js").then((n) => n.m), true ? __vite__mapDeps([192,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/textile", () => __vitePreload(() => import("./mode-textile-SAmH8K2P.js").then((n) => n.m), true ? __vite__mapDeps([193,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/toml", () => __vitePreload(() => import("./mode-toml-DuEwpoQH.js").then((n) => n.m), true ? __vite__mapDeps([194,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/tsx", () => __vitePreload(() => import("./mode-tsx-BIvAGOO_.js").then((n) => n.m), true ? __vite__mapDeps([195,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/turtle", () => __vitePreload(() => import("./mode-turtle-beFm2Jh8.js").then((n) => n.m), true ? __vite__mapDeps([196,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/twig", () => __vitePreload(() => import("./mode-twig-Dh-KH-UG.js").then((n) => n.m), true ? __vite__mapDeps([197,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/typescript", () => __vitePreload(() => import("./mode-typescript-Bwgk1LJ1.js").then((n) => n.m), true ? __vite__mapDeps([198,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/vala", () => __vitePreload(() => import("./mode-vala-CMH4nojV.js").then((n) => n.m), true ? __vite__mapDeps([199,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/vbscript", () => __vitePreload(() => import("./mode-vbscript-BD5_dmoJ.js").then((n) => n.m), true ? __vite__mapDeps([200,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/velocity", () => __vitePreload(() => import("./mode-velocity-DL3kV132.js").then((n) => n.m), true ? __vite__mapDeps([201,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/verilog", () => __vitePreload(() => import("./mode-verilog-6FclDmvN.js").then((n) => n.m), true ? __vite__mapDeps([202,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/vhdl", () => __vitePreload(() => import("./mode-vhdl-B0M7YKt5.js").then((n) => n.m), true ? __vite__mapDeps([203,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/visualforce", () => __vitePreload(() => import("./mode-visualforce-BAT9PK65.js").then((n) => n.m), true ? __vite__mapDeps([204,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/wollok", () => __vitePreload(() => import("./mode-wollok-DBH6w10z.js").then((n) => n.m), true ? __vite__mapDeps([205,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/xml", () => __vitePreload(() => import("./mode-xml-BlXZNuxd.js").then((n) => n.m), true ? __vite__mapDeps([206,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/xquery", () => __vitePreload(() => import("./mode-xquery-BtVw-BhC.js").then((n) => n.m), true ? __vite__mapDeps([207,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/yaml", () => __vitePreload(() => import("./mode-yaml-VIut228V.js").then((n) => n.m), true ? __vite__mapDeps([208,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/zeek", () => __vitePreload(() => import("./mode-zeek-Bw_ez6fG.js").then((n) => n.m), true ? __vite__mapDeps([209,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/ambiance", () => __vitePreload(() => import("./theme-ambiance-B4uluc5k.js").then((n) => n.t), true ? __vite__mapDeps([210,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/chaos", () => __vitePreload(() => import("./theme-chaos-D6mzr2Yb.js").then((n) => n.t), true ? __vite__mapDeps([211,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/chrome", () => __vitePreload(() => import("./theme-chrome-DWVisJrw.js").then((n) => n.t), true ? __vite__mapDeps([212,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/cloud9_day", () => __vitePreload(() => import("./theme-cloud9_day-CCS6wwhu.js").then((n) => n.t), true ? __vite__mapDeps([213,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/cloud9_night", () => __vitePreload(() => import("./theme-cloud9_night-C3c1vNDz.js").then((n) => n.t), true ? __vite__mapDeps([214,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/cloud9_night_low_color", () => __vitePreload(() => import("./theme-cloud9_night_low_color-4BLx3xDL.js").then((n) => n.t), true ? __vite__mapDeps([215,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/clouds", () => __vitePreload(() => import("./theme-clouds-BvQPPs5g.js").then((n) => n.t), true ? __vite__mapDeps([216,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/clouds_midnight", () => __vitePreload(() => import("./theme-clouds_midnight-us7iSnbK.js").then((n) => n.t), true ? __vite__mapDeps([217,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/cobalt", () => __vitePreload(() => import("./theme-cobalt-CzxFL8Q4.js").then((n) => n.t), true ? __vite__mapDeps([218,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/crimson_editor", () => __vitePreload(() => import("./theme-crimson_editor-CsAUwCfY.js").then((n) => n.t), true ? __vite__mapDeps([219,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/dawn", () => __vitePreload(() => import("./theme-dawn-TctOOE68.js").then((n) => n.t), true ? __vite__mapDeps([220,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/dracula", () => __vitePreload(() => import("./theme-dracula-CJfG5-Ty.js").then((n) => n.t), true ? __vite__mapDeps([221,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/dreamweaver", () => __vitePreload(() => import("./theme-dreamweaver-cLgxs_cE.js").then((n) => n.t), true ? __vite__mapDeps([222,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/eclipse", () => __vitePreload(() => import("./theme-eclipse-FbIS5qp3.js").then((n) => n.t), true ? __vite__mapDeps([223,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/github", () => __vitePreload(() => import("./theme-github-zH6VvHWx.js").then((n) => n.t), true ? __vite__mapDeps([224,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/gob", () => __vitePreload(() => import("./theme-gob-CBrCppgV.js").then((n) => n.t), true ? __vite__mapDeps([225,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/gruvbox", () => __vitePreload(() => import("./theme-gruvbox-DexkiKae.js").then((n) => n.t), true ? __vite__mapDeps([226,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/gruvbox_dark_hard", () => __vitePreload(() => import("./theme-gruvbox_dark_hard-QGwl-11q.js").then((n) => n.t), true ? __vite__mapDeps([227,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/gruvbox_light_hard", () => __vitePreload(() => import("./theme-gruvbox_light_hard-BmZRKRJq.js").then((n) => n.t), true ? __vite__mapDeps([228,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/idle_fingers", () => __vitePreload(() => import("./theme-idle_fingers-Tr85tBUX.js").then((n) => n.t), true ? __vite__mapDeps([229,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/iplastic", () => __vitePreload(() => import("./theme-iplastic-BBTiX1aR.js").then((n) => n.t), true ? __vite__mapDeps([230,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/katzenmilch", () => __vitePreload(() => import("./theme-katzenmilch-CAi8HTbl.js").then((n) => n.t), true ? __vite__mapDeps([231,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/kr_theme", () => __vitePreload(() => import("./theme-kr_theme-C33kJdeb.js").then((n) => n.t), true ? __vite__mapDeps([232,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/kuroir", () => __vitePreload(() => import("./theme-kuroir-Dp7jOpKN.js").then((n) => n.t), true ? __vite__mapDeps([233,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/merbivore", () => __vitePreload(() => import("./theme-merbivore-C1_PgmaH.js").then((n) => n.t), true ? __vite__mapDeps([234,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/merbivore_soft", () => __vitePreload(() => import("./theme-merbivore_soft-DcmhLZLi.js").then((n) => n.t), true ? __vite__mapDeps([235,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/mono_industrial", () => __vitePreload(() => import("./theme-mono_industrial-7xq5X-6H.js").then((n) => n.t), true ? __vite__mapDeps([236,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/monokai", () => __vitePreload(() => import("./theme-monokai-CoHG5EbA.js").then((n) => n.t), true ? __vite__mapDeps([237,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/nord_dark", () => __vitePreload(() => import("./theme-nord_dark-DQOVwIlZ.js").then((n) => n.t), true ? __vite__mapDeps([238,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/one_dark", () => __vitePreload(() => import("./theme-one_dark-ClUHZuKU.js").then((n) => n.t), true ? __vite__mapDeps([239,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/pastel_on_dark", () => __vitePreload(() => import("./theme-pastel_on_dark-B2sRrws-.js").then((n) => n.t), true ? __vite__mapDeps([240,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/solarized_dark", () => __vitePreload(() => import("./theme-solarized_dark-Cz2rKIjR.js").then((n) => n.t), true ? __vite__mapDeps([241,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/solarized_light", () => __vitePreload(() => import("./theme-solarized_light-ZdvOkaOF.js").then((n) => n.t), true ? __vite__mapDeps([242,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/sqlserver", () => __vitePreload(() => import("./theme-sqlserver-CPF3daef.js").then((n) => n.t), true ? __vite__mapDeps([243,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/terminal", () => __vitePreload(() => import("./theme-terminal-CsbEyZb2.js").then((n) => n.t), true ? __vite__mapDeps([244,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/textmate", () => __vitePreload(() => import("./theme-textmate-DQtUVNIm.js").then((n) => n.t), true ? __vite__mapDeps([245,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/tomorrow", () => __vitePreload(() => import("./theme-tomorrow-DwlZnZZB.js").then((n) => n.t), true ? __vite__mapDeps([246,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/tomorrow_night", () => __vitePreload(() => import("./theme-tomorrow_night-bv60VzkD.js").then((n) => n.t), true ? __vite__mapDeps([247,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/tomorrow_night_blue", () => __vitePreload(() => import("./theme-tomorrow_night_blue-RBG7DPD_.js").then((n) => n.t), true ? __vite__mapDeps([248,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/tomorrow_night_bright", () => __vitePreload(() => import("./theme-tomorrow_night_bright-BgTIxLno.js").then((n) => n.t), true ? __vite__mapDeps([249,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/tomorrow_night_eighties", () => __vitePreload(() => import("./theme-tomorrow_night_eighties-erYM-vJd.js").then((n) => n.t), true ? __vite__mapDeps([250,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/twilight", () => __vitePreload(() => import("./theme-twilight-DohOeJpP.js").then((n) => n.t), true ? __vite__mapDeps([251,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/vibrant_ink", () => __vitePreload(() => import("./theme-vibrant_ink-BzcsyjCq.js").then((n) => n.t), true ? __vite__mapDeps([252,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/xcode", () => __vitePreload(() => import("./theme-xcode-KGoc_oWe.js").then((n) => n.t), true ? __vite__mapDeps([253,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/base_worker", () => __vitePreload(() => import("./worker-base-CgOHIwHc.js").then((n) => n.w), true ? __vite__mapDeps([254,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/coffee_worker", () => __vitePreload(() => import("./worker-coffee-DjtVRDXQ.js").then((n) => n.w), true ? __vite__mapDeps([255,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/css_worker", () => __vitePreload(() => import("./worker-css-Da_QyoXf.js").then((n) => n.w), true ? __vite__mapDeps([256,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/html_worker", () => __vitePreload(() => import("./worker-html-XeS91PbI.js").then((n) => n.w), true ? __vite__mapDeps([257,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/javascript_worker", () => __vitePreload(() => import("./worker-javascript-DglDr8oQ.js").then((n) => n.w), true ? __vite__mapDeps([258,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/json_worker", () => __vitePreload(() => import("./worker-json-Dq6edhIa.js").then((n) => n.w), true ? __vite__mapDeps([259,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/lua_worker", () => __vitePreload(() => import("./worker-lua-BUwzH5Wt.js").then((n) => n.w), true ? __vite__mapDeps([260,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/php_worker", () => __vitePreload(() => import("./worker-php-Cw36pTaU.js").then((n) => n.w), true ? __vite__mapDeps([261,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/xml_worker", () => __vitePreload(() => import("./worker-xml-D9OvSH3q.js").then((n) => n.w), true ? __vite__mapDeps([262,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/xquery_worker", () => __vitePreload(() => import("./worker-xquery-BKyStHrf.js").then((n) => n.w), true ? __vite__mapDeps([263,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/yaml_worker", () => __vitePreload(() => import("./worker-yaml-DyLD0qcp.js").then((n) => n.w), true ? __vite__mapDeps([264,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/abap", () => __vitePreload(() => import("./abap-CEsUs72j.js").then((n) => n.a), true ? __vite__mapDeps([265,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/abc", () => __vitePreload(() => import("./abc-CNZluz4Z.js").then((n) => n.a), true ? __vite__mapDeps([266,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/actionscript", () => __vitePreload(() => import("./actionscript-B-swKpKA.js").then((n) => n.a), true ? __vite__mapDeps([267,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/ada", () => __vitePreload(() => import("./ada-DOVqaW44.js").then((n) => n.a), true ? __vite__mapDeps([268,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/alda", () => __vitePreload(() => import("./alda-D67DWsG8.js").then((n) => n.a), true ? __vite__mapDeps([269,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/apache_conf", () => __vitePreload(() => import("./apache_conf-CCOknK1B.js").then((n) => n.a), true ? __vite__mapDeps([270,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/apex", () => __vitePreload(() => import("./apex-DhhkyrI4.js").then((n) => n.a), true ? __vite__mapDeps([271,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/applescript", () => __vitePreload(() => import("./applescript-C9WBHmmT.js").then((n) => n.a), true ? __vite__mapDeps([272,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/aql", () => __vitePreload(() => import("./aql-CBlK0mDs.js").then((n) => n.a), true ? __vite__mapDeps([273,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/asciidoc", () => __vitePreload(() => import("./asciidoc-97pJIx1N.js").then((n) => n.a), true ? __vite__mapDeps([274,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/asl", () => __vitePreload(() => import("./asl-BM22YjRo.js").then((n) => n.a), true ? __vite__mapDeps([275,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/assembly_x86", () => __vitePreload(() => import("./assembly_x86-DFbmeI29.js").then((n) => n.a), true ? __vite__mapDeps([276,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/autohotkey", () => __vitePreload(() => import("./autohotkey-DR_btT5s.js").then((n) => n.a), true ? __vite__mapDeps([277,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/batchfile", () => __vitePreload(() => import("./batchfile-CWX-sKB0.js").then((n) => n.b), true ? __vite__mapDeps([278,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/bibtex", () => __vitePreload(() => import("./bibtex-ZRUXLYHb.js").then((n) => n.b), true ? __vite__mapDeps([279,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/c9search", () => __vitePreload(() => import("./c9search-Co8rde2h.js").then((n) => n.c), true ? __vite__mapDeps([280,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/c_cpp", () => __vitePreload(() => import("./c_cpp-Dqe5L_LF.js").then((n) => n.c), true ? __vite__mapDeps([281,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/cirru", () => __vitePreload(() => import("./cirru-DmHABcnI.js").then((n) => n.c), true ? __vite__mapDeps([282,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/clojure", () => __vitePreload(() => import("./clojure-DmnuN_Ss.js").then((n) => n.c), true ? __vite__mapDeps([283,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/cobol", () => __vitePreload(() => import("./cobol-BPply1Q_.js").then((n) => n.c), true ? __vite__mapDeps([284,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/coffee", () => __vitePreload(() => import("./coffee-BVi820kf.js").then((n) => n.c), true ? __vite__mapDeps([285,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/coldfusion", () => __vitePreload(() => import("./coldfusion-D5O3vvM2.js").then((n) => n.c), true ? __vite__mapDeps([286,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/crystal", () => __vitePreload(() => import("./crystal-DzSgP4TJ.js").then((n) => n.c), true ? __vite__mapDeps([287,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/csharp", () => __vitePreload(() => import("./csharp-CNnmOEnj.js").then((n) => n.c), true ? __vite__mapDeps([288,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/csound_document", () => __vitePreload(() => import("./csound_document-j-7q_Nah.js").then((n) => n.c), true ? __vite__mapDeps([289,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/csound_orchestra", () => __vitePreload(() => import("./csound_orchestra-ChQtnNZZ.js").then((n) => n.c), true ? __vite__mapDeps([290,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/csound_score", () => __vitePreload(() => import("./csound_score-CqvBe7k8.js").then((n) => n.c), true ? __vite__mapDeps([291,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/csp", () => __vitePreload(() => import("./csp-BUoMNZ5U.js").then((n) => n.c), true ? __vite__mapDeps([292,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/css", () => __vitePreload(() => import("./css-CS6w3kod.js").then((n) => n.c), true ? __vite__mapDeps([293,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/curly", () => __vitePreload(() => import("./curly-BADMHUUo.js").then((n) => n.c), true ? __vite__mapDeps([294,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/d", () => __vitePreload(() => import("./d-QW3nP0eX.js").then((n) => n.d), true ? __vite__mapDeps([295,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/dart", () => __vitePreload(() => import("./dart-CsT8dyAF.js").then((n) => n.d), true ? __vite__mapDeps([296,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/diff", () => __vitePreload(() => import("./diff-BAtPi95_.js").then((n) => n.d), true ? __vite__mapDeps([297,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/django", () => __vitePreload(() => import("./django-B1n7dois.js").then((n) => n.d), true ? __vite__mapDeps([298,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/dockerfile", () => __vitePreload(() => import("./dockerfile-py6blxxX.js").then((n) => n.d), true ? __vite__mapDeps([299,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/dot", () => __vitePreload(() => import("./dot-DjsOktfx.js").then((n) => n.d), true ? __vite__mapDeps([300,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/drools", () => __vitePreload(() => import("./drools-CIYq9jJK.js").then((n) => n.d), true ? __vite__mapDeps([301,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/edifact", () => __vitePreload(() => import("./edifact-Cb73PUHH.js").then((n) => n.e), true ? __vite__mapDeps([302,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/eiffel", () => __vitePreload(() => import("./eiffel-DqQEYrv9.js").then((n) => n.e), true ? __vite__mapDeps([303,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/ejs", () => __vitePreload(() => import("./ejs-DWl3vP4w.js").then((n) => n.e), true ? __vite__mapDeps([304,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/elixir", () => __vitePreload(() => import("./elixir-BJda7gNe.js").then((n) => n.e), true ? __vite__mapDeps([305,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/elm", () => __vitePreload(() => import("./elm-PbbgNvYa.js").then((n) => n.e), true ? __vite__mapDeps([306,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/erlang", () => __vitePreload(() => import("./erlang-RMn66iAt.js").then((n) => n.e), true ? __vite__mapDeps([307,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/forth", () => __vitePreload(() => import("./forth-C187vFZA.js").then((n) => n.f), true ? __vite__mapDeps([308,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/fortran", () => __vitePreload(() => import("./fortran-LayfPElz.js").then((n) => n.f), true ? __vite__mapDeps([309,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/fsharp", () => __vitePreload(() => import("./fsharp-rVs8DV2p.js").then((n) => n.f), true ? __vite__mapDeps([310,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/fsl", () => __vitePreload(() => import("./fsl-Du4fyyH0.js").then((n) => n.f), true ? __vite__mapDeps([311,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/ftl", () => __vitePreload(() => import("./ftl-4pOLNi-S.js").then((n) => n.f), true ? __vite__mapDeps([312,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/gcode", () => __vitePreload(() => import("./gcode-5t6R3a6s.js").then((n) => n.g), true ? __vite__mapDeps([313,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/gherkin", () => __vitePreload(() => import("./gherkin-C7sgbKhz.js").then((n) => n.g), true ? __vite__mapDeps([314,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/gitignore", () => __vitePreload(() => import("./gitignore-BJExyNpy.js").then((n) => n.g), true ? __vite__mapDeps([315,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/glsl", () => __vitePreload(() => import("./glsl-BIT7tyqM.js").then((n) => n.g), true ? __vite__mapDeps([316,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/gobstones", () => __vitePreload(() => import("./gobstones-DZC5o0Yg.js").then((n) => n.g), true ? __vite__mapDeps([317,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/golang", () => __vitePreload(() => import("./golang-Cky0HXmm.js").then((n) => n.g), true ? __vite__mapDeps([318,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/graphqlschema", () => __vitePreload(() => import("./graphqlschema-DHz8XIrn.js").then((n) => n.g), true ? __vite__mapDeps([319,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/groovy", () => __vitePreload(() => import("./groovy-CxV4LfQ1.js").then((n) => n.g), true ? __vite__mapDeps([320,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/haml", () => __vitePreload(() => import("./haml-CUQKHFbq.js").then((n) => n.h), true ? __vite__mapDeps([321,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/handlebars", () => __vitePreload(() => import("./handlebars-DjBU5Qci.js").then((n) => n.h), true ? __vite__mapDeps([322,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/haskell", () => __vitePreload(() => import("./haskell-Dg_IYtIF.js").then((n) => n.h), true ? __vite__mapDeps([323,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/haskell_cabal", () => __vitePreload(() => import("./haskell_cabal-DooJpaup.js").then((n) => n.h), true ? __vite__mapDeps([324,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/haxe", () => __vitePreload(() => import("./haxe-BcWirKAJ.js").then((n) => n.h), true ? __vite__mapDeps([325,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/hjson", () => __vitePreload(() => import("./hjson-l0lQzsls.js").then((n) => n.h), true ? __vite__mapDeps([326,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/html", () => __vitePreload(() => import("./html-DmuB9C6-.js").then((n) => n.h), true ? __vite__mapDeps([327,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/html_elixir", () => __vitePreload(() => import("./html_elixir-cfoBbPki.js").then((n) => n.h), true ? __vite__mapDeps([328,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/html_ruby", () => __vitePreload(() => import("./html_ruby-CZCw0U8k.js").then((n) => n.h), true ? __vite__mapDeps([329,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/ini", () => __vitePreload(() => import("./ini-D0fXEKqf.js").then((n) => n.i), true ? __vite__mapDeps([330,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/io", () => __vitePreload(() => import("./io-Cw1KSq5U.js").then((n) => n.i), true ? __vite__mapDeps([331,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/ion", () => __vitePreload(() => import("./ion-rBAJBfqq.js").then((n) => n.i), true ? __vite__mapDeps([332,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/jack", () => __vitePreload(() => import("./jack-BRp9SkWx.js").then((n) => n.j), true ? __vite__mapDeps([333,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/jade", () => __vitePreload(() => import("./jade-DkefQPfW.js").then((n) => n.j), true ? __vite__mapDeps([334,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/java", () => __vitePreload(() => import("./java-CdR78ZQy.js").then((n) => n.j), true ? __vite__mapDeps([335,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/javascript", () => __vitePreload(() => import("./javascript-D1CnXGZV.js").then((n) => n.j), true ? __vite__mapDeps([336,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/jexl", () => __vitePreload(() => import("./jexl-DHKJn5mp.js").then((n) => n.j), true ? __vite__mapDeps([337,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/json", () => __vitePreload(() => import("./json-Dn7_q9gR.js").then((n) => n.j), true ? __vite__mapDeps([338,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/json5", () => __vitePreload(() => import("./json5-D_Nfthur.js").then((n) => n.j), true ? __vite__mapDeps([339,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/jsoniq", () => __vitePreload(() => import("./jsoniq-Dr5RpXfE.js").then((n) => n.j), true ? __vite__mapDeps([340,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/jsp", () => __vitePreload(() => import("./jsp-C-dIwKao.js").then((n) => n.j), true ? __vite__mapDeps([341,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/jssm", () => __vitePreload(() => import("./jssm-1VoYjpRH.js").then((n) => n.j), true ? __vite__mapDeps([342,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/jsx", () => __vitePreload(() => import("./jsx-BZYz8C-8.js").then((n) => n.j), true ? __vite__mapDeps([343,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/julia", () => __vitePreload(() => import("./julia-ZeECDrtS.js").then((n) => n.j), true ? __vite__mapDeps([344,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/kotlin", () => __vitePreload(() => import("./kotlin-Tavyyrjz.js").then((n) => n.k), true ? __vite__mapDeps([345,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/latex", () => __vitePreload(() => import("./latex-CbSzbM95.js").then((n) => n.l), true ? __vite__mapDeps([346,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/latte", () => __vitePreload(() => import("./latte-x16b9N4M.js").then((n) => n.l), true ? __vite__mapDeps([347,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/less", () => __vitePreload(() => import("./less-BBVoQUNx.js").then((n) => n.l), true ? __vite__mapDeps([348,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/liquid", () => __vitePreload(() => import("./liquid-BJD9Jggn.js").then((n) => n.l), true ? __vite__mapDeps([349,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/lisp", () => __vitePreload(() => import("./lisp-brU3Njk9.js").then((n) => n.l), true ? __vite__mapDeps([350,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/livescript", () => __vitePreload(() => import("./livescript-R54hsikb.js").then((n) => n.l), true ? __vite__mapDeps([351,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/logiql", () => __vitePreload(() => import("./logiql-VT03gQju.js").then((n) => n.l), true ? __vite__mapDeps([352,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/logtalk", () => __vitePreload(() => import("./logtalk-DgD5tEKl.js").then((n) => n.l), true ? __vite__mapDeps([353,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/lsl", () => __vitePreload(() => import("./lsl-DwANLG5L.js").then((n) => n.l), true ? __vite__mapDeps([354,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/lua", () => __vitePreload(() => import("./lua-KB462xJZ.js").then((n) => n.l), true ? __vite__mapDeps([355,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/luapage", () => __vitePreload(() => import("./luapage-C2KxtZRD.js").then((n) => n.l), true ? __vite__mapDeps([356,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/lucene", () => __vitePreload(() => import("./lucene-Ddsdwf8B.js").then((n) => n.l), true ? __vite__mapDeps([357,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/makefile", () => __vitePreload(() => import("./makefile-BAKUlOxX.js").then((n) => n.m), true ? __vite__mapDeps([358,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/markdown", () => __vitePreload(() => import("./markdown-C7NXMxs_.js").then((n) => n.m), true ? __vite__mapDeps([359,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/mask", () => __vitePreload(() => import("./mask-CHd8Ii9R.js").then((n) => n.m), true ? __vite__mapDeps([360,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/matlab", () => __vitePreload(() => import("./matlab-BgLHc73d.js").then((n) => n.m), true ? __vite__mapDeps([361,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/maze", () => __vitePreload(() => import("./maze-xJbIIxkl.js").then((n) => n.m), true ? __vite__mapDeps([362,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/mediawiki", () => __vitePreload(() => import("./mediawiki-BpU2_ljM.js").then((n) => n.m), true ? __vite__mapDeps([363,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/mel", () => __vitePreload(() => import("./mel-B0bsWAr_.js").then((n) => n.m), true ? __vite__mapDeps([364,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/mips", () => __vitePreload(() => import("./mips-nu4hdQb-.js").then((n) => n.m), true ? __vite__mapDeps([365,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/mixal", () => __vitePreload(() => import("./mixal-iqu_c_rC.js").then((n) => n.m), true ? __vite__mapDeps([366,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/mushcode", () => __vitePreload(() => import("./mushcode-CUUfxNb6.js").then((n) => n.m), true ? __vite__mapDeps([367,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/mysql", () => __vitePreload(() => import("./mysql-BdbM_ZxD.js").then((n) => n.m), true ? __vite__mapDeps([368,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/nginx", () => __vitePreload(() => import("./nginx-C_NvS4P5.js").then((n) => n.n), true ? __vite__mapDeps([369,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/nim", () => __vitePreload(() => import("./nim-CQ_C_zvq.js").then((n) => n.n), true ? __vite__mapDeps([370,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/nix", () => __vitePreload(() => import("./nix-ILaSSPcB.js").then((n) => n.n), true ? __vite__mapDeps([371,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/nsis", () => __vitePreload(() => import("./nsis-CZRhd0ay.js").then((n) => n.n), true ? __vite__mapDeps([372,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/nunjucks", () => __vitePreload(() => import("./nunjucks-DEW4FIKf.js").then((n) => n.n), true ? __vite__mapDeps([373,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/objectivec", () => __vitePreload(() => import("./objectivec-C6YpGJTm.js").then((n) => n.o), true ? __vite__mapDeps([374,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/ocaml", () => __vitePreload(() => import("./ocaml-2cjitzaq.js").then((n) => n.o), true ? __vite__mapDeps([375,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/partiql", () => __vitePreload(() => import("./partiql-B7-LpKL_.js").then((n) => n.p), true ? __vite__mapDeps([376,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/pascal", () => __vitePreload(() => import("./pascal-BhSzRQuD.js").then((n) => n.p), true ? __vite__mapDeps([377,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/perl", () => __vitePreload(() => import("./perl-BU8bn5Cu.js").then((n) => n.p), true ? __vite__mapDeps([378,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/pgsql", () => __vitePreload(() => import("./pgsql-Dd3ExB6a.js").then((n) => n.p), true ? __vite__mapDeps([379,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/php", () => __vitePreload(() => import("./php-gD9ZDW9G.js").then((n) => n.p), true ? __vite__mapDeps([380,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/php_laravel_blade", () => __vitePreload(() => import("./php_laravel_blade-Dxj3F60-.js").then((n) => n.p), true ? __vite__mapDeps([381,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/pig", () => __vitePreload(() => import("./pig-CuX1r4qQ.js").then((n) => n.p), true ? __vite__mapDeps([382,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/plain_text", () => __vitePreload(() => import("./plain_text-CUNdYPfv.js").then((n) => n.p), true ? __vite__mapDeps([383,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/plsql", () => __vitePreload(() => import("./plsql-D4MDpFXo.js").then((n) => n.p), true ? __vite__mapDeps([384,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/powershell", () => __vitePreload(() => import("./powershell-wlTiAGHi.js").then((n) => n.p), true ? __vite__mapDeps([385,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/praat", () => __vitePreload(() => import("./praat-9jhAaIQ_.js").then((n) => n.p), true ? __vite__mapDeps([386,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/prisma", () => __vitePreload(() => import("./prisma-CSA2bC57.js").then((n) => n.p), true ? __vite__mapDeps([387,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/prolog", () => __vitePreload(() => import("./prolog-BHcuuWm7.js").then((n) => n.p), true ? __vite__mapDeps([388,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/properties", () => __vitePreload(() => import("./properties-CtEk0z8X.js").then((n) => n.p), true ? __vite__mapDeps([389,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/protobuf", () => __vitePreload(() => import("./protobuf-OSZ0U1eW.js").then((n) => n.p), true ? __vite__mapDeps([390,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/puppet", () => __vitePreload(() => import("./puppet-DI9V265k.js").then((n) => n.p), true ? __vite__mapDeps([391,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/python", () => __vitePreload(() => import("./python-BRPEAeSJ.js").then((n) => n.p), true ? __vite__mapDeps([392,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/qml", () => __vitePreload(() => import("./qml-ABzcuRnX.js").then((n) => n.q), true ? __vite__mapDeps([393,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/r", () => __vitePreload(() => import("./r-CBI5rCWz.js").then((n) => n.r), true ? __vite__mapDeps([394,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/raku", () => __vitePreload(() => import("./raku-hrjc4ubt.js").then((n) => n.r), true ? __vite__mapDeps([395,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/razor", () => __vitePreload(() => import("./razor-iSLg8LVw.js").then((n) => n.r), true ? __vite__mapDeps([396,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/rdoc", () => __vitePreload(() => import("./rdoc-zX8SZqt6.js").then((n) => n.r), true ? __vite__mapDeps([397,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/red", () => __vitePreload(() => import("./red-DOofQE2H.js").then((n) => n.r), true ? __vite__mapDeps([398,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/redshift", () => __vitePreload(() => import("./redshift-Hhw-UQHY.js").then((n) => n.r), true ? __vite__mapDeps([399,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/rhtml", () => __vitePreload(() => import("./rhtml-BvhChPVY.js").then((n) => n.r), true ? __vite__mapDeps([400,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/robot", () => __vitePreload(() => import("./robot-Ci0OVa9-.js").then((n) => n.r), true ? __vite__mapDeps([401,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/rst", () => __vitePreload(() => import("./rst-DCE6iA3i.js").then((n) => n.r), true ? __vite__mapDeps([402,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/ruby", () => __vitePreload(() => import("./ruby-CZGLnLT7.js").then((n) => n.r), true ? __vite__mapDeps([403,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/rust", () => __vitePreload(() => import("./rust-c5qetp3n.js").then((n) => n.r), true ? __vite__mapDeps([404,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/sac", () => __vitePreload(() => import("./sac-CSf5sDos.js").then((n) => n.s), true ? __vite__mapDeps([405,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/sass", () => __vitePreload(() => import("./sass-DaZ8szBO.js").then((n) => n.s), true ? __vite__mapDeps([406,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/scad", () => __vitePreload(() => import("./scad-CVusb0HT.js").then((n) => n.s), true ? __vite__mapDeps([407,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/scala", () => __vitePreload(() => import("./scala-CDdmlwB_.js").then((n) => n.s), true ? __vite__mapDeps([408,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/scheme", () => __vitePreload(() => import("./scheme-DHQsYzhT.js").then((n) => n.s), true ? __vite__mapDeps([409,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/scrypt", () => __vitePreload(() => import("./scrypt-DgPkw0WW.js").then((n) => n.s), true ? __vite__mapDeps([410,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/scss", () => __vitePreload(() => import("./scss-YW3L-2yq.js").then((n) => n.s), true ? __vite__mapDeps([411,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/sh", () => __vitePreload(() => import("./sh-DWcnS245.js").then((n) => n.s), true ? __vite__mapDeps([412,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/sjs", () => __vitePreload(() => import("./sjs-C4mscX92.js").then((n) => n.s), true ? __vite__mapDeps([413,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/slim", () => __vitePreload(() => import("./slim-BHpBabcA.js").then((n) => n.s), true ? __vite__mapDeps([414,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/smarty", () => __vitePreload(() => import("./smarty-BI4Go1fr.js").then((n) => n.s), true ? __vite__mapDeps([415,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/smithy", () => __vitePreload(() => import("./smithy-DOEiwlEw.js").then((n) => n.s), true ? __vite__mapDeps([416,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/snippets", () => __vitePreload(() => import("./snippets-DXhyjLWK.js").then((n) => n.s), true ? __vite__mapDeps([417,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/soy_template", () => __vitePreload(() => import("./soy_template-_lplzK_3.js").then((n) => n.s), true ? __vite__mapDeps([418,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/space", () => __vitePreload(() => import("./space-BFRaE9cQ.js").then((n) => n.s), true ? __vite__mapDeps([419,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/sparql", () => __vitePreload(() => import("./sparql-0GEuLc3r.js").then((n) => n.s), true ? __vite__mapDeps([420,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/sql", () => __vitePreload(() => import("./sql-CtwR3Rip.js").then((n) => n.s), true ? __vite__mapDeps([421,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/sqlserver", () => __vitePreload(() => import("./sqlserver-Bjhpf087.js").then((n) => n.s), true ? __vite__mapDeps([422,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/stylus", () => __vitePreload(() => import("./stylus-CGaJzFiU.js").then((n) => n.s), true ? __vite__mapDeps([423,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/svg", () => __vitePreload(() => import("./svg-Cvl0wkJ6.js").then((n) => n.s), true ? __vite__mapDeps([424,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/swift", () => __vitePreload(() => import("./swift-BMZwfT9O.js").then((n) => n.s), true ? __vite__mapDeps([425,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/tcl", () => __vitePreload(() => import("./tcl-Bbw2nAxK.js").then((n) => n.t), true ? __vite__mapDeps([426,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/terraform", () => __vitePreload(() => import("./terraform-D8lc2x8I.js").then((n) => n.t), true ? __vite__mapDeps([427,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/tex", () => __vitePreload(() => import("./tex-C0PuHebH.js").then((n) => n.t), true ? __vite__mapDeps([428,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/text", () => __vitePreload(() => import("./text-W0uvhcLs.js").then((n) => n.t), true ? __vite__mapDeps([429,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/textile", () => __vitePreload(() => import("./textile-s60qmdzJ.js").then((n) => n.t), true ? __vite__mapDeps([430,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/toml", () => __vitePreload(() => import("./toml-CEKH2DS9.js").then((n) => n.t), true ? __vite__mapDeps([431,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/tsx", () => __vitePreload(() => import("./tsx-CXJT3DM4.js").then((n) => n.t), true ? __vite__mapDeps([432,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/turtle", () => __vitePreload(() => import("./turtle-D5jMlPrc.js").then((n) => n.t), true ? __vite__mapDeps([433,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/twig", () => __vitePreload(() => import("./twig-CXG-bFlZ.js").then((n) => n.t), true ? __vite__mapDeps([434,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/typescript", () => __vitePreload(() => import("./typescript-CiZ7zDrF.js").then((n) => n.t), true ? __vite__mapDeps([435,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/vala", () => __vitePreload(() => import("./vala-B7rbJ9nI.js").then((n) => n.v), true ? __vite__mapDeps([436,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/vbscript", () => __vitePreload(() => import("./vbscript-Dov_hbCw.js").then((n) => n.v), true ? __vite__mapDeps([437,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/velocity", () => __vitePreload(() => import("./velocity-CK1SoJ8P.js").then((n) => n.v), true ? __vite__mapDeps([438,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/verilog", () => __vitePreload(() => import("./verilog--5hx8IP1.js").then((n) => n.v), true ? __vite__mapDeps([439,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/vhdl", () => __vitePreload(() => import("./vhdl-D_qrqksV.js").then((n) => n.v), true ? __vite__mapDeps([440,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/visualforce", () => __vitePreload(() => import("./visualforce-U6AQSjD6.js").then((n) => n.v), true ? __vite__mapDeps([441,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/wollok", () => __vitePreload(() => import("./wollok-HweflpAN.js").then((n) => n.w), true ? __vite__mapDeps([442,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/xml", () => __vitePreload(() => import("./xml-PWR1Xfhc.js").then((n) => n.x), true ? __vite__mapDeps([443,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/xquery", () => __vitePreload(() => import("./xquery-CCCS4Ekw.js").then((n) => n.x), true ? __vite__mapDeps([444,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/yaml", () => __vitePreload(() => import("./yaml-YBWsxdcK.js").then((n) => n.y), true ? __vite__mapDeps([445,1]) : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/zeek", () => __vitePreload(() => import("./zeek-D1ij6H2K.js").then((n) => n.z), true ? __vite__mapDeps([446,1]) : void 0, import.meta.url));
const contentStyles = css`

  /*ace_scrollbar.css*/
  .ace_editor > .ace_sb-v div, .ace_editor > .ace_sb-h div {
    position: absolute;
    background: rgba(128, 128, 128, 0.6);
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    border: 1px solid #bbb;
    border-radius: 2px;
    z-index: 8;
  }

  .ace_editor > .ace_sb-v, .ace_editor > .ace_sb-h {
    position: absolute;
    z-index: 6;
    background: none;
    overflow: hidden !important;
  }

  .ace_editor > .ace_sb-v {
    z-index: 6;
    right: 0;
    top: 0;
    width: 12px;
  }

  .ace_editor > .ace_sb-v div {
    z-index: 8;
    right: 0;
    width: 100%;
  }

  .ace_editor > .ace_sb-h {
    bottom: 0;
    left: 0;
    height: 12px;
  }

  .ace_editor > .ace_sb-h div {
    bottom: 0;
    height: 100%;
  }

  .ace_editor > .ace_sb_grabbed {
    z-index: 8;
    background: #000;
  }

  /*ace_editor.css*/

  .ace_br1 {
    border-top-left-radius: 3px;
  }

  .ace_br2 {
    border-top-right-radius: 3px;
  }

  .ace_br3 {
    border-top-left-radius: 3px;
    border-top-right-radius: 3px;
  }

  .ace_br4 {
    border-bottom-right-radius: 3px;
  }

  .ace_br5 {
    border-top-left-radius: 3px;
    border-bottom-right-radius: 3px;
  }

  .ace_br6 {
    border-top-right-radius: 3px;
    border-bottom-right-radius: 3px;
  }

  .ace_br7 {
    border-top-left-radius: 3px;
    border-top-right-radius: 3px;
    border-bottom-right-radius: 3px;
  }

  .ace_br8 {
    border-bottom-left-radius: 3px;
  }

  .ace_br9 {
    border-top-left-radius: 3px;
    border-bottom-left-radius: 3px;
  }

  .ace_br10 {
    border-top-right-radius: 3px;
    border-bottom-left-radius: 3px;
  }

  .ace_br11 {
    border-top-left-radius: 3px;
    border-top-right-radius: 3px;
    border-bottom-left-radius: 3px;
  }

  .ace_br12 {
    border-bottom-right-radius: 3px;
    border-bottom-left-radius: 3px;
  }

  .ace_br13 {
    border-top-left-radius: 3px;
    border-bottom-right-radius: 3px;
    border-bottom-left-radius: 3px;
  }

  .ace_br14 {
    border-top-right-radius: 3px;
    border-bottom-right-radius: 3px;
    border-bottom-left-radius: 3px;
  }

  .ace_br15 {
    border-top-left-radius: 3px;
    border-top-right-radius: 3px;
    border-bottom-right-radius: 3px;
    border-bottom-left-radius: 3px;
  }

  .ace_editor {
    height: 100%;
    width: 100%;
    position: relative;
    overflow: hidden;
    padding:  0;
    font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Source Code Pro', 'source-code-pro', monospace;
    direction: ltr;
    text-align: left;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    border: 1px solid;
    border-radius: var(--lumo-border-radius-l);
    border-color: var(--lumo-contrast-20pct);
  }

  .ace_scroller {
    position: absolute;
    overflow: hidden;
    top: 0;
    bottom: 0;
    background-color: inherit;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: text;
  }

  .ace_content {
    position: absolute;
    box-sizing: border-box;
    min-width: 100%;
    contain: style size layout;
    font-variant-ligatures: no-common-ligatures;
  }

  .ace_dragging .ace_scroller:before {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    content: '';
    background: rgba(250, 250, 250, 0.01);
    z-index: 1000;
  }

  .ace_dragging.ace_dark .ace_scroller:before {
    background: rgba(0, 0, 0, 0.01);
  }

  .ace_gutter {
    position: absolute;
    overflow: hidden;
    width: auto;
    top: 0;
    bottom: 0;
    left: 0;
    cursor: default;
    z-index: 1;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    contain: style size layout;
  }

  .ace_gutter-active-line {
    position: absolute;
    left: 0;
    right: 0;
  }

  .ace_scroller.ace_scroll-left:after {
    content: "";
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;
    pointer-events: none;
  }

  .ace_gutter-cell {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding-left: 19px;
    padding-right: 6px;
    background-repeat: no-repeat;
  }

  .ace_gutter-cell.ace_error {
    background-image: url("./style/main-1.png");
    background-repeat: no-repeat;
    background-position: 2px center;
  }

  .ace_gutter-cell.ace_warning {
    background-image: url("./style/main-2.png");
    background-position: 2px center;
  }

  .ace_gutter-cell.ace_info {
    background-image: url("./style/main-3.png");
    background-position: 2px center;
  }

  .ace_dark .ace_gutter-cell.ace_info {
    background-image: url("./style/main-4.png");
  }

  .ace_scrollbar {
    contain: strict;
    position: absolute;
    right: 0;
    bottom: 0;
    z-index: 6;
  }

  .ace_scrollbar-inner {
    position: absolute;
    cursor: text;
    left: 0;
    top: 0;
  }

  .ace_scrollbar-v {
    overflow-x: hidden;
    overflow-y: scroll;
    top: 0;
  }

  .ace_scrollbar-h {
    overflow-x: scroll;
    overflow-y: hidden;
    left: 0;
  }

  .ace_print-margin {
    position: absolute;
    height: 100%;
  }

  .ace_text-input {
    position: absolute;
    z-index: 0;
    width: 0.5em;
    height: 1em;
    opacity: 0;
    background: transparent;
    -moz-appearance: none;
    appearance: none;
    border: none;
    resize: none;
    outline: none;
    overflow: hidden;
    font: inherit;
    padding: 0 1px;
    margin: 0 -1px;
    contain: strict;
    -ms-user-select: text;
    -moz-user-select: text;
    -webkit-user-select: text;
    user-select: text;
    /*with \`pre-line\` chrome inserts &nbsp; instead of space*/
    white-space: pre !important;
  }

  .ace_text-input.ace_composition {
    background: transparent;
    color: inherit;
    z-index: 1000;
    opacity: 1;
  }

  .ace_composition_placeholder {
    color: transparent
  }

  .ace_composition_marker {
    border-bottom: 1px solid;
    position: absolute;
    border-radius: 0;
    margin-top: 1px;
  }

  [ace_nocontext=true] {
    transform: none !important;
    filter: none !important;
    clip-path: none !important;
    mask: none !important;
    contain: none !important;
    perspective: none !important;
    mix-blend-mode: initial !important;
    z-index: auto;
  }

  .ace_layer {
    z-index: 1;
    position: absolute;
    overflow: hidden;
    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/
    word-wrap: normal;
    white-space: pre;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
    /* setting pointer-events: auto; on node under the mouse, which changes
    during scroll, will break mouse wheel scrolling in Safari */
    pointer-events: none;
  }

  .ace_gutter-layer {
    position: relative;
    width: auto;
    text-align: right;
    pointer-events: auto;
    height: 1000000px;
    contain: style size layout;
  }

  .ace_text-layer {
    font: inherit !important;
    position: absolute;
    height: 1000000px;
    width: 1000000px;
    contain: style size layout;
  }

  .ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {
    contain: style size layout;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
  }

  .ace_hidpi .ace_text-layer,
  .ace_hidpi .ace_gutter-layer,
  .ace_hidpi .ace_content,
  .ace_hidpi .ace_gutter {
    contain: strict;
    will-change: transform;
  }

  .ace_hidpi .ace_text-layer > .ace_line,
  .ace_hidpi .ace_text-layer > .ace_line_group {
    contain: strict;
  }

  .ace_cjk {
    display: inline-block;
    text-align: center;
  }

  .ace_cursor-layer {
    z-index: 4;
  }

  .ace_cursor {
    z-index: 4;
    position: absolute;
    box-sizing: border-box;
    border-left: 2px solid;
    /* workaround for smooth cursor repaintng whole screen in chrome */
    transform: translatez(0);
  }

  .ace_multiselect .ace_cursor {
    border-left-width: 1px;
  }

  .ace_slim-cursors .ace_cursor {
    border-left-width: 1px;
  }

  .ace_overwrite-cursors .ace_cursor {
    border-left-width: 0;
    border-bottom: 1px solid;
  }

  .ace_hidden-cursors .ace_cursor {
    opacity: 0.2;
  }

  .ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {
    opacity: 0;
  }

  .ace_smooth-blinking .ace_cursor {
    transition: opacity 0.18s;
  }

  .ace_animate-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: step-end;
    animation-name: blink-ace-animate;
    animation-iteration-count: infinite;
  }

  .ace_animate-blinking.ace_smooth-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: ease-in-out;
    animation-name: blink-ace-animate-smooth;
  }

  @keyframes blink-ace-animate {
    from, to {
      opacity: 1;
    }
    60% {
      opacity: 0;
    }
  }

  @keyframes blink-ace-animate-smooth {
    from, to {
      opacity: 1;
    }
    45% {
      opacity: 1;
    }
    60% {
      opacity: 0;
    }
    85% {
      opacity: 0;
    }
  }

  .ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {
    position: absolute;
    z-index: 3;
  }

  .ace_marker-layer .ace_selection {
    position: absolute;
    z-index: 5;
  }

  .ace_marker-layer .ace_bracket {
    position: absolute;
    z-index: 6;
  }

  .ace_marker-layer .ace_error_bracket {
    position: absolute;
    border-bottom: 1px solid #DE5555;
    border-radius: 0;
  }

  .ace_marker-layer .ace_active-line {
    position: absolute;
    z-index: 2;
  }

  .ace_marker-layer .ace_selected-word {
    position: absolute;
    z-index: 4;
    box-sizing: border-box;
  }

  .ace_line .ace_fold {
    box-sizing: border-box;
    display: inline-block;
    height: 11px;
    margin-top: -2px;
    vertical-align: middle;
    background-image: url("./style/main-5.png"),
    url("./style/main-6.png");
    background-repeat: no-repeat, repeat-x;
    background-position: center center, top left;
    color: transparent;
    border: 1px solid black;
    border-radius: 2px;
    cursor: pointer;
    pointer-events: auto;
  }

  .ace_dark .ace_fold {
  }

  .ace_fold:hover {
    background-image: url("./style/main-7.png"),
    url("./style/main-8.png");
  }

  .ace_tooltip {
    background-color: #f5f5f5;
    border: 1px solid gray;
    border-radius: 1px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    color: black;
    max-width: 100%;
    padding: 3px 4px;
    position: fixed;
    z-index: 999999;
    box-sizing: border-box;
    cursor: default;
    white-space: pre;
    word-wrap: break-word;
    line-height: normal;
    font-style: normal;
    font-weight: normal;
    letter-spacing: normal;
    pointer-events: none;
  }

  .ace_tooltip:focus {
    outline: 1px solid black;
  }

  .ace_folding-enabled > .ace_gutter-cell {
    padding-right: 13px;
  }

  .ace_fold-widget {
    box-sizing: border-box;
    margin: 0 -12px 0 1px;
    display: none;
    width: 11px;
    vertical-align: top;
    background-image: url("./style/main-9.png");
    background-repeat: no-repeat;
    background-position: center;
    border-radius: 3px;
    border: 1px solid transparent;
    cursor: pointer;
  }

  .ace_folding-enabled .ace_fold-widget {
    display: inline-block;
  }

  .ace_fold-widget.ace_end {
    background-image: url("./style/main-10.png");
  }

  .ace_fold-widget.ace_closed {
    background-image: url("./style/main-11.png");
  }

  .ace_fold-widget:hover {
    border: 1px solid rgba(0, 0, 0, 0.3);
    background-color: rgba(255, 255, 255, 0.2);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);
  }

  .ace_fold-widget:active {
    border: 1px solid rgba(0, 0, 0, 0.4);
    background-color: rgba(0, 0, 0, 0.05);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
  }

  /**
  * Dark version for fold widgets
  */

  .ace_dark .ace_fold-widget {
    background-image: url("./style/main-12.png");
  }

  .ace_dark .ace_fold-widget.ace_end {
    background-image: url("./style/main-13.png");
  }

  .ace_dark .ace_fold-widget.ace_closed {
    background-image: url("./style/main-14.png");
  }

  .ace_dark .ace_fold-widget:hover {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
    background-color: rgba(255, 255, 255, 0.1);
  }

  .ace_dark .ace_fold-widget:active {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
  }

  .ace_inline_button {
    border: 1px solid lightgray;
    display: inline-block;
    margin: -1px 8px;
    padding: 0 5px;
    pointer-events: auto;
    cursor: pointer;
  }

  .ace_inline_button:hover {
    border-color: gray;
    background: rgba(200, 200, 200, 0.2);
    display: inline-block;
    pointer-events: auto;
  }

  .ace_fold-widget.ace_invalid {
    background-color: #FFB4B4;
    border-color: #DE5555;
  }

  .ace_fade-fold-widgets .ace_fold-widget {
    transition: opacity 0.4s ease 0.05s;
    opacity: 0;
  }

  .ace_fade-fold-widgets:hover .ace_fold-widget {
    transition: opacity 0.05s ease 0.05s;
    opacity: 1;
  }

  .ace_underline {
    text-decoration: underline;
  }

  .ace_bold {
    font-weight: bold;
  }

  .ace_nobold .ace_bold {
    font-weight: normal;
  }

  .ace_italic {
    font-style: italic;
  }

  .ace_error-marker {
    background-color: rgba(255, 0, 0, 0.2);
    position: absolute;
    z-index: 9;
  }

  .ace_highlight-marker {
    background-color: rgba(255, 255, 0, 0.2);
    position: absolute;
    z-index: 8;
  }

  .ace_mobile-menu {
    position: absolute;
    line-height: 1.5;
    border-radius: 4px;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    background: white;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #dcdcdc;
    color: black;
  }

  .ace_dark > .ace_mobile-menu {
    background: #333;
    color: #ccc;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #444;
  }

  .ace_mobile-button {
    padding: 2px;
    cursor: pointer;
    overflow: hidden;
  }

  .ace_mobile-button:hover {
    background-color: #eee;
    opacity: 1;
  }

  .ace_mobile-button:active {
    background-color: #ddd;
  }

  .ace_placeholder {
    font-family: arial;
    transform: scale(0.9);
    transform-origin: left;
    white-space: pre;
    opacity: 0.7;
    margin: 0 10px;
  }

  .ace_ghost_text {
    opacity: 0.5;
    font-style: italic;
    white-space: pre;
  }

  /*ace-tm*/

  .ace-tm .ace_gutter {
    background: #f0f0f0;
    color: #333;
  }

  .ace-tm .ace_print-margin {
    width: 1px;
    background: #e8e8e8;
  }

  .ace-tm .ace_fold {
    background-color: #6B72E6;
  }

  .ace-tm {
    background-color: #FFFFFF;
    color: black;
  }

  .ace-tm .ace_cursor {
    color: black;
  }

  .ace-tm .ace_invisible {
    color: rgb(191, 191, 191);
  }

  .ace-tm .ace_storage,
  .ace-tm .ace_keyword {
    color: blue;
  }

  .ace-tm .ace_constant {
    color: rgb(197, 6, 11);
  }

  .ace-tm .ace_constant.ace_buildin {
    color: rgb(88, 72, 246);
  }

  .ace-tm .ace_constant.ace_language {
    color: rgb(88, 92, 246);
  }

  .ace-tm .ace_constant.ace_library {
    color: rgb(6, 150, 14);
  }

  .ace-tm .ace_invalid {
    background-color: rgba(255, 0, 0, 0.1);
    color: red;
  }

  .ace-tm .ace_support.ace_function {
    color: rgb(60, 76, 114);
  }

  .ace-tm .ace_support.ace_constant {
    color: rgb(6, 150, 14);
  }

  .ace-tm .ace_support.ace_type,
  .ace-tm .ace_support.ace_class {
    color: rgb(109, 121, 222);
  }

  .ace-tm .ace_keyword.ace_operator {
    color: rgb(104, 118, 135);
  }

  .ace-tm .ace_string {
    color: rgb(3, 106, 7);
  }

  .ace-tm .ace_comment {
    color: rgb(76, 136, 107);
  }

  .ace-tm .ace_comment.ace_doc {
    color: rgb(0, 102, 255);
  }

  .ace-tm .ace_comment.ace_doc.ace_tag {
    color: rgb(128, 159, 191);
  }

  .ace-tm .ace_constant.ace_numeric {
    color: rgb(0, 0, 205);
  }

  .ace-tm .ace_variable {
    color: rgb(49, 132, 149);
  }

  .ace-tm .ace_xml-pe {
    color: rgb(104, 104, 91);
  }

  .ace-tm .ace_entity.ace_name.ace_function {
    color: #0000A2;
  }

  .ace-tm .ace_heading {
    color: rgb(12, 7, 255);
  }

  .ace-tm .ace_list {
    color: rgb(185, 6, 144);
  }

  .ace-tm .ace_meta.ace_tag {
    color: rgb(0, 22, 142);
  }

  .ace-tm .ace_string.ace_regex {
    color: rgb(255, 0, 0)
  }

  .ace-tm .ace_marker-layer .ace_selection {
    background: rgb(181, 213, 255);
  }

  .ace-tm.ace_multiselect .ace_selection.ace_start {
    box-shadow: 0 0 3px 0px white;
  }

  .ace-tm .ace_marker-layer .ace_step {
    background: rgb(252, 255, 0);
  }

  .ace-tm .ace_marker-layer .ace_stack {
    background: rgb(164, 229, 101);
  }

  .ace-tm .ace_marker-layer .ace_bracket {
    margin: -1px 0 0 -1px;
    border: 1px solid rgb(192, 192, 192);
  }

  .ace-tm .ace_marker-layer .ace_active-line {
    background: rgba(0, 0, 0, 0.07);
  }

  .ace-tm .ace_gutter-active-line {
    background-color: #dcdcdc;
  }

  .ace-tm .ace_marker-layer .ace_selected-word {
    background: rgb(250, 250, 255);
    border: 1px solid rgb(200, 200, 250);
  }

  .ace-tm .ace_indent-guide {
    background: url("./style/main-15.png") right repeat-y;
  }

  .ace-tm .ace_indent-guide-active {
    background: url("./style/main-16.png") right repeat-y;
  }

  /*error_marker.css*/

  .error_widget_wrapper {
    background: inherit;
    color: inherit;
    border: none
  }

  .error_widget {
    border-top: solid 2px;
    border-bottom: solid 2px;
    margin: 5px 0;
    padding: 10px 40px;
    white-space: pre-wrap;
  }

  .error_widget.ace_error, .error_widget_arrow.ace_error {
    border-color: #ff5a5a
  }

  .error_widget.ace_warning, .error_widget_arrow.ace_warning {
    border-color: #F1D817
  }

  .error_widget.ace_info, .error_widget_arrow.ace_info {
    border-color: #5a5a5a
  }

  .error_widget.ace_ok, .error_widget_arrow.ace_ok {
    border-color: #5aaa5a
  }

  .error_widget_arrow {
    position: absolute;
    border: solid 5px;
    border-top-color: transparent !important;
    border-right-color: transparent !important;
    border-left-color: transparent !important;
    top: -5px;
  }

  /*codelense.css*/

  .ace_codeLens {
    position: absolute;
    color: #aaa;
    font-size: 88%;
    background: inherit;
    width: 100%;
    display: flex;
    align-items: flex-end;
    pointer-events: none;
  }

  .ace_codeLens > a {
    cursor: pointer;
    pointer-events: auto;
  }

  .ace_codeLens > a:hover {
    color: #0000ff;
    text-decoration: underline;
  }

  .ace_dark > .ace_codeLens > a:hover {
    color: #4e94ce;
  }

  /*snippets.css*/

  .ace_snippet-marker {
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    background: rgba(194, 193, 208, 0.09);
    border: 1px dotted rgba(211, 208, 235, 0.62);
    position: absolute;
  }

  /*autocompletion.css*/

  .ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {
    background-color: #CAD6FA;
    z-index: 1;
  }

  .ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {
    background-color: #3a674e;
  }

  .ace_editor.ace_autocomplete .ace_line-hover {
    border: 1px solid #abbffe;
    margin-top: -1px;
    background: rgba(233, 233, 253, 0.4);
    position: absolute;
    z-index: 2;
  }

  .ace_dark.ace_editor.ace_autocomplete .ace_line-hover {
    border: 1px solid rgba(109, 150, 13, 0.8);
    background: rgba(58, 103, 78, 0.62);
  }

  .ace_completion-meta {
    opacity: 0.5;
    margin: 0 0.9em;
  }

  .ace_completion-message {
    color: blue;
  }

  .ace_editor.ace_autocomplete .ace_completion-highlight {
    color: #2d69c7;
  }

  .ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight {
    color: #93ca12;
  }

  .ace_editor.ace_autocomplete {
    width: 300px;
    z-index: 200000;
    border: 1px lightgray solid;
    position: fixed;
    box-shadow: 2px 3px 5px rgba(0, 0, 0, .2);
    line-height: 1.4;
    background: #fefefe;
    color: #111;
  }

  .ace_dark.ace_editor.ace_autocomplete {
    border: 1px #484747 solid;
    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);
    line-height: 1.4;
    background: #25282c;
    color: #c1c1c1;
  }

  .ace_autocomplete_right .ace_text-layer {
    width: calc(100% - 8px);
  }

  .ace_autocomplete_right .ace_line {
    display: flex;
  }

  .ace_autocomplete_right .ace_completion-meta {
    flex: 1;
    text-align: right;
  }

  /*inlinetooltip.css*/

  .ace_inline_autocomplete_tooltip {
    display: inline-block;
  }

  .inline_autocomplete_tooltip_entry {
    display: inline-block;
    padding: 0 5px;
  }

  .inline_autocomplete_tooltip_button {
    display: inline-block;
    cursor: pointer;
    padding: 5px;
  }

  .inline_autocomplete_tooltip_button:hover {
    background-color: rgba(0, 0, 0, 0.1);
  }

  div.inline_autocomplete_tooltip_button_disabled {
    display: inline-block;
    padding: 5px;
    cursor: default;
    color: #777;
  }

  /*settings_menu.css*/

  #ace_settingsmenu, #kbshortcutmenu {
    background-color: #F7F7F7;
    color: black;
    box-shadow: -5px 4px 5px rgba(126, 126, 126, 0.55);
    padding: 1em 0.5em 2em 1em;
    overflow: auto;
    position: absolute;
    margin: 0;
    bottom: 0;
    right: 0;
    top: 0;
    z-index: 9991;
    cursor: default;
  }

  .ace_dark #ace_settingsmenu, .ace_dark #kbshortcutmenu {
    box-shadow: -20px 10px 25px rgba(126, 126, 126, 0.25);
    background-color: rgba(255, 255, 255, 0.6);
    color: black;
  }

  .ace_optionsMenuEntry:hover {
    background-color: rgba(100, 100, 100, 0.1);
    transition: all 0.3s
  }

  .ace_closeButton {
    background: rgba(245, 146, 146, 0.5);
    border: 1px solid #F48A8A;
    border-radius: 50%;
    padding: 7px;
    position: absolute;
    right: -8px;
    top: -8px;
    z-index: 100000;
  }

  .ace_closeButton {
    background: rgba(245, 146, 146, 0.9);
  }

  .ace_optionsMenuKey {
    color: darkslateblue;
    font-weight: bold;
  }

  .ace_optionsMenuCommand {
    color: darkcyan;
    font-weight: normal;
  }

  .ace_optionsMenuEntry input, .ace_optionsMenuEntry button {
    vertical-align: middle;
  }

  .ace_optionsMenuEntry button[ace_selected_button=true] {
    background: #e7e7e7;
    box-shadow: 1px 0px 2px 0px #adadad inset;
    border-color: #adadad;
  }

  .ace_optionsMenuEntry button {
    background: white;
    border: 1px solid lightgray;
    margin: 0px;
  }

  .ace_optionsMenuEntry button:hover {
    background: #f0f0f0;
  }

  /*promtp.css*/

  .ace_prompt_container {
    max-width: 603px;
    width: 100%;
    margin: 20px auto;
    padding: 3px;
    background: white;
    border-radius: 2px;
    box-shadow: 0px 2px 3px 0px #555;
  }

  /*ace_searchbox*/
  /* ------------------------------------------------------------------------------------------
  * Editor Search Form
  * --------------------------------------------------------------------------------------- */

  .ace_search {
    background-color: #ddd;
    color: #666;
    border: 1px solid #cbcbcb;
    border-top: 0 none;
    overflow: hidden;
    margin: 0;
    padding: 4px 6px 0 4px;
    position: absolute;
    top: 0;
    z-index: 99;
    white-space: normal;
  }

  .ace_search.left {
    border-left: 0 none;
    border-radius: 0px 0px 5px 0px;
    left: 0;
  }

  .ace_search.right {
    border-radius: 0px 0px 0px 5px;
    border-right: 0 none;
    right: 0;
  }

  .ace_search_form, .ace_replace_form {
    margin: 0 20px 4px 0;
    overflow: hidden;
    line-height: 1.9;
  }

  .ace_replace_form {
    margin-right: 0;
  }

  .ace_search_form.ace_nomatch {
    outline: 1px solid red;
  }

  .ace_search_field {
    border-radius: 3px 0 0 3px;
    background-color: white;
    color: black;
    border: 1px solid #cbcbcb;
    border-right: 0 none;
    outline: 0;
    padding: 0;
    font-size: inherit;
    margin: 0;
    line-height: inherit;
    padding: 0 6px;
    min-width: 17em;
    vertical-align: top;
    min-height: 1.8em;
    box-sizing: content-box;
  }

  .ace_searchbtn {
    border: 1px solid #cbcbcb;
    line-height: inherit;
    display: inline-block;
    padding: 0 6px;
    background: #fff;
    border-right: 0 none;
    border-left: 1px solid #dcdcdc;
    cursor: pointer;
    margin: 0;
    position: relative;
    color: #666;
  }

  .ace_searchbtn:last-child {
    border-radius: 0 3px 3px 0;
    border-right: 1px solid #cbcbcb;
  }

  .ace_searchbtn:disabled {
    background: none;
    cursor: default;
  }

  .ace_searchbtn:hover {
    background-color: #eef1f6;
  }

  .ace_searchbtn.prev, .ace_searchbtn.next {
    padding: 0px 0.7em
  }

  .ace_searchbtn.prev:after, .ace_searchbtn.next:after {
    content: "";
    border: solid 2px #888;
    width: 0.5em;
    height: 0.5em;
    border-width: 2px 0 0 2px;
    display: inline-block;
    transform: rotate(-45deg);
  }

  .ace_searchbtn.next:after {
    border-width: 0 2px 2px 0;
  }

  .ace_searchbtn_close {
    background: url("./style/main-17.png") no-repeat 50% 0;
    border-radius: 50%;
    border: 0 none;
    color: #656565;
    cursor: pointer;
    font: 16px/16px Arial;
    padding: 0;
    height: 14px;
    width: 14px;
    top: 9px;
    right: 7px;
    position: absolute;
  }

  .ace_searchbtn_close:hover {
    background-color: #656565;
    background-position: 50% 100%;
    color: white;
  }

  .ace_button {
    margin-left: 2px;
    cursor: pointer;
    -webkit-user-select: none;
    -moz-user-select: none;
    -o-user-select: none;
    -ms-user-select: none;
    user-select: none;
    overflow: hidden;
    opacity: 0.7;
    border: 1px solid rgba(100, 100, 100, 0.23);
    padding: 1px;
    box-sizing: border-box !important;
    color: black;
  }

  .ace_button:hover {
    background-color: #eee;
    opacity: 1;
  }

  .ace_button:active {
    background-color: #ddd;
  }

  .ace_button.checked {
    border-color: #3399ff;
    opacity: 1;
  }

  .ace_search_options {
    margin-bottom: 3px;
    text-align: right;
    -webkit-user-select: none;
    -moz-user-select: none;
    -o-user-select: none;
    -ms-user-select: none;
    user-select: none;
    clear: both;
  }

  .ace_search_counter {
    float: left;
    font-family: arial;
    padding: 0 8px;
  }

  /*incremental-occur-highlighting*/

  .ace_occur-highlight {
    border-radius: 4px;
    background-color: rgba(87, 255, 8, 0.25);
    position: absolute;
    z-index: 4;
    box-sizing: border-box;
    box-shadow: 0 0 4px rgb(91, 255, 50);
  }

  .ace_dark .ace_occur-highlight {
    background-color: rgb(80, 140, 85);
    box-shadow: 0 0 4px rgb(60, 120, 70);
  }

  /*incremental-search-highlighting*/

  .ace_marker-layer .ace_isearch-result {
    position: absolute;
    z-index: 6;
    box-sizing: border-box;
  }

  div.ace_isearch-result {
    border-radius: 4px;
    background-color: rgba(255, 200, 0, 0.5);
    box-shadow: 0 0 4px rgb(255, 200, 0);
  }

  .ace_dark div.ace_isearch-result {
    background-color: rgb(100, 110, 160);
    box-shadow: 0 0 4px rgb(80, 90, 140);
  }

  /*emacsMode*/

  .emacs-mode .ace_cursor {
    border: 1px rgba(50, 250, 50, 0.8) solid !important;
    box-sizing: border-box !important;
    background-color: rgba(0, 250, 0, 0.9);
    opacity: 0.5;
  }

  .emacs-mode .ace_hidden-cursors .ace_cursor {
    opacity: 1;
    background-color: transparent;
  }

  .emacs-mode .ace_overwrite-cursors .ace_cursor {
    opacity: 1;
    background-color: transparent;
    border-width: 0 0 2px 2px !important;
  }

  .emacs-mode .ace_text-layer {
    z-index: 4
  }

  .emacs-mode .ace_cursor-layer {
    z-index: 2
  }

  /*vimMode*/

  .normal-mode .ace_cursor {
    border: none;
    background-color: rgba(255, 0, 0, 0.5);
  }

  .normal-mode .ace_hidden-cursors .ace_cursor {
    background-color: transparent;
    border: 1px solid red;
    opacity: 0.7
  }

  .ace_dialog {
    position: absolute;
    left: 0;
    right: 0;
    background: inherit;
    z-index: 15;
    padding: .1em .8em;
    overflow: hidden;
    color: inherit;
  }

  .ace_dialog-top {
    border-bottom: 1px solid #444;
    top: 0;
  }

  .ace_dialog-bottom {
    border-top: 1px solid #444;
    bottom: 0;
  }

  .ace_dialog input {
    border: none;
    outline: none;
    background: transparent;
    width: 20em;
    color: inherit;
    font-family: monospace;
  }
`;
registerStyles$1("", contentStyles, { moduleId: "jmix-code-editor-content-styles" });
const statesStyles = css`

  :host {
    width: 50em;
    height: 20em;
  }

  .jmix-code-editor-container {
    height: 100%;
  }
`;
const jmixCodeEditorStyles = [contentStyles, statesStyles];
registerStyles$1("jmix-code-editor", [inputFieldShared, jmixCodeEditorStyles], { moduleId: "jmix-code-editor-styles" });
class JmixCodeEditor extends ResizeMixin(InputFieldMixin(ThemableMixin(ElementMixin(PolymerElement)))) {
  static get is() {
    return "jmix-code-editor";
  }
  static get template() {
    return html`
            <div class="jmix-code-editor-container">
                <div part="label">
                    <slot name="label"></slot>
                    <span part="required-indicator" aria-hidden="true"></span>
                </div>

                <div part="input-field"
                     readonly="[[readonly]]"
                     disabled="[[disabled]]"
                     invalid="[[invalid]]"></div>

                <div part="helper-text">
                    <slot name="helper"></slot>
                </div>

                <div part="error-message">
                    <slot name="error-message"></slot>
                </div>
            </div>

            <slot name="tooltip"></slot>
        `;
  }
  static get properties() {
    return {
      theme: {
        type: String,
        observer: "_onThemeChange",
        notify: true
      },
      mode: {
        type: String,
        value: "plain_text",
        observer: "_onModeChange"
      },
      highlightActiveLine: {
        type: Boolean,
        value: true,
        observer: "_onHighlightActiveLineChange"
      },
      highlightGutterLine: {
        type: Boolean,
        value: true,
        observer: "_onHighlightGutterLineChange"
      },
      showGutter: {
        type: Boolean,
        value: true,
        observer: "_onShowGutterChange"
      },
      showLineNumbers: {
        type: Boolean,
        value: true,
        observer: "_onShowLineNumbersChange"
      },
      showPrintMargin: {
        type: Boolean,
        value: true,
        observer: "_onShowPrintMarginChange"
      },
      printMarginColumn: {
        type: Number,
        value: 80,
        observer: "_onPrintMarginColumnChange"
      },
      value: {
        type: String,
        observer: "_onValueChange"
      },
      fontSize: {
        type: String,
        value: "1rem",
        observer: "_onFontSizeChange"
      },
      textWrap: {
        type: Boolean,
        value: false,
        observer: "_onTextWrapChange"
      },
      useSoftTabs: {
        type: Boolean,
        value: true,
        observer: "_onUseSoftTabsChange"
      },
      /** @private */
      _editor: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["_disabledChanged(disabled, readonly, _editor)"];
  }
  /** @protected */
  ready() {
    super.ready();
    const editor = this.shadowRoot.querySelector('[part="input-field"]');
    if (this.theme === void 0) {
      this.initApplicationThemeObserver();
    }
    this._editor = ace.edit(editor, {
      theme: "ace/theme/" + this.theme,
      mode: "ace/mode/" + this.mode,
      highlightActiveLine: this.highlightActiveLine,
      highlightGutterLine: this.highlightGutterLine,
      showGutter: this.showGutter,
      showLineNumbers: this.showLineNumbers,
      showPrintMargin: this.showPrintMargin,
      printMarginColumn: this.printMarginColumn,
      value: this.value,
      fontSize: this.fontSize,
      wrap: this.textWrap,
      useSoftTabs: this.useSoftTabs,
      useWorker: false
    });
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this._editor);
    this.addController(this._tooltipController);
    this._editor.on("blur", () => {
      this.value = this._editor.getValue();
      const customEvent = new CustomEvent("value-changed", { detail: { value: this._editor.getValue() } });
      this.dispatchEvent(customEvent);
      this._setFocused(false);
    });
    this.addEventListener("focus", (e2) => {
      this._setFocused(true);
    });
    this._setFocusElement(this._editor.textInput.getElement());
  }
  initApplicationThemeObserver() {
    this._applyTheme();
    this._applicationThemeObserver = new MutationObserver((mutations) => {
      if (mutations.filter((mutation) => mutation.type === "attributes" && mutation.attributeName === "theme").length !== 0) {
        this._applyTheme();
      }
    });
    this._applicationThemeObserver.observe(document.documentElement, {
      attributes: true
    });
  }
  /**
   * @protected
   */
  _applyTheme() {
    const currentTheme = this._getCurrentApplicationTheme();
    this.theme = currentTheme === "dark" ? "nord_dark" : "textmate";
  }
  /**
   * @protected
   */
  _getCurrentApplicationTheme() {
    return document.documentElement.getAttribute("theme");
  }
  /**
   * @protected
   */
  _disabledChanged(disabled, readonly, editor) {
    if (disabled === void 0 || readonly === void 0 || editor === void 0) {
      return;
    }
    editor.setReadOnly(disabled || readonly);
    if (!disabled && !readonly) {
      editor.textInput.getElement().removeAttribute("disabled");
    }
    this._editor.setHighlightActiveLine(this.highlightActiveLine && !readonly);
    this._editor.setHighlightGutterLine(this.highlightGutterLine && !readonly);
    this._editor.renderer.$cursorLayer.element.style.opacity = readonly ? 0 : 1;
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this._editor.resize();
  }
  /**
   * @protected
   */
  _onModeChange(mode) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.session.setMode("ace/mode/" + mode);
  }
  /**
   * @protected
   */
  _onThemeChange(theme) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setTheme("ace/theme/" + theme);
  }
  /**
   * @protected
   */
  _onHighlightActiveLineChange(showActiveLine) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setHighlightActiveLine(showActiveLine);
  }
  /**
   * @protected
   */
  _onHighlightGutterLineChange(showGutterLine) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setHighlightGutterLine(showGutterLine);
  }
  /**
   * @protected
   */
  _onShowGutterChange(showGutter) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setOption("showGutter", showGutter);
  }
  /**
   * @protected
   */
  _onShowLineNumbersChange(showLineNumbers) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setOption("showLineNumbers", showLineNumbers);
  }
  /**
   * @protected
   */
  _onShowPrintMarginChange(showPrintMargin) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setShowPrintMargin(showPrintMargin);
  }
  /**
   * @protected
   */
  _onValueChange(value) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.session.setValue(value);
  }
  /**
   * @protected
   */
  _onFontSizeChange(fontSize) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setFontSize(fontSize);
  }
  /**
   * @private
   */
  _onTextWrapChange(textWrap) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.session.setUseWrapMode(textWrap);
  }
  /**
   * @private
   */
  _onUseSoftTabsChange(useSoftTabs) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.session.setUseSoftTabs(useSoftTabs);
  }
  /**
   * @protected
   */
  _onPrintMarginColumnChange(printMarginColumn) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setPrintMarginColumn(printMarginColumn);
  }
  get clearElement() {
    return null;
  }
}
defineCustomElement(JmixCodeEditor);
const entityComboBox = css`
  [part="action-part"] ::slotted(*) {
    gap: var(--lumo-space-xs);
    margin-left: var(--lumo-space-xs);
  }
  
  :host([has-actions]) [part="input-field"] {
    padding-right: var(--lumo-space-xs);
  }
`;
registerStyles$1("jmix-combo-box-picker", entityComboBox, {
  moduleId: "lumo-combo-box-picker-styles"
});
registerStyles$1("jmix-combo-box-picker", [], {
  moduleId: "jmix-combo-box-picker-styles"
});
class JmixComboBoxPicker extends ComboBox {
  static get is() {
    return "jmix-combo-box-picker";
  }
  static get template() {
    return html`
            <style>
                [part="action-part"] ::slotted(*) {
                    display: flex;
                }

                :host([readonly]) [part="action-part"] {
                    display: none;
                }

                :host([opened]) {
                    pointer-events: auto;
                }
            </style>

            <div class="value-picker-container">
                <div part="label">
                    <slot name="label"></slot>
                    <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
                </div>

                <vaadin-input-container
                        part="input-field"
                        readonly="[[readonly]]"
                        disabled="[[disabled]]"
                        invalid="[[invalid]]"
                        theme$="[[_theme]]"
                >
                    <slot name="prefix" slot="prefix"></slot>
                    <slot name="input"></slot>
                    <div id="toggleButton" part="toggle-button" slot="suffix" aria-hidden="true"></div>
                    <!-- Jmix API -->
                    <div id="pickerAction" part="action-part" slot="suffix">
                        <slot name="actions"></slot>
                    </div>
                </vaadin-input-container>

                <div part="helper-text">
                    <slot name="helper"></slot>
                </div>

                <div part="error-message">
                    <slot name="error-message"></slot>
                </div>
            </div>

            <vaadin-combo-box-overlay
                    id="overlay"
                    opened="[[_overlayOpened]]"
                    loading$="[[loading]]"
                    theme$="[[_theme]]"
                    position-target="[[_positionTarget]]"
                    no-vertical-overlap
            ></vaadin-combo-box-overlay>

            <slot name="tooltip"></slot>
        `;
  }
  /**
   * Used by `ClearButtonMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return null;
  }
}
defineCustomElement(JmixComboBoxPicker);
const loginForm = css`
  .jmix-login-form-additional-fields-container {
    display: flex;
    gap: var(--lumo-space-s);
    justify-content: end;
    padding-top: var(--lumo-space-m);
  }
  
  .jmix-login-form-remember-me {
    align-self: center;
    flex-grow: 1;
  }
  
  .jmix-login-form-locales-select {
    width: var(--jmix-login-form-locales-select-width, 8em);
  }
  
  vaadin-select.jmix-login-form-locales-select vaadin-select-value-button {
    width: 0;
  }
`;
registerStyles$1("jmix-login-form", [loginForm], {
  moduleId: "lumo-jmix-login-form-styles"
});
class JmixLoginForm extends LoginForm {
  static get template() {
    return html`
            <style>
                vaadin-login-form-wrapper > form > * {
                    width: 100%;
                }
            </style>
            <vaadin-login-form-wrapper id="vaadinLoginFormWrapper" theme$="[[_theme]]" error="[[error]]" i18n="[[i18n]]">
                <form method="POST" action$="[[action]]" on-formdata="_onFormData" slot="form">
                    <input id="csrf" type="hidden"/>
                    <vaadin-text-field
                            name="username"
                            label="[[i18n.form.username]]"
                            error-message="[[i18n.errorMessage.username]]"
                            id="vaadinLoginUsername"
                            required
                            on-keydown="_handleInputKeydown"
                            autocapitalize="none"
                            autocorrect="off"
                            spellcheck="false"
                            autocomplete="username"
                            value="[[username]]"
                            manual-validation
                    >
                        <input type="text" slot="input" on-keyup="_handleInputKeyup"/>
                    </vaadin-text-field>

                    <vaadin-password-field
                            name="password"
                            label="[[i18n.form.password]]"
                            error-message="[[i18n.errorMessage.password]]"
                            id="vaadinLoginPassword"
                            required
                            on-keydown="_handleInputKeydown"
                            spellcheck="false"
                            autocomplete="current-password"
                            value="[[password]]"
                            manual-validation
                    >
                        <input type="password" slot="input" on-keyup="_handleInputKeyup"/>
                    </vaadin-password-field>

                    <div id="additionalFields" class="jmix-login-form-additional-fields-container">
                        <vaadin-checkbox id="rememberMeCheckbox"
                                         label="[[i18n.form.rememberMe]]"
                                         class="jmix-login-form-remember-me"></vaadin-checkbox>
                        <vaadin-select id="localesSelect"
                                       class="jmix-login-form-locales-select">
                        </vaadin-select>
                    </div>
                </form>

                <vaadin-button slot="submit" theme="primary contained submit" on-click="submit" disabled$="[[disabled]]">
                    [[i18n.form.submit]]
                </vaadin-button>

                <vaadin-button
                        slot="forgot-password"
                        theme="tertiary small"
                        on-click="_onForgotPasswordClick"
                        hidden$="[[noForgotPassword]]"
                >
                    [[i18n.form.forgotPassword]]
                </vaadin-button>
            </vaadin-login-form-wrapper>
        `;
  }
  static get is() {
    return "jmix-login-form";
  }
  static get properties() {
    return {
      username: {
        type: String,
        value: null,
        notify: true
      },
      password: {
        type: String,
        value: null,
        notify: true
      },
      rememberMeVisibility: {
        type: Boolean,
        value: true
      },
      localesVisibility: {
        type: Boolean,
        notify: true
      },
      locales: {
        type: Object,
        value: []
      },
      /* CAUTION! Copied from LoginMixin */
      i18n: {
        type: Object,
        value: function() {
          return {
            form: {
              title: "Log in",
              username: "Username",
              password: "Password",
              submit: "Log in",
              forgotPassword: "Forgot password",
              rememberMe: "Remember me"
            },
            errorMessage: {
              title: "Incorrect username or password",
              message: "Check that you have entered the correct username and password and try again.",
              username: "Username is required",
              password: "Password is required"
            }
          };
        },
        notify: true
      }
    };
  }
  static get observers() {
    return [
      "_onVisibilityPropertiesChanged(rememberMeVisibility, localesVisibility)",
      `_onLocalesPropertyChanged(locales)`
    ];
  }
  ready() {
    super.ready();
    this.$.localesSelect.addEventListener("value-changed", (e2) => this._localeValueChanged(e2));
    this.$.rememberMeCheckbox.addEventListener("checked-changed", (e2) => this._onRememberMeValueChange(e2));
    this.$.localesSelect.jmixUserOriginated = true;
    this.$.rememberMeCheckbox.jmixUserOriginated = true;
  }
  _onVisibilityPropertiesChanged(rememberMeVisibility, localesVisibility) {
    this.$.additionalFields.hidden = !rememberMeVisibility && !localesVisibility;
    this.$.rememberMeCheckbox.hidden = !rememberMeVisibility;
    this.$.localesSelect.hidden = !localesVisibility;
  }
  _onLocalesPropertyChanged(items) {
    this.$.localesSelect.items = items;
  }
  selectLocale(localeString) {
    const currentValue = this.$.localesSelect.value;
    if (localeString && currentValue !== localeString) {
      this.$.localesSelect.jmixUserOriginated = false;
      this.$.localesSelect.value = localeString;
    }
  }
  setRememberMe(rememberMe) {
    if (this.$.rememberMeCheckbox.checked !== rememberMe) {
      this.$.rememberMeCheckbox.jmixUserOriginated = false;
      this.$.rememberMeCheckbox.checked = rememberMe;
    }
  }
  _onRememberMeValueChange(e2) {
    if (this.$.rememberMeCheckbox.jmixUserOriginated) {
      const customEvent = new CustomEvent("remember-me-changed", { detail: { checked: e2.detail.value } });
      this.dispatchEvent(customEvent);
    }
    this.$.rememberMeCheckbox.jmixUserOriginated = true;
  }
  _localeValueChanged(e2) {
    const localeString = e2.detail.value;
    if (this.$.localesSelect.jmixUserOriginated) {
      const customEvent = new CustomEvent("locale-selection-changed", { detail: { localeString } });
      this.dispatchEvent(customEvent);
    }
    this.$.localesSelect.jmixUserOriginated = true;
  }
}
defineCustomElement(JmixLoginForm);
const multiSelectComboBoxPicker = css`
  [part="action-part"] ::slotted(*) {
    gap: var(--lumo-space-xs);
    margin-left: var(--lumo-space-xs);
  }
  
  :host([has-actions]) [part="input-field"] {
    padding-right: var(--lumo-space-xs);
  }
`;
registerStyles$1("jmix-multi-select-combo-box-picker", multiSelectComboBoxPicker, {
  moduleId: "lumo-multi-select-combo-box-picker-styles"
});
class JmixMultiSelectComboBoxInternal extends ComboBoxDataProviderMixin(ComboBoxMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "jmix-multi-select-combo-box-internal";
  }
  static get template() {
    return html`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <slot></slot>

      <vaadin-multi-select-combo-box-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[_target]]"
        no-vertical-overlap
        restore-focus-node="[[inputElement]]"
      ></vaadin-multi-select-combo-box-overlay>
    `;
  }
  static get properties() {
    return {
      /**
       * A subset of items, filtered based on the user input.
       */
      filteredItems: {
        type: Array,
        notify: true
      },
      /**
       * When true, filter string isn't cleared after selecting an item.
       */
      keepFilter: {
        type: Boolean,
        value: false
      },
      /**
       * When set to `true`, "loading" attribute is set
       * on the host and the overlay element.
       * @type {boolean}
       */
      loading: {
        type: Boolean,
        notify: true
      },
      /**
       * Total number of items.
       * @type {number | undefined}
       */
      size: {
        type: Number,
        notify: true
      },
      /**
       * Selected items to render in the dropdown
       * when the component is read-only.
       */
      selectedItems: {
        type: Array,
        value: () => []
      },
      /**
       * Set to true to group selected items at the top of the overlay.
       * @attr {boolean} selected-items-on-top
       */
      selectedItemsOnTop: {
        type: Boolean,
        value: false
      },
      /**
       * Last input value entered by the user before value is updated.
       * Used to store `filter` property value before clearing it.
       */
      lastFilter: {
        type: String,
        notify: true
      },
      /**
       * A subset of items to be shown at the top of the overlay.
       */
      topGroup: {
        type: Array,
        observer: "_topGroupChanged"
      },
      _target: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["_readonlyChanged(readonly)"];
  }
  /**
   * Reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.querySelector('[part="clear-button"]');
  }
  /**
   * Tag name prefix used by scroller and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-multi-select-combo-box";
  }
  /**
   * Override method inherited from the combo-box
   * to allow opening dropdown when readonly.
   * @override
   */
  open() {
    if (!this.disabled && !(this.readonly && this.selectedItems.length === 0)) {
      this.opened = true;
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this._target = this;
    this._toggleElement = this.querySelector(".toggle-button");
  }
  /** @private */
  _readonlyChanged() {
    this._setDropdownItems(this.filteredItems);
  }
  /**
   * Override combo-box method to group selected
   * items at the top of the overlay.
   *
   * @protected
   * @override
   */
  _setDropdownItems(items) {
    if (this.readonly) {
      super._setDropdownItems(this.selectedItems);
      return;
    }
    if (this.filter || !this.selectedItemsOnTop) {
      super._setDropdownItems(items);
      return;
    }
    if (items && items.length && this.topGroup && this.topGroup.length) {
      const filteredItems = items.filter(
        (item2) => this._comboBox._findIndex(item2, this.topGroup, this.itemIdPath) === -1
      );
      super._setDropdownItems(this.topGroup.concat(filteredItems));
      return;
    }
    super._setDropdownItems(items);
  }
  /** @private */
  _topGroupChanged(topGroup) {
    if (topGroup) {
      this._setDropdownItems(this.filteredItems);
    }
  }
  /**
   * Override combo-box method to set correct owner for using by item renderers.
   * This needs to be done before the scroller gets added to the DOM to ensure
   * Lit directive works in case when combo-box is opened using attribute.
   *
   * @protected
   * @override
   */
  _initScroller() {
    const comboBox2 = this.getRootNode().host;
    this._comboBox = comboBox2;
    super._initScroller(comboBox2);
  }
  /**
   * Override Enter handler to keep overlay open
   * when item is selected or unselected.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onEnter(event) {
    if (this.opened) {
      event.preventDefault();
      event.stopPropagation();
      if (this.readonly) {
        this.close();
      } else if (this._hasValidInputValue()) {
        const focusedItem = this._dropdownItems[this._focusedIndex];
        this._commitValue();
        this._focusedIndex = this._dropdownItems.indexOf(focusedItem);
      }
      return;
    }
    super._onEnter(event);
  }
  /**
   * Override Escape handler to not clear
   * selected items when readonly.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (this.readonly) {
      event.stopPropagation();
      if (this.opened) {
        this.close();
      }
      return;
    }
    super._onEscape(event);
  }
  /**
   * Override from combo-box to ignore requests to clear the filter if the
   * keepFilter option is enabled. Exceptions are when the dropdown is closed,
   * so the filter is still cleared on cancel and focus out.
   * @protected
   * @override
   */
  _clearFilter() {
    if (!this.keepFilter || !this.opened) {
      super._clearFilter();
    }
  }
  /**
   * Override method from combo-box to always clear the filter when reverting
   * the input value, regardless of the keepFilter option.
   * @override
   * @protected
   */
  _revertInputValueToValue() {
    super._revertInputValueToValue();
    this.filter = "";
  }
  /**
   * @protected
   * @override
   */
  _commitValue() {
    this.lastFilter = this.filter;
    super._commitValue();
  }
  /**
   * Override method inherited from the combo-box
   * to not update focused item when readonly.
   * @protected
   * @override
   */
  _onArrowDown() {
    if (!this.readonly) {
      super._onArrowDown();
    } else if (!this.opened) {
      this.open();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not update focused item when readonly.
   * @protected
   * @override
   */
  _onArrowUp() {
    if (!this.readonly) {
      super._onArrowUp();
    } else if (!this.opened) {
      this.open();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to close dropdown on blur when readonly.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    if (!focused) {
      this._ignoreCommitValue = true;
    }
    super._setFocused(focused);
    if (!focused && this.readonly && !this._closeOnBlurIsPrevented) {
      this.close();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not commit an already selected item again
   * on blur, which would result in un-selecting.
   * @protected
   * @override
   */
  _detectAndDispatchChange() {
    if (this._ignoreCommitValue) {
      this._ignoreCommitValue = false;
      this.selectedItem = null;
      this._inputElementValue = "";
      return;
    }
    super._detectAndDispatchChange();
  }
  /**
   * @param {CustomEvent} event
   * @protected
   * @override
   */
  _overlaySelectedItemChanged(event) {
    event.stopPropagation();
    if (this.readonly) {
      return;
    }
    if (event.detail.item instanceof ComboBoxPlaceholder) {
      return;
    }
    if (this.opened) {
      this.lastFilter = this.filter;
      this.dispatchEvent(
        new CustomEvent("combo-box-item-selected", {
          detail: {
            item: event.detail.item
          }
        })
      );
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not request data provider when read-only.
   *
   * @protected
   * @override
   */
  _shouldFetchData() {
    if (this.readonly) {
      return false;
    }
    return super._shouldFetchData();
  }
  /**
   * Override method inherited from the combo-box
   * to not clear the data provider cache when read-only.
   *
   * @protected
   * @override
   */
  clearCache() {
    if (this.readonly) {
      return;
    }
    super.clearCache();
  }
  /**
   * Jmix API
   *
   * @param {Event} event
   * @protected
   * @override
   */
  _onHostClick(event) {
    const path = event.composedPath();
    if (!path.includes(this._actionsBox)) {
      super._onHostClick(event);
    }
  }
}
defineCustomElement(JmixMultiSelectComboBoxInternal);
registerStyles$1("jmix-multi-select-combo-box-picker", [], {
  moduleId: "jmix-multi-select-combo-box-picker-styles"
});
class JmixMultiSelectComboBoxPicker extends MultiSelectComboBox {
  static get is() {
    return "jmix-multi-select-combo-box-picker";
  }
  static get template() {
    return html`
            <style>
                [part="action-part"] ::slotted(*) {
                    display: flex;
                }

                :host([readonly]) [part="action-part"] {
                    display: none;
                }
            </style>
            
            <div class="vaadin-multi-select-combo-box-container">
                <div part="label">
                    <slot name="label"></slot>
                    <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
                </div>

                <vaadin-multi-select-combo-box-internal
                        id="comboBox"
                        items="[[items]]"
                        item-id-path="[[itemIdPath]]"
                        item-label-path="[[itemLabelPath]]"
                        item-value-path="[[itemValuePath]]"
                        disabled="[[disabled]]"
                        readonly="[[readonly]]"
                        auto-open-disabled="[[autoOpenDisabled]]"
                        allow-custom-value="[[allowCustomValue]]"
                        overlay-class="[[overlayClass]]"
                        data-provider="[[dataProvider]]"
                        filter="{{filter}}"
                        last-filter="{{_lastFilter}}"
                        loading="{{loading}}"
                        size="{{size}}"
                        filtered-items="[[filteredItems]]"
                        selected-items="[[selectedItems]]"
                        selected-items-on-top="[[selectedItemsOnTop]]"
                        item-class-name-generator="[[itemClassNameGenerator]]"
                        top-group="[[_topGroup]]"
                        opened="{{opened}}"
                        renderer="[[renderer]]"
                        keep-filter="[[keepFilter]]"
                        theme$="[[_theme]]"
                        on-combo-box-item-selected="_onComboBoxItemSelected"
                        on-change="_onComboBoxChange"
                        on-custom-value-set="_onCustomValueSet"
                        on-filtered-items-changed="_onFilteredItemsChanged"
                >
                    <vaadin-multi-select-combo-box-container
                            part="input-field"
                            auto-expand-vertically="[[autoExpandVertically]]"
                            readonly="[[readonly]]"
                            disabled="[[disabled]]"
                            invalid="[[invalid]]"
                            theme$="[[_theme]]"
                    >
                        <slot name="overflow" slot="prefix"></slot>
                        <div id="chips" part="chips" slot="prefix">
                            <slot name="chip"></slot>
                        </div>
                        <slot name="input"></slot>
                        <div id="toggleButton" class="toggle-button" part="toggle-button" slot="suffix"
                             aria-hidden="true"></div>
                        <!-- Jmix API -->
                        <div id="pickerAction" part="action-part" slot="suffix">
                            <slot name="actions"></slot>
                        </div>
                    </vaadin-multi-select-combo-box-container>
                </jmix-multi-select-combo-box-internal>

                <div part="helper-text">
                    <slot name="helper"></slot>
                </div>

                <div part="error-message">
                    <slot name="error-message"></slot>
                </div>
            </div>

            <slot name="tooltip"></slot>
        `;
  }
  /**
   * Used by `ClearButtonMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return null;
  }
}
defineCustomElement(JmixMultiSelectComboBoxPicker);
/*!
 * Quill Editor v1.3.7
 * https://quilljs.com/
 * Copyright (c) 2014, Jason Chen
 * Copyright (c) 2013, salesforce.com
 */
!function(t2, e2) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e2() : "function" == typeof define && define.amd ? define([], e2) : "object" == typeof exports ? exports.Quill = e2() : t2.Quill = e2();
}("undefined" != typeof self ? self : void 0, function() {
  return function(t2) {
    function e2(r) {
      if (n[r]) return n[r].exports;
      var o = n[r] = { i: r, l: false, exports: {} };
      return t2[r].call(o.exports, o, o.exports, e2), o.l = true, o.exports;
    }
    var n = {};
    return e2.m = t2, e2.c = n, e2.d = function(t3, n2, r) {
      e2.o(t3, n2) || Object.defineProperty(t3, n2, { configurable: false, enumerable: true, get: r });
    }, e2.n = function(t3) {
      var n2 = t3 && t3.__esModule ? function() {
        return t3.default;
      } : function() {
        return t3;
      };
      return e2.d(n2, "a", n2), n2;
    }, e2.o = function(t3, e3) {
      return Object.prototype.hasOwnProperty.call(t3, e3);
    }, e2.p = "", e2(e2.s = 45);
  }([function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true });
    var r = n(17), o = n(18), i2 = n(19), l = n(48), a3 = n(49), s3 = n(50), u2 = n(51), c2 = n(52), f = n(11), h3 = n(29), p = n(30), d3 = n(28), y3 = n(1), v = { Scope: y3.Scope, create: y3.create, find: y3.find, query: y3.query, register: y3.register, Container: r.default, Format: o.default, Leaf: i2.default, Embed: u2.default, Scroll: l.default, Block: s3.default, Inline: a3.default, Text: c2.default, Attributor: { Attribute: f.default, Class: h3.default, Style: p.default, Store: d3.default } };
    e2.default = v;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      var n2 = i2(t3);
      if (null == n2) throw new s3("Unable to create " + t3 + " blot");
      var r2 = n2;
      return new r2(t3 instanceof Node || t3.nodeType === Node.TEXT_NODE ? t3 : r2.create(e3), e3);
    }
    function o(t3, n2) {
      return void 0 === n2 && (n2 = false), null == t3 ? null : null != t3[e2.DATA_KEY] ? t3[e2.DATA_KEY].blot : n2 ? o(t3.parentNode, n2) : null;
    }
    function i2(t3, e3) {
      void 0 === e3 && (e3 = p.ANY);
      var n2;
      if ("string" == typeof t3) n2 = h3[t3] || u2[t3];
      else if (t3 instanceof Text || t3.nodeType === Node.TEXT_NODE) n2 = h3.text;
      else if ("number" == typeof t3) t3 & p.LEVEL & p.BLOCK ? n2 = h3.block : t3 & p.LEVEL & p.INLINE && (n2 = h3.inline);
      else if (t3 instanceof HTMLElement) {
        var r2 = (t3.getAttribute("class") || "").split(/\s+/);
        for (var o2 in r2) if (n2 = c2[r2[o2]]) break;
        n2 = n2 || f[t3.tagName];
      }
      return null == n2 ? null : e3 & p.LEVEL & n2.scope && e3 & p.TYPE & n2.scope ? n2 : null;
    }
    function l() {
      for (var t3 = [], e3 = 0; e3 < arguments.length; e3++) t3[e3] = arguments[e3];
      if (t3.length > 1) return t3.map(function(t4) {
        return l(t4);
      });
      var n2 = t3[0];
      if ("string" != typeof n2.blotName && "string" != typeof n2.attrName) throw new s3("Invalid definition");
      if ("abstract" === n2.blotName) throw new s3("Cannot register abstract class");
      if (h3[n2.blotName || n2.attrName] = n2, "string" == typeof n2.keyName) u2[n2.keyName] = n2;
      else if (null != n2.className && (c2[n2.className] = n2), null != n2.tagName) {
        Array.isArray(n2.tagName) ? n2.tagName = n2.tagName.map(function(t4) {
          return t4.toUpperCase();
        }) : n2.tagName = n2.tagName.toUpperCase();
        var r2 = Array.isArray(n2.tagName) ? n2.tagName : [n2.tagName];
        r2.forEach(function(t4) {
          null != f[t4] && null != n2.className || (f[t4] = n2);
        });
      }
      return n2;
    }
    var a3 = this && this.__extends || function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    }();
    Object.defineProperty(e2, "__esModule", { value: true });
    var s3 = function(t3) {
      function e3(e4) {
        var n2 = this;
        return e4 = "[Parchment] " + e4, n2 = t3.call(this, e4) || this, n2.message = e4, n2.name = n2.constructor.name, n2;
      }
      return a3(e3, t3), e3;
    }(Error);
    e2.ParchmentError = s3;
    var u2 = {}, c2 = {}, f = {}, h3 = {};
    e2.DATA_KEY = "__blot";
    var p;
    !function(t3) {
      t3[t3.TYPE = 3] = "TYPE", t3[t3.LEVEL = 12] = "LEVEL", t3[t3.ATTRIBUTE = 13] = "ATTRIBUTE", t3[t3.BLOT = 14] = "BLOT", t3[t3.INLINE = 7] = "INLINE", t3[t3.BLOCK = 11] = "BLOCK", t3[t3.BLOCK_BLOT = 10] = "BLOCK_BLOT", t3[t3.INLINE_BLOT = 6] = "INLINE_BLOT", t3[t3.BLOCK_ATTRIBUTE = 9] = "BLOCK_ATTRIBUTE", t3[t3.INLINE_ATTRIBUTE = 5] = "INLINE_ATTRIBUTE", t3[t3.ANY = 15] = "ANY";
    }(p = e2.Scope || (e2.Scope = {})), e2.create = r, e2.find = o, e2.query = i2, e2.register = l;
  }, function(t2, e2) {
    var n = Object.prototype.hasOwnProperty, r = Object.prototype.toString, o = Object.defineProperty, i2 = Object.getOwnPropertyDescriptor, l = function(t3) {
      return "function" == typeof Array.isArray ? Array.isArray(t3) : "[object Array]" === r.call(t3);
    }, a3 = function(t3) {
      if (!t3 || "[object Object]" !== r.call(t3)) return false;
      var e3 = n.call(t3, "constructor"), o2 = t3.constructor && t3.constructor.prototype && n.call(t3.constructor.prototype, "isPrototypeOf");
      if (t3.constructor && !e3 && !o2) return false;
      var i3;
      for (i3 in t3) ;
      return void 0 === i3 || n.call(t3, i3);
    }, s3 = function(t3, e3) {
      o && "__proto__" === e3.name ? o(t3, e3.name, { enumerable: true, configurable: true, value: e3.newValue, writable: true }) : t3[e3.name] = e3.newValue;
    }, u2 = function(t3, e3) {
      if ("__proto__" === e3) {
        if (!n.call(t3, e3)) return;
        if (i2) return i2(t3, e3).value;
      }
      return t3[e3];
    };
    t2.exports = function t3() {
      var e3, n2, r2, o2, i3, c2, f = arguments[0], h3 = 1, p = arguments.length, d3 = false;
      for ("boolean" == typeof f && (d3 = f, f = arguments[1] || {}, h3 = 2), (null == f || "object" != typeof f && "function" != typeof f) && (f = {}); h3 < p; ++h3) if (null != (e3 = arguments[h3])) for (n2 in e3) r2 = u2(f, n2), o2 = u2(e3, n2), f !== o2 && (d3 && o2 && (a3(o2) || (i3 = l(o2))) ? (i3 ? (i3 = false, c2 = r2 && l(r2) ? r2 : []) : c2 = r2 && a3(r2) ? r2 : {}, s3(f, { name: n2, newValue: t3(d3, c2, o2) })) : void 0 !== o2 && s3(f, { name: n2, newValue: o2 }));
      return f;
    };
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function a3(t3) {
      var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return null == t3 ? e3 : ("function" == typeof t3.formats && (e3 = (0, f.default)(e3, t3.formats())), null == t3.parent || "scroll" == t3.parent.blotName || t3.parent.statics.scope !== t3.statics.scope ? e3 : a3(t3.parent, e3));
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.BlockEmbed = e2.bubbleFormats = void 0;
    var s3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), u2 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, c2 = n(2), f = r(c2), h3 = n(4), p = r(h3), d3 = n(0), y3 = r(d3), v = n(14), b2 = r(v), g = n(5), m3 = r(g), _ = n(8), O2 = r(_), w2 = function(t3) {
      function e3() {
        return o(this, e3), i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return l(e3, t3), s3(e3, [{ key: "attach", value: function() {
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "attach", this).call(this), this.attributes = new y3.default.Attributor.Store(this.domNode);
      } }, { key: "delta", value: function() {
        return new p.default().insert(this.value(), (0, f.default)(this.formats(), this.attributes.values()));
      } }, { key: "format", value: function(t4, e4) {
        var n2 = y3.default.query(t4, y3.default.Scope.BLOCK_ATTRIBUTE);
        null != n2 && this.attributes.attribute(n2, e4);
      } }, { key: "formatAt", value: function(t4, e4, n2, r2) {
        this.format(n2, r2);
      } }, { key: "insertAt", value: function(t4, n2, r2) {
        if ("string" == typeof n2 && n2.endsWith("\n")) {
          var o2 = y3.default.create(x2.blotName);
          this.parent.insertBefore(o2, 0 === t4 ? this : this.next), o2.insertAt(0, n2.slice(0, -1));
        } else u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertAt", this).call(this, t4, n2, r2);
      } }]), e3;
    }(y3.default.Embed);
    w2.scope = y3.default.Scope.BLOCK_BLOT;
    var x2 = function(t3) {
      function e3(t4) {
        o(this, e3);
        var n2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4));
        return n2.cache = {}, n2;
      }
      return l(e3, t3), s3(e3, [{ key: "delta", value: function() {
        return null == this.cache.delta && (this.cache.delta = this.descendants(y3.default.Leaf).reduce(function(t4, e4) {
          return 0 === e4.length() ? t4 : t4.insert(e4.value(), a3(e4));
        }, new p.default()).insert("\n", a3(this))), this.cache.delta;
      } }, { key: "deleteAt", value: function(t4, n2) {
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "deleteAt", this).call(this, t4, n2), this.cache = {};
      } }, { key: "formatAt", value: function(t4, n2, r2, o2) {
        n2 <= 0 || (y3.default.query(r2, y3.default.Scope.BLOCK) ? t4 + n2 === this.length() && this.format(r2, o2) : u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "formatAt", this).call(this, t4, Math.min(n2, this.length() - t4 - 1), r2, o2), this.cache = {});
      } }, { key: "insertAt", value: function(t4, n2, r2) {
        if (null != r2) return u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertAt", this).call(this, t4, n2, r2);
        if (0 !== n2.length) {
          var o2 = n2.split("\n"), i3 = o2.shift();
          i3.length > 0 && (t4 < this.length() - 1 || null == this.children.tail ? u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertAt", this).call(this, Math.min(t4, this.length() - 1), i3) : this.children.tail.insertAt(this.children.tail.length(), i3), this.cache = {});
          var l2 = this;
          o2.reduce(function(t5, e4) {
            return l2 = l2.split(t5, true), l2.insertAt(0, e4), e4.length;
          }, t4 + i3.length);
        }
      } }, { key: "insertBefore", value: function(t4, n2) {
        var r2 = this.children.head;
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertBefore", this).call(this, t4, n2), r2 instanceof b2.default && r2.remove(), this.cache = {};
      } }, { key: "length", value: function() {
        return null == this.cache.length && (this.cache.length = u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "length", this).call(this) + 1), this.cache.length;
      } }, { key: "moveChildren", value: function(t4, n2) {
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "moveChildren", this).call(this, t4, n2), this.cache = {};
      } }, { key: "optimize", value: function(t4) {
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "optimize", this).call(this, t4), this.cache = {};
      } }, { key: "path", value: function(t4) {
        return u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "path", this).call(this, t4, true);
      } }, { key: "removeChild", value: function(t4) {
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "removeChild", this).call(this, t4), this.cache = {};
      } }, { key: "split", value: function(t4) {
        var n2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if (n2 && (0 === t4 || t4 >= this.length() - 1)) {
          var r2 = this.clone();
          return 0 === t4 ? (this.parent.insertBefore(r2, this), this) : (this.parent.insertBefore(r2, this.next), r2);
        }
        var o2 = u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "split", this).call(this, t4, n2);
        return this.cache = {}, o2;
      } }]), e3;
    }(y3.default.Block);
    x2.blotName = "block", x2.tagName = "P", x2.defaultChild = "break", x2.allowedChildren = [m3.default, y3.default.Embed, O2.default], e2.bubbleFormats = a3, e2.BlockEmbed = w2, e2.default = x2;
  }, function(t2, e2, n) {
    var r = n(54), o = n(12), i2 = n(2), l = n(20), a3 = String.fromCharCode(0), s3 = function(t3) {
      Array.isArray(t3) ? this.ops = t3 : null != t3 && Array.isArray(t3.ops) ? this.ops = t3.ops : this.ops = [];
    };
    s3.prototype.insert = function(t3, e3) {
      var n2 = {};
      return 0 === t3.length ? this : (n2.insert = t3, null != e3 && "object" == typeof e3 && Object.keys(e3).length > 0 && (n2.attributes = e3), this.push(n2));
    }, s3.prototype.delete = function(t3) {
      return t3 <= 0 ? this : this.push({ delete: t3 });
    }, s3.prototype.retain = function(t3, e3) {
      if (t3 <= 0) return this;
      var n2 = { retain: t3 };
      return null != e3 && "object" == typeof e3 && Object.keys(e3).length > 0 && (n2.attributes = e3), this.push(n2);
    }, s3.prototype.push = function(t3) {
      var e3 = this.ops.length, n2 = this.ops[e3 - 1];
      if (t3 = i2(true, {}, t3), "object" == typeof n2) {
        if ("number" == typeof t3.delete && "number" == typeof n2.delete) return this.ops[e3 - 1] = { delete: n2.delete + t3.delete }, this;
        if ("number" == typeof n2.delete && null != t3.insert && (e3 -= 1, "object" != typeof (n2 = this.ops[e3 - 1]))) return this.ops.unshift(t3), this;
        if (o(t3.attributes, n2.attributes)) {
          if ("string" == typeof t3.insert && "string" == typeof n2.insert) return this.ops[e3 - 1] = { insert: n2.insert + t3.insert }, "object" == typeof t3.attributes && (this.ops[e3 - 1].attributes = t3.attributes), this;
          if ("number" == typeof t3.retain && "number" == typeof n2.retain) return this.ops[e3 - 1] = { retain: n2.retain + t3.retain }, "object" == typeof t3.attributes && (this.ops[e3 - 1].attributes = t3.attributes), this;
        }
      }
      return e3 === this.ops.length ? this.ops.push(t3) : this.ops.splice(e3, 0, t3), this;
    }, s3.prototype.chop = function() {
      var t3 = this.ops[this.ops.length - 1];
      return t3 && t3.retain && !t3.attributes && this.ops.pop(), this;
    }, s3.prototype.filter = function(t3) {
      return this.ops.filter(t3);
    }, s3.prototype.forEach = function(t3) {
      this.ops.forEach(t3);
    }, s3.prototype.map = function(t3) {
      return this.ops.map(t3);
    }, s3.prototype.partition = function(t3) {
      var e3 = [], n2 = [];
      return this.forEach(function(r2) {
        (t3(r2) ? e3 : n2).push(r2);
      }), [e3, n2];
    }, s3.prototype.reduce = function(t3, e3) {
      return this.ops.reduce(t3, e3);
    }, s3.prototype.changeLength = function() {
      return this.reduce(function(t3, e3) {
        return e3.insert ? t3 + l.length(e3) : e3.delete ? t3 - e3.delete : t3;
      }, 0);
    }, s3.prototype.length = function() {
      return this.reduce(function(t3, e3) {
        return t3 + l.length(e3);
      }, 0);
    }, s3.prototype.slice = function(t3, e3) {
      t3 = t3 || 0, "number" != typeof e3 && (e3 = 1 / 0);
      for (var n2 = [], r2 = l.iterator(this.ops), o2 = 0; o2 < e3 && r2.hasNext(); ) {
        var i3;
        o2 < t3 ? i3 = r2.next(t3 - o2) : (i3 = r2.next(e3 - o2), n2.push(i3)), o2 += l.length(i3);
      }
      return new s3(n2);
    }, s3.prototype.compose = function(t3) {
      var e3 = l.iterator(this.ops), n2 = l.iterator(t3.ops), r2 = [], i3 = n2.peek();
      if (null != i3 && "number" == typeof i3.retain && null == i3.attributes) {
        for (var a4 = i3.retain; "insert" === e3.peekType() && e3.peekLength() <= a4; ) a4 -= e3.peekLength(), r2.push(e3.next());
        i3.retain - a4 > 0 && n2.next(i3.retain - a4);
      }
      for (var u2 = new s3(r2); e3.hasNext() || n2.hasNext(); ) if ("insert" === n2.peekType()) u2.push(n2.next());
      else if ("delete" === e3.peekType()) u2.push(e3.next());
      else {
        var c2 = Math.min(e3.peekLength(), n2.peekLength()), f = e3.next(c2), h3 = n2.next(c2);
        if ("number" == typeof h3.retain) {
          var p = {};
          "number" == typeof f.retain ? p.retain = c2 : p.insert = f.insert;
          var d3 = l.attributes.compose(f.attributes, h3.attributes, "number" == typeof f.retain);
          if (d3 && (p.attributes = d3), u2.push(p), !n2.hasNext() && o(u2.ops[u2.ops.length - 1], p)) {
            var y3 = new s3(e3.rest());
            return u2.concat(y3).chop();
          }
        } else "number" == typeof h3.delete && "number" == typeof f.retain && u2.push(h3);
      }
      return u2.chop();
    }, s3.prototype.concat = function(t3) {
      var e3 = new s3(this.ops.slice());
      return t3.ops.length > 0 && (e3.push(t3.ops[0]), e3.ops = e3.ops.concat(t3.ops.slice(1))), e3;
    }, s3.prototype.diff = function(t3, e3) {
      if (this.ops === t3.ops) return new s3();
      var n2 = [this, t3].map(function(e4) {
        return e4.map(function(n3) {
          if (null != n3.insert) return "string" == typeof n3.insert ? n3.insert : a3;
          var r2 = e4 === t3 ? "on" : "with";
          throw new Error("diff() called " + r2 + " non-document");
        }).join("");
      }), i3 = new s3(), u2 = r(n2[0], n2[1], e3), c2 = l.iterator(this.ops), f = l.iterator(t3.ops);
      return u2.forEach(function(t4) {
        for (var e4 = t4[1].length; e4 > 0; ) {
          var n3 = 0;
          switch (t4[0]) {
            case r.INSERT:
              n3 = Math.min(f.peekLength(), e4), i3.push(f.next(n3));
              break;
            case r.DELETE:
              n3 = Math.min(e4, c2.peekLength()), c2.next(n3), i3.delete(n3);
              break;
            case r.EQUAL:
              n3 = Math.min(c2.peekLength(), f.peekLength(), e4);
              var a4 = c2.next(n3), s4 = f.next(n3);
              o(a4.insert, s4.insert) ? i3.retain(n3, l.attributes.diff(a4.attributes, s4.attributes)) : i3.push(s4).delete(n3);
          }
          e4 -= n3;
        }
      }), i3.chop();
    }, s3.prototype.eachLine = function(t3, e3) {
      e3 = e3 || "\n";
      for (var n2 = l.iterator(this.ops), r2 = new s3(), o2 = 0; n2.hasNext(); ) {
        if ("insert" !== n2.peekType()) return;
        var i3 = n2.peek(), a4 = l.length(i3) - n2.peekLength(), u2 = "string" == typeof i3.insert ? i3.insert.indexOf(e3, a4) - a4 : -1;
        if (u2 < 0) r2.push(n2.next());
        else if (u2 > 0) r2.push(n2.next(u2));
        else {
          if (false === t3(r2, n2.next(1).attributes || {}, o2)) return;
          o2 += 1, r2 = new s3();
        }
      }
      r2.length() > 0 && t3(r2, {}, o2);
    }, s3.prototype.transform = function(t3, e3) {
      if (e3 = !!e3, "number" == typeof t3) return this.transformPosition(t3, e3);
      for (var n2 = l.iterator(this.ops), r2 = l.iterator(t3.ops), o2 = new s3(); n2.hasNext() || r2.hasNext(); ) if ("insert" !== n2.peekType() || !e3 && "insert" === r2.peekType()) if ("insert" === r2.peekType()) o2.push(r2.next());
      else {
        var i3 = Math.min(n2.peekLength(), r2.peekLength()), a4 = n2.next(i3), u2 = r2.next(i3);
        if (a4.delete) continue;
        u2.delete ? o2.push(u2) : o2.retain(i3, l.attributes.transform(a4.attributes, u2.attributes, e3));
      }
      else o2.retain(l.length(n2.next()));
      return o2.chop();
    }, s3.prototype.transformPosition = function(t3, e3) {
      e3 = !!e3;
      for (var n2 = l.iterator(this.ops), r2 = 0; n2.hasNext() && r2 <= t3; ) {
        var o2 = n2.peekLength(), i3 = n2.peekType();
        n2.next(), "delete" !== i3 ? ("insert" === i3 && (r2 < t3 || !e3) && (t3 += o2), r2 += o2) : t3 -= Math.min(o2, t3 - r2);
      }
      return t3;
    }, t2.exports = s3;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var a3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = n(8), c2 = r(u2), f = n(0), h3 = r(f), p = function(t3) {
      function e3() {
        return o(this, e3), i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return l(e3, t3), a3(e3, [{ key: "formatAt", value: function(t4, n2, r2, o2) {
        if (e3.compare(this.statics.blotName, r2) < 0 && h3.default.query(r2, h3.default.Scope.BLOT)) {
          var i3 = this.isolate(t4, n2);
          o2 && i3.wrap(r2, o2);
        } else s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "formatAt", this).call(this, t4, n2, r2, o2);
      } }, { key: "optimize", value: function(t4) {
        if (s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "optimize", this).call(this, t4), this.parent instanceof e3 && e3.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
          var n2 = this.parent.isolate(this.offset(), this.length());
          this.moveChildren(n2), n2.wrap(this);
        }
      } }], [{ key: "compare", value: function(t4, n2) {
        var r2 = e3.order.indexOf(t4), o2 = e3.order.indexOf(n2);
        return r2 >= 0 || o2 >= 0 ? r2 - o2 : t4 === n2 ? 0 : t4 < n2 ? -1 : 1;
      } }]), e3;
    }(h3.default.Inline);
    p.allowedChildren = [p, h3.default.Embed, c2.default], p.order = ["cursor", "inline", "underline", "strike", "italic", "bold", "script", "link", "code"], e2.default = p;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3, n2) {
      return e3 in t3 ? Object.defineProperty(t3, e3, { value: n2, enumerable: true, configurable: true, writable: true }) : t3[e3] = n2, t3;
    }
    function i2(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function l(t3, e3) {
      if (e3 = (0, N.default)(true, { container: t3, modules: { clipboard: true, keyboard: true, history: true } }, e3), e3.theme && e3.theme !== S3.DEFAULTS.theme) {
        if (e3.theme = S3.import("themes/" + e3.theme), null == e3.theme) throw new Error("Invalid theme " + e3.theme + ". Did you register it?");
      } else e3.theme = T2.default;
      var n2 = (0, N.default)(true, {}, e3.theme.DEFAULTS);
      [n2, e3].forEach(function(t4) {
        t4.modules = t4.modules || {}, Object.keys(t4.modules).forEach(function(e4) {
          true === t4.modules[e4] && (t4.modules[e4] = {});
        });
      });
      var r2 = Object.keys(n2.modules).concat(Object.keys(e3.modules)), o2 = r2.reduce(function(t4, e4) {
        var n3 = S3.import("modules/" + e4);
        return null == n3 ? P.error("Cannot load " + e4 + " module. Are you sure you registered it?") : t4[e4] = n3.DEFAULTS || {}, t4;
      }, {});
      return null != e3.modules && e3.modules.toolbar && e3.modules.toolbar.constructor !== Object && (e3.modules.toolbar = { container: e3.modules.toolbar }), e3 = (0, N.default)(true, {}, S3.DEFAULTS, { modules: o2 }, n2, e3), ["bounds", "container", "scrollingContainer"].forEach(function(t4) {
        "string" == typeof e3[t4] && (e3[t4] = document.querySelector(e3[t4]));
      }), e3.modules = Object.keys(e3.modules).reduce(function(t4, n3) {
        return e3.modules[n3] && (t4[n3] = e3.modules[n3]), t4;
      }, {}), e3;
    }
    function a3(t3, e3, n2, r2) {
      if (this.options.strict && !this.isEnabled() && e3 === g.default.sources.USER) return new d3.default();
      var o2 = null == n2 ? null : this.getSelection(), i3 = this.editor.delta, l2 = t3();
      if (null != o2 && (true === n2 && (n2 = o2.index), null == r2 ? o2 = u2(o2, l2, e3) : 0 !== r2 && (o2 = u2(o2, n2, r2, e3)), this.setSelection(o2, g.default.sources.SILENT)), l2.length() > 0) {
        var a4, s4 = [g.default.events.TEXT_CHANGE, l2, i3, e3];
        if ((a4 = this.emitter).emit.apply(a4, [g.default.events.EDITOR_CHANGE].concat(s4)), e3 !== g.default.sources.SILENT) {
          var c3;
          (c3 = this.emitter).emit.apply(c3, s4);
        }
      }
      return l2;
    }
    function s3(t3, e3, n2, r2, o2) {
      var i3 = {};
      return "number" == typeof t3.index && "number" == typeof t3.length ? "number" != typeof e3 ? (o2 = r2, r2 = n2, n2 = e3, e3 = t3.length, t3 = t3.index) : (e3 = t3.length, t3 = t3.index) : "number" != typeof e3 && (o2 = r2, r2 = n2, n2 = e3, e3 = 0), "object" === (void 0 === n2 ? "undefined" : c2(n2)) ? (i3 = n2, o2 = r2) : "string" == typeof n2 && (null != r2 ? i3[n2] = r2 : o2 = n2), o2 = o2 || g.default.sources.API, [t3, e3, i3, o2];
    }
    function u2(t3, e3, n2, r2) {
      if (null == t3) return null;
      var o2 = void 0, i3 = void 0;
      if (e3 instanceof d3.default) {
        var l2 = [t3.index, t3.index + t3.length].map(function(t4) {
          return e3.transformPosition(t4, r2 !== g.default.sources.USER);
        }), a4 = f(l2, 2);
        o2 = a4[0], i3 = a4[1];
      } else {
        var s4 = [t3.index, t3.index + t3.length].map(function(t4) {
          return t4 < e3 || t4 === e3 && r2 === g.default.sources.USER ? t4 : n2 >= 0 ? t4 + n2 : Math.max(e3, t4 + n2);
        }), u3 = f(s4, 2);
        o2 = u3[0], i3 = u3[1];
      }
      return new x2.Range(o2, i3 - o2);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.overload = e2.expandConfig = void 0;
    var c2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
      return typeof t3;
    } : function(t3) {
      return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
    }, f = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), h3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }();
    n(53);
    var p = n(4), d3 = r(p), y3 = n(57), v = r(y3), b2 = n(9), g = r(b2), m3 = n(7), _ = r(m3), O2 = n(0), w2 = r(O2), x2 = n(22), k2 = r(x2), E2 = n(2), N = r(E2), j = n(10), A = r(j), q2 = n(32), T2 = r(q2), P = (0, A.default)("quill"), S3 = function() {
      function t3(e3) {
        var n2 = this, r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (i2(this, t3), this.options = l(e3, r2), this.container = this.options.container, null == this.container) return P.error("Invalid Quill container", e3);
        this.options.debug && t3.debug(this.options.debug);
        var o2 = this.container.innerHTML.trim();
        this.container.classList.add("ql-container"), this.container.innerHTML = "", this.container.__quill = this, this.root = this.addContainer("ql-editor"), this.root.classList.add("ql-blank"), this.root.setAttribute("data-gramm", false), this.scrollingContainer = this.options.scrollingContainer || this.root, this.emitter = new g.default(), this.scroll = w2.default.create(this.root, { emitter: this.emitter, whitelist: this.options.formats }), this.editor = new v.default(this.scroll), this.selection = new k2.default(this.scroll, this.emitter), this.theme = new this.options.theme(this, this.options), this.keyboard = this.theme.addModule("keyboard"), this.clipboard = this.theme.addModule("clipboard"), this.history = this.theme.addModule("history"), this.theme.init(), this.emitter.on(g.default.events.EDITOR_CHANGE, function(t4) {
          t4 === g.default.events.TEXT_CHANGE && n2.root.classList.toggle("ql-blank", n2.editor.isBlank());
        }), this.emitter.on(g.default.events.SCROLL_UPDATE, function(t4, e4) {
          var r3 = n2.selection.lastRange, o3 = r3 && 0 === r3.length ? r3.index : void 0;
          a3.call(n2, function() {
            return n2.editor.update(null, e4, o3);
          }, t4);
        });
        var s4 = this.clipboard.convert(`<div class='ql-editor' style="white-space: normal;">` + o2 + "<p><br></p></div>");
        this.setContents(s4), this.history.clear(), this.options.placeholder && this.root.setAttribute("data-placeholder", this.options.placeholder), this.options.readOnly && this.disable();
      }
      return h3(t3, null, [{ key: "debug", value: function(t4) {
        true === t4 && (t4 = "log"), A.default.level(t4);
      } }, { key: "find", value: function(t4) {
        return t4.__quill || w2.default.find(t4);
      } }, { key: "import", value: function(t4) {
        return null == this.imports[t4] && P.error("Cannot import " + t4 + ". Are you sure it was registered?"), this.imports[t4];
      } }, { key: "register", value: function(t4, e3) {
        var n2 = this, r2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        if ("string" != typeof t4) {
          var o2 = t4.attrName || t4.blotName;
          "string" == typeof o2 ? this.register("formats/" + o2, t4, e3) : Object.keys(t4).forEach(function(r3) {
            n2.register(r3, t4[r3], e3);
          });
        } else null == this.imports[t4] || r2 || P.warn("Overwriting " + t4 + " with", e3), this.imports[t4] = e3, (t4.startsWith("blots/") || t4.startsWith("formats/")) && "abstract" !== e3.blotName ? w2.default.register(e3) : t4.startsWith("modules") && "function" == typeof e3.register && e3.register();
      } }]), h3(t3, [{ key: "addContainer", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        if ("string" == typeof t4) {
          var n2 = t4;
          t4 = document.createElement("div"), t4.classList.add(n2);
        }
        return this.container.insertBefore(t4, e3), t4;
      } }, { key: "blur", value: function() {
        this.selection.setRange(null);
      } }, { key: "deleteText", value: function(t4, e3, n2) {
        var r2 = this, o2 = s3(t4, e3, n2), i3 = f(o2, 4);
        return t4 = i3[0], e3 = i3[1], n2 = i3[3], a3.call(this, function() {
          return r2.editor.deleteText(t4, e3);
        }, n2, t4, -1 * e3);
      } }, { key: "disable", value: function() {
        this.enable(false);
      } }, { key: "enable", value: function() {
        var t4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        this.scroll.enable(t4), this.container.classList.toggle("ql-disabled", !t4);
      } }, { key: "focus", value: function() {
        var t4 = this.scrollingContainer.scrollTop;
        this.selection.focus(), this.scrollingContainer.scrollTop = t4, this.scrollIntoView();
      } }, { key: "format", value: function(t4, e3) {
        var n2 = this, r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : g.default.sources.API;
        return a3.call(this, function() {
          var r3 = n2.getSelection(true), i3 = new d3.default();
          if (null == r3) return i3;
          if (w2.default.query(t4, w2.default.Scope.BLOCK)) i3 = n2.editor.formatLine(r3.index, r3.length, o({}, t4, e3));
          else {
            if (0 === r3.length) return n2.selection.format(t4, e3), i3;
            i3 = n2.editor.formatText(r3.index, r3.length, o({}, t4, e3));
          }
          return n2.setSelection(r3, g.default.sources.SILENT), i3;
        }, r2);
      } }, { key: "formatLine", value: function(t4, e3, n2, r2, o2) {
        var i3 = this, l2 = void 0, u3 = s3(t4, e3, n2, r2, o2), c3 = f(u3, 4);
        return t4 = c3[0], e3 = c3[1], l2 = c3[2], o2 = c3[3], a3.call(this, function() {
          return i3.editor.formatLine(t4, e3, l2);
        }, o2, t4, 0);
      } }, { key: "formatText", value: function(t4, e3, n2, r2, o2) {
        var i3 = this, l2 = void 0, u3 = s3(t4, e3, n2, r2, o2), c3 = f(u3, 4);
        return t4 = c3[0], e3 = c3[1], l2 = c3[2], o2 = c3[3], a3.call(this, function() {
          return i3.editor.formatText(t4, e3, l2);
        }, o2, t4, 0);
      } }, { key: "getBounds", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n2 = void 0;
        n2 = "number" == typeof t4 ? this.selection.getBounds(t4, e3) : this.selection.getBounds(t4.index, t4.length);
        var r2 = this.container.getBoundingClientRect();
        return { bottom: n2.bottom - r2.top, height: n2.height, left: n2.left - r2.left, right: n2.right - r2.left, top: n2.top - r2.top, width: n2.width };
      } }, { key: "getContents", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getLength() - t4, n2 = s3(t4, e3), r2 = f(n2, 2);
        return t4 = r2[0], e3 = r2[1], this.editor.getContents(t4, e3);
      } }, { key: "getFormat", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.getSelection(true), e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        return "number" == typeof t4 ? this.editor.getFormat(t4, e3) : this.editor.getFormat(t4.index, t4.length);
      } }, { key: "getIndex", value: function(t4) {
        return t4.offset(this.scroll);
      } }, { key: "getLength", value: function() {
        return this.scroll.length();
      } }, { key: "getLeaf", value: function(t4) {
        return this.scroll.leaf(t4);
      } }, { key: "getLine", value: function(t4) {
        return this.scroll.line(t4);
      } }, { key: "getLines", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;
        return "number" != typeof t4 ? this.scroll.lines(t4.index, t4.length) : this.scroll.lines(t4, e3);
      } }, { key: "getModule", value: function(t4) {
        return this.theme.modules[t4];
      } }, { key: "getSelection", value: function() {
        return arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && this.focus(), this.update(), this.selection.getRange()[0];
      } }, { key: "getText", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getLength() - t4, n2 = s3(t4, e3), r2 = f(n2, 2);
        return t4 = r2[0], e3 = r2[1], this.editor.getText(t4, e3);
      } }, { key: "hasFocus", value: function() {
        return this.selection.hasFocus();
      } }, { key: "insertEmbed", value: function(e3, n2, r2) {
        var o2 = this, i3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t3.sources.API;
        return a3.call(this, function() {
          return o2.editor.insertEmbed(e3, n2, r2);
        }, i3, e3);
      } }, { key: "insertText", value: function(t4, e3, n2, r2, o2) {
        var i3 = this, l2 = void 0, u3 = s3(t4, 0, n2, r2, o2), c3 = f(u3, 4);
        return t4 = c3[0], l2 = c3[2], o2 = c3[3], a3.call(this, function() {
          return i3.editor.insertText(t4, e3, l2);
        }, o2, t4, e3.length);
      } }, { key: "isEnabled", value: function() {
        return !this.container.classList.contains("ql-disabled");
      } }, { key: "off", value: function() {
        return this.emitter.off.apply(this.emitter, arguments);
      } }, { key: "on", value: function() {
        return this.emitter.on.apply(this.emitter, arguments);
      } }, { key: "once", value: function() {
        return this.emitter.once.apply(this.emitter, arguments);
      } }, { key: "pasteHTML", value: function(t4, e3, n2) {
        this.clipboard.dangerouslyPasteHTML(t4, e3, n2);
      } }, { key: "removeFormat", value: function(t4, e3, n2) {
        var r2 = this, o2 = s3(t4, e3, n2), i3 = f(o2, 4);
        return t4 = i3[0], e3 = i3[1], n2 = i3[3], a3.call(this, function() {
          return r2.editor.removeFormat(t4, e3);
        }, n2, t4);
      } }, { key: "scrollIntoView", value: function() {
        this.selection.scrollIntoView(this.scrollingContainer);
      } }, { key: "setContents", value: function(t4) {
        var e3 = this, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : g.default.sources.API;
        return a3.call(this, function() {
          t4 = new d3.default(t4);
          var n3 = e3.getLength(), r2 = e3.editor.deleteText(0, n3), o2 = e3.editor.applyDelta(t4), i3 = o2.ops[o2.ops.length - 1];
          return null != i3 && "string" == typeof i3.insert && "\n" === i3.insert[i3.insert.length - 1] && (e3.editor.deleteText(e3.getLength() - 1, 1), o2.delete(1)), r2.compose(o2);
        }, n2);
      } }, { key: "setSelection", value: function(e3, n2, r2) {
        if (null == e3) this.selection.setRange(null, n2 || t3.sources.API);
        else {
          var o2 = s3(e3, n2, r2), i3 = f(o2, 4);
          e3 = i3[0], n2 = i3[1], r2 = i3[3], this.selection.setRange(new x2.Range(e3, n2), r2), r2 !== g.default.sources.SILENT && this.selection.scrollIntoView(this.scrollingContainer);
        }
      } }, { key: "setText", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : g.default.sources.API, n2 = new d3.default().insert(t4);
        return this.setContents(n2, e3);
      } }, { key: "update", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : g.default.sources.USER, e3 = this.scroll.update(t4);
        return this.selection.update(t4), e3;
      } }, { key: "updateContents", value: function(t4) {
        var e3 = this, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : g.default.sources.API;
        return a3.call(this, function() {
          return t4 = new d3.default(t4), e3.editor.applyDelta(t4, n2);
        }, n2, true);
      } }]), t3;
    }();
    S3.DEFAULTS = { bounds: null, formats: null, modules: {}, placeholder: "", readOnly: false, scrollingContainer: null, strict: true, theme: "default" }, S3.events = g.default.events, S3.sources = g.default.sources, S3.version = "1.3.7", S3.imports = { delta: d3.default, parchment: w2.default, "core/module": _.default, "core/theme": T2.default }, e2.expandConfig = l, e2.overload = s3, e2.default = S3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = function t3(e3) {
      var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      r(this, t3), this.quill = e3, this.options = n2;
    };
    o.DEFAULTS = {}, e2.default = o;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = n(0), a3 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(l), s3 = function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), e3;
    }(a3.default.Text);
    e2.default = s3;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var a3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = n(58), c2 = r(u2), f = n(10), h3 = r(f), p = (0, h3.default)("quill:events");
    ["selectionchange", "mousedown", "mouseup", "click"].forEach(function(t3) {
      document.addEventListener(t3, function() {
        for (var t4 = arguments.length, e3 = Array(t4), n2 = 0; n2 < t4; n2++) e3[n2] = arguments[n2];
        [].slice.call(document.querySelectorAll(".ql-container")).forEach(function(t5) {
          if (t5.__quill && t5.__quill.emitter) {
            var n3;
            (n3 = t5.__quill.emitter).handleDOM.apply(n3, e3);
          }
        });
      });
    });
    var d3 = function(t3) {
      function e3() {
        o(this, e3);
        var t4 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this));
        return t4.listeners = {}, t4.on("error", p.error), t4;
      }
      return l(e3, t3), a3(e3, [{ key: "emit", value: function() {
        p.log.apply(p, arguments), s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "emit", this).apply(this, arguments);
      } }, { key: "handleDOM", value: function(t4) {
        for (var e4 = arguments.length, n2 = Array(e4 > 1 ? e4 - 1 : 0), r2 = 1; r2 < e4; r2++) n2[r2 - 1] = arguments[r2];
        (this.listeners[t4.type] || []).forEach(function(e5) {
          var r3 = e5.node, o2 = e5.handler;
          (t4.target === r3 || r3.contains(t4.target)) && o2.apply(void 0, [t4].concat(n2));
        });
      } }, { key: "listenDOM", value: function(t4, e4, n2) {
        this.listeners[t4] || (this.listeners[t4] = []), this.listeners[t4].push({ node: e4, handler: n2 });
      } }]), e3;
    }(c2.default);
    d3.events = { EDITOR_CHANGE: "editor-change", SCROLL_BEFORE_UPDATE: "scroll-before-update", SCROLL_OPTIMIZE: "scroll-optimize", SCROLL_UPDATE: "scroll-update", SELECTION_CHANGE: "selection-change", TEXT_CHANGE: "text-change" }, d3.sources = { API: "api", SILENT: "silent", USER: "user" }, e2.default = d3;
  }, function(t2, e2, n) {
    function r(t3) {
      if (i2.indexOf(t3) <= i2.indexOf(l)) {
        for (var e3, n2 = arguments.length, r2 = Array(n2 > 1 ? n2 - 1 : 0), o2 = 1; o2 < n2; o2++) r2[o2 - 1] = arguments[o2];
        (e3 = console)[t3].apply(e3, r2);
      }
    }
    function o(t3) {
      return i2.reduce(function(e3, n2) {
        return e3[n2] = r.bind(console, n2, t3), e3;
      }, {});
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var i2 = ["error", "warn", "log", "info"], l = "warn";
    r.level = o.level = function(t3) {
      l = t3;
    }, e2.default = o;
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true });
    var r = n(1), o = function() {
      function t3(t4, e3, n2) {
        void 0 === n2 && (n2 = {}), this.attrName = t4, this.keyName = e3;
        var o2 = r.Scope.TYPE & r.Scope.ATTRIBUTE;
        null != n2.scope ? this.scope = n2.scope & r.Scope.LEVEL | o2 : this.scope = r.Scope.ATTRIBUTE, null != n2.whitelist && (this.whitelist = n2.whitelist);
      }
      return t3.keys = function(t4) {
        return [].map.call(t4.attributes, function(t5) {
          return t5.name;
        });
      }, t3.prototype.add = function(t4, e3) {
        return !!this.canAdd(t4, e3) && (t4.setAttribute(this.keyName, e3), true);
      }, t3.prototype.canAdd = function(t4, e3) {
        return null != r.query(t4, r.Scope.BLOT & (this.scope | r.Scope.TYPE)) && (null == this.whitelist || ("string" == typeof e3 ? this.whitelist.indexOf(e3.replace(/["']/g, "")) > -1 : this.whitelist.indexOf(e3) > -1));
      }, t3.prototype.remove = function(t4) {
        t4.removeAttribute(this.keyName);
      }, t3.prototype.value = function(t4) {
        var e3 = t4.getAttribute(this.keyName);
        return this.canAdd(t4, e3) && e3 ? e3 : "";
      }, t3;
    }();
    e2.default = o;
  }, function(t2, e2, n) {
    function r(t3) {
      return null === t3 || void 0 === t3;
    }
    function o(t3) {
      return !(!t3 || "object" != typeof t3 || "number" != typeof t3.length) && ("function" == typeof t3.copy && "function" == typeof t3.slice && !(t3.length > 0 && "number" != typeof t3[0]));
    }
    function i2(t3, e3, n2) {
      var i3, c2;
      if (r(t3) || r(e3)) return false;
      if (t3.prototype !== e3.prototype) return false;
      if (s3(t3)) return !!s3(e3) && (t3 = l.call(t3), e3 = l.call(e3), u2(t3, e3, n2));
      if (o(t3)) {
        if (!o(e3)) return false;
        if (t3.length !== e3.length) return false;
        for (i3 = 0; i3 < t3.length; i3++) if (t3[i3] !== e3[i3]) return false;
        return true;
      }
      try {
        var f = a3(t3), h3 = a3(e3);
      } catch (t4) {
        return false;
      }
      if (f.length != h3.length) return false;
      for (f.sort(), h3.sort(), i3 = f.length - 1; i3 >= 0; i3--) if (f[i3] != h3[i3]) return false;
      for (i3 = f.length - 1; i3 >= 0; i3--) if (c2 = f[i3], !u2(t3[c2], e3[c2], n2)) return false;
      return typeof t3 == typeof e3;
    }
    var l = Array.prototype.slice, a3 = n(55), s3 = n(56), u2 = t2.exports = function(t3, e3, n2) {
      return n2 || (n2 = {}), t3 === e3 || (t3 instanceof Date && e3 instanceof Date ? t3.getTime() === e3.getTime() : !t3 || !e3 || "object" != typeof t3 && "object" != typeof e3 ? n2.strict ? t3 === e3 : t3 == e3 : i2(t3, e3, n2));
    };
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.Code = void 0;
    var a3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), s3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), u2 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, c2 = n(4), f = r(c2), h3 = n(0), p = r(h3), d3 = n(3), y3 = r(d3), v = n(5), b2 = r(v), g = n(8), m3 = r(g), _ = function(t3) {
      function e3() {
        return o(this, e3), i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return l(e3, t3), e3;
    }(b2.default);
    _.blotName = "code", _.tagName = "CODE";
    var O2 = function(t3) {
      function e3() {
        return o(this, e3), i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return l(e3, t3), s3(e3, [{ key: "delta", value: function() {
        var t4 = this, e4 = this.domNode.textContent;
        return e4.endsWith("\n") && (e4 = e4.slice(0, -1)), e4.split("\n").reduce(function(e5, n2) {
          return e5.insert(n2).insert("\n", t4.formats());
        }, new f.default());
      } }, { key: "format", value: function(t4, n2) {
        if (t4 !== this.statics.blotName || !n2) {
          var r2 = this.descendant(m3.default, this.length() - 1), o2 = a3(r2, 1), i3 = o2[0];
          null != i3 && i3.deleteAt(i3.length() - 1, 1), u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "format", this).call(this, t4, n2);
        }
      } }, { key: "formatAt", value: function(t4, n2, r2, o2) {
        if (0 !== n2 && null != p.default.query(r2, p.default.Scope.BLOCK) && (r2 !== this.statics.blotName || o2 !== this.statics.formats(this.domNode))) {
          var i3 = this.newlineIndex(t4);
          if (!(i3 < 0 || i3 >= t4 + n2)) {
            var l2 = this.newlineIndex(t4, true) + 1, a4 = i3 - l2 + 1, s4 = this.isolate(l2, a4), u3 = s4.next;
            s4.format(r2, o2), u3 instanceof e3 && u3.formatAt(0, t4 - l2 + n2 - a4, r2, o2);
          }
        }
      } }, { key: "insertAt", value: function(t4, e4, n2) {
        if (null == n2) {
          var r2 = this.descendant(m3.default, t4), o2 = a3(r2, 2), i3 = o2[0], l2 = o2[1];
          i3.insertAt(l2, e4);
        }
      } }, { key: "length", value: function() {
        var t4 = this.domNode.textContent.length;
        return this.domNode.textContent.endsWith("\n") ? t4 : t4 + 1;
      } }, { key: "newlineIndex", value: function(t4) {
        if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) return this.domNode.textContent.slice(0, t4).lastIndexOf("\n");
        var e4 = this.domNode.textContent.slice(t4).indexOf("\n");
        return e4 > -1 ? t4 + e4 : -1;
      } }, { key: "optimize", value: function(t4) {
        this.domNode.textContent.endsWith("\n") || this.appendChild(p.default.create("text", "\n")), u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "optimize", this).call(this, t4);
        var n2 = this.next;
        null != n2 && n2.prev === this && n2.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === n2.statics.formats(n2.domNode) && (n2.optimize(t4), n2.moveChildren(this), n2.remove());
      } }, { key: "replace", value: function(t4) {
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "replace", this).call(this, t4), [].slice.call(this.domNode.querySelectorAll("*")).forEach(function(t5) {
          var e4 = p.default.find(t5);
          null == e4 ? t5.parentNode.removeChild(t5) : e4 instanceof p.default.Embed ? e4.remove() : e4.unwrap();
        });
      } }], [{ key: "create", value: function(t4) {
        var n2 = u2(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this, t4);
        return n2.setAttribute("spellcheck", false), n2;
      } }, { key: "formats", value: function() {
        return true;
      } }]), e3;
    }(y3.default);
    O2.blotName = "code-block", O2.tagName = "PRE", O2.TAB = "  ", e2.Code = _, e2.default = O2;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(0), u2 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(s3), c2 = function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, [{ key: "insertInto", value: function(t4, n2) {
        0 === t4.children.length ? a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertInto", this).call(this, t4, n2) : this.remove();
      } }, { key: "length", value: function() {
        return 0;
      } }, { key: "value", value: function() {
        return "";
      } }], [{ key: "value", value: function() {
      } }]), e3;
    }(u2.default.Embed);
    c2.blotName = "break", c2.tagName = "BR", e2.default = c2;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function l(t3, e3) {
      var n2 = document.createElement("a");
      n2.href = t3;
      var r2 = n2.href.slice(0, n2.href.indexOf(":"));
      return e3.indexOf(r2) > -1;
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.sanitize = e2.default = void 0;
    var a3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = n(5), c2 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(u2), f = function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), a3(e3, [{ key: "format", value: function(t4, n2) {
        if (t4 !== this.statics.blotName || !n2) return s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "format", this).call(this, t4, n2);
        n2 = this.constructor.sanitize(n2), this.domNode.setAttribute("href", n2);
      } }], [{ key: "create", value: function(t4) {
        var n2 = s3(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this, t4);
        return t4 = this.sanitize(t4), n2.setAttribute("href", t4), n2.setAttribute("rel", "noopener noreferrer"), n2.setAttribute("target", "_blank"), n2;
      } }, { key: "formats", value: function(t4) {
        return t4.getAttribute("href");
      } }, { key: "sanitize", value: function(t4) {
        return l(t4, this.PROTOCOL_WHITELIST) ? t4 : this.SANITIZED_URL;
      } }]), e3;
    }(c2.default);
    f.blotName = "link", f.tagName = "A", f.SANITIZED_URL = "about:blank", f.PROTOCOL_WHITELIST = ["http", "https", "mailto", "tel"], e2.default = f, e2.sanitize = l;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      t3.setAttribute(e3, !("true" === t3.getAttribute(e3)));
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
      return typeof t3;
    } : function(t3) {
      return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
    }, a3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), s3 = n(25), u2 = r(s3), c2 = n(106), f = r(c2), h3 = 0, p = function() {
      function t3(e3) {
        var n2 = this;
        o(this, t3), this.select = e3, this.container = document.createElement("span"), this.buildPicker(), this.select.style.display = "none", this.select.parentNode.insertBefore(this.container, this.select), this.label.addEventListener("mousedown", function() {
          n2.togglePicker();
        }), this.label.addEventListener("keydown", function(t4) {
          switch (t4.keyCode) {
            case u2.default.keys.ENTER:
              n2.togglePicker();
              break;
            case u2.default.keys.ESCAPE:
              n2.escape(), t4.preventDefault();
          }
        }), this.select.addEventListener("change", this.update.bind(this));
      }
      return a3(t3, [{ key: "togglePicker", value: function() {
        this.container.classList.toggle("ql-expanded"), i2(this.label, "aria-expanded"), i2(this.options, "aria-hidden");
      } }, { key: "buildItem", value: function(t4) {
        var e3 = this, n2 = document.createElement("span");
        return n2.tabIndex = "0", n2.setAttribute("role", "button"), n2.classList.add("ql-picker-item"), t4.hasAttribute("value") && n2.setAttribute("data-value", t4.getAttribute("value")), t4.textContent && n2.setAttribute("data-label", t4.textContent), n2.addEventListener("click", function() {
          e3.selectItem(n2, true);
        }), n2.addEventListener("keydown", function(t5) {
          switch (t5.keyCode) {
            case u2.default.keys.ENTER:
              e3.selectItem(n2, true), t5.preventDefault();
              break;
            case u2.default.keys.ESCAPE:
              e3.escape(), t5.preventDefault();
          }
        }), n2;
      } }, { key: "buildLabel", value: function() {
        var t4 = document.createElement("span");
        return t4.classList.add("ql-picker-label"), t4.innerHTML = f.default, t4.tabIndex = "0", t4.setAttribute("role", "button"), t4.setAttribute("aria-expanded", "false"), this.container.appendChild(t4), t4;
      } }, { key: "buildOptions", value: function() {
        var t4 = this, e3 = document.createElement("span");
        e3.classList.add("ql-picker-options"), e3.setAttribute("aria-hidden", "true"), e3.tabIndex = "-1", e3.id = "ql-picker-options-" + h3, h3 += 1, this.label.setAttribute("aria-controls", e3.id), this.options = e3, [].slice.call(this.select.options).forEach(function(n2) {
          var r2 = t4.buildItem(n2);
          e3.appendChild(r2), true === n2.selected && t4.selectItem(r2);
        }), this.container.appendChild(e3);
      } }, { key: "buildPicker", value: function() {
        var t4 = this;
        [].slice.call(this.select.attributes).forEach(function(e3) {
          t4.container.setAttribute(e3.name, e3.value);
        }), this.container.classList.add("ql-picker"), this.label = this.buildLabel(), this.buildOptions();
      } }, { key: "escape", value: function() {
        var t4 = this;
        this.close(), setTimeout(function() {
          return t4.label.focus();
        }, 1);
      } }, { key: "close", value: function() {
        this.container.classList.remove("ql-expanded"), this.label.setAttribute("aria-expanded", "false"), this.options.setAttribute("aria-hidden", "true");
      } }, { key: "selectItem", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n2 = this.container.querySelector(".ql-selected");
        if (t4 !== n2 && (null != n2 && n2.classList.remove("ql-selected"), null != t4 && (t4.classList.add("ql-selected"), this.select.selectedIndex = [].indexOf.call(t4.parentNode.children, t4), t4.hasAttribute("data-value") ? this.label.setAttribute("data-value", t4.getAttribute("data-value")) : this.label.removeAttribute("data-value"), t4.hasAttribute("data-label") ? this.label.setAttribute("data-label", t4.getAttribute("data-label")) : this.label.removeAttribute("data-label"), e3))) {
          if ("function" == typeof Event) this.select.dispatchEvent(new Event("change"));
          else if ("object" === ("undefined" == typeof Event ? "undefined" : l(Event))) {
            var r2 = document.createEvent("Event");
            r2.initEvent("change", true, true), this.select.dispatchEvent(r2);
          }
          this.close();
        }
      } }, { key: "update", value: function() {
        var t4 = void 0;
        if (this.select.selectedIndex > -1) {
          var e3 = this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex];
          t4 = this.select.options[this.select.selectedIndex], this.selectItem(e3);
        } else this.selectItem(null);
        var n2 = null != t4 && t4 !== this.select.querySelector("option[selected]");
        this.label.classList.toggle("ql-active", n2);
      } }]), t3;
    }();
    e2.default = p;
  }, function(t2, e2, n) {
    function r(t3) {
      var e3 = a3.find(t3);
      if (null == e3) try {
        e3 = a3.create(t3);
      } catch (n2) {
        e3 = a3.create(a3.Scope.INLINE), [].slice.call(t3.childNodes).forEach(function(t4) {
          e3.domNode.appendChild(t4);
        }), t3.parentNode && t3.parentNode.replaceChild(e3.domNode, t3), e3.attach();
      }
      return e3;
    }
    var o = this && this.__extends || function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    }();
    Object.defineProperty(e2, "__esModule", { value: true });
    var i2 = n(47), l = n(27), a3 = n(1), s3 = function(t3) {
      function e3(e4) {
        var n2 = t3.call(this, e4) || this;
        return n2.build(), n2;
      }
      return o(e3, t3), e3.prototype.appendChild = function(t4) {
        this.insertBefore(t4);
      }, e3.prototype.attach = function() {
        t3.prototype.attach.call(this), this.children.forEach(function(t4) {
          t4.attach();
        });
      }, e3.prototype.build = function() {
        var t4 = this;
        this.children = new i2.default(), [].slice.call(this.domNode.childNodes).reverse().forEach(function(e4) {
          try {
            var n2 = r(e4);
            t4.insertBefore(n2, t4.children.head || void 0);
          } catch (t5) {
            if (t5 instanceof a3.ParchmentError) return;
            throw t5;
          }
        });
      }, e3.prototype.deleteAt = function(t4, e4) {
        if (0 === t4 && e4 === this.length()) return this.remove();
        this.children.forEachAt(t4, e4, function(t5, e5, n2) {
          t5.deleteAt(e5, n2);
        });
      }, e3.prototype.descendant = function(t4, n2) {
        var r2 = this.children.find(n2), o2 = r2[0], i3 = r2[1];
        return null == t4.blotName && t4(o2) || null != t4.blotName && o2 instanceof t4 ? [o2, i3] : o2 instanceof e3 ? o2.descendant(t4, i3) : [null, -1];
      }, e3.prototype.descendants = function(t4, n2, r2) {
        void 0 === n2 && (n2 = 0), void 0 === r2 && (r2 = Number.MAX_VALUE);
        var o2 = [], i3 = r2;
        return this.children.forEachAt(n2, r2, function(n3, r3, l2) {
          (null == t4.blotName && t4(n3) || null != t4.blotName && n3 instanceof t4) && o2.push(n3), n3 instanceof e3 && (o2 = o2.concat(n3.descendants(t4, r3, i3))), i3 -= l2;
        }), o2;
      }, e3.prototype.detach = function() {
        this.children.forEach(function(t4) {
          t4.detach();
        }), t3.prototype.detach.call(this);
      }, e3.prototype.formatAt = function(t4, e4, n2, r2) {
        this.children.forEachAt(t4, e4, function(t5, e5, o2) {
          t5.formatAt(e5, o2, n2, r2);
        });
      }, e3.prototype.insertAt = function(t4, e4, n2) {
        var r2 = this.children.find(t4), o2 = r2[0], i3 = r2[1];
        if (o2) o2.insertAt(i3, e4, n2);
        else {
          var l2 = null == n2 ? a3.create("text", e4) : a3.create(e4, n2);
          this.appendChild(l2);
        }
      }, e3.prototype.insertBefore = function(t4, e4) {
        if (null != this.statics.allowedChildren && !this.statics.allowedChildren.some(function(e5) {
          return t4 instanceof e5;
        })) throw new a3.ParchmentError("Cannot insert " + t4.statics.blotName + " into " + this.statics.blotName);
        t4.insertInto(this, e4);
      }, e3.prototype.length = function() {
        return this.children.reduce(function(t4, e4) {
          return t4 + e4.length();
        }, 0);
      }, e3.prototype.moveChildren = function(t4, e4) {
        this.children.forEach(function(n2) {
          t4.insertBefore(n2, e4);
        });
      }, e3.prototype.optimize = function(e4) {
        if (t3.prototype.optimize.call(this, e4), 0 === this.children.length) if (null != this.statics.defaultChild) {
          var n2 = a3.create(this.statics.defaultChild);
          this.appendChild(n2), n2.optimize(e4);
        } else this.remove();
      }, e3.prototype.path = function(t4, n2) {
        void 0 === n2 && (n2 = false);
        var r2 = this.children.find(t4, n2), o2 = r2[0], i3 = r2[1], l2 = [[this, t4]];
        return o2 instanceof e3 ? l2.concat(o2.path(i3, n2)) : (null != o2 && l2.push([o2, i3]), l2);
      }, e3.prototype.removeChild = function(t4) {
        this.children.remove(t4);
      }, e3.prototype.replace = function(n2) {
        n2 instanceof e3 && n2.moveChildren(this), t3.prototype.replace.call(this, n2);
      }, e3.prototype.split = function(t4, e4) {
        if (void 0 === e4 && (e4 = false), !e4) {
          if (0 === t4) return this;
          if (t4 === this.length()) return this.next;
        }
        var n2 = this.clone();
        return this.parent.insertBefore(n2, this.next), this.children.forEachAt(t4, this.length(), function(t5, r2, o2) {
          t5 = t5.split(r2, e4), n2.appendChild(t5);
        }), n2;
      }, e3.prototype.unwrap = function() {
        this.moveChildren(this.parent, this.next), this.remove();
      }, e3.prototype.update = function(t4, e4) {
        var n2 = this, o2 = [], i3 = [];
        t4.forEach(function(t5) {
          t5.target === n2.domNode && "childList" === t5.type && (o2.push.apply(o2, t5.addedNodes), i3.push.apply(i3, t5.removedNodes));
        }), i3.forEach(function(t5) {
          if (!(null != t5.parentNode && "IFRAME" !== t5.tagName && document.body.compareDocumentPosition(t5) & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
            var e5 = a3.find(t5);
            null != e5 && (null != e5.domNode.parentNode && e5.domNode.parentNode !== n2.domNode || e5.detach());
          }
        }), o2.filter(function(t5) {
          return t5.parentNode == n2.domNode;
        }).sort(function(t5, e5) {
          return t5 === e5 ? 0 : t5.compareDocumentPosition(e5) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1;
        }).forEach(function(t5) {
          var e5 = null;
          null != t5.nextSibling && (e5 = a3.find(t5.nextSibling));
          var o3 = r(t5);
          o3.next == e5 && null != o3.next || (null != o3.parent && o3.parent.removeChild(n2), n2.insertBefore(o3, e5 || void 0));
        });
      }, e3;
    }(l.default);
    e2.default = s3;
  }, function(t2, e2, n) {
    var r = this && this.__extends || function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    }();
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(11), i2 = n(28), l = n(17), a3 = n(1), s3 = function(t3) {
      function e3(e4) {
        var n2 = t3.call(this, e4) || this;
        return n2.attributes = new i2.default(n2.domNode), n2;
      }
      return r(e3, t3), e3.formats = function(t4) {
        return "string" == typeof this.tagName || (Array.isArray(this.tagName) ? t4.tagName.toLowerCase() : void 0);
      }, e3.prototype.format = function(t4, e4) {
        var n2 = a3.query(t4);
        n2 instanceof o.default ? this.attributes.attribute(n2, e4) : e4 && (null == n2 || t4 === this.statics.blotName && this.formats()[t4] === e4 || this.replaceWith(t4, e4));
      }, e3.prototype.formats = function() {
        var t4 = this.attributes.values(), e4 = this.statics.formats(this.domNode);
        return null != e4 && (t4[this.statics.blotName] = e4), t4;
      }, e3.prototype.replaceWith = function(e4, n2) {
        var r2 = t3.prototype.replaceWith.call(this, e4, n2);
        return this.attributes.copy(r2), r2;
      }, e3.prototype.update = function(e4, n2) {
        var r2 = this;
        t3.prototype.update.call(this, e4, n2), e4.some(function(t4) {
          return t4.target === r2.domNode && "attributes" === t4.type;
        }) && this.attributes.build();
      }, e3.prototype.wrap = function(n2, r2) {
        var o2 = t3.prototype.wrap.call(this, n2, r2);
        return o2 instanceof e3 && o2.statics.scope === this.statics.scope && this.attributes.move(o2), o2;
      }, e3;
    }(l.default);
    e2.default = s3;
  }, function(t2, e2, n) {
    var r = this && this.__extends || function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    }();
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(27), i2 = n(1), l = function(t3) {
      function e3() {
        return null !== t3 && t3.apply(this, arguments) || this;
      }
      return r(e3, t3), e3.value = function(t4) {
        return true;
      }, e3.prototype.index = function(t4, e4) {
        return this.domNode === t4 || this.domNode.compareDocumentPosition(t4) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(e4, 1) : -1;
      }, e3.prototype.position = function(t4, e4) {
        var n2 = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);
        return t4 > 0 && (n2 += 1), [this.parent.domNode, n2];
      }, e3.prototype.value = function() {
        var t4;
        return t4 = {}, t4[this.statics.blotName] = this.statics.value(this.domNode) || true, t4;
      }, e3.scope = i2.Scope.INLINE_BLOT, e3;
    }(o.default);
    e2.default = l;
  }, function(t2, e2, n) {
    function r(t3) {
      this.ops = t3, this.index = 0, this.offset = 0;
    }
    var o = n(12), i2 = n(2), l = { attributes: { compose: function(t3, e3, n2) {
      "object" != typeof t3 && (t3 = {}), "object" != typeof e3 && (e3 = {});
      var r2 = i2(true, {}, e3);
      n2 || (r2 = Object.keys(r2).reduce(function(t4, e4) {
        return null != r2[e4] && (t4[e4] = r2[e4]), t4;
      }, {}));
      for (var o2 in t3) void 0 !== t3[o2] && void 0 === e3[o2] && (r2[o2] = t3[o2]);
      return Object.keys(r2).length > 0 ? r2 : void 0;
    }, diff: function(t3, e3) {
      "object" != typeof t3 && (t3 = {}), "object" != typeof e3 && (e3 = {});
      var n2 = Object.keys(t3).concat(Object.keys(e3)).reduce(function(n3, r2) {
        return o(t3[r2], e3[r2]) || (n3[r2] = void 0 === e3[r2] ? null : e3[r2]), n3;
      }, {});
      return Object.keys(n2).length > 0 ? n2 : void 0;
    }, transform: function(t3, e3, n2) {
      if ("object" != typeof t3) return e3;
      if ("object" == typeof e3) {
        if (!n2) return e3;
        var r2 = Object.keys(e3).reduce(function(n3, r3) {
          return void 0 === t3[r3] && (n3[r3] = e3[r3]), n3;
        }, {});
        return Object.keys(r2).length > 0 ? r2 : void 0;
      }
    } }, iterator: function(t3) {
      return new r(t3);
    }, length: function(t3) {
      return "number" == typeof t3.delete ? t3.delete : "number" == typeof t3.retain ? t3.retain : "string" == typeof t3.insert ? t3.insert.length : 1;
    } };
    r.prototype.hasNext = function() {
      return this.peekLength() < 1 / 0;
    }, r.prototype.next = function(t3) {
      t3 || (t3 = 1 / 0);
      var e3 = this.ops[this.index];
      if (e3) {
        var n2 = this.offset, r2 = l.length(e3);
        if (t3 >= r2 - n2 ? (t3 = r2 - n2, this.index += 1, this.offset = 0) : this.offset += t3, "number" == typeof e3.delete) return { delete: t3 };
        var o2 = {};
        return e3.attributes && (o2.attributes = e3.attributes), "number" == typeof e3.retain ? o2.retain = t3 : "string" == typeof e3.insert ? o2.insert = e3.insert.substr(n2, t3) : o2.insert = e3.insert, o2;
      }
      return { retain: 1 / 0 };
    }, r.prototype.peek = function() {
      return this.ops[this.index];
    }, r.prototype.peekLength = function() {
      return this.ops[this.index] ? l.length(this.ops[this.index]) - this.offset : 1 / 0;
    }, r.prototype.peekType = function() {
      return this.ops[this.index] ? "number" == typeof this.ops[this.index].delete ? "delete" : "number" == typeof this.ops[this.index].retain ? "retain" : "insert" : "retain";
    }, r.prototype.rest = function() {
      if (this.hasNext()) {
        if (0 === this.offset) return this.ops.slice(this.index);
        var t3 = this.offset, e3 = this.index, n2 = this.next(), r2 = this.ops.slice(this.index);
        return this.offset = t3, this.index = e3, [n2].concat(r2);
      }
      return [];
    }, t2.exports = l;
  }, function(t2, e2) {
    var n = function() {
      function t3(t4, e4) {
        return null != e4 && t4 instanceof e4;
      }
      function e3(n3, r2, o2, i3, c2) {
        function f(n4, o3) {
          if (null === n4) return null;
          if (0 === o3) return n4;
          var y3, v;
          if ("object" != typeof n4) return n4;
          if (t3(n4, a3)) y3 = new a3();
          else if (t3(n4, s3)) y3 = new s3();
          else if (t3(n4, u2)) y3 = new u2(function(t4, e4) {
            n4.then(function(e5) {
              t4(f(e5, o3 - 1));
            }, function(t5) {
              e4(f(t5, o3 - 1));
            });
          });
          else if (e3.__isArray(n4)) y3 = [];
          else if (e3.__isRegExp(n4)) y3 = new RegExp(n4.source, l(n4)), n4.lastIndex && (y3.lastIndex = n4.lastIndex);
          else if (e3.__isDate(n4)) y3 = new Date(n4.getTime());
          else {
            if (d3 && Buffer.isBuffer(n4)) return y3 = Buffer.allocUnsafe ? Buffer.allocUnsafe(n4.length) : new Buffer(n4.length), n4.copy(y3), y3;
            t3(n4, Error) ? y3 = Object.create(n4) : void 0 === i3 ? (v = Object.getPrototypeOf(n4), y3 = Object.create(v)) : (y3 = Object.create(i3), v = i3);
          }
          if (r2) {
            var b2 = h3.indexOf(n4);
            if (-1 != b2) return p[b2];
            h3.push(n4), p.push(y3);
          }
          t3(n4, a3) && n4.forEach(function(t4, e4) {
            var n5 = f(e4, o3 - 1), r3 = f(t4, o3 - 1);
            y3.set(n5, r3);
          }), t3(n4, s3) && n4.forEach(function(t4) {
            var e4 = f(t4, o3 - 1);
            y3.add(e4);
          });
          for (var g in n4) {
            var m3;
            v && (m3 = Object.getOwnPropertyDescriptor(v, g)), m3 && null == m3.set || (y3[g] = f(n4[g], o3 - 1));
          }
          if (Object.getOwnPropertySymbols) for (var _ = Object.getOwnPropertySymbols(n4), g = 0; g < _.length; g++) {
            var O2 = _[g], w2 = Object.getOwnPropertyDescriptor(n4, O2);
            (!w2 || w2.enumerable || c2) && (y3[O2] = f(n4[O2], o3 - 1), w2.enumerable || Object.defineProperty(y3, O2, { enumerable: false }));
          }
          if (c2) for (var x2 = Object.getOwnPropertyNames(n4), g = 0; g < x2.length; g++) {
            var k2 = x2[g], w2 = Object.getOwnPropertyDescriptor(n4, k2);
            w2 && w2.enumerable || (y3[k2] = f(n4[k2], o3 - 1), Object.defineProperty(y3, k2, { enumerable: false }));
          }
          return y3;
        }
        "object" == typeof r2 && (o2 = r2.depth, i3 = r2.prototype, c2 = r2.includeNonEnumerable, r2 = r2.circular);
        var h3 = [], p = [], d3 = "undefined" != typeof Buffer;
        return void 0 === r2 && (r2 = true), void 0 === o2 && (o2 = 1 / 0), f(n3, o2);
      }
      function n2(t4) {
        return Object.prototype.toString.call(t4);
      }
      function r(t4) {
        return "object" == typeof t4 && "[object Date]" === n2(t4);
      }
      function o(t4) {
        return "object" == typeof t4 && "[object Array]" === n2(t4);
      }
      function i2(t4) {
        return "object" == typeof t4 && "[object RegExp]" === n2(t4);
      }
      function l(t4) {
        var e4 = "";
        return t4.global && (e4 += "g"), t4.ignoreCase && (e4 += "i"), t4.multiline && (e4 += "m"), e4;
      }
      var a3;
      try {
        a3 = Map;
      } catch (t4) {
        a3 = function() {
        };
      }
      var s3;
      try {
        s3 = Set;
      } catch (t4) {
        s3 = function() {
        };
      }
      var u2;
      try {
        u2 = Promise;
      } catch (t4) {
        u2 = function() {
        };
      }
      return e3.clonePrototype = function(t4) {
        if (null === t4) return null;
        var e4 = function() {
        };
        return e4.prototype = t4, new e4();
      }, e3.__objToStr = n2, e3.__isDate = r, e3.__isArray = o, e3.__isRegExp = i2, e3.__getRegExpFlags = l, e3;
    }();
    "object" == typeof t2 && t2.exports && (t2.exports = n);
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3) {
      if (Array.isArray(t3)) {
        for (var e3 = 0, n2 = Array(t3.length); e3 < t3.length; e3++) n2[e3] = t3[e3];
        return n2;
      }
      return Array.from(t3);
    }
    function i2(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function l(t3, e3) {
      try {
        e3.parentNode;
      } catch (t4) {
        return false;
      }
      return e3 instanceof Text && (e3 = e3.parentNode), t3.contains(e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.Range = void 0;
    var a3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), s3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), u2 = n(0), c2 = r(u2), f = n(21), h3 = r(f), p = n(12), d3 = r(p), y3 = n(9), v = r(y3), b2 = n(10), g = r(b2), m3 = (0, g.default)("quill:selection"), _ = function t3(e3) {
      var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
      i2(this, t3), this.index = e3, this.length = n2;
    }, O2 = function() {
      function t3(e3, n2) {
        var r2 = this;
        i2(this, t3), this.emitter = n2, this.scroll = e3, this.composing = false, this.mouseDown = false, this.root = this.scroll.domNode, this.cursor = c2.default.create("cursor", this), this.lastRange = this.savedRange = new _(0, 0), this.handleComposition(), this.handleDragging(), this.emitter.listenDOM("selectionchange", document, function() {
          r2.mouseDown || setTimeout(r2.update.bind(r2, v.default.sources.USER), 1);
        }), this.emitter.on(v.default.events.EDITOR_CHANGE, function(t4, e4) {
          t4 === v.default.events.TEXT_CHANGE && e4.length() > 0 && r2.update(v.default.sources.SILENT);
        }), this.emitter.on(v.default.events.SCROLL_BEFORE_UPDATE, function() {
          if (r2.hasFocus()) {
            var t4 = r2.getNativeRange();
            null != t4 && t4.start.node !== r2.cursor.textNode && r2.emitter.once(v.default.events.SCROLL_UPDATE, function() {
              try {
                r2.setNativeRange(t4.start.node, t4.start.offset, t4.end.node, t4.end.offset);
              } catch (t5) {
              }
            });
          }
        }), this.emitter.on(v.default.events.SCROLL_OPTIMIZE, function(t4, e4) {
          if (e4.range) {
            var n3 = e4.range, o2 = n3.startNode, i3 = n3.startOffset, l2 = n3.endNode, a4 = n3.endOffset;
            r2.setNativeRange(o2, i3, l2, a4);
          }
        }), this.update(v.default.sources.SILENT);
      }
      return s3(t3, [{ key: "handleComposition", value: function() {
        var t4 = this;
        this.root.addEventListener("compositionstart", function() {
          t4.composing = true;
        }), this.root.addEventListener("compositionend", function() {
          if (t4.composing = false, t4.cursor.parent) {
            var e3 = t4.cursor.restore();
            if (!e3) return;
            setTimeout(function() {
              t4.setNativeRange(e3.startNode, e3.startOffset, e3.endNode, e3.endOffset);
            }, 1);
          }
        });
      } }, { key: "handleDragging", value: function() {
        var t4 = this;
        this.emitter.listenDOM("mousedown", document.body, function() {
          t4.mouseDown = true;
        }), this.emitter.listenDOM("mouseup", document.body, function() {
          t4.mouseDown = false, t4.update(v.default.sources.USER);
        });
      } }, { key: "focus", value: function() {
        this.hasFocus() || (this.root.focus(), this.setRange(this.savedRange));
      } }, { key: "format", value: function(t4, e3) {
        if (null == this.scroll.whitelist || this.scroll.whitelist[t4]) {
          this.scroll.update();
          var n2 = this.getNativeRange();
          if (null != n2 && n2.native.collapsed && !c2.default.query(t4, c2.default.Scope.BLOCK)) {
            if (n2.start.node !== this.cursor.textNode) {
              var r2 = c2.default.find(n2.start.node, false);
              if (null == r2) return;
              if (r2 instanceof c2.default.Leaf) {
                var o2 = r2.split(n2.start.offset);
                r2.parent.insertBefore(this.cursor, o2);
              } else r2.insertBefore(this.cursor, n2.start.node);
              this.cursor.attach();
            }
            this.cursor.format(t4, e3), this.scroll.optimize(), this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length), this.update();
          }
        }
      } }, { key: "getBounds", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n2 = this.scroll.length();
        t4 = Math.min(t4, n2 - 1), e3 = Math.min(t4 + e3, n2 - 1) - t4;
        var r2 = void 0, o2 = this.scroll.leaf(t4), i3 = a3(o2, 2), l2 = i3[0], s4 = i3[1];
        if (null == l2) return null;
        var u3 = l2.position(s4, true), c3 = a3(u3, 2);
        r2 = c3[0], s4 = c3[1];
        var f2 = document.createRange();
        if (e3 > 0) {
          f2.setStart(r2, s4);
          var h4 = this.scroll.leaf(t4 + e3), p2 = a3(h4, 2);
          if (l2 = p2[0], s4 = p2[1], null == l2) return null;
          var d4 = l2.position(s4, true), y4 = a3(d4, 2);
          return r2 = y4[0], s4 = y4[1], f2.setEnd(r2, s4), f2.getBoundingClientRect();
        }
        var v2 = "left", b3 = void 0;
        return r2 instanceof Text ? (s4 < r2.data.length ? (f2.setStart(r2, s4), f2.setEnd(r2, s4 + 1)) : (f2.setStart(r2, s4 - 1), f2.setEnd(r2, s4), v2 = "right"), b3 = f2.getBoundingClientRect()) : (b3 = l2.domNode.getBoundingClientRect(), s4 > 0 && (v2 = "right")), { bottom: b3.top + b3.height, height: b3.height, left: b3[v2], right: b3[v2], top: b3.top, width: 0 };
      } }, { key: "getNativeRange", value: function() {
        var t4 = document.getSelection();
        if (null == t4 || t4.rangeCount <= 0) return null;
        var e3 = t4.getRangeAt(0);
        if (null == e3) return null;
        var n2 = this.normalizeNative(e3);
        return m3.info("getNativeRange", n2), n2;
      } }, { key: "getRange", value: function() {
        var t4 = this.getNativeRange();
        return null == t4 ? [null, null] : [this.normalizedToRange(t4), t4];
      } }, { key: "hasFocus", value: function() {
        return document.activeElement === this.root;
      } }, { key: "normalizedToRange", value: function(t4) {
        var e3 = this, n2 = [[t4.start.node, t4.start.offset]];
        t4.native.collapsed || n2.push([t4.end.node, t4.end.offset]);
        var r2 = n2.map(function(t5) {
          var n3 = a3(t5, 2), r3 = n3[0], o2 = n3[1], i4 = c2.default.find(r3, true), l3 = i4.offset(e3.scroll);
          return 0 === o2 ? l3 : i4 instanceof c2.default.Container ? l3 + i4.length() : l3 + i4.index(r3, o2);
        }), i3 = Math.min(Math.max.apply(Math, o(r2)), this.scroll.length() - 1), l2 = Math.min.apply(Math, [i3].concat(o(r2)));
        return new _(l2, i3 - l2);
      } }, { key: "normalizeNative", value: function(t4) {
        if (!l(this.root, t4.startContainer) || !t4.collapsed && !l(this.root, t4.endContainer)) return null;
        var e3 = { start: { node: t4.startContainer, offset: t4.startOffset }, end: { node: t4.endContainer, offset: t4.endOffset }, native: t4 };
        return [e3.start, e3.end].forEach(function(t5) {
          for (var e4 = t5.node, n2 = t5.offset; !(e4 instanceof Text) && e4.childNodes.length > 0; ) if (e4.childNodes.length > n2) e4 = e4.childNodes[n2], n2 = 0;
          else {
            if (e4.childNodes.length !== n2) break;
            e4 = e4.lastChild, n2 = e4 instanceof Text ? e4.data.length : e4.childNodes.length + 1;
          }
          t5.node = e4, t5.offset = n2;
        }), e3;
      } }, { key: "rangeToNative", value: function(t4) {
        var e3 = this, n2 = t4.collapsed ? [t4.index] : [t4.index, t4.index + t4.length], r2 = [], o2 = this.scroll.length();
        return n2.forEach(function(t5, n3) {
          t5 = Math.min(o2 - 1, t5);
          var i3 = void 0, l2 = e3.scroll.leaf(t5), s4 = a3(l2, 2), u3 = s4[0], c3 = s4[1], f2 = u3.position(c3, 0 !== n3), h4 = a3(f2, 2);
          i3 = h4[0], c3 = h4[1], r2.push(i3, c3);
        }), r2.length < 2 && (r2 = r2.concat(r2)), r2;
      } }, { key: "scrollIntoView", value: function(t4) {
        var e3 = this.lastRange;
        if (null != e3) {
          var n2 = this.getBounds(e3.index, e3.length);
          if (null != n2) {
            var r2 = this.scroll.length() - 1, o2 = this.scroll.line(Math.min(e3.index, r2)), i3 = a3(o2, 1), l2 = i3[0], s4 = l2;
            if (e3.length > 0) {
              var u3 = this.scroll.line(Math.min(e3.index + e3.length, r2));
              s4 = a3(u3, 1)[0];
            }
            if (null != l2 && null != s4) {
              var c3 = t4.getBoundingClientRect();
              n2.top < c3.top ? t4.scrollTop -= c3.top - n2.top : n2.bottom > c3.bottom && (t4.scrollTop += n2.bottom - c3.bottom);
            }
          }
        }
      } }, { key: "setNativeRange", value: function(t4, e3) {
        var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t4, r2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e3, o2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        if (m3.info("setNativeRange", t4, e3, n2, r2), null == t4 || null != this.root.parentNode && null != t4.parentNode && null != n2.parentNode) {
          var i3 = document.getSelection();
          if (null != i3) if (null != t4) {
            this.hasFocus() || this.root.focus();
            var l2 = (this.getNativeRange() || {}).native;
            if (null == l2 || o2 || t4 !== l2.startContainer || e3 !== l2.startOffset || n2 !== l2.endContainer || r2 !== l2.endOffset) {
              "BR" == t4.tagName && (e3 = [].indexOf.call(t4.parentNode.childNodes, t4), t4 = t4.parentNode), "BR" == n2.tagName && (r2 = [].indexOf.call(n2.parentNode.childNodes, n2), n2 = n2.parentNode);
              var a4 = document.createRange();
              a4.setStart(t4, e3), a4.setEnd(n2, r2), i3.removeAllRanges(), i3.addRange(a4);
            }
          } else i3.removeAllRanges(), this.root.blur(), document.body.focus();
        }
      } }, { key: "setRange", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : v.default.sources.API;
        if ("string" == typeof e3 && (n2 = e3, e3 = false), m3.info("setRange", t4), null != t4) {
          var r2 = this.rangeToNative(t4);
          this.setNativeRange.apply(this, o(r2).concat([e3]));
        } else this.setNativeRange(null);
        this.update(n2);
      } }, { key: "update", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : v.default.sources.USER, e3 = this.lastRange, n2 = this.getRange(), r2 = a3(n2, 2), o2 = r2[0], i3 = r2[1];
        if (this.lastRange = o2, null != this.lastRange && (this.savedRange = this.lastRange), !(0, d3.default)(e3, this.lastRange)) {
          var l2;
          !this.composing && null != i3 && i3.native.collapsed && i3.start.node !== this.cursor.textNode && this.cursor.restore();
          var s4 = [v.default.events.SELECTION_CHANGE, (0, h3.default)(this.lastRange), (0, h3.default)(e3), t4];
          if ((l2 = this.emitter).emit.apply(l2, [v.default.events.EDITOR_CHANGE].concat(s4)), t4 !== v.default.sources.SILENT) {
            var u3;
            (u3 = this.emitter).emit.apply(u3, s4);
          }
        }
      } }]), t3;
    }();
    e2.Range = _, e2.default = O2;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var a3 = n(0), s3 = r(a3), u2 = n(3), c2 = r(u2), f = function(t3) {
      function e3() {
        return o(this, e3), i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return l(e3, t3), e3;
    }(s3.default.Container);
    f.allowedChildren = [c2.default, u2.BlockEmbed, f], e2.default = f;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.ColorStyle = e2.ColorClass = e2.ColorAttributor = void 0;
    var l = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(0), u2 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(s3), c2 = function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, [{ key: "value", value: function(t4) {
        var n2 = a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "value", this).call(this, t4);
        return n2.startsWith("rgb(") ? (n2 = n2.replace(/^[^\d]+/, "").replace(/[^\d]+$/, ""), "#" + n2.split(",").map(function(t5) {
          return ("00" + parseInt(t5).toString(16)).slice(-2);
        }).join("")) : n2;
      } }]), e3;
    }(u2.default.Attributor.Style), f = new u2.default.Attributor.Class("color", "ql-color", { scope: u2.default.Scope.INLINE }), h3 = new c2("color", "color", { scope: u2.default.Scope.INLINE });
    e2.ColorAttributor = c2, e2.ColorClass = f, e2.ColorStyle = h3;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3, n2) {
      return e3 in t3 ? Object.defineProperty(t3, e3, { value: n2, enumerable: true, configurable: true, writable: true }) : t3[e3] = n2, t3;
    }
    function i2(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function l(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function a3(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function s3(t3, e3) {
      var n2, r2 = t3 === D2.keys.LEFT ? "prefix" : "suffix";
      return n2 = { key: t3, shiftKey: e3, altKey: null }, o(n2, r2, /^$/), o(n2, "handler", function(n3) {
        var r3 = n3.index;
        t3 === D2.keys.RIGHT && (r3 += n3.length + 1);
        var o2 = this.quill.getLeaf(r3);
        return !(b2(o2, 1)[0] instanceof T2.default.Embed) || (t3 === D2.keys.LEFT ? e3 ? this.quill.setSelection(n3.index - 1, n3.length + 1, S3.default.sources.USER) : this.quill.setSelection(n3.index - 1, S3.default.sources.USER) : e3 ? this.quill.setSelection(n3.index, n3.length + 1, S3.default.sources.USER) : this.quill.setSelection(n3.index + n3.length + 1, S3.default.sources.USER), false);
      }), n2;
    }
    function u2(t3, e3) {
      if (!(0 === t3.index || this.quill.getLength() <= 1)) {
        var n2 = this.quill.getLine(t3.index), r2 = b2(n2, 1), o2 = r2[0], i3 = {};
        if (0 === e3.offset) {
          var l2 = this.quill.getLine(t3.index - 1), a4 = b2(l2, 1), s4 = a4[0];
          if (null != s4 && s4.length() > 1) {
            var u3 = o2.formats(), c3 = this.quill.getFormat(t3.index - 1, 1);
            i3 = A.default.attributes.diff(u3, c3) || {};
          }
        }
        var f2 = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(e3.prefix) ? 2 : 1;
        this.quill.deleteText(t3.index - f2, f2, S3.default.sources.USER), Object.keys(i3).length > 0 && this.quill.formatLine(t3.index - f2, f2, i3, S3.default.sources.USER), this.quill.focus();
      }
    }
    function c2(t3, e3) {
      var n2 = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e3.suffix) ? 2 : 1;
      if (!(t3.index >= this.quill.getLength() - n2)) {
        var r2 = {}, o2 = 0, i3 = this.quill.getLine(t3.index), l2 = b2(i3, 1), a4 = l2[0];
        if (e3.offset >= a4.length() - 1) {
          var s4 = this.quill.getLine(t3.index + 1), u3 = b2(s4, 1), c3 = u3[0];
          if (c3) {
            var f2 = a4.formats(), h4 = this.quill.getFormat(t3.index, 1);
            r2 = A.default.attributes.diff(f2, h4) || {}, o2 = c3.length();
          }
        }
        this.quill.deleteText(t3.index, n2, S3.default.sources.USER), Object.keys(r2).length > 0 && this.quill.formatLine(t3.index + o2 - 1, n2, r2, S3.default.sources.USER);
      }
    }
    function f(t3) {
      var e3 = this.quill.getLines(t3), n2 = {};
      if (e3.length > 1) {
        var r2 = e3[0].formats(), o2 = e3[e3.length - 1].formats();
        n2 = A.default.attributes.diff(o2, r2) || {};
      }
      this.quill.deleteText(t3, S3.default.sources.USER), Object.keys(n2).length > 0 && this.quill.formatLine(t3.index, 1, n2, S3.default.sources.USER), this.quill.setSelection(t3.index, S3.default.sources.SILENT), this.quill.focus();
    }
    function h3(t3, e3) {
      var n2 = this;
      t3.length > 0 && this.quill.scroll.deleteAt(t3.index, t3.length);
      var r2 = Object.keys(e3.format).reduce(function(t4, n3) {
        return T2.default.query(n3, T2.default.Scope.BLOCK) && !Array.isArray(e3.format[n3]) && (t4[n3] = e3.format[n3]), t4;
      }, {});
      this.quill.insertText(t3.index, "\n", r2, S3.default.sources.USER), this.quill.setSelection(t3.index + 1, S3.default.sources.SILENT), this.quill.focus(), Object.keys(e3.format).forEach(function(t4) {
        null == r2[t4] && (Array.isArray(e3.format[t4]) || "link" !== t4 && n2.quill.format(t4, e3.format[t4], S3.default.sources.USER));
      });
    }
    function p(t3) {
      return { key: D2.keys.TAB, shiftKey: !t3, format: { "code-block": true }, handler: function(e3) {
        var n2 = T2.default.query("code-block"), r2 = e3.index, o2 = e3.length, i3 = this.quill.scroll.descendant(n2, r2), l2 = b2(i3, 2), a4 = l2[0], s4 = l2[1];
        if (null != a4) {
          var u3 = this.quill.getIndex(a4), c3 = a4.newlineIndex(s4, true) + 1, f2 = a4.newlineIndex(u3 + s4 + o2), h4 = a4.domNode.textContent.slice(c3, f2).split("\n");
          s4 = 0, h4.forEach(function(e4, i4) {
            t3 ? (a4.insertAt(c3 + s4, n2.TAB), s4 += n2.TAB.length, 0 === i4 ? r2 += n2.TAB.length : o2 += n2.TAB.length) : e4.startsWith(n2.TAB) && (a4.deleteAt(c3 + s4, n2.TAB.length), s4 -= n2.TAB.length, 0 === i4 ? r2 -= n2.TAB.length : o2 -= n2.TAB.length), s4 += e4.length + 1;
          }), this.quill.update(S3.default.sources.USER), this.quill.setSelection(r2, o2, S3.default.sources.SILENT);
        }
      } };
    }
    function d3(t3) {
      return { key: t3[0].toUpperCase(), shortKey: true, handler: function(e3, n2) {
        this.quill.format(t3, !n2.format[t3], S3.default.sources.USER);
      } };
    }
    function y3(t3) {
      if ("string" == typeof t3 || "number" == typeof t3) return y3({ key: t3 });
      if ("object" === (void 0 === t3 ? "undefined" : v(t3)) && (t3 = (0, _.default)(t3, false)), "string" == typeof t3.key) if (null != D2.keys[t3.key.toUpperCase()]) t3.key = D2.keys[t3.key.toUpperCase()];
      else {
        if (1 !== t3.key.length) return null;
        t3.key = t3.key.toUpperCase().charCodeAt(0);
      }
      return t3.shortKey && (t3[B2] = t3.shortKey, delete t3.shortKey), t3;
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.SHORTKEY = e2.default = void 0;
    var v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
      return typeof t3;
    } : function(t3) {
      return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
    }, b2 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), g = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), m3 = n(21), _ = r(m3), O2 = n(12), w2 = r(O2), x2 = n(2), k2 = r(x2), E2 = n(4), N = r(E2), j = n(20), A = r(j), q2 = n(0), T2 = r(q2), P = n(6), S3 = r(P), C = n(10), L2 = r(C), M3 = n(7), R2 = r(M3), I2 = (0, L2.default)("quill:keyboard"), B2 = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey", D2 = function(t3) {
      function e3(t4, n2) {
        i2(this, e3);
        var r2 = l(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.bindings = {}, Object.keys(r2.options.bindings).forEach(function(e4) {
          ("list autofill" !== e4 || null == t4.scroll.whitelist || t4.scroll.whitelist.list) && r2.options.bindings[e4] && r2.addBinding(r2.options.bindings[e4]);
        }), r2.addBinding({ key: e3.keys.ENTER, shiftKey: null }, h3), r2.addBinding({ key: e3.keys.ENTER, metaKey: null, ctrlKey: null, altKey: null }, function() {
        }), /Firefox/i.test(navigator.userAgent) ? (r2.addBinding({ key: e3.keys.BACKSPACE }, { collapsed: true }, u2), r2.addBinding({ key: e3.keys.DELETE }, { collapsed: true }, c2)) : (r2.addBinding({ key: e3.keys.BACKSPACE }, { collapsed: true, prefix: /^.?$/ }, u2), r2.addBinding({ key: e3.keys.DELETE }, { collapsed: true, suffix: /^.?$/ }, c2)), r2.addBinding({ key: e3.keys.BACKSPACE }, { collapsed: false }, f), r2.addBinding({ key: e3.keys.DELETE }, { collapsed: false }, f), r2.addBinding({ key: e3.keys.BACKSPACE, altKey: null, ctrlKey: null, metaKey: null, shiftKey: null }, { collapsed: true, offset: 0 }, u2), r2.listen(), r2;
      }
      return a3(e3, t3), g(e3, null, [{ key: "match", value: function(t4, e4) {
        return e4 = y3(e4), !["altKey", "ctrlKey", "metaKey", "shiftKey"].some(function(n2) {
          return !!e4[n2] !== t4[n2] && null !== e4[n2];
        }) && e4.key === (t4.which || t4.keyCode);
      } }]), g(e3, [{ key: "addBinding", value: function(t4) {
        var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r2 = y3(t4);
        if (null == r2 || null == r2.key) return I2.warn("Attempted to add invalid keyboard binding", r2);
        "function" == typeof e4 && (e4 = { handler: e4 }), "function" == typeof n2 && (n2 = { handler: n2 }), r2 = (0, k2.default)(r2, e4, n2), this.bindings[r2.key] = this.bindings[r2.key] || [], this.bindings[r2.key].push(r2);
      } }, { key: "listen", value: function() {
        var t4 = this;
        this.quill.root.addEventListener("keydown", function(n2) {
          if (!n2.defaultPrevented) {
            var r2 = n2.which || n2.keyCode, o2 = (t4.bindings[r2] || []).filter(function(t5) {
              return e3.match(n2, t5);
            });
            if (0 !== o2.length) {
              var i3 = t4.quill.getSelection();
              if (null != i3 && t4.quill.hasFocus()) {
                var l2 = t4.quill.getLine(i3.index), a4 = b2(l2, 2), s4 = a4[0], u3 = a4[1], c3 = t4.quill.getLeaf(i3.index), f2 = b2(c3, 2), h4 = f2[0], p2 = f2[1], d4 = 0 === i3.length ? [h4, p2] : t4.quill.getLeaf(i3.index + i3.length), y4 = b2(d4, 2), g2 = y4[0], m4 = y4[1], _2 = h4 instanceof T2.default.Text ? h4.value().slice(0, p2) : "", O3 = g2 instanceof T2.default.Text ? g2.value().slice(m4) : "", x3 = { collapsed: 0 === i3.length, empty: 0 === i3.length && s4.length() <= 1, format: t4.quill.getFormat(i3), offset: u3, prefix: _2, suffix: O3 };
                o2.some(function(e4) {
                  if (null != e4.collapsed && e4.collapsed !== x3.collapsed) return false;
                  if (null != e4.empty && e4.empty !== x3.empty) return false;
                  if (null != e4.offset && e4.offset !== x3.offset) return false;
                  if (Array.isArray(e4.format)) {
                    if (e4.format.every(function(t5) {
                      return null == x3.format[t5];
                    })) return false;
                  } else if ("object" === v(e4.format) && !Object.keys(e4.format).every(function(t5) {
                    return true === e4.format[t5] ? null != x3.format[t5] : false === e4.format[t5] ? null == x3.format[t5] : (0, w2.default)(e4.format[t5], x3.format[t5]);
                  })) return false;
                  return !(null != e4.prefix && !e4.prefix.test(x3.prefix)) && (!(null != e4.suffix && !e4.suffix.test(x3.suffix)) && true !== e4.handler.call(t4, i3, x3));
                }) && n2.preventDefault();
              }
            }
          }
        });
      } }]), e3;
    }(R2.default);
    D2.keys = { BACKSPACE: 8, TAB: 9, ENTER: 13, ESCAPE: 27, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, DELETE: 46 }, D2.DEFAULTS = { bindings: { bold: d3("bold"), italic: d3("italic"), underline: d3("underline"), indent: { key: D2.keys.TAB, format: ["blockquote", "indent", "list"], handler: function(t3, e3) {
      if (e3.collapsed && 0 !== e3.offset) return true;
      this.quill.format("indent", "+1", S3.default.sources.USER);
    } }, outdent: { key: D2.keys.TAB, shiftKey: true, format: ["blockquote", "indent", "list"], handler: function(t3, e3) {
      if (e3.collapsed && 0 !== e3.offset) return true;
      this.quill.format("indent", "-1", S3.default.sources.USER);
    } }, "outdent backspace": { key: D2.keys.BACKSPACE, collapsed: true, shiftKey: null, metaKey: null, ctrlKey: null, altKey: null, format: ["indent", "list"], offset: 0, handler: function(t3, e3) {
      null != e3.format.indent ? this.quill.format("indent", "-1", S3.default.sources.USER) : null != e3.format.list && this.quill.format("list", false, S3.default.sources.USER);
    } }, "indent code-block": p(true), "outdent code-block": p(false), "remove tab": { key: D2.keys.TAB, shiftKey: true, collapsed: true, prefix: /\t$/, handler: function(t3) {
      this.quill.deleteText(t3.index - 1, 1, S3.default.sources.USER);
    } }, tab: { key: D2.keys.TAB, handler: function(t3) {
      this.quill.history.cutoff();
      var e3 = new N.default().retain(t3.index).delete(t3.length).insert("	");
      this.quill.updateContents(e3, S3.default.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t3.index + 1, S3.default.sources.SILENT);
    } }, "list empty enter": { key: D2.keys.ENTER, collapsed: true, format: ["list"], empty: true, handler: function(t3, e3) {
      this.quill.format("list", false, S3.default.sources.USER), e3.format.indent && this.quill.format("indent", false, S3.default.sources.USER);
    } }, "checklist enter": { key: D2.keys.ENTER, collapsed: true, format: { list: "checked" }, handler: function(t3) {
      var e3 = this.quill.getLine(t3.index), n2 = b2(e3, 2), r2 = n2[0], o2 = n2[1], i3 = (0, k2.default)({}, r2.formats(), { list: "checked" }), l2 = new N.default().retain(t3.index).insert("\n", i3).retain(r2.length() - o2 - 1).retain(1, { list: "unchecked" });
      this.quill.updateContents(l2, S3.default.sources.USER), this.quill.setSelection(t3.index + 1, S3.default.sources.SILENT), this.quill.scrollIntoView();
    } }, "header enter": { key: D2.keys.ENTER, collapsed: true, format: ["header"], suffix: /^$/, handler: function(t3, e3) {
      var n2 = this.quill.getLine(t3.index), r2 = b2(n2, 2), o2 = r2[0], i3 = r2[1], l2 = new N.default().retain(t3.index).insert("\n", e3.format).retain(o2.length() - i3 - 1).retain(1, { header: null });
      this.quill.updateContents(l2, S3.default.sources.USER), this.quill.setSelection(t3.index + 1, S3.default.sources.SILENT), this.quill.scrollIntoView();
    } }, "list autofill": { key: " ", collapsed: true, format: { list: false }, prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/, handler: function(t3, e3) {
      var n2 = e3.prefix.length, r2 = this.quill.getLine(t3.index), o2 = b2(r2, 2), i3 = o2[0], l2 = o2[1];
      if (l2 > n2) return true;
      var a4 = void 0;
      switch (e3.prefix.trim()) {
        case "[]":
        case "[ ]":
          a4 = "unchecked";
          break;
        case "[x]":
          a4 = "checked";
          break;
        case "-":
        case "*":
          a4 = "bullet";
          break;
        default:
          a4 = "ordered";
      }
      this.quill.insertText(t3.index, " ", S3.default.sources.USER), this.quill.history.cutoff();
      var s4 = new N.default().retain(t3.index - l2).delete(n2 + 1).retain(i3.length() - 2 - l2).retain(1, { list: a4 });
      this.quill.updateContents(s4, S3.default.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t3.index - n2, S3.default.sources.SILENT);
    } }, "code exit": { key: D2.keys.ENTER, collapsed: true, format: ["code-block"], prefix: /\n\n$/, suffix: /^\s+$/, handler: function(t3) {
      var e3 = this.quill.getLine(t3.index), n2 = b2(e3, 2), r2 = n2[0], o2 = n2[1], i3 = new N.default().retain(t3.index + r2.length() - o2 - 2).retain(1, { "code-block": null }).delete(1);
      this.quill.updateContents(i3, S3.default.sources.USER);
    } }, "embed left": s3(D2.keys.LEFT, false), "embed left shift": s3(D2.keys.LEFT, true), "embed right": s3(D2.keys.RIGHT, false), "embed right shift": s3(D2.keys.RIGHT, true) } }, e2.default = D2, e2.SHORTKEY = B2;
  }, function(t2, e2, n) {
    t2.exports = { align: { "": n(75), center: n(76), right: n(77), justify: n(78) }, background: n(79), blockquote: n(80), bold: n(81), clean: n(82), code: n(40), "code-block": n(40), color: n(83), direction: { "": n(84), rtl: n(85) }, float: { center: n(86), full: n(87), left: n(88), right: n(89) }, formula: n(90), header: { 1: n(91), 2: n(92) }, italic: n(93), image: n(94), indent: { "+1": n(95), "-1": n(96) }, link: n(97), list: { ordered: n(98), bullet: n(99), check: n(100) }, script: { sub: n(101), super: n(102) }, strike: n(103), underline: n(104), video: n(105) };
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true });
    var r = n(1), o = function() {
      function t3(t4) {
        this.domNode = t4, this.domNode[r.DATA_KEY] = { blot: this };
      }
      return Object.defineProperty(t3.prototype, "statics", { get: function() {
        return this.constructor;
      }, enumerable: true, configurable: true }), t3.create = function(t4) {
        if (null == this.tagName) throw new r.ParchmentError("Blot definition missing tagName");
        var e3;
        return Array.isArray(this.tagName) ? ("string" == typeof t4 && (t4 = t4.toUpperCase(), parseInt(t4).toString() === t4 && (t4 = parseInt(t4))), e3 = "number" == typeof t4 ? document.createElement(this.tagName[t4 - 1]) : this.tagName.indexOf(t4) > -1 ? document.createElement(t4) : document.createElement(this.tagName[0])) : e3 = document.createElement(this.tagName), this.className && e3.classList.add(this.className), e3;
      }, t3.prototype.attach = function() {
        null != this.parent && (this.scroll = this.parent.scroll);
      }, t3.prototype.clone = function() {
        var t4 = this.domNode.cloneNode(false);
        return r.create(t4);
      }, t3.prototype.detach = function() {
        null != this.parent && this.parent.removeChild(this), delete this.domNode[r.DATA_KEY];
      }, t3.prototype.deleteAt = function(t4, e3) {
        this.isolate(t4, e3).remove();
      }, t3.prototype.formatAt = function(t4, e3, n2, o2) {
        var i2 = this.isolate(t4, e3);
        if (null != r.query(n2, r.Scope.BLOT) && o2) i2.wrap(n2, o2);
        else if (null != r.query(n2, r.Scope.ATTRIBUTE)) {
          var l = r.create(this.statics.scope);
          i2.wrap(l), l.format(n2, o2);
        }
      }, t3.prototype.insertAt = function(t4, e3, n2) {
        var o2 = null == n2 ? r.create("text", e3) : r.create(e3, n2), i2 = this.split(t4);
        this.parent.insertBefore(o2, i2);
      }, t3.prototype.insertInto = function(t4, e3) {
        void 0 === e3 && (e3 = null), null != this.parent && this.parent.children.remove(this);
        var n2 = null;
        t4.children.insertBefore(this, e3), null != e3 && (n2 = e3.domNode), this.domNode.parentNode == t4.domNode && this.domNode.nextSibling == n2 || t4.domNode.insertBefore(this.domNode, n2), this.parent = t4, this.attach();
      }, t3.prototype.isolate = function(t4, e3) {
        var n2 = this.split(t4);
        return n2.split(e3), n2;
      }, t3.prototype.length = function() {
        return 1;
      }, t3.prototype.offset = function(t4) {
        return void 0 === t4 && (t4 = this.parent), null == this.parent || this == t4 ? 0 : this.parent.children.offset(this) + this.parent.offset(t4);
      }, t3.prototype.optimize = function(t4) {
        null != this.domNode[r.DATA_KEY] && delete this.domNode[r.DATA_KEY].mutations;
      }, t3.prototype.remove = function() {
        null != this.domNode.parentNode && this.domNode.parentNode.removeChild(this.domNode), this.detach();
      }, t3.prototype.replace = function(t4) {
        null != t4.parent && (t4.parent.insertBefore(this, t4.next), t4.remove());
      }, t3.prototype.replaceWith = function(t4, e3) {
        var n2 = "string" == typeof t4 ? r.create(t4, e3) : t4;
        return n2.replace(this), n2;
      }, t3.prototype.split = function(t4, e3) {
        return 0 === t4 ? this : this.next;
      }, t3.prototype.update = function(t4, e3) {
      }, t3.prototype.wrap = function(t4, e3) {
        var n2 = "string" == typeof t4 ? r.create(t4, e3) : t4;
        return null != this.parent && this.parent.insertBefore(n2, this.next), n2.appendChild(this), n2;
      }, t3.blotName = "abstract", t3;
    }();
    e2.default = o;
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true });
    var r = n(11), o = n(29), i2 = n(30), l = n(1), a3 = function() {
      function t3(t4) {
        this.attributes = {}, this.domNode = t4, this.build();
      }
      return t3.prototype.attribute = function(t4, e3) {
        e3 ? t4.add(this.domNode, e3) && (null != t4.value(this.domNode) ? this.attributes[t4.attrName] = t4 : delete this.attributes[t4.attrName]) : (t4.remove(this.domNode), delete this.attributes[t4.attrName]);
      }, t3.prototype.build = function() {
        var t4 = this;
        this.attributes = {};
        var e3 = r.default.keys(this.domNode), n2 = o.default.keys(this.domNode), a4 = i2.default.keys(this.domNode);
        e3.concat(n2).concat(a4).forEach(function(e4) {
          var n3 = l.query(e4, l.Scope.ATTRIBUTE);
          n3 instanceof r.default && (t4.attributes[n3.attrName] = n3);
        });
      }, t3.prototype.copy = function(t4) {
        var e3 = this;
        Object.keys(this.attributes).forEach(function(n2) {
          var r2 = e3.attributes[n2].value(e3.domNode);
          t4.format(n2, r2);
        });
      }, t3.prototype.move = function(t4) {
        var e3 = this;
        this.copy(t4), Object.keys(this.attributes).forEach(function(t5) {
          e3.attributes[t5].remove(e3.domNode);
        }), this.attributes = {};
      }, t3.prototype.values = function() {
        var t4 = this;
        return Object.keys(this.attributes).reduce(function(e3, n2) {
          return e3[n2] = t4.attributes[n2].value(t4.domNode), e3;
        }, {});
      }, t3;
    }();
    e2.default = a3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      return (t3.getAttribute("class") || "").split(/\s+/).filter(function(t4) {
        return 0 === t4.indexOf(e3 + "-");
      });
    }
    var o = this && this.__extends || function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    }();
    Object.defineProperty(e2, "__esModule", { value: true });
    var i2 = n(11), l = function(t3) {
      function e3() {
        return null !== t3 && t3.apply(this, arguments) || this;
      }
      return o(e3, t3), e3.keys = function(t4) {
        return (t4.getAttribute("class") || "").split(/\s+/).map(function(t5) {
          return t5.split("-").slice(0, -1).join("-");
        });
      }, e3.prototype.add = function(t4, e4) {
        return !!this.canAdd(t4, e4) && (this.remove(t4), t4.classList.add(this.keyName + "-" + e4), true);
      }, e3.prototype.remove = function(t4) {
        r(t4, this.keyName).forEach(function(e4) {
          t4.classList.remove(e4);
        }), 0 === t4.classList.length && t4.removeAttribute("class");
      }, e3.prototype.value = function(t4) {
        var e4 = r(t4, this.keyName)[0] || "", n2 = e4.slice(this.keyName.length + 1);
        return this.canAdd(t4, n2) ? n2 : "";
      }, e3;
    }(i2.default);
    e2.default = l;
  }, function(t2, e2, n) {
    function r(t3) {
      var e3 = t3.split("-"), n2 = e3.slice(1).map(function(t4) {
        return t4[0].toUpperCase() + t4.slice(1);
      }).join("");
      return e3[0] + n2;
    }
    var o = this && this.__extends || function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    }();
    Object.defineProperty(e2, "__esModule", { value: true });
    var i2 = n(11), l = function(t3) {
      function e3() {
        return null !== t3 && t3.apply(this, arguments) || this;
      }
      return o(e3, t3), e3.keys = function(t4) {
        return (t4.getAttribute("style") || "").split(";").map(function(t5) {
          return t5.split(":")[0].trim();
        });
      }, e3.prototype.add = function(t4, e4) {
        return !!this.canAdd(t4, e4) && (t4.style[r(this.keyName)] = e4, true);
      }, e3.prototype.remove = function(t4) {
        t4.style[r(this.keyName)] = "", t4.getAttribute("style") || t4.removeAttribute("style");
      }, e3.prototype.value = function(t4) {
        var e4 = t4.style[r(this.keyName)];
        return this.canAdd(t4, e4) ? e4 : "";
      }, e3;
    }(i2.default);
    e2.default = l;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var a3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), c2 = n(0), f = r(c2), h3 = n(8), p = r(h3), d3 = function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4));
        return r2.selection = n2, r2.textNode = document.createTextNode(e3.CONTENTS), r2.domNode.appendChild(r2.textNode), r2._length = 0, r2;
      }
      return l(e3, t3), u2(e3, null, [{ key: "value", value: function() {
      } }]), u2(e3, [{ key: "detach", value: function() {
        null != this.parent && this.parent.removeChild(this);
      } }, { key: "format", value: function(t4, n2) {
        if (0 !== this._length) return s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "format", this).call(this, t4, n2);
        for (var r2 = this, o2 = 0; null != r2 && r2.statics.scope !== f.default.Scope.BLOCK_BLOT; ) o2 += r2.offset(r2.parent), r2 = r2.parent;
        null != r2 && (this._length = e3.CONTENTS.length, r2.optimize(), r2.formatAt(o2, e3.CONTENTS.length, t4, n2), this._length = 0);
      } }, { key: "index", value: function(t4, n2) {
        return t4 === this.textNode ? 0 : s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "index", this).call(this, t4, n2);
      } }, { key: "length", value: function() {
        return this._length;
      } }, { key: "position", value: function() {
        return [this.textNode, this.textNode.data.length];
      } }, { key: "remove", value: function() {
        s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "remove", this).call(this), this.parent = null;
      } }, { key: "restore", value: function() {
        if (!this.selection.composing && null != this.parent) {
          var t4 = this.textNode, n2 = this.selection.getNativeRange(), r2 = void 0, o2 = void 0, i3 = void 0;
          if (null != n2 && n2.start.node === t4 && n2.end.node === t4) {
            var l2 = [t4, n2.start.offset, n2.end.offset];
            r2 = l2[0], o2 = l2[1], i3 = l2[2];
          }
          for (; null != this.domNode.lastChild && this.domNode.lastChild !== this.textNode; ) this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
          if (this.textNode.data !== e3.CONTENTS) {
            var s4 = this.textNode.data.split(e3.CONTENTS).join("");
            this.next instanceof p.default ? (r2 = this.next.domNode, this.next.insertAt(0, s4), this.textNode.data = e3.CONTENTS) : (this.textNode.data = s4, this.parent.insertBefore(f.default.create(this.textNode), this), this.textNode = document.createTextNode(e3.CONTENTS), this.domNode.appendChild(this.textNode));
          }
          if (this.remove(), null != o2) {
            var u3 = [o2, i3].map(function(t5) {
              return Math.max(0, Math.min(r2.data.length, t5 - 1));
            }), c3 = a3(u3, 2);
            return o2 = c3[0], i3 = c3[1], { startNode: r2, startOffset: o2, endNode: r2, endOffset: i3 };
          }
        }
      } }, { key: "update", value: function(t4, e4) {
        var n2 = this;
        if (t4.some(function(t5) {
          return "characterData" === t5.type && t5.target === n2.textNode;
        })) {
          var r2 = this.restore();
          r2 && (e4.range = r2);
        }
      } }, { key: "value", value: function() {
        return "";
      } }]), e3;
    }(f.default.Embed);
    d3.blotName = "cursor", d3.className = "ql-cursor", d3.tagName = "span", d3.CONTENTS = "\uFEFF", e2.default = d3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), i2 = function() {
      function t3(e3, n2) {
        r(this, t3), this.quill = e3, this.options = n2, this.modules = {};
      }
      return o(t3, [{ key: "init", value: function() {
        var t4 = this;
        Object.keys(this.options.modules).forEach(function(e3) {
          null == t4.modules[e3] && t4.addModule(e3);
        });
      } }, { key: "addModule", value: function(t4) {
        var e3 = this.quill.constructor.import("modules/" + t4);
        return this.modules[t4] = new e3(this.quill, this.options.modules[t4] || {}), this.modules[t4];
      } }]), t3;
    }();
    i2.DEFAULTS = { modules: {} }, i2.themes = { default: i2 }, e2.default = i2;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var a3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = n(0), c2 = r(u2), f = n(8), h3 = r(f), p = "\uFEFF", d3 = function(t3) {
      function e3(t4) {
        o(this, e3);
        var n2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4));
        return n2.contentNode = document.createElement("span"), n2.contentNode.setAttribute("contenteditable", false), [].slice.call(n2.domNode.childNodes).forEach(function(t5) {
          n2.contentNode.appendChild(t5);
        }), n2.leftGuard = document.createTextNode(p), n2.rightGuard = document.createTextNode(p), n2.domNode.appendChild(n2.leftGuard), n2.domNode.appendChild(n2.contentNode), n2.domNode.appendChild(n2.rightGuard), n2;
      }
      return l(e3, t3), a3(e3, [{ key: "index", value: function(t4, n2) {
        return t4 === this.leftGuard ? 0 : t4 === this.rightGuard ? 1 : s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "index", this).call(this, t4, n2);
      } }, { key: "restore", value: function(t4) {
        var e4 = void 0, n2 = void 0, r2 = t4.data.split(p).join("");
        if (t4 === this.leftGuard) if (this.prev instanceof h3.default) {
          var o2 = this.prev.length();
          this.prev.insertAt(o2, r2), e4 = { startNode: this.prev.domNode, startOffset: o2 + r2.length };
        } else n2 = document.createTextNode(r2), this.parent.insertBefore(c2.default.create(n2), this), e4 = { startNode: n2, startOffset: r2.length };
        else t4 === this.rightGuard && (this.next instanceof h3.default ? (this.next.insertAt(0, r2), e4 = { startNode: this.next.domNode, startOffset: r2.length }) : (n2 = document.createTextNode(r2), this.parent.insertBefore(c2.default.create(n2), this.next), e4 = { startNode: n2, startOffset: r2.length }));
        return t4.data = p, e4;
      } }, { key: "update", value: function(t4, e4) {
        var n2 = this;
        t4.forEach(function(t5) {
          if ("characterData" === t5.type && (t5.target === n2.leftGuard || t5.target === n2.rightGuard)) {
            var r2 = n2.restore(t5.target);
            r2 && (e4.range = r2);
          }
        });
      } }]), e3;
    }(c2.default.Embed);
    e2.default = d3;
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true }), e2.AlignStyle = e2.AlignClass = e2.AlignAttribute = void 0;
    var r = n(0), o = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(r), i2 = { scope: o.default.Scope.BLOCK, whitelist: ["right", "center", "justify"] }, l = new o.default.Attributor.Attribute("align", "align", i2), a3 = new o.default.Attributor.Class("align", "ql-align", i2), s3 = new o.default.Attributor.Style("align", "text-align", i2);
    e2.AlignAttribute = l, e2.AlignClass = a3, e2.AlignStyle = s3;
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true }), e2.BackgroundStyle = e2.BackgroundClass = void 0;
    var r = n(0), o = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(r), i2 = n(24), l = new o.default.Attributor.Class("background", "ql-bg", { scope: o.default.Scope.INLINE }), a3 = new i2.ColorAttributor("background", "background-color", { scope: o.default.Scope.INLINE });
    e2.BackgroundClass = l, e2.BackgroundStyle = a3;
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true }), e2.DirectionStyle = e2.DirectionClass = e2.DirectionAttribute = void 0;
    var r = n(0), o = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(r), i2 = { scope: o.default.Scope.BLOCK, whitelist: ["rtl"] }, l = new o.default.Attributor.Attribute("direction", "dir", i2), a3 = new o.default.Attributor.Class("direction", "ql-direction", i2), s3 = new o.default.Attributor.Style("direction", "direction", i2);
    e2.DirectionAttribute = l, e2.DirectionClass = a3, e2.DirectionStyle = s3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.FontClass = e2.FontStyle = void 0;
    var l = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(0), u2 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(s3), c2 = { scope: u2.default.Scope.INLINE, whitelist: ["serif", "monospace"] }, f = new u2.default.Attributor.Class("font", "ql-font", c2), h3 = function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, [{ key: "value", value: function(t4) {
        return a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "value", this).call(this, t4).replace(/["']/g, "");
      } }]), e3;
    }(u2.default.Attributor.Style), p = new h3("font", "font-family", c2);
    e2.FontStyle = p, e2.FontClass = f;
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true }), e2.SizeStyle = e2.SizeClass = void 0;
    var r = n(0), o = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(r), i2 = new o.default.Attributor.Class("size", "ql-size", { scope: o.default.Scope.INLINE, whitelist: ["small", "large", "huge"] }), l = new o.default.Attributor.Style("size", "font-size", { scope: o.default.Scope.INLINE, whitelist: ["10px", "18px", "32px"] });
    e2.SizeClass = i2, e2.SizeStyle = l;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(5), u2 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(s3), c2 = function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, [{ key: "optimize", value: function(t4) {
        a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "optimize", this).call(this, t4), this.domNode.tagName !== this.statics.tagName[0] && this.replaceWith(this.statics.blotName);
      } }], [{ key: "create", value: function() {
        return a3(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this);
      } }, { key: "formats", value: function() {
        return true;
      } }]), e3;
    }(u2.default);
    c2.blotName = "bold", c2.tagName = ["STRONG", "B"], e2.default = c2;
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"></polyline> <polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>';
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(16), u2 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(s3), c2 = function(t3) {
      function e3(t4, n2) {
        r(this, e3);
        var i3 = o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4));
        return i3.label.innerHTML = n2, i3.container.classList.add("ql-color-picker"), [].slice.call(i3.container.querySelectorAll(".ql-picker-item"), 0, 7).forEach(function(t5) {
          t5.classList.add("ql-primary");
        }), i3;
      }
      return i2(e3, t3), l(e3, [{ key: "buildItem", value: function(t4) {
        var n2 = a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "buildItem", this).call(this, t4);
        return n2.style.backgroundColor = t4.getAttribute("value") || "", n2;
      } }, { key: "selectItem", value: function(t4, n2) {
        a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "selectItem", this).call(this, t4, n2);
        var r2 = this.label.querySelector(".ql-color-label"), o2 = t4 ? t4.getAttribute("data-value") || "" : "";
        r2 && ("line" === r2.tagName ? r2.style.stroke = o2 : r2.style.fill = o2);
      } }]), e3;
    }(u2.default);
    e2.default = c2;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(16), u2 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(s3), c2 = function(t3) {
      function e3(t4, n2) {
        r(this, e3);
        var i3 = o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4));
        return i3.container.classList.add("ql-icon-picker"), [].forEach.call(i3.container.querySelectorAll(".ql-picker-item"), function(t5) {
          t5.innerHTML = n2[t5.getAttribute("data-value") || ""];
        }), i3.defaultItem = i3.container.querySelector(".ql-selected"), i3.selectItem(i3.defaultItem), i3;
      }
      return i2(e3, t3), l(e3, [{ key: "selectItem", value: function(t4, n2) {
        a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "selectItem", this).call(this, t4, n2), t4 = t4 || this.defaultItem, this.label.innerHTML = t4.innerHTML;
      } }]), e3;
    }(u2.default);
    e2.default = c2;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), i2 = function() {
      function t3(e3, n2) {
        var o2 = this;
        r(this, t3), this.quill = e3, this.boundsContainer = n2 || document.body, this.root = e3.addContainer("ql-tooltip"), this.root.innerHTML = this.constructor.TEMPLATE, this.quill.root === this.quill.scrollingContainer && this.quill.root.addEventListener("scroll", function() {
          o2.root.style.marginTop = -1 * o2.quill.root.scrollTop + "px";
        }), this.hide();
      }
      return o(t3, [{ key: "hide", value: function() {
        this.root.classList.add("ql-hidden");
      } }, { key: "position", value: function(t4) {
        var e3 = t4.left + t4.width / 2 - this.root.offsetWidth / 2, n2 = t4.bottom + this.quill.root.scrollTop;
        this.root.style.left = e3 + "px", this.root.style.top = n2 + "px", this.root.classList.remove("ql-flip");
        var r2 = this.boundsContainer.getBoundingClientRect(), o2 = this.root.getBoundingClientRect(), i3 = 0;
        if (o2.right > r2.right && (i3 = r2.right - o2.right, this.root.style.left = e3 + i3 + "px"), o2.left < r2.left && (i3 = r2.left - o2.left, this.root.style.left = e3 + i3 + "px"), o2.bottom > r2.bottom) {
          var l = o2.bottom - o2.top, a3 = t4.bottom - t4.top + l;
          this.root.style.top = n2 - a3 + "px", this.root.classList.add("ql-flip");
        }
        return i3;
      } }, { key: "show", value: function() {
        this.root.classList.remove("ql-editing"), this.root.classList.remove("ql-hidden");
      } }]), t3;
    }();
    e2.default = i2;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function a3(t3) {
      var e3 = t3.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || t3.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
      return e3 ? (e3[1] || "https") + "://www.youtube.com/embed/" + e3[2] + "?showinfo=0" : (e3 = t3.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) ? (e3[1] || "https") + "://player.vimeo.com/video/" + e3[2] + "/" : t3;
    }
    function s3(t3, e3) {
      var n2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      e3.forEach(function(e4) {
        var r2 = document.createElement("option");
        e4 === n2 ? r2.setAttribute("selected", "selected") : r2.setAttribute("value", e4), t3.appendChild(r2);
      });
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.BaseTooltip = void 0;
    var u2 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), c2 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, f = n(2), h3 = r(f), p = n(4), d3 = r(p), y3 = n(9), v = r(y3), b2 = n(25), g = r(b2), m3 = n(32), _ = r(m3), O2 = n(41), w2 = r(O2), x2 = n(42), k2 = r(x2), E2 = n(16), N = r(E2), j = n(43), A = r(j), q2 = [false, "center", "right", "justify"], T2 = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"], P = [false, "serif", "monospace"], S3 = ["1", "2", "3", false], C = ["small", false, "large", "huge"], L2 = function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2)), l2 = function e4(n3) {
          if (!document.body.contains(t4.root)) return document.body.removeEventListener("click", e4);
          null == r2.tooltip || r2.tooltip.root.contains(n3.target) || document.activeElement === r2.tooltip.textbox || r2.quill.hasFocus() || r2.tooltip.hide(), null != r2.pickers && r2.pickers.forEach(function(t5) {
            t5.container.contains(n3.target) || t5.close();
          });
        };
        return t4.emitter.listenDOM("click", document.body, l2), r2;
      }
      return l(e3, t3), u2(e3, [{ key: "addModule", value: function(t4) {
        var n2 = c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "addModule", this).call(this, t4);
        return "toolbar" === t4 && this.extendToolbar(n2), n2;
      } }, { key: "buildButtons", value: function(t4, e4) {
        t4.forEach(function(t5) {
          (t5.getAttribute("class") || "").split(/\s+/).forEach(function(n2) {
            if (n2.startsWith("ql-") && (n2 = n2.slice("ql-".length), null != e4[n2])) if ("direction" === n2) t5.innerHTML = e4[n2][""] + e4[n2].rtl;
            else if ("string" == typeof e4[n2]) t5.innerHTML = e4[n2];
            else {
              var r2 = t5.value || "";
              null != r2 && e4[n2][r2] && (t5.innerHTML = e4[n2][r2]);
            }
          });
        });
      } }, { key: "buildPickers", value: function(t4, e4) {
        var n2 = this;
        this.pickers = t4.map(function(t5) {
          if (t5.classList.contains("ql-align")) return null == t5.querySelector("option") && s3(t5, q2), new k2.default(t5, e4.align);
          if (t5.classList.contains("ql-background") || t5.classList.contains("ql-color")) {
            var n3 = t5.classList.contains("ql-background") ? "background" : "color";
            return null == t5.querySelector("option") && s3(t5, T2, "background" === n3 ? "#ffffff" : "#000000"), new w2.default(t5, e4[n3]);
          }
          return null == t5.querySelector("option") && (t5.classList.contains("ql-font") ? s3(t5, P) : t5.classList.contains("ql-header") ? s3(t5, S3) : t5.classList.contains("ql-size") && s3(t5, C)), new N.default(t5);
        });
        var r2 = function() {
          n2.pickers.forEach(function(t5) {
            t5.update();
          });
        };
        this.quill.on(v.default.events.EDITOR_CHANGE, r2);
      } }]), e3;
    }(_.default);
    L2.DEFAULTS = (0, h3.default)(true, {}, _.default.DEFAULTS, { modules: { toolbar: { handlers: { formula: function() {
      this.quill.theme.tooltip.edit("formula");
    }, image: function() {
      var t3 = this, e3 = this.container.querySelector("input.ql-image[type=file]");
      null == e3 && (e3 = document.createElement("input"), e3.setAttribute("type", "file"), e3.setAttribute("accept", "image/png, image/gif, image/jpeg, image/bmp, image/x-icon"), e3.classList.add("ql-image"), e3.addEventListener("change", function() {
        if (null != e3.files && null != e3.files[0]) {
          var n2 = new FileReader();
          n2.onload = function(n3) {
            var r2 = t3.quill.getSelection(true);
            t3.quill.updateContents(new d3.default().retain(r2.index).delete(r2.length).insert({ image: n3.target.result }), v.default.sources.USER), t3.quill.setSelection(r2.index + 1, v.default.sources.SILENT), e3.value = "";
          }, n2.readAsDataURL(e3.files[0]);
        }
      }), this.container.appendChild(e3)), e3.click();
    }, video: function() {
      this.quill.theme.tooltip.edit("video");
    } } } } });
    var M3 = function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.textbox = r2.root.querySelector('input[type="text"]'), r2.listen(), r2;
      }
      return l(e3, t3), u2(e3, [{ key: "listen", value: function() {
        var t4 = this;
        this.textbox.addEventListener("keydown", function(e4) {
          g.default.match(e4, "enter") ? (t4.save(), e4.preventDefault()) : g.default.match(e4, "escape") && (t4.cancel(), e4.preventDefault());
        });
      } }, { key: "cancel", value: function() {
        this.hide();
      } }, { key: "edit", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "link", e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        this.root.classList.remove("ql-hidden"), this.root.classList.add("ql-editing"), null != e4 ? this.textbox.value = e4 : t4 !== this.root.getAttribute("data-mode") && (this.textbox.value = ""), this.position(this.quill.getBounds(this.quill.selection.savedRange)), this.textbox.select(), this.textbox.setAttribute("placeholder", this.textbox.getAttribute("data-" + t4) || ""), this.root.setAttribute("data-mode", t4);
      } }, { key: "restoreFocus", value: function() {
        var t4 = this.quill.scrollingContainer.scrollTop;
        this.quill.focus(), this.quill.scrollingContainer.scrollTop = t4;
      } }, { key: "save", value: function() {
        var t4 = this.textbox.value;
        switch (this.root.getAttribute("data-mode")) {
          case "link":
            var e4 = this.quill.root.scrollTop;
            this.linkRange ? (this.quill.formatText(this.linkRange, "link", t4, v.default.sources.USER), delete this.linkRange) : (this.restoreFocus(), this.quill.format("link", t4, v.default.sources.USER)), this.quill.root.scrollTop = e4;
            break;
          case "video":
            t4 = a3(t4);
          case "formula":
            if (!t4) break;
            var n2 = this.quill.getSelection(true);
            if (null != n2) {
              var r2 = n2.index + n2.length;
              this.quill.insertEmbed(r2, this.root.getAttribute("data-mode"), t4, v.default.sources.USER), "formula" === this.root.getAttribute("data-mode") && this.quill.insertText(r2 + 1, " ", v.default.sources.USER), this.quill.setSelection(r2 + 2, v.default.sources.USER);
            }
        }
        this.textbox.value = "", this.hide();
      } }]), e3;
    }(A.default);
    e2.BaseTooltip = M3, e2.default = L2;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(46), i2 = r(o), l = n(34), a3 = n(36), s3 = n(62), u2 = n(63), c2 = r(u2), f = n(64), h3 = r(f), p = n(65), d3 = r(p), y3 = n(35), v = n(24), b2 = n(37), g = n(38), m3 = n(39), _ = r(m3), O2 = n(66), w2 = r(O2), x2 = n(15), k2 = r(x2), E2 = n(67), N = r(E2), j = n(68), A = r(j), q2 = n(69), T2 = r(q2), P = n(70), S3 = r(P), C = n(71), L2 = r(C), M3 = n(13), R2 = r(M3), I2 = n(72), B2 = r(I2), D2 = n(73), U = r(D2), F = n(74), H3 = r(F), K2 = n(26), z2 = r(K2), V = n(16), Z = r(V), W = n(41), G2 = r(W), Y2 = n(42), X2 = r(Y2), $ = n(43), Q2 = r($), J = n(107), tt = r(J), et = n(108), nt = r(et);
    i2.default.register({ "attributors/attribute/direction": a3.DirectionAttribute, "attributors/class/align": l.AlignClass, "attributors/class/background": y3.BackgroundClass, "attributors/class/color": v.ColorClass, "attributors/class/direction": a3.DirectionClass, "attributors/class/font": b2.FontClass, "attributors/class/size": g.SizeClass, "attributors/style/align": l.AlignStyle, "attributors/style/background": y3.BackgroundStyle, "attributors/style/color": v.ColorStyle, "attributors/style/direction": a3.DirectionStyle, "attributors/style/font": b2.FontStyle, "attributors/style/size": g.SizeStyle }, true), i2.default.register({ "formats/align": l.AlignClass, "formats/direction": a3.DirectionClass, "formats/indent": s3.IndentClass, "formats/background": y3.BackgroundStyle, "formats/color": v.ColorStyle, "formats/font": b2.FontClass, "formats/size": g.SizeClass, "formats/blockquote": c2.default, "formats/code-block": R2.default, "formats/header": h3.default, "formats/list": d3.default, "formats/bold": _.default, "formats/code": M3.Code, "formats/italic": w2.default, "formats/link": k2.default, "formats/script": N.default, "formats/strike": A.default, "formats/underline": T2.default, "formats/image": S3.default, "formats/video": L2.default, "formats/list/item": p.ListItem, "modules/formula": B2.default, "modules/syntax": U.default, "modules/toolbar": H3.default, "themes/bubble": tt.default, "themes/snow": nt.default, "ui/icons": z2.default, "ui/picker": Z.default, "ui/icon-picker": X2.default, "ui/color-picker": G2.default, "ui/tooltip": Q2.default }, true), e2.default = i2.default;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(0), i2 = r(o), l = n(6), a3 = r(l), s3 = n(3), u2 = r(s3), c2 = n(14), f = r(c2), h3 = n(23), p = r(h3), d3 = n(31), y3 = r(d3), v = n(33), b2 = r(v), g = n(5), m3 = r(g), _ = n(59), O2 = r(_), w2 = n(8), x2 = r(w2), k2 = n(60), E2 = r(k2), N = n(61), j = r(N), A = n(25), q2 = r(A);
    a3.default.register({ "blots/block": u2.default, "blots/block/embed": s3.BlockEmbed, "blots/break": f.default, "blots/container": p.default, "blots/cursor": y3.default, "blots/embed": b2.default, "blots/inline": m3.default, "blots/scroll": O2.default, "blots/text": x2.default, "modules/clipboard": E2.default, "modules/history": j.default, "modules/keyboard": q2.default }), i2.default.register(u2.default, f.default, y3.default, m3.default, O2.default, x2.default), e2.default = a3.default;
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true });
    var r = function() {
      function t3() {
        this.head = this.tail = null, this.length = 0;
      }
      return t3.prototype.append = function() {
        for (var t4 = [], e3 = 0; e3 < arguments.length; e3++) t4[e3] = arguments[e3];
        this.insertBefore(t4[0], null), t4.length > 1 && this.append.apply(this, t4.slice(1));
      }, t3.prototype.contains = function(t4) {
        for (var e3, n2 = this.iterator(); e3 = n2(); ) if (e3 === t4) return true;
        return false;
      }, t3.prototype.insertBefore = function(t4, e3) {
        t4 && (t4.next = e3, null != e3 ? (t4.prev = e3.prev, null != e3.prev && (e3.prev.next = t4), e3.prev = t4, e3 === this.head && (this.head = t4)) : null != this.tail ? (this.tail.next = t4, t4.prev = this.tail, this.tail = t4) : (t4.prev = null, this.head = this.tail = t4), this.length += 1);
      }, t3.prototype.offset = function(t4) {
        for (var e3 = 0, n2 = this.head; null != n2; ) {
          if (n2 === t4) return e3;
          e3 += n2.length(), n2 = n2.next;
        }
        return -1;
      }, t3.prototype.remove = function(t4) {
        this.contains(t4) && (null != t4.prev && (t4.prev.next = t4.next), null != t4.next && (t4.next.prev = t4.prev), t4 === this.head && (this.head = t4.next), t4 === this.tail && (this.tail = t4.prev), this.length -= 1);
      }, t3.prototype.iterator = function(t4) {
        return void 0 === t4 && (t4 = this.head), function() {
          var e3 = t4;
          return null != t4 && (t4 = t4.next), e3;
        };
      }, t3.prototype.find = function(t4, e3) {
        void 0 === e3 && (e3 = false);
        for (var n2, r2 = this.iterator(); n2 = r2(); ) {
          var o = n2.length();
          if (t4 < o || e3 && t4 === o && (null == n2.next || 0 !== n2.next.length())) return [n2, t4];
          t4 -= o;
        }
        return [null, 0];
      }, t3.prototype.forEach = function(t4) {
        for (var e3, n2 = this.iterator(); e3 = n2(); ) t4(e3);
      }, t3.prototype.forEachAt = function(t4, e3, n2) {
        if (!(e3 <= 0)) for (var r2, o = this.find(t4), i2 = o[0], l = o[1], a3 = t4 - l, s3 = this.iterator(i2); (r2 = s3()) && a3 < t4 + e3; ) {
          var u2 = r2.length();
          t4 > a3 ? n2(r2, t4 - a3, Math.min(e3, a3 + u2 - t4)) : n2(r2, 0, Math.min(u2, t4 + e3 - a3)), a3 += u2;
        }
      }, t3.prototype.map = function(t4) {
        return this.reduce(function(e3, n2) {
          return e3.push(t4(n2)), e3;
        }, []);
      }, t3.prototype.reduce = function(t4, e3) {
        for (var n2, r2 = this.iterator(); n2 = r2(); ) e3 = t4(e3, n2);
        return e3;
      }, t3;
    }();
    e2.default = r;
  }, function(t2, e2, n) {
    var r = this && this.__extends || function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    }();
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(17), i2 = n(1), l = { attributes: true, characterData: true, characterDataOldValue: true, childList: true, subtree: true }, a3 = function(t3) {
      function e3(e4) {
        var n2 = t3.call(this, e4) || this;
        return n2.scroll = n2, n2.observer = new MutationObserver(function(t4) {
          n2.update(t4);
        }), n2.observer.observe(n2.domNode, l), n2.attach(), n2;
      }
      return r(e3, t3), e3.prototype.detach = function() {
        t3.prototype.detach.call(this), this.observer.disconnect();
      }, e3.prototype.deleteAt = function(e4, n2) {
        this.update(), 0 === e4 && n2 === this.length() ? this.children.forEach(function(t4) {
          t4.remove();
        }) : t3.prototype.deleteAt.call(this, e4, n2);
      }, e3.prototype.formatAt = function(e4, n2, r2, o2) {
        this.update(), t3.prototype.formatAt.call(this, e4, n2, r2, o2);
      }, e3.prototype.insertAt = function(e4, n2, r2) {
        this.update(), t3.prototype.insertAt.call(this, e4, n2, r2);
      }, e3.prototype.optimize = function(e4, n2) {
        var r2 = this;
        void 0 === e4 && (e4 = []), void 0 === n2 && (n2 = {}), t3.prototype.optimize.call(this, n2);
        for (var l2 = [].slice.call(this.observer.takeRecords()); l2.length > 0; ) e4.push(l2.pop());
        for (var a4 = function(t4, e5) {
          void 0 === e5 && (e5 = true), null != t4 && t4 !== r2 && null != t4.domNode.parentNode && (null == t4.domNode[i2.DATA_KEY].mutations && (t4.domNode[i2.DATA_KEY].mutations = []), e5 && a4(t4.parent));
        }, s3 = function(t4) {
          null != t4.domNode[i2.DATA_KEY] && null != t4.domNode[i2.DATA_KEY].mutations && (t4 instanceof o.default && t4.children.forEach(s3), t4.optimize(n2));
        }, u2 = e4, c2 = 0; u2.length > 0; c2 += 1) {
          if (c2 >= 100) throw new Error("[Parchment] Maximum optimize iterations reached");
          for (u2.forEach(function(t4) {
            var e5 = i2.find(t4.target, true);
            null != e5 && (e5.domNode === t4.target && ("childList" === t4.type ? (a4(i2.find(t4.previousSibling, false)), [].forEach.call(t4.addedNodes, function(t5) {
              var e6 = i2.find(t5, false);
              a4(e6, false), e6 instanceof o.default && e6.children.forEach(function(t6) {
                a4(t6, false);
              });
            })) : "attributes" === t4.type && a4(e5.prev)), a4(e5));
          }), this.children.forEach(s3), u2 = [].slice.call(this.observer.takeRecords()), l2 = u2.slice(); l2.length > 0; ) e4.push(l2.pop());
        }
      }, e3.prototype.update = function(e4, n2) {
        var r2 = this;
        void 0 === n2 && (n2 = {}), e4 = e4 || this.observer.takeRecords(), e4.map(function(t4) {
          var e5 = i2.find(t4.target, true);
          return null == e5 ? null : null == e5.domNode[i2.DATA_KEY].mutations ? (e5.domNode[i2.DATA_KEY].mutations = [t4], e5) : (e5.domNode[i2.DATA_KEY].mutations.push(t4), null);
        }).forEach(function(t4) {
          null != t4 && t4 !== r2 && null != t4.domNode[i2.DATA_KEY] && t4.update(t4.domNode[i2.DATA_KEY].mutations || [], n2);
        }), null != this.domNode[i2.DATA_KEY].mutations && t3.prototype.update.call(this, this.domNode[i2.DATA_KEY].mutations, n2), this.optimize(e4, n2);
      }, e3.blotName = "scroll", e3.defaultChild = "block", e3.scope = i2.Scope.BLOCK_BLOT, e3.tagName = "DIV", e3;
    }(o.default);
    e2.default = a3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (Object.keys(t3).length !== Object.keys(e3).length) return false;
      for (var n2 in t3) if (t3[n2] !== e3[n2]) return false;
      return true;
    }
    var o = this && this.__extends || function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    }();
    Object.defineProperty(e2, "__esModule", { value: true });
    var i2 = n(18), l = n(1), a3 = function(t3) {
      function e3() {
        return null !== t3 && t3.apply(this, arguments) || this;
      }
      return o(e3, t3), e3.formats = function(n2) {
        if (n2.tagName !== e3.tagName) return t3.formats.call(this, n2);
      }, e3.prototype.format = function(n2, r2) {
        var o2 = this;
        n2 !== this.statics.blotName || r2 ? t3.prototype.format.call(this, n2, r2) : (this.children.forEach(function(t4) {
          t4 instanceof i2.default || (t4 = t4.wrap(e3.blotName, true)), o2.attributes.copy(t4);
        }), this.unwrap());
      }, e3.prototype.formatAt = function(e4, n2, r2, o2) {
        if (null != this.formats()[r2] || l.query(r2, l.Scope.ATTRIBUTE)) {
          this.isolate(e4, n2).format(r2, o2);
        } else t3.prototype.formatAt.call(this, e4, n2, r2, o2);
      }, e3.prototype.optimize = function(n2) {
        t3.prototype.optimize.call(this, n2);
        var o2 = this.formats();
        if (0 === Object.keys(o2).length) return this.unwrap();
        var i3 = this.next;
        i3 instanceof e3 && i3.prev === this && r(o2, i3.formats()) && (i3.moveChildren(this), i3.remove());
      }, e3.blotName = "inline", e3.scope = l.Scope.INLINE_BLOT, e3.tagName = "SPAN", e3;
    }(i2.default);
    e2.default = a3;
  }, function(t2, e2, n) {
    var r = this && this.__extends || function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    }();
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(18), i2 = n(1), l = function(t3) {
      function e3() {
        return null !== t3 && t3.apply(this, arguments) || this;
      }
      return r(e3, t3), e3.formats = function(n2) {
        var r2 = i2.query(e3.blotName).tagName;
        if (n2.tagName !== r2) return t3.formats.call(this, n2);
      }, e3.prototype.format = function(n2, r2) {
        null != i2.query(n2, i2.Scope.BLOCK) && (n2 !== this.statics.blotName || r2 ? t3.prototype.format.call(this, n2, r2) : this.replaceWith(e3.blotName));
      }, e3.prototype.formatAt = function(e4, n2, r2, o2) {
        null != i2.query(r2, i2.Scope.BLOCK) ? this.format(r2, o2) : t3.prototype.formatAt.call(this, e4, n2, r2, o2);
      }, e3.prototype.insertAt = function(e4, n2, r2) {
        if (null == r2 || null != i2.query(n2, i2.Scope.INLINE)) t3.prototype.insertAt.call(this, e4, n2, r2);
        else {
          var o2 = this.split(e4), l2 = i2.create(n2, r2);
          o2.parent.insertBefore(l2, o2);
        }
      }, e3.prototype.update = function(e4, n2) {
        navigator.userAgent.match(/Trident/) ? this.build() : t3.prototype.update.call(this, e4, n2);
      }, e3.blotName = "block", e3.scope = i2.Scope.BLOCK_BLOT, e3.tagName = "P", e3;
    }(o.default);
    e2.default = l;
  }, function(t2, e2, n) {
    var r = this && this.__extends || function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    }();
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(19), i2 = function(t3) {
      function e3() {
        return null !== t3 && t3.apply(this, arguments) || this;
      }
      return r(e3, t3), e3.formats = function(t4) {
      }, e3.prototype.format = function(e4, n2) {
        t3.prototype.formatAt.call(this, 0, this.length(), e4, n2);
      }, e3.prototype.formatAt = function(e4, n2, r2, o2) {
        0 === e4 && n2 === this.length() ? this.format(r2, o2) : t3.prototype.formatAt.call(this, e4, n2, r2, o2);
      }, e3.prototype.formats = function() {
        return this.statics.formats(this.domNode);
      }, e3;
    }(o.default);
    e2.default = i2;
  }, function(t2, e2, n) {
    var r = this && this.__extends || function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    }();
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(19), i2 = n(1), l = function(t3) {
      function e3(e4) {
        var n2 = t3.call(this, e4) || this;
        return n2.text = n2.statics.value(n2.domNode), n2;
      }
      return r(e3, t3), e3.create = function(t4) {
        return document.createTextNode(t4);
      }, e3.value = function(t4) {
        var e4 = t4.data;
        return e4.normalize && (e4 = e4.normalize()), e4;
      }, e3.prototype.deleteAt = function(t4, e4) {
        this.domNode.data = this.text = this.text.slice(0, t4) + this.text.slice(t4 + e4);
      }, e3.prototype.index = function(t4, e4) {
        return this.domNode === t4 ? e4 : -1;
      }, e3.prototype.insertAt = function(e4, n2, r2) {
        null == r2 ? (this.text = this.text.slice(0, e4) + n2 + this.text.slice(e4), this.domNode.data = this.text) : t3.prototype.insertAt.call(this, e4, n2, r2);
      }, e3.prototype.length = function() {
        return this.text.length;
      }, e3.prototype.optimize = function(n2) {
        t3.prototype.optimize.call(this, n2), this.text = this.statics.value(this.domNode), 0 === this.text.length ? this.remove() : this.next instanceof e3 && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());
      }, e3.prototype.position = function(t4, e4) {
        return [this.domNode, t4];
      }, e3.prototype.split = function(t4, e4) {
        if (void 0 === e4 && (e4 = false), !e4) {
          if (0 === t4) return this;
          if (t4 === this.length()) return this.next;
        }
        var n2 = i2.create(this.domNode.splitText(t4));
        return this.parent.insertBefore(n2, this.next), this.text = this.statics.value(this.domNode), n2;
      }, e3.prototype.update = function(t4, e4) {
        var n2 = this;
        t4.some(function(t5) {
          return "characterData" === t5.type && t5.target === n2.domNode;
        }) && (this.text = this.statics.value(this.domNode));
      }, e3.prototype.value = function() {
        return this.text;
      }, e3.blotName = "text", e3.scope = i2.Scope.INLINE_BLOT, e3;
    }(o.default);
    e2.default = l;
  }, function(t2, e2, n) {
    var r = document.createElement("div");
    if (r.classList.toggle("test-class", false), r.classList.contains("test-class")) {
      var o = DOMTokenList.prototype.toggle;
      DOMTokenList.prototype.toggle = function(t3, e3) {
        return arguments.length > 1 && !this.contains(t3) == !e3 ? e3 : o.call(this, t3);
      };
    }
    String.prototype.startsWith || (String.prototype.startsWith = function(t3, e3) {
      return e3 = e3 || 0, this.substr(e3, t3.length) === t3;
    }), String.prototype.endsWith || (String.prototype.endsWith = function(t3, e3) {
      var n2 = this.toString();
      ("number" != typeof e3 || !isFinite(e3) || Math.floor(e3) !== e3 || e3 > n2.length) && (e3 = n2.length), e3 -= t3.length;
      var r2 = n2.indexOf(t3, e3);
      return -1 !== r2 && r2 === e3;
    }), Array.prototype.find || Object.defineProperty(Array.prototype, "find", { value: function(t3) {
      if (null === this) throw new TypeError("Array.prototype.find called on null or undefined");
      if ("function" != typeof t3) throw new TypeError("predicate must be a function");
      for (var e3, n2 = Object(this), r2 = n2.length >>> 0, o2 = arguments[1], i2 = 0; i2 < r2; i2++) if (e3 = n2[i2], t3.call(o2, e3, i2, n2)) return e3;
    } }), document.addEventListener("DOMContentLoaded", function() {
      document.execCommand("enableObjectResizing", false, false), document.execCommand("autoUrlDetect", false, false);
    });
  }, function(t2, e2) {
    function n(t3, e3, n2) {
      if (t3 == e3) return t3 ? [[v, t3]] : [];
      (n2 < 0 || t3.length < n2) && (n2 = null);
      var o2 = l(t3, e3), i3 = t3.substring(0, o2);
      t3 = t3.substring(o2), e3 = e3.substring(o2), o2 = a3(t3, e3);
      var s4 = t3.substring(t3.length - o2);
      t3 = t3.substring(0, t3.length - o2), e3 = e3.substring(0, e3.length - o2);
      var c3 = r(t3, e3);
      return i3 && c3.unshift([v, i3]), s4 && c3.push([v, s4]), u2(c3), null != n2 && (c3 = f(c3, n2)), c3 = h3(c3);
    }
    function r(t3, e3) {
      var r2;
      if (!t3) return [[y3, e3]];
      if (!e3) return [[d3, t3]];
      var i3 = t3.length > e3.length ? t3 : e3, l2 = t3.length > e3.length ? e3 : t3, a4 = i3.indexOf(l2);
      if (-1 != a4) return r2 = [[y3, i3.substring(0, a4)], [v, l2], [y3, i3.substring(a4 + l2.length)]], t3.length > e3.length && (r2[0][0] = r2[2][0] = d3), r2;
      if (1 == l2.length) return [[d3, t3], [y3, e3]];
      var u3 = s3(t3, e3);
      if (u3) {
        var c3 = u3[0], f2 = u3[1], h4 = u3[2], p2 = u3[3], b3 = u3[4], g = n(c3, h4), m3 = n(f2, p2);
        return g.concat([[v, b3]], m3);
      }
      return o(t3, e3);
    }
    function o(t3, e3) {
      for (var n2 = t3.length, r2 = e3.length, o2 = Math.ceil((n2 + r2) / 2), l2 = o2, a4 = 2 * o2, s4 = new Array(a4), u3 = new Array(a4), c3 = 0; c3 < a4; c3++) s4[c3] = -1, u3[c3] = -1;
      s4[l2 + 1] = 0, u3[l2 + 1] = 0;
      for (var f2 = n2 - r2, h4 = f2 % 2 != 0, p2 = 0, v2 = 0, b3 = 0, g = 0, m3 = 0; m3 < o2; m3++) {
        for (var _ = -m3 + p2; _ <= m3 - v2; _ += 2) {
          var O2, w2 = l2 + _;
          O2 = _ == -m3 || _ != m3 && s4[w2 - 1] < s4[w2 + 1] ? s4[w2 + 1] : s4[w2 - 1] + 1;
          for (var x2 = O2 - _; O2 < n2 && x2 < r2 && t3.charAt(O2) == e3.charAt(x2); ) O2++, x2++;
          if (s4[w2] = O2, O2 > n2) v2 += 2;
          else if (x2 > r2) p2 += 2;
          else if (h4) {
            var k2 = l2 + f2 - _;
            if (k2 >= 0 && k2 < a4 && -1 != u3[k2]) {
              var E2 = n2 - u3[k2];
              if (O2 >= E2) return i2(t3, e3, O2, x2);
            }
          }
        }
        for (var N = -m3 + b3; N <= m3 - g; N += 2) {
          var E2, k2 = l2 + N;
          E2 = N == -m3 || N != m3 && u3[k2 - 1] < u3[k2 + 1] ? u3[k2 + 1] : u3[k2 - 1] + 1;
          for (var j = E2 - N; E2 < n2 && j < r2 && t3.charAt(n2 - E2 - 1) == e3.charAt(r2 - j - 1); ) E2++, j++;
          if (u3[k2] = E2, E2 > n2) g += 2;
          else if (j > r2) b3 += 2;
          else if (!h4) {
            var w2 = l2 + f2 - N;
            if (w2 >= 0 && w2 < a4 && -1 != s4[w2]) {
              var O2 = s4[w2], x2 = l2 + O2 - w2;
              if (E2 = n2 - E2, O2 >= E2) return i2(t3, e3, O2, x2);
            }
          }
        }
      }
      return [[d3, t3], [y3, e3]];
    }
    function i2(t3, e3, r2, o2) {
      var i3 = t3.substring(0, r2), l2 = e3.substring(0, o2), a4 = t3.substring(r2), s4 = e3.substring(o2), u3 = n(i3, l2), c3 = n(a4, s4);
      return u3.concat(c3);
    }
    function l(t3, e3) {
      if (!t3 || !e3 || t3.charAt(0) != e3.charAt(0)) return 0;
      for (var n2 = 0, r2 = Math.min(t3.length, e3.length), o2 = r2, i3 = 0; n2 < o2; ) t3.substring(i3, o2) == e3.substring(i3, o2) ? (n2 = o2, i3 = n2) : r2 = o2, o2 = Math.floor((r2 - n2) / 2 + n2);
      return o2;
    }
    function a3(t3, e3) {
      if (!t3 || !e3 || t3.charAt(t3.length - 1) != e3.charAt(e3.length - 1)) return 0;
      for (var n2 = 0, r2 = Math.min(t3.length, e3.length), o2 = r2, i3 = 0; n2 < o2; ) t3.substring(t3.length - o2, t3.length - i3) == e3.substring(e3.length - o2, e3.length - i3) ? (n2 = o2, i3 = n2) : r2 = o2, o2 = Math.floor((r2 - n2) / 2 + n2);
      return o2;
    }
    function s3(t3, e3) {
      function n2(t4, e4, n3) {
        for (var r3, o3, i4, s5, u4 = t4.substring(n3, n3 + Math.floor(t4.length / 4)), c4 = -1, f3 = ""; -1 != (c4 = e4.indexOf(u4, c4 + 1)); ) {
          var h5 = l(t4.substring(n3), e4.substring(c4)), p3 = a3(t4.substring(0, n3), e4.substring(0, c4));
          f3.length < p3 + h5 && (f3 = e4.substring(c4 - p3, c4) + e4.substring(c4, c4 + h5), r3 = t4.substring(0, n3 - p3), o3 = t4.substring(n3 + h5), i4 = e4.substring(0, c4 - p3), s5 = e4.substring(c4 + h5));
        }
        return 2 * f3.length >= t4.length ? [r3, o3, i4, s5, f3] : null;
      }
      var r2 = t3.length > e3.length ? t3 : e3, o2 = t3.length > e3.length ? e3 : t3;
      if (r2.length < 4 || 2 * o2.length < r2.length) return null;
      var i3, s4 = n2(r2, o2, Math.ceil(r2.length / 4)), u3 = n2(r2, o2, Math.ceil(r2.length / 2));
      if (!s4 && !u3) return null;
      i3 = u3 ? s4 && s4[4].length > u3[4].length ? s4 : u3 : s4;
      var c3, f2, h4, p2;
      return t3.length > e3.length ? (c3 = i3[0], f2 = i3[1], h4 = i3[2], p2 = i3[3]) : (h4 = i3[0], p2 = i3[1], c3 = i3[2], f2 = i3[3]), [c3, f2, h4, p2, i3[4]];
    }
    function u2(t3) {
      t3.push([v, ""]);
      for (var e3, n2 = 0, r2 = 0, o2 = 0, i3 = "", s4 = ""; n2 < t3.length; ) switch (t3[n2][0]) {
        case y3:
          o2++, s4 += t3[n2][1], n2++;
          break;
        case d3:
          r2++, i3 += t3[n2][1], n2++;
          break;
        case v:
          r2 + o2 > 1 ? (0 !== r2 && 0 !== o2 && (e3 = l(s4, i3), 0 !== e3 && (n2 - r2 - o2 > 0 && t3[n2 - r2 - o2 - 1][0] == v ? t3[n2 - r2 - o2 - 1][1] += s4.substring(0, e3) : (t3.splice(0, 0, [v, s4.substring(0, e3)]), n2++), s4 = s4.substring(e3), i3 = i3.substring(e3)), 0 !== (e3 = a3(s4, i3)) && (t3[n2][1] = s4.substring(s4.length - e3) + t3[n2][1], s4 = s4.substring(0, s4.length - e3), i3 = i3.substring(0, i3.length - e3))), 0 === r2 ? t3.splice(n2 - o2, r2 + o2, [y3, s4]) : 0 === o2 ? t3.splice(n2 - r2, r2 + o2, [d3, i3]) : t3.splice(n2 - r2 - o2, r2 + o2, [d3, i3], [y3, s4]), n2 = n2 - r2 - o2 + (r2 ? 1 : 0) + (o2 ? 1 : 0) + 1) : 0 !== n2 && t3[n2 - 1][0] == v ? (t3[n2 - 1][1] += t3[n2][1], t3.splice(n2, 1)) : n2++, o2 = 0, r2 = 0, i3 = "", s4 = "";
      }
      "" === t3[t3.length - 1][1] && t3.pop();
      var c3 = false;
      for (n2 = 1; n2 < t3.length - 1; ) t3[n2 - 1][0] == v && t3[n2 + 1][0] == v && (t3[n2][1].substring(t3[n2][1].length - t3[n2 - 1][1].length) == t3[n2 - 1][1] ? (t3[n2][1] = t3[n2 - 1][1] + t3[n2][1].substring(0, t3[n2][1].length - t3[n2 - 1][1].length), t3[n2 + 1][1] = t3[n2 - 1][1] + t3[n2 + 1][1], t3.splice(n2 - 1, 1), c3 = true) : t3[n2][1].substring(0, t3[n2 + 1][1].length) == t3[n2 + 1][1] && (t3[n2 - 1][1] += t3[n2 + 1][1], t3[n2][1] = t3[n2][1].substring(t3[n2 + 1][1].length) + t3[n2 + 1][1], t3.splice(n2 + 1, 1), c3 = true)), n2++;
      c3 && u2(t3);
    }
    function c2(t3, e3) {
      if (0 === e3) return [v, t3];
      for (var n2 = 0, r2 = 0; r2 < t3.length; r2++) {
        var o2 = t3[r2];
        if (o2[0] === d3 || o2[0] === v) {
          var i3 = n2 + o2[1].length;
          if (e3 === i3) return [r2 + 1, t3];
          if (e3 < i3) {
            t3 = t3.slice();
            var l2 = e3 - n2, a4 = [o2[0], o2[1].slice(0, l2)], s4 = [o2[0], o2[1].slice(l2)];
            return t3.splice(r2, 1, a4, s4), [r2 + 1, t3];
          }
          n2 = i3;
        }
      }
      throw new Error("cursor_pos is out of bounds!");
    }
    function f(t3, e3) {
      var n2 = c2(t3, e3), r2 = n2[1], o2 = n2[0], i3 = r2[o2], l2 = r2[o2 + 1];
      if (null == i3) return t3;
      if (i3[0] !== v) return t3;
      if (null != l2 && i3[1] + l2[1] === l2[1] + i3[1]) return r2.splice(o2, 2, l2, i3), p(r2, o2, 2);
      if (null != l2 && 0 === l2[1].indexOf(i3[1])) {
        r2.splice(o2, 2, [l2[0], i3[1]], [0, i3[1]]);
        var a4 = l2[1].slice(i3[1].length);
        return a4.length > 0 && r2.splice(o2 + 2, 0, [l2[0], a4]), p(r2, o2, 3);
      }
      return t3;
    }
    function h3(t3) {
      for (var e3 = false, n2 = function(t4) {
        return t4.charCodeAt(0) >= 56320 && t4.charCodeAt(0) <= 57343;
      }, r2 = 2; r2 < t3.length; r2 += 1) t3[r2 - 2][0] === v && function(t4) {
        return t4.charCodeAt(t4.length - 1) >= 55296 && t4.charCodeAt(t4.length - 1) <= 56319;
      }(t3[r2 - 2][1]) && t3[r2 - 1][0] === d3 && n2(t3[r2 - 1][1]) && t3[r2][0] === y3 && n2(t3[r2][1]) && (e3 = true, t3[r2 - 1][1] = t3[r2 - 2][1].slice(-1) + t3[r2 - 1][1], t3[r2][1] = t3[r2 - 2][1].slice(-1) + t3[r2][1], t3[r2 - 2][1] = t3[r2 - 2][1].slice(0, -1));
      if (!e3) return t3;
      for (var o2 = [], r2 = 0; r2 < t3.length; r2 += 1) t3[r2][1].length > 0 && o2.push(t3[r2]);
      return o2;
    }
    function p(t3, e3, n2) {
      for (var r2 = e3 + n2 - 1; r2 >= 0 && r2 >= e3 - 1; r2--) if (r2 + 1 < t3.length) {
        var o2 = t3[r2], i3 = t3[r2 + 1];
        o2[0] === i3[1] && t3.splice(r2, 2, [o2[0], o2[1] + i3[1]]);
      }
      return t3;
    }
    var d3 = -1, y3 = 1, v = 0, b2 = n;
    b2.INSERT = y3, b2.DELETE = d3, b2.EQUAL = v, t2.exports = b2;
  }, function(t2, e2) {
    function n(t3) {
      var e3 = [];
      for (var n2 in t3) e3.push(n2);
      return e3;
    }
    e2 = t2.exports = "function" == typeof Object.keys ? Object.keys : n, e2.shim = n;
  }, function(t2, e2) {
    function n(t3) {
      return "[object Arguments]" == Object.prototype.toString.call(t3);
    }
    function r(t3) {
      return t3 && "object" == typeof t3 && "number" == typeof t3.length && Object.prototype.hasOwnProperty.call(t3, "callee") && !Object.prototype.propertyIsEnumerable.call(t3, "callee") || false;
    }
    var o = "[object Arguments]" == function() {
      return Object.prototype.toString.call(arguments);
    }();
    e2 = t2.exports = o ? n : r, e2.supported = n, e2.unsupported = r;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3, n2) {
      return e3 in t3 ? Object.defineProperty(t3, e3, { value: n2, enumerable: true, configurable: true, writable: true }) : t3[e3] = n2, t3;
    }
    function i2(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function l(t3, e3) {
      return Object.keys(e3).reduce(function(n2, r2) {
        return null == t3[r2] ? n2 : (e3[r2] === t3[r2] ? n2[r2] = e3[r2] : Array.isArray(e3[r2]) ? e3[r2].indexOf(t3[r2]) < 0 && (n2[r2] = e3[r2].concat([t3[r2]])) : n2[r2] = [e3[r2], t3[r2]], n2);
      }, {});
    }
    function a3(t3) {
      return t3.reduce(function(t4, e3) {
        if (1 === e3.insert) {
          var n2 = (0, N.default)(e3.attributes);
          return delete n2.image, t4.insert({ image: e3.attributes.image }, n2);
        }
        if (null == e3.attributes || true !== e3.attributes.list && true !== e3.attributes.bullet || (e3 = (0, N.default)(e3), e3.attributes.list ? e3.attributes.list = "ordered" : (e3.attributes.list = "bullet", delete e3.attributes.bullet)), "string" == typeof e3.insert) {
          var r2 = e3.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
          return t4.insert(r2, e3.attributes);
        }
        return t4.push(e3);
      }, new h3.default());
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var s3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
      return typeof t3;
    } : function(t3) {
      return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
    }, u2 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), c2 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), f = n(4), h3 = r(f), p = n(20), d3 = r(p), y3 = n(0), v = r(y3), b2 = n(13), g = r(b2), m3 = n(31), _ = r(m3), O2 = n(3), w2 = r(O2), x2 = n(14), k2 = r(x2), E2 = n(21), N = r(E2), j = n(12), A = r(j), q2 = n(2), T2 = r(q2), P = /^[ -~]*$/, S3 = function() {
      function t3(e3) {
        i2(this, t3), this.scroll = e3, this.delta = this.getDelta();
      }
      return c2(t3, [{ key: "applyDelta", value: function(t4) {
        var e3 = this, n2 = false;
        this.scroll.update();
        var r2 = this.scroll.length();
        return this.scroll.batchStart(), t4 = a3(t4), t4.reduce(function(t5, o2) {
          var i3 = o2.retain || o2.delete || o2.insert.length || 1, l2 = o2.attributes || {};
          if (null != o2.insert) {
            if ("string" == typeof o2.insert) {
              var a4 = o2.insert;
              a4.endsWith("\n") && n2 && (n2 = false, a4 = a4.slice(0, -1)), t5 >= r2 && !a4.endsWith("\n") && (n2 = true), e3.scroll.insertAt(t5, a4);
              var c3 = e3.scroll.line(t5), f2 = u2(c3, 2), h4 = f2[0], p2 = f2[1], y4 = (0, T2.default)({}, (0, O2.bubbleFormats)(h4));
              if (h4 instanceof w2.default) {
                var b3 = h4.descendant(v.default.Leaf, p2), g2 = u2(b3, 1), m4 = g2[0];
                y4 = (0, T2.default)(y4, (0, O2.bubbleFormats)(m4));
              }
              l2 = d3.default.attributes.diff(y4, l2) || {};
            } else if ("object" === s3(o2.insert)) {
              var _2 = Object.keys(o2.insert)[0];
              if (null == _2) return t5;
              e3.scroll.insertAt(t5, _2, o2.insert[_2]);
            }
            r2 += i3;
          }
          return Object.keys(l2).forEach(function(n3) {
            e3.scroll.formatAt(t5, i3, n3, l2[n3]);
          }), t5 + i3;
        }, 0), t4.reduce(function(t5, n3) {
          return "number" == typeof n3.delete ? (e3.scroll.deleteAt(t5, n3.delete), t5) : t5 + (n3.retain || n3.insert.length || 1);
        }, 0), this.scroll.batchEnd(), this.update(t4);
      } }, { key: "deleteText", value: function(t4, e3) {
        return this.scroll.deleteAt(t4, e3), this.update(new h3.default().retain(t4).delete(e3));
      } }, { key: "formatLine", value: function(t4, e3) {
        var n2 = this, r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return this.scroll.update(), Object.keys(r2).forEach(function(o2) {
          if (null == n2.scroll.whitelist || n2.scroll.whitelist[o2]) {
            var i3 = n2.scroll.lines(t4, Math.max(e3, 1)), l2 = e3;
            i3.forEach(function(e4) {
              var i4 = e4.length();
              if (e4 instanceof g.default) {
                var a4 = t4 - e4.offset(n2.scroll), s4 = e4.newlineIndex(a4 + l2) - a4 + 1;
                e4.formatAt(a4, s4, o2, r2[o2]);
              } else e4.format(o2, r2[o2]);
              l2 -= i4;
            });
          }
        }), this.scroll.optimize(), this.update(new h3.default().retain(t4).retain(e3, (0, N.default)(r2)));
      } }, { key: "formatText", value: function(t4, e3) {
        var n2 = this, r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return Object.keys(r2).forEach(function(o2) {
          n2.scroll.formatAt(t4, e3, o2, r2[o2]);
        }), this.update(new h3.default().retain(t4).retain(e3, (0, N.default)(r2)));
      } }, { key: "getContents", value: function(t4, e3) {
        return this.delta.slice(t4, t4 + e3);
      } }, { key: "getDelta", value: function() {
        return this.scroll.lines().reduce(function(t4, e3) {
          return t4.concat(e3.delta());
        }, new h3.default());
      } }, { key: "getFormat", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n2 = [], r2 = [];
        0 === e3 ? this.scroll.path(t4).forEach(function(t5) {
          var e4 = u2(t5, 1), o3 = e4[0];
          o3 instanceof w2.default ? n2.push(o3) : o3 instanceof v.default.Leaf && r2.push(o3);
        }) : (n2 = this.scroll.lines(t4, e3), r2 = this.scroll.descendants(v.default.Leaf, t4, e3));
        var o2 = [n2, r2].map(function(t5) {
          if (0 === t5.length) return {};
          for (var e4 = (0, O2.bubbleFormats)(t5.shift()); Object.keys(e4).length > 0; ) {
            var n3 = t5.shift();
            if (null == n3) return e4;
            e4 = l((0, O2.bubbleFormats)(n3), e4);
          }
          return e4;
        });
        return T2.default.apply(T2.default, o2);
      } }, { key: "getText", value: function(t4, e3) {
        return this.getContents(t4, e3).filter(function(t5) {
          return "string" == typeof t5.insert;
        }).map(function(t5) {
          return t5.insert;
        }).join("");
      } }, { key: "insertEmbed", value: function(t4, e3, n2) {
        return this.scroll.insertAt(t4, e3, n2), this.update(new h3.default().retain(t4).insert(o({}, e3, n2)));
      } }, { key: "insertText", value: function(t4, e3) {
        var n2 = this, r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return e3 = e3.replace(/\r\n/g, "\n").replace(/\r/g, "\n"), this.scroll.insertAt(t4, e3), Object.keys(r2).forEach(function(o2) {
          n2.scroll.formatAt(t4, e3.length, o2, r2[o2]);
        }), this.update(new h3.default().retain(t4).insert(e3, (0, N.default)(r2)));
      } }, { key: "isBlank", value: function() {
        if (0 == this.scroll.children.length) return true;
        if (this.scroll.children.length > 1) return false;
        var t4 = this.scroll.children.head;
        return t4.statics.blotName === w2.default.blotName && (!(t4.children.length > 1) && t4.children.head instanceof k2.default);
      } }, { key: "removeFormat", value: function(t4, e3) {
        var n2 = this.getText(t4, e3), r2 = this.scroll.line(t4 + e3), o2 = u2(r2, 2), i3 = o2[0], l2 = o2[1], a4 = 0, s4 = new h3.default();
        null != i3 && (a4 = i3 instanceof g.default ? i3.newlineIndex(l2) - l2 + 1 : i3.length() - l2, s4 = i3.delta().slice(l2, l2 + a4 - 1).insert("\n"));
        var c3 = this.getContents(t4, e3 + a4), f2 = c3.diff(new h3.default().insert(n2).concat(s4)), p2 = new h3.default().retain(t4).concat(f2);
        return this.applyDelta(p2);
      } }, { key: "update", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, r2 = this.delta;
        if (1 === e3.length && "characterData" === e3[0].type && e3[0].target.data.match(P) && v.default.find(e3[0].target)) {
          var o2 = v.default.find(e3[0].target), i3 = (0, O2.bubbleFormats)(o2), l2 = o2.offset(this.scroll), a4 = e3[0].oldValue.replace(_.default.CONTENTS, ""), s4 = new h3.default().insert(a4), u3 = new h3.default().insert(o2.value());
          t4 = new h3.default().retain(l2).concat(s4.diff(u3, n2)).reduce(function(t5, e4) {
            return e4.insert ? t5.insert(e4.insert, i3) : t5.push(e4);
          }, new h3.default()), this.delta = r2.compose(t4);
        } else this.delta = this.getDelta(), t4 && (0, A.default)(r2.compose(t4), this.delta) || (t4 = r2.diff(this.delta, n2));
        return t4;
      } }]), t3;
    }();
    e2.default = S3;
  }, function(t2, e2) {
    function n() {
    }
    function r(t3, e3, n2) {
      this.fn = t3, this.context = e3, this.once = n2 || false;
    }
    function o() {
      this._events = new n(), this._eventsCount = 0;
    }
    var i2 = Object.prototype.hasOwnProperty, l = "~";
    Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (l = false)), o.prototype.eventNames = function() {
      var t3, e3, n2 = [];
      if (0 === this._eventsCount) return n2;
      for (e3 in t3 = this._events) i2.call(t3, e3) && n2.push(l ? e3.slice(1) : e3);
      return Object.getOwnPropertySymbols ? n2.concat(Object.getOwnPropertySymbols(t3)) : n2;
    }, o.prototype.listeners = function(t3, e3) {
      var n2 = l ? l + t3 : t3, r2 = this._events[n2];
      if (e3) return !!r2;
      if (!r2) return [];
      if (r2.fn) return [r2.fn];
      for (var o2 = 0, i3 = r2.length, a3 = new Array(i3); o2 < i3; o2++) a3[o2] = r2[o2].fn;
      return a3;
    }, o.prototype.emit = function(t3, e3, n2, r2, o2, i3) {
      var a3 = l ? l + t3 : t3;
      if (!this._events[a3]) return false;
      var s3, u2, c2 = this._events[a3], f = arguments.length;
      if (c2.fn) {
        switch (c2.once && this.removeListener(t3, c2.fn, void 0, true), f) {
          case 1:
            return c2.fn.call(c2.context), true;
          case 2:
            return c2.fn.call(c2.context, e3), true;
          case 3:
            return c2.fn.call(c2.context, e3, n2), true;
          case 4:
            return c2.fn.call(c2.context, e3, n2, r2), true;
          case 5:
            return c2.fn.call(c2.context, e3, n2, r2, o2), true;
          case 6:
            return c2.fn.call(c2.context, e3, n2, r2, o2, i3), true;
        }
        for (u2 = 1, s3 = new Array(f - 1); u2 < f; u2++) s3[u2 - 1] = arguments[u2];
        c2.fn.apply(c2.context, s3);
      } else {
        var h3, p = c2.length;
        for (u2 = 0; u2 < p; u2++) switch (c2[u2].once && this.removeListener(t3, c2[u2].fn, void 0, true), f) {
          case 1:
            c2[u2].fn.call(c2[u2].context);
            break;
          case 2:
            c2[u2].fn.call(c2[u2].context, e3);
            break;
          case 3:
            c2[u2].fn.call(c2[u2].context, e3, n2);
            break;
          case 4:
            c2[u2].fn.call(c2[u2].context, e3, n2, r2);
            break;
          default:
            if (!s3) for (h3 = 1, s3 = new Array(f - 1); h3 < f; h3++) s3[h3 - 1] = arguments[h3];
            c2[u2].fn.apply(c2[u2].context, s3);
        }
      }
      return true;
    }, o.prototype.on = function(t3, e3, n2) {
      var o2 = new r(e3, n2 || this), i3 = l ? l + t3 : t3;
      return this._events[i3] ? this._events[i3].fn ? this._events[i3] = [this._events[i3], o2] : this._events[i3].push(o2) : (this._events[i3] = o2, this._eventsCount++), this;
    }, o.prototype.once = function(t3, e3, n2) {
      var o2 = new r(e3, n2 || this, true), i3 = l ? l + t3 : t3;
      return this._events[i3] ? this._events[i3].fn ? this._events[i3] = [this._events[i3], o2] : this._events[i3].push(o2) : (this._events[i3] = o2, this._eventsCount++), this;
    }, o.prototype.removeListener = function(t3, e3, r2, o2) {
      var i3 = l ? l + t3 : t3;
      if (!this._events[i3]) return this;
      if (!e3) return 0 == --this._eventsCount ? this._events = new n() : delete this._events[i3], this;
      var a3 = this._events[i3];
      if (a3.fn) a3.fn !== e3 || o2 && !a3.once || r2 && a3.context !== r2 || (0 == --this._eventsCount ? this._events = new n() : delete this._events[i3]);
      else {
        for (var s3 = 0, u2 = [], c2 = a3.length; s3 < c2; s3++) (a3[s3].fn !== e3 || o2 && !a3[s3].once || r2 && a3[s3].context !== r2) && u2.push(a3[s3]);
        u2.length ? this._events[i3] = 1 === u2.length ? u2[0] : u2 : 0 == --this._eventsCount ? this._events = new n() : delete this._events[i3];
      }
      return this;
    }, o.prototype.removeAllListeners = function(t3) {
      var e3;
      return t3 ? (e3 = l ? l + t3 : t3, this._events[e3] && (0 == --this._eventsCount ? this._events = new n() : delete this._events[e3])) : (this._events = new n(), this._eventsCount = 0), this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prototype.setMaxListeners = function() {
      return this;
    }, o.prefixed = l, o.EventEmitter = o, void 0 !== t2 && (t2.exports = o);
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function a3(t3) {
      return t3 instanceof v.default || t3 instanceof y3.BlockEmbed;
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var s3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), u2 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), c2 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, f = n(0), h3 = r(f), p = n(9), d3 = r(p), y3 = n(3), v = r(y3), b2 = n(14), g = r(b2), m3 = n(13), _ = r(m3), O2 = n(23), w2 = r(O2), x2 = function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4));
        return r2.emitter = n2.emitter, Array.isArray(n2.whitelist) && (r2.whitelist = n2.whitelist.reduce(function(t5, e4) {
          return t5[e4] = true, t5;
        }, {})), r2.domNode.addEventListener("DOMNodeInserted", function() {
        }), r2.optimize(), r2.enable(), r2;
      }
      return l(e3, t3), u2(e3, [{ key: "batchStart", value: function() {
        this.batch = true;
      } }, { key: "batchEnd", value: function() {
        this.batch = false, this.optimize();
      } }, { key: "deleteAt", value: function(t4, n2) {
        var r2 = this.line(t4), o2 = s3(r2, 2), i3 = o2[0], l2 = o2[1], a4 = this.line(t4 + n2), u3 = s3(a4, 1), f2 = u3[0];
        if (c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "deleteAt", this).call(this, t4, n2), null != f2 && i3 !== f2 && l2 > 0) {
          if (i3 instanceof y3.BlockEmbed || f2 instanceof y3.BlockEmbed) return void this.optimize();
          if (i3 instanceof _.default) {
            var h4 = i3.newlineIndex(i3.length(), true);
            if (h4 > -1 && (i3 = i3.split(h4 + 1)) === f2) return void this.optimize();
          } else if (f2 instanceof _.default) {
            var p2 = f2.newlineIndex(0);
            p2 > -1 && f2.split(p2 + 1);
          }
          var d4 = f2.children.head instanceof g.default ? null : f2.children.head;
          i3.moveChildren(f2, d4), i3.remove();
        }
        this.optimize();
      } }, { key: "enable", value: function() {
        var t4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        this.domNode.setAttribute("contenteditable", t4);
      } }, { key: "formatAt", value: function(t4, n2, r2, o2) {
        (null == this.whitelist || this.whitelist[r2]) && (c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "formatAt", this).call(this, t4, n2, r2, o2), this.optimize());
      } }, { key: "insertAt", value: function(t4, n2, r2) {
        if (null == r2 || null == this.whitelist || this.whitelist[n2]) {
          if (t4 >= this.length()) if (null == r2 || null == h3.default.query(n2, h3.default.Scope.BLOCK)) {
            var o2 = h3.default.create(this.statics.defaultChild);
            this.appendChild(o2), null == r2 && n2.endsWith("\n") && (n2 = n2.slice(0, -1)), o2.insertAt(0, n2, r2);
          } else {
            var i3 = h3.default.create(n2, r2);
            this.appendChild(i3);
          }
          else c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertAt", this).call(this, t4, n2, r2);
          this.optimize();
        }
      } }, { key: "insertBefore", value: function(t4, n2) {
        if (t4.statics.scope === h3.default.Scope.INLINE_BLOT) {
          var r2 = h3.default.create(this.statics.defaultChild);
          r2.appendChild(t4), t4 = r2;
        }
        c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertBefore", this).call(this, t4, n2);
      } }, { key: "leaf", value: function(t4) {
        return this.path(t4).pop() || [null, -1];
      } }, { key: "line", value: function(t4) {
        return t4 === this.length() ? this.line(t4 - 1) : this.descendant(a3, t4);
      } }, { key: "lines", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;
        return function t5(e5, n2, r2) {
          var o2 = [], i3 = r2;
          return e5.children.forEachAt(n2, r2, function(e6, n3, r3) {
            a3(e6) ? o2.push(e6) : e6 instanceof h3.default.Container && (o2 = o2.concat(t5(e6, n3, i3))), i3 -= r3;
          }), o2;
        }(this, t4, e4);
      } }, { key: "optimize", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        true !== this.batch && (c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "optimize", this).call(this, t4, n2), t4.length > 0 && this.emitter.emit(d3.default.events.SCROLL_OPTIMIZE, t4, n2));
      } }, { key: "path", value: function(t4) {
        return c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "path", this).call(this, t4).slice(1);
      } }, { key: "update", value: function(t4) {
        if (true !== this.batch) {
          var n2 = d3.default.sources.USER;
          "string" == typeof t4 && (n2 = t4), Array.isArray(t4) || (t4 = this.observer.takeRecords()), t4.length > 0 && this.emitter.emit(d3.default.events.SCROLL_BEFORE_UPDATE, n2, t4), c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "update", this).call(this, t4.concat([])), t4.length > 0 && this.emitter.emit(d3.default.events.SCROLL_UPDATE, n2, t4);
        }
      } }]), e3;
    }(h3.default.Scroll);
    x2.blotName = "scroll", x2.className = "ql-editor", x2.tagName = "DIV", x2.defaultChild = "block", x2.allowedChildren = [v.default, y3.BlockEmbed, w2.default], e2.default = x2;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3, n2) {
      return e3 in t3 ? Object.defineProperty(t3, e3, { value: n2, enumerable: true, configurable: true, writable: true }) : t3[e3] = n2, t3;
    }
    function i2(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function l(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function a3(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function s3(t3, e3, n2) {
      return "object" === (void 0 === e3 ? "undefined" : x2(e3)) ? Object.keys(e3).reduce(function(t4, n3) {
        return s3(t4, n3, e3[n3]);
      }, t3) : t3.reduce(function(t4, r2) {
        return r2.attributes && r2.attributes[e3] ? t4.push(r2) : t4.insert(r2.insert, (0, j.default)({}, o({}, e3, n2), r2.attributes));
      }, new q2.default());
    }
    function u2(t3) {
      if (t3.nodeType !== Node.ELEMENT_NODE) return {};
      return t3["__ql-computed-style"] || (t3["__ql-computed-style"] = window.getComputedStyle(t3));
    }
    function c2(t3, e3) {
      for (var n2 = "", r2 = t3.ops.length - 1; r2 >= 0 && n2.length < e3.length; --r2) {
        var o2 = t3.ops[r2];
        if ("string" != typeof o2.insert) break;
        n2 = o2.insert + n2;
      }
      return n2.slice(-1 * e3.length) === e3;
    }
    function f(t3) {
      return 0 !== t3.childNodes.length && ["block", "list-item"].indexOf(u2(t3).display) > -1;
    }
    function h3(t3, e3, n2) {
      return t3.nodeType === t3.TEXT_NODE ? n2.reduce(function(e4, n3) {
        return n3(t3, e4);
      }, new q2.default()) : t3.nodeType === t3.ELEMENT_NODE ? [].reduce.call(t3.childNodes || [], function(r2, o2) {
        var i3 = h3(o2, e3, n2);
        return o2.nodeType === t3.ELEMENT_NODE && (i3 = e3.reduce(function(t4, e4) {
          return e4(o2, t4);
        }, i3), i3 = (o2[W] || []).reduce(function(t4, e4) {
          return e4(o2, t4);
        }, i3)), r2.concat(i3);
      }, new q2.default()) : new q2.default();
    }
    function p(t3, e3, n2) {
      return s3(n2, t3, true);
    }
    function d3(t3, e3) {
      var n2 = P.default.Attributor.Attribute.keys(t3), r2 = P.default.Attributor.Class.keys(t3), o2 = P.default.Attributor.Style.keys(t3), i3 = {};
      return n2.concat(r2).concat(o2).forEach(function(e4) {
        var n3 = P.default.query(e4, P.default.Scope.ATTRIBUTE);
        null != n3 && (i3[n3.attrName] = n3.value(t3), i3[n3.attrName]) || (n3 = Y2[e4], null == n3 || n3.attrName !== e4 && n3.keyName !== e4 || (i3[n3.attrName] = n3.value(t3) || void 0), null == (n3 = X2[e4]) || n3.attrName !== e4 && n3.keyName !== e4 || (n3 = X2[e4], i3[n3.attrName] = n3.value(t3) || void 0));
      }), Object.keys(i3).length > 0 && (e3 = s3(e3, i3)), e3;
    }
    function y3(t3, e3) {
      var n2 = P.default.query(t3);
      if (null == n2) return e3;
      if (n2.prototype instanceof P.default.Embed) {
        var r2 = {}, o2 = n2.value(t3);
        null != o2 && (r2[n2.blotName] = o2, e3 = new q2.default().insert(r2, n2.formats(t3)));
      } else "function" == typeof n2.formats && (e3 = s3(e3, n2.blotName, n2.formats(t3)));
      return e3;
    }
    function v(t3, e3) {
      return c2(e3, "\n") || e3.insert("\n"), e3;
    }
    function b2() {
      return new q2.default();
    }
    function g(t3, e3) {
      var n2 = P.default.query(t3);
      if (null == n2 || "list-item" !== n2.blotName || !c2(e3, "\n")) return e3;
      for (var r2 = -1, o2 = t3.parentNode; !o2.classList.contains("ql-clipboard"); ) "list" === (P.default.query(o2) || {}).blotName && (r2 += 1), o2 = o2.parentNode;
      return r2 <= 0 ? e3 : e3.compose(new q2.default().retain(e3.length() - 1).retain(1, { indent: r2 }));
    }
    function m3(t3, e3) {
      return c2(e3, "\n") || (f(t3) || e3.length() > 0 && t3.nextSibling && f(t3.nextSibling)) && e3.insert("\n"), e3;
    }
    function _(t3, e3) {
      if (f(t3) && null != t3.nextElementSibling && !c2(e3, "\n\n")) {
        var n2 = t3.offsetHeight + parseFloat(u2(t3).marginTop) + parseFloat(u2(t3).marginBottom);
        t3.nextElementSibling.offsetTop > t3.offsetTop + 1.5 * n2 && e3.insert("\n");
      }
      return e3;
    }
    function O2(t3, e3) {
      var n2 = {}, r2 = t3.style || {};
      return r2.fontStyle && "italic" === u2(t3).fontStyle && (n2.italic = true), r2.fontWeight && (u2(t3).fontWeight.startsWith("bold") || parseInt(u2(t3).fontWeight) >= 700) && (n2.bold = true), Object.keys(n2).length > 0 && (e3 = s3(e3, n2)), parseFloat(r2.textIndent || 0) > 0 && (e3 = new q2.default().insert("	").concat(e3)), e3;
    }
    function w2(t3, e3) {
      var n2 = t3.data;
      if ("O:P" === t3.parentNode.tagName) return e3.insert(n2.trim());
      if (0 === n2.trim().length && t3.parentNode.classList.contains("ql-clipboard")) return e3;
      if (!u2(t3.parentNode).whiteSpace.startsWith("pre")) {
        var r2 = function(t4, e4) {
          return e4 = e4.replace(/[^\u00a0]/g, ""), e4.length < 1 && t4 ? " " : e4;
        };
        n2 = n2.replace(/\r\n/g, " ").replace(/\n/g, " "), n2 = n2.replace(/\s\s+/g, r2.bind(r2, true)), (null == t3.previousSibling && f(t3.parentNode) || null != t3.previousSibling && f(t3.previousSibling)) && (n2 = n2.replace(/^\s+/, r2.bind(r2, false))), (null == t3.nextSibling && f(t3.parentNode) || null != t3.nextSibling && f(t3.nextSibling)) && (n2 = n2.replace(/\s+$/, r2.bind(r2, false)));
      }
      return e3.insert(n2);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.matchText = e2.matchSpacing = e2.matchNewline = e2.matchBlot = e2.matchAttributor = e2.default = void 0;
    var x2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
      return typeof t3;
    } : function(t3) {
      return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
    }, k2 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), E2 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), N = n(2), j = r(N), A = n(4), q2 = r(A), T2 = n(0), P = r(T2), S3 = n(6), C = r(S3), L2 = n(10), M3 = r(L2), R2 = n(7), I2 = r(R2), B2 = n(34), D2 = n(35), U = n(13), F = r(U), H3 = n(24), K2 = n(36), z2 = n(37), V = n(38), Z = (0, M3.default)("quill:clipboard"), W = "__ql-matcher", G2 = [[Node.TEXT_NODE, w2], [Node.TEXT_NODE, m3], ["br", v], [Node.ELEMENT_NODE, m3], [Node.ELEMENT_NODE, y3], [Node.ELEMENT_NODE, _], [Node.ELEMENT_NODE, d3], [Node.ELEMENT_NODE, O2], ["li", g], ["b", p.bind(p, "bold")], ["i", p.bind(p, "italic")], ["style", b2]], Y2 = [B2.AlignAttribute, K2.DirectionAttribute].reduce(function(t3, e3) {
      return t3[e3.keyName] = e3, t3;
    }, {}), X2 = [B2.AlignStyle, D2.BackgroundStyle, H3.ColorStyle, K2.DirectionStyle, z2.FontStyle, V.SizeStyle].reduce(function(t3, e3) {
      return t3[e3.keyName] = e3, t3;
    }, {}), $ = function(t3) {
      function e3(t4, n2) {
        i2(this, e3);
        var r2 = l(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.quill.root.addEventListener("paste", r2.onPaste.bind(r2)), r2.container = r2.quill.addContainer("ql-clipboard"), r2.container.setAttribute("contenteditable", true), r2.container.setAttribute("tabindex", -1), r2.matchers = [], G2.concat(r2.options.matchers).forEach(function(t5) {
          var e4 = k2(t5, 2), o2 = e4[0], i3 = e4[1];
          (n2.matchVisual || i3 !== _) && r2.addMatcher(o2, i3);
        }), r2;
      }
      return a3(e3, t3), E2(e3, [{ key: "addMatcher", value: function(t4, e4) {
        this.matchers.push([t4, e4]);
      } }, { key: "convert", value: function(t4) {
        if ("string" == typeof t4) return this.container.innerHTML = t4.replace(/\>\r?\n +\</g, "><"), this.convert();
        var e4 = this.quill.getFormat(this.quill.selection.savedRange.index);
        if (e4[F.default.blotName]) {
          var n2 = this.container.innerText;
          return this.container.innerHTML = "", new q2.default().insert(n2, o({}, F.default.blotName, e4[F.default.blotName]));
        }
        var r2 = this.prepareMatching(), i3 = k2(r2, 2), l2 = i3[0], a4 = i3[1], s4 = h3(this.container, l2, a4);
        return c2(s4, "\n") && null == s4.ops[s4.ops.length - 1].attributes && (s4 = s4.compose(new q2.default().retain(s4.length() - 1).delete(1))), Z.log("convert", this.container.innerHTML, s4), this.container.innerHTML = "", s4;
      } }, { key: "dangerouslyPasteHTML", value: function(t4, e4) {
        var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : C.default.sources.API;
        if ("string" == typeof t4) this.quill.setContents(this.convert(t4), e4), this.quill.setSelection(0, C.default.sources.SILENT);
        else {
          var r2 = this.convert(e4);
          this.quill.updateContents(new q2.default().retain(t4).concat(r2), n2), this.quill.setSelection(t4 + r2.length(), C.default.sources.SILENT);
        }
      } }, { key: "onPaste", value: function(t4) {
        var e4 = this;
        if (!t4.defaultPrevented && this.quill.isEnabled()) {
          var n2 = this.quill.getSelection(), r2 = new q2.default().retain(n2.index), o2 = this.quill.scrollingContainer.scrollTop;
          this.container.focus(), this.quill.selection.update(C.default.sources.SILENT), setTimeout(function() {
            r2 = r2.concat(e4.convert()).delete(n2.length), e4.quill.updateContents(r2, C.default.sources.USER), e4.quill.setSelection(r2.length() - n2.length, C.default.sources.SILENT), e4.quill.scrollingContainer.scrollTop = o2, e4.quill.focus();
          }, 1);
        }
      } }, { key: "prepareMatching", value: function() {
        var t4 = this, e4 = [], n2 = [];
        return this.matchers.forEach(function(r2) {
          var o2 = k2(r2, 2), i3 = o2[0], l2 = o2[1];
          switch (i3) {
            case Node.TEXT_NODE:
              n2.push(l2);
              break;
            case Node.ELEMENT_NODE:
              e4.push(l2);
              break;
            default:
              [].forEach.call(t4.container.querySelectorAll(i3), function(t5) {
                t5[W] = t5[W] || [], t5[W].push(l2);
              });
          }
        }), [e4, n2];
      } }]), e3;
    }(I2.default);
    $.DEFAULTS = { matchers: [], matchVisual: true }, e2.default = $, e2.matchAttributor = d3, e2.matchBlot = y3, e2.matchNewline = m3, e2.matchSpacing = _, e2.matchText = w2;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function a3(t3) {
      var e3 = t3.ops[t3.ops.length - 1];
      return null != e3 && (null != e3.insert ? "string" == typeof e3.insert && e3.insert.endsWith("\n") : null != e3.attributes && Object.keys(e3.attributes).some(function(t4) {
        return null != f.default.query(t4, f.default.Scope.BLOCK);
      }));
    }
    function s3(t3) {
      var e3 = t3.reduce(function(t4, e4) {
        return t4 += e4.delete || 0;
      }, 0), n2 = t3.length() - e3;
      return a3(t3) && (n2 -= 1), n2;
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.getLastChangeIndex = e2.default = void 0;
    var u2 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), c2 = n(0), f = r(c2), h3 = n(6), p = r(h3), d3 = n(7), y3 = r(d3), v = function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.lastRecorded = 0, r2.ignoreChange = false, r2.clear(), r2.quill.on(p.default.events.EDITOR_CHANGE, function(t5, e4, n3, o2) {
          t5 !== p.default.events.TEXT_CHANGE || r2.ignoreChange || (r2.options.userOnly && o2 !== p.default.sources.USER ? r2.transform(e4) : r2.record(e4, n3));
        }), r2.quill.keyboard.addBinding({ key: "Z", shortKey: true }, r2.undo.bind(r2)), r2.quill.keyboard.addBinding({ key: "Z", shortKey: true, shiftKey: true }, r2.redo.bind(r2)), /Win/i.test(navigator.platform) && r2.quill.keyboard.addBinding({ key: "Y", shortKey: true }, r2.redo.bind(r2)), r2;
      }
      return l(e3, t3), u2(e3, [{ key: "change", value: function(t4, e4) {
        if (0 !== this.stack[t4].length) {
          var n2 = this.stack[t4].pop();
          this.stack[e4].push(n2), this.lastRecorded = 0, this.ignoreChange = true, this.quill.updateContents(n2[t4], p.default.sources.USER), this.ignoreChange = false;
          var r2 = s3(n2[t4]);
          this.quill.setSelection(r2);
        }
      } }, { key: "clear", value: function() {
        this.stack = { undo: [], redo: [] };
      } }, { key: "cutoff", value: function() {
        this.lastRecorded = 0;
      } }, { key: "record", value: function(t4, e4) {
        if (0 !== t4.ops.length) {
          this.stack.redo = [];
          var n2 = this.quill.getContents().diff(e4), r2 = Date.now();
          if (this.lastRecorded + this.options.delay > r2 && this.stack.undo.length > 0) {
            var o2 = this.stack.undo.pop();
            n2 = n2.compose(o2.undo), t4 = o2.redo.compose(t4);
          } else this.lastRecorded = r2;
          this.stack.undo.push({ redo: t4, undo: n2 }), this.stack.undo.length > this.options.maxStack && this.stack.undo.shift();
        }
      } }, { key: "redo", value: function() {
        this.change("redo", "undo");
      } }, { key: "transform", value: function(t4) {
        this.stack.undo.forEach(function(e4) {
          e4.undo = t4.transform(e4.undo, true), e4.redo = t4.transform(e4.redo, true);
        }), this.stack.redo.forEach(function(e4) {
          e4.undo = t4.transform(e4.undo, true), e4.redo = t4.transform(e4.redo, true);
        });
      } }, { key: "undo", value: function() {
        this.change("undo", "redo");
      } }]), e3;
    }(y3.default);
    v.DEFAULTS = { delay: 1e3, maxStack: 100, userOnly: false }, e2.default = v, e2.getLastChangeIndex = s3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.IndentClass = void 0;
    var l = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(0), u2 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(s3), c2 = function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, [{ key: "add", value: function(t4, n2) {
        if ("+1" === n2 || "-1" === n2) {
          var r2 = this.value(t4) || 0;
          n2 = "+1" === n2 ? r2 + 1 : r2 - 1;
        }
        return 0 === n2 ? (this.remove(t4), true) : a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "add", this).call(this, t4, n2);
      } }, { key: "canAdd", value: function(t4, n2) {
        return a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "canAdd", this).call(this, t4, n2) || a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "canAdd", this).call(this, t4, parseInt(n2));
      } }, { key: "value", value: function(t4) {
        return parseInt(a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "value", this).call(this, t4)) || void 0;
      } }]), e3;
    }(u2.default.Attributor.Class), f = new c2("indent", "ql-indent", { scope: u2.default.Scope.BLOCK, whitelist: [1, 2, 3, 4, 5, 6, 7, 8] });
    e2.IndentClass = f;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = n(3), a3 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(l), s3 = function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), e3;
    }(a3.default);
    s3.blotName = "blockquote", s3.tagName = "blockquote", e2.default = s3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), a3 = n(3), s3 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(a3), u2 = function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, null, [{ key: "formats", value: function(t4) {
        return this.tagName.indexOf(t4.tagName) + 1;
      } }]), e3;
    }(s3.default);
    u2.blotName = "header", u2.tagName = ["H1", "H2", "H3", "H4", "H5", "H6"], e2.default = u2;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3, n2) {
      return e3 in t3 ? Object.defineProperty(t3, e3, { value: n2, enumerable: true, configurable: true, writable: true }) : t3[e3] = n2, t3;
    }
    function i2(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function l(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function a3(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.ListItem = void 0;
    var s3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), u2 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, c2 = n(0), f = r(c2), h3 = n(3), p = r(h3), d3 = n(23), y3 = r(d3), v = function(t3) {
      function e3() {
        return i2(this, e3), l(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return a3(e3, t3), s3(e3, [{ key: "format", value: function(t4, n2) {
        t4 !== b2.blotName || n2 ? u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "format", this).call(this, t4, n2) : this.replaceWith(f.default.create(this.statics.scope));
      } }, { key: "remove", value: function() {
        null == this.prev && null == this.next ? this.parent.remove() : u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "remove", this).call(this);
      } }, { key: "replaceWith", value: function(t4, n2) {
        return this.parent.isolate(this.offset(this.parent), this.length()), t4 === this.parent.statics.blotName ? (this.parent.replaceWith(t4, n2), this) : (this.parent.unwrap(), u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "replaceWith", this).call(this, t4, n2));
      } }], [{ key: "formats", value: function(t4) {
        return t4.tagName === this.tagName ? void 0 : u2(e3.__proto__ || Object.getPrototypeOf(e3), "formats", this).call(this, t4);
      } }]), e3;
    }(p.default);
    v.blotName = "list-item", v.tagName = "LI";
    var b2 = function(t3) {
      function e3(t4) {
        i2(this, e3);
        var n2 = l(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4)), r2 = function(e4) {
          if (e4.target.parentNode === t4) {
            var r3 = n2.statics.formats(t4), o2 = f.default.find(e4.target);
            "checked" === r3 ? o2.format("list", "unchecked") : "unchecked" === r3 && o2.format("list", "checked");
          }
        };
        return t4.addEventListener("touchstart", r2), t4.addEventListener("mousedown", r2), n2;
      }
      return a3(e3, t3), s3(e3, null, [{ key: "create", value: function(t4) {
        var n2 = "ordered" === t4 ? "OL" : "UL", r2 = u2(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this, n2);
        return "checked" !== t4 && "unchecked" !== t4 || r2.setAttribute("data-checked", "checked" === t4), r2;
      } }, { key: "formats", value: function(t4) {
        return "OL" === t4.tagName ? "ordered" : "UL" === t4.tagName ? t4.hasAttribute("data-checked") ? "true" === t4.getAttribute("data-checked") ? "checked" : "unchecked" : "bullet" : void 0;
      } }]), s3(e3, [{ key: "format", value: function(t4, e4) {
        this.children.length > 0 && this.children.tail.format(t4, e4);
      } }, { key: "formats", value: function() {
        return o({}, this.statics.blotName, this.statics.formats(this.domNode));
      } }, { key: "insertBefore", value: function(t4, n2) {
        if (t4 instanceof v) u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertBefore", this).call(this, t4, n2);
        else {
          var r2 = null == n2 ? this.length() : n2.offset(this), o2 = this.split(r2);
          o2.parent.insertBefore(t4, o2);
        }
      } }, { key: "optimize", value: function(t4) {
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "optimize", this).call(this, t4);
        var n2 = this.next;
        null != n2 && n2.prev === this && n2.statics.blotName === this.statics.blotName && n2.domNode.tagName === this.domNode.tagName && n2.domNode.getAttribute("data-checked") === this.domNode.getAttribute("data-checked") && (n2.moveChildren(this), n2.remove());
      } }, { key: "replace", value: function(t4) {
        if (t4.statics.blotName !== this.statics.blotName) {
          var n2 = f.default.create(this.statics.defaultChild);
          t4.moveChildren(n2), this.appendChild(n2);
        }
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "replace", this).call(this, t4);
      } }]), e3;
    }(y3.default);
    b2.blotName = "list", b2.scope = f.default.Scope.BLOCK_BLOT, b2.tagName = ["OL", "UL"], b2.defaultChild = "list-item", b2.allowedChildren = [v], e2.ListItem = v, e2.default = b2;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = n(39), a3 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(l), s3 = function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), e3;
    }(a3.default);
    s3.blotName = "italic", s3.tagName = ["EM", "I"], e2.default = s3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(5), u2 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(s3), c2 = function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, null, [{ key: "create", value: function(t4) {
        return "super" === t4 ? document.createElement("sup") : "sub" === t4 ? document.createElement("sub") : a3(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this, t4);
      } }, { key: "formats", value: function(t4) {
        return "SUB" === t4.tagName ? "sub" : "SUP" === t4.tagName ? "super" : void 0;
      } }]), e3;
    }(u2.default);
    c2.blotName = "script", c2.tagName = ["SUB", "SUP"], e2.default = c2;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = n(5), a3 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(l), s3 = function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), e3;
    }(a3.default);
    s3.blotName = "strike", s3.tagName = "S", e2.default = s3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = n(5), a3 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(l), s3 = function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), e3;
    }(a3.default);
    s3.blotName = "underline", s3.tagName = "U", e2.default = s3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(0), u2 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(s3), c2 = n(15), f = ["alt", "height", "width"], h3 = function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, [{ key: "format", value: function(t4, n2) {
        f.indexOf(t4) > -1 ? n2 ? this.domNode.setAttribute(t4, n2) : this.domNode.removeAttribute(t4) : a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "format", this).call(this, t4, n2);
      } }], [{ key: "create", value: function(t4) {
        var n2 = a3(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this, t4);
        return "string" == typeof t4 && n2.setAttribute("src", this.sanitize(t4)), n2;
      } }, { key: "formats", value: function(t4) {
        return f.reduce(function(e4, n2) {
          return t4.hasAttribute(n2) && (e4[n2] = t4.getAttribute(n2)), e4;
        }, {});
      } }, { key: "match", value: function(t4) {
        return /\.(jpe?g|gif|png)$/.test(t4) || /^data:image\/.+;base64/.test(t4);
      } }, { key: "sanitize", value: function(t4) {
        return (0, c2.sanitize)(t4, ["http", "https", "data"]) ? t4 : "//:0";
      } }, { key: "value", value: function(t4) {
        return t4.getAttribute("src");
      } }]), e3;
    }(u2.default.Embed);
    h3.blotName = "image", h3.tagName = "IMG", e2.default = h3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(3), u2 = n(15), c2 = function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }(u2), f = ["height", "width"], h3 = function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, [{ key: "format", value: function(t4, n2) {
        f.indexOf(t4) > -1 ? n2 ? this.domNode.setAttribute(t4, n2) : this.domNode.removeAttribute(t4) : a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "format", this).call(this, t4, n2);
      } }], [{ key: "create", value: function(t4) {
        var n2 = a3(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this, t4);
        return n2.setAttribute("frameborder", "0"), n2.setAttribute("allowfullscreen", true), n2.setAttribute("src", this.sanitize(t4)), n2;
      } }, { key: "formats", value: function(t4) {
        return f.reduce(function(e4, n2) {
          return t4.hasAttribute(n2) && (e4[n2] = t4.getAttribute(n2)), e4;
        }, {});
      } }, { key: "sanitize", value: function(t4) {
        return c2.default.sanitize(t4);
      } }, { key: "value", value: function(t4) {
        return t4.getAttribute("src");
      } }]), e3;
    }(s3.BlockEmbed);
    h3.blotName = "video", h3.className = "ql-video", h3.tagName = "IFRAME", e2.default = h3;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.FormulaBlot = void 0;
    var a3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = n(33), c2 = r(u2), f = n(6), h3 = r(f), p = n(7), d3 = r(p), y3 = function(t3) {
      function e3() {
        return o(this, e3), i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return l(e3, t3), a3(e3, null, [{ key: "create", value: function(t4) {
        var n2 = s3(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this, t4);
        return "string" == typeof t4 && (window.katex.render(t4, n2, { throwOnError: false, errorColor: "#f00" }), n2.setAttribute("data-value", t4)), n2;
      } }, { key: "value", value: function(t4) {
        return t4.getAttribute("data-value");
      } }]), e3;
    }(c2.default);
    y3.blotName = "formula", y3.className = "ql-formula", y3.tagName = "SPAN";
    var v = function(t3) {
      function e3() {
        o(this, e3);
        var t4 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this));
        if (null == window.katex) throw new Error("Formula module requires KaTeX.");
        return t4;
      }
      return l(e3, t3), a3(e3, null, [{ key: "register", value: function() {
        h3.default.register(y3, true);
      } }]), e3;
    }(d3.default);
    e2.FormulaBlot = y3, e2.default = v;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.CodeToken = e2.CodeBlock = void 0;
    var a3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = n(0), c2 = r(u2), f = n(6), h3 = r(f), p = n(7), d3 = r(p), y3 = n(13), v = r(y3), b2 = function(t3) {
      function e3() {
        return o(this, e3), i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return l(e3, t3), a3(e3, [{ key: "replaceWith", value: function(t4) {
        this.domNode.textContent = this.domNode.textContent, this.attach(), s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "replaceWith", this).call(this, t4);
      } }, { key: "highlight", value: function(t4) {
        var e4 = this.domNode.textContent;
        this.cachedText !== e4 && ((e4.trim().length > 0 || null == this.cachedText) && (this.domNode.innerHTML = t4(e4), this.domNode.normalize(), this.attach()), this.cachedText = e4);
      } }]), e3;
    }(v.default);
    b2.className = "ql-syntax";
    var g = new c2.default.Attributor.Class("token", "hljs", { scope: c2.default.Scope.INLINE }), m3 = function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        if ("function" != typeof r2.options.highlight) throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
        var l2 = null;
        return r2.quill.on(h3.default.events.SCROLL_OPTIMIZE, function() {
          clearTimeout(l2), l2 = setTimeout(function() {
            r2.highlight(), l2 = null;
          }, r2.options.interval);
        }), r2.highlight(), r2;
      }
      return l(e3, t3), a3(e3, null, [{ key: "register", value: function() {
        h3.default.register(g, true), h3.default.register(b2, true);
      } }]), a3(e3, [{ key: "highlight", value: function() {
        var t4 = this;
        if (!this.quill.selection.composing) {
          this.quill.update(h3.default.sources.USER);
          var e4 = this.quill.getSelection();
          this.quill.scroll.descendants(b2).forEach(function(e5) {
            e5.highlight(t4.options.highlight);
          }), this.quill.update(h3.default.sources.SILENT), null != e4 && this.quill.setSelection(e4, h3.default.sources.SILENT);
        }
      } }]), e3;
    }(d3.default);
    m3.DEFAULTS = { highlight: function() {
      return null == window.hljs ? null : function(t3) {
        return window.hljs.highlightAuto(t3).value;
      };
    }(), interval: 1e3 }, e2.CodeBlock = b2, e2.CodeToken = g, e2.default = m3;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3, n2) {
      return e3 in t3 ? Object.defineProperty(t3, e3, { value: n2, enumerable: true, configurable: true, writable: true }) : t3[e3] = n2, t3;
    }
    function i2(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function l(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function a3(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function s3(t3, e3, n2) {
      var r2 = document.createElement("button");
      r2.setAttribute("type", "button"), r2.classList.add("ql-" + e3), null != n2 && (r2.value = n2), t3.appendChild(r2);
    }
    function u2(t3, e3) {
      Array.isArray(e3[0]) || (e3 = [e3]), e3.forEach(function(e4) {
        var n2 = document.createElement("span");
        n2.classList.add("ql-formats"), e4.forEach(function(t4) {
          if ("string" == typeof t4) s3(n2, t4);
          else {
            var e5 = Object.keys(t4)[0], r2 = t4[e5];
            Array.isArray(r2) ? c2(n2, e5, r2) : s3(n2, e5, r2);
          }
        }), t3.appendChild(n2);
      });
    }
    function c2(t3, e3, n2) {
      var r2 = document.createElement("select");
      r2.classList.add("ql-" + e3), n2.forEach(function(t4) {
        var e4 = document.createElement("option");
        false !== t4 ? e4.setAttribute("value", t4) : e4.setAttribute("selected", "selected"), r2.appendChild(e4);
      }), t3.appendChild(r2);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.addControls = e2.default = void 0;
    var f = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), h3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), p = n(4), d3 = r(p), y3 = n(0), v = r(y3), b2 = n(6), g = r(b2), m3 = n(10), _ = r(m3), O2 = n(7), w2 = r(O2), x2 = (0, _.default)("quill:toolbar"), k2 = function(t3) {
      function e3(t4, n2) {
        i2(this, e3);
        var r2 = l(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        if (Array.isArray(r2.options.container)) {
          var o2 = document.createElement("div");
          u2(o2, r2.options.container), t4.container.parentNode.insertBefore(o2, t4.container), r2.container = o2;
        } else "string" == typeof r2.options.container ? r2.container = document.querySelector(r2.options.container) : r2.container = r2.options.container;
        if (!(r2.container instanceof HTMLElement)) {
          var a4;
          return a4 = x2.error("Container required for toolbar", r2.options), l(r2, a4);
        }
        return r2.container.classList.add("ql-toolbar"), r2.controls = [], r2.handlers = {}, Object.keys(r2.options.handlers).forEach(function(t5) {
          r2.addHandler(t5, r2.options.handlers[t5]);
        }), [].forEach.call(r2.container.querySelectorAll("button, select"), function(t5) {
          r2.attach(t5);
        }), r2.quill.on(g.default.events.EDITOR_CHANGE, function(t5, e4) {
          t5 === g.default.events.SELECTION_CHANGE && r2.update(e4);
        }), r2.quill.on(g.default.events.SCROLL_OPTIMIZE, function() {
          var t5 = r2.quill.selection.getRange(), e4 = f(t5, 1), n3 = e4[0];
          r2.update(n3);
        }), r2;
      }
      return a3(e3, t3), h3(e3, [{ key: "addHandler", value: function(t4, e4) {
        this.handlers[t4] = e4;
      } }, { key: "attach", value: function(t4) {
        var e4 = this, n2 = [].find.call(t4.classList, function(t5) {
          return 0 === t5.indexOf("ql-");
        });
        if (n2) {
          if (n2 = n2.slice("ql-".length), "BUTTON" === t4.tagName && t4.setAttribute("type", "button"), null == this.handlers[n2]) {
            if (null != this.quill.scroll.whitelist && null == this.quill.scroll.whitelist[n2]) return void x2.warn("ignoring attaching to disabled format", n2, t4);
            if (null == v.default.query(n2)) return void x2.warn("ignoring attaching to nonexistent format", n2, t4);
          }
          var r2 = "SELECT" === t4.tagName ? "change" : "click";
          t4.addEventListener(r2, function(r3) {
            var i3 = void 0;
            if ("SELECT" === t4.tagName) {
              if (t4.selectedIndex < 0) return;
              var l2 = t4.options[t4.selectedIndex];
              i3 = !l2.hasAttribute("selected") && (l2.value || false);
            } else i3 = !t4.classList.contains("ql-active") && (t4.value || !t4.hasAttribute("value")), r3.preventDefault();
            e4.quill.focus();
            var a4 = e4.quill.selection.getRange(), s4 = f(a4, 1), u3 = s4[0];
            if (null != e4.handlers[n2]) e4.handlers[n2].call(e4, i3);
            else if (v.default.query(n2).prototype instanceof v.default.Embed) {
              if (!(i3 = prompt("Enter " + n2))) return;
              e4.quill.updateContents(new d3.default().retain(u3.index).delete(u3.length).insert(o({}, n2, i3)), g.default.sources.USER);
            } else e4.quill.format(n2, i3, g.default.sources.USER);
            e4.update(u3);
          }), this.controls.push([n2, t4]);
        }
      } }, { key: "update", value: function(t4) {
        var e4 = null == t4 ? {} : this.quill.getFormat(t4);
        this.controls.forEach(function(n2) {
          var r2 = f(n2, 2), o2 = r2[0], i3 = r2[1];
          if ("SELECT" === i3.tagName) {
            var l2 = void 0;
            if (null == t4) l2 = null;
            else if (null == e4[o2]) l2 = i3.querySelector("option[selected]");
            else if (!Array.isArray(e4[o2])) {
              var a4 = e4[o2];
              "string" == typeof a4 && (a4 = a4.replace(/\"/g, '\\"')), l2 = i3.querySelector('option[value="' + a4 + '"]');
            }
            null == l2 ? (i3.value = "", i3.selectedIndex = -1) : l2.selected = true;
          } else if (null == t4) i3.classList.remove("ql-active");
          else if (i3.hasAttribute("value")) {
            var s4 = e4[o2] === i3.getAttribute("value") || null != e4[o2] && e4[o2].toString() === i3.getAttribute("value") || null == e4[o2] && !i3.getAttribute("value");
            i3.classList.toggle("ql-active", s4);
          } else i3.classList.toggle("ql-active", null != e4[o2]);
        });
      } }]), e3;
    }(w2.default);
    k2.DEFAULTS = {}, k2.DEFAULTS = { container: null, handlers: { clean: function() {
      var t3 = this, e3 = this.quill.getSelection();
      if (null != e3) if (0 == e3.length) {
        var n2 = this.quill.getFormat();
        Object.keys(n2).forEach(function(e4) {
          null != v.default.query(e4, v.default.Scope.INLINE) && t3.quill.format(e4, false);
        });
      } else this.quill.removeFormat(e3, g.default.sources.USER);
    }, direction: function(t3) {
      var e3 = this.quill.getFormat().align;
      "rtl" === t3 && null == e3 ? this.quill.format("align", "right", g.default.sources.USER) : t3 || "right" !== e3 || this.quill.format("align", false, g.default.sources.USER), this.quill.format("direction", t3, g.default.sources.USER);
    }, indent: function(t3) {
      var e3 = this.quill.getSelection(), n2 = this.quill.getFormat(e3), r2 = parseInt(n2.indent || 0);
      if ("+1" === t3 || "-1" === t3) {
        var o2 = "+1" === t3 ? 1 : -1;
        "rtl" === n2.direction && (o2 *= -1), this.quill.format("indent", r2 + o2, g.default.sources.USER);
      }
    }, link: function(t3) {
      true === t3 && (t3 = prompt("Enter link URL:")), this.quill.format("link", t3, g.default.sources.USER);
    }, list: function(t3) {
      var e3 = this.quill.getSelection(), n2 = this.quill.getFormat(e3);
      "check" === t3 ? "checked" === n2.list || "unchecked" === n2.list ? this.quill.format("list", false, g.default.sources.USER) : this.quill.format("list", "unchecked", g.default.sources.USER) : this.quill.format("list", t3, g.default.sources.USER);
    } } }, e2.default = k2, e2.addControls = u2;
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <g class="ql-fill ql-color-label"> <polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points="12 6.868 12 6 11.62 6 12 6.868"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points="5.5 13 9 5 12.5 13"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <rect class="ql-fill ql-stroke" height=3 width=3 x=4 y=5></rect> <rect class="ql-fill ql-stroke" height=3 width=3 x=11 y=5></rect> <path class="ql-even ql-fill ql-stroke" d=M7,8c0,4.031-3,5-3,5></path> <path class="ql-even ql-fill ql-stroke" d=M14,8c0,4.031-3,5-3,5></path> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class="ql-color-label ql-stroke ql-transparent" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points="5.5 11 9 3 12.5 11"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"></polygon> <line class="ql-stroke ql-fill" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"></polygon> <line class="ql-stroke ql-fill" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform="translate(24 18) rotate(-180)"/> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewBox="0 0 18 18"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewBox="0 0 18 18"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"></polyline> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"></polyline> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="5 7 5 11 3 9 5 7"></polyline> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class="ql-even ql-stroke" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class="ql-even ql-stroke" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class="ql-stroke ql-thin" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class="ql-stroke ql-thin" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class="ql-stroke ql-thin" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points="3 4 4 5 6 3"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points="3 14 4 15 6 13"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="3 9 4 10 6 8"></polyline> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class="ql-stroke ql-thin" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <polygon class=ql-stroke points="7 11 9 13 11 11 7 11"></polygon> <polygon class=ql-stroke points="7 7 9 5 11 7 7 7"></polygon> </svg>';
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.BubbleTooltip = void 0;
    var a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), u2 = n(2), c2 = r(u2), f = n(9), h3 = r(f), p = n(44), d3 = r(p), y3 = n(22), v = n(26), b2 = r(v), g = [["bold", "italic", "link"], [{ header: 1 }, { header: 2 }, "blockquote"]], m3 = function(t3) {
      function e3(t4, n2) {
        o(this, e3), null != n2.modules.toolbar && null == n2.modules.toolbar.container && (n2.modules.toolbar.container = g);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.quill.container.classList.add("ql-bubble"), r2;
      }
      return l(e3, t3), s3(e3, [{ key: "extendToolbar", value: function(t4) {
        this.tooltip = new _(this.quill, this.options.bounds), this.tooltip.root.appendChild(t4.container), this.buildButtons([].slice.call(t4.container.querySelectorAll("button")), b2.default), this.buildPickers([].slice.call(t4.container.querySelectorAll("select")), b2.default);
      } }]), e3;
    }(d3.default);
    m3.DEFAULTS = (0, c2.default)(true, {}, d3.default.DEFAULTS, { modules: { toolbar: { handlers: { link: function(t3) {
      t3 ? this.quill.theme.tooltip.edit() : this.quill.format("link", false);
    } } } } });
    var _ = function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.quill.on(h3.default.events.EDITOR_CHANGE, function(t5, e4, n3, o2) {
          if (t5 === h3.default.events.SELECTION_CHANGE) if (null != e4 && e4.length > 0 && o2 === h3.default.sources.USER) {
            r2.show(), r2.root.style.left = "0px", r2.root.style.width = "", r2.root.style.width = r2.root.offsetWidth + "px";
            var i3 = r2.quill.getLines(e4.index, e4.length);
            if (1 === i3.length) r2.position(r2.quill.getBounds(e4));
            else {
              var l2 = i3[i3.length - 1], a4 = r2.quill.getIndex(l2), s4 = Math.min(l2.length() - 1, e4.index + e4.length - a4), u3 = r2.quill.getBounds(new y3.Range(a4, s4));
              r2.position(u3);
            }
          } else document.activeElement !== r2.textbox && r2.quill.hasFocus() && r2.hide();
        }), r2;
      }
      return l(e3, t3), s3(e3, [{ key: "listen", value: function() {
        var t4 = this;
        a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "listen", this).call(this), this.root.querySelector(".ql-close").addEventListener("click", function() {
          t4.root.classList.remove("ql-editing");
        }), this.quill.on(h3.default.events.SCROLL_OPTIMIZE, function() {
          setTimeout(function() {
            if (!t4.root.classList.contains("ql-hidden")) {
              var e4 = t4.quill.getSelection();
              null != e4 && t4.position(t4.quill.getBounds(e4));
            }
          }, 1);
        });
      } }, { key: "cancel", value: function() {
        this.show();
      } }, { key: "position", value: function(t4) {
        var n2 = a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "position", this).call(this, t4), r2 = this.root.querySelector(".ql-tooltip-arrow");
        if (r2.style.marginLeft = "", 0 === n2) return n2;
        r2.style.marginLeft = -1 * n2 - r2.offsetWidth / 2 + "px";
      } }]), e3;
    }(p.BaseTooltip);
    _.TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join(""), e2.BubbleTooltip = _, e2.default = m3;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var a3 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = /* @__PURE__ */ function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    }(), c2 = n(2), f = r(c2), h3 = n(9), p = r(h3), d3 = n(44), y3 = r(d3), v = n(15), b2 = r(v), g = n(22), m3 = n(26), _ = r(m3), O2 = [[{ header: ["1", "2", "3", false] }], ["bold", "italic", "underline", "link"], [{ list: "ordered" }, { list: "bullet" }], ["clean"]], w2 = function(t3) {
      function e3(t4, n2) {
        o(this, e3), null != n2.modules.toolbar && null == n2.modules.toolbar.container && (n2.modules.toolbar.container = O2);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.quill.container.classList.add("ql-snow"), r2;
      }
      return l(e3, t3), u2(e3, [{ key: "extendToolbar", value: function(t4) {
        t4.container.classList.add("ql-snow"), this.buildButtons([].slice.call(t4.container.querySelectorAll("button")), _.default), this.buildPickers([].slice.call(t4.container.querySelectorAll("select")), _.default), this.tooltip = new x2(this.quill, this.options.bounds), t4.container.querySelector(".ql-link") && this.quill.keyboard.addBinding({ key: "K", shortKey: true }, function(e4, n2) {
          t4.handlers.link.call(t4, !n2.format.link);
        });
      } }]), e3;
    }(y3.default);
    w2.DEFAULTS = (0, f.default)(true, {}, y3.default.DEFAULTS, { modules: { toolbar: { handlers: { link: function(t3) {
      if (t3) {
        var e3 = this.quill.getSelection();
        if (null == e3 || 0 == e3.length) return;
        var n2 = this.quill.getText(e3);
        /^\S+@\S+\.\S+$/.test(n2) && 0 !== n2.indexOf("mailto:") && (n2 = "mailto:" + n2);
        this.quill.theme.tooltip.edit("link", n2);
      } else this.quill.format("link", false);
    } } } } });
    var x2 = function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.preview = r2.root.querySelector("a.ql-preview"), r2;
      }
      return l(e3, t3), u2(e3, [{ key: "listen", value: function() {
        var t4 = this;
        s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "listen", this).call(this), this.root.querySelector("a.ql-action").addEventListener("click", function(e4) {
          t4.root.classList.contains("ql-editing") ? t4.save() : t4.edit("link", t4.preview.textContent), e4.preventDefault();
        }), this.root.querySelector("a.ql-remove").addEventListener("click", function(e4) {
          if (null != t4.linkRange) {
            var n2 = t4.linkRange;
            t4.restoreFocus(), t4.quill.formatText(n2, "link", false, p.default.sources.USER), delete t4.linkRange;
          }
          e4.preventDefault(), t4.hide();
        }), this.quill.on(p.default.events.SELECTION_CHANGE, function(e4, n2, r2) {
          if (null != e4) {
            if (0 === e4.length && r2 === p.default.sources.USER) {
              var o2 = t4.quill.scroll.descendant(b2.default, e4.index), i3 = a3(o2, 2), l2 = i3[0], s4 = i3[1];
              if (null != l2) {
                t4.linkRange = new g.Range(e4.index - s4, l2.length());
                var u3 = b2.default.formats(l2.domNode);
                return t4.preview.textContent = u3, t4.preview.setAttribute("href", u3), t4.show(), void t4.position(t4.quill.getBounds(t4.linkRange));
              }
            } else delete t4.linkRange;
            t4.hide();
          }
        });
      } }, { key: "show", value: function() {
        s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "show", this).call(this), this.root.removeAttribute("data-mode");
      } }]), e3;
    }(d3.BaseTooltip);
    x2.TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join(""), e2.default = w2;
  }]).default;
});
const jmixRichTextEditorStyles = css`
    :host {
        display: flex;
        box-sizing: content-box;

        min-height: calc(var(--lumo-size-m) * 8);
        --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
        --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);

        font-family: var(--lumo-font-family);
        font-size: var(--lumo-font-size-m);
        line-height: var(--lumo-line-height-m);
        -webkit-text-size-adjust: 100%;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        
        padding: var(--lumo-space-xs) 0;
    }

    :host([hidden]) {
        display: none !important;
    }

    :host([disabled]) {
        pointer-events: none;
        opacity: 0.5;
        -webkit-user-select: none;
        -moz-user-select: none;
        user-select: none;
    }

    :host(:not([has-label])) [part='label'] {
        display: none;
    }

    :host([disabled]) [part='label'] {
        color: var(--lumo-disabled-text-color);
        -webkit-text-fill-color: var(--lumo-disabled-text-color);
    }

    .jmix-rich-text-editor-wrapper {
        display: flex;
        flex-direction: column;
        min-height: 100%;
        max-height: 100%;
        flex: auto;
    }

    [part="editor"] {
        display: flex;
        flex-direction: column;
        flex: auto;
        height: 100%;
        overflow-y: auto;
    }

    :host(:not([theme~='no-border'])) [part="editor"] {
        border: 1px solid var(--lumo-contrast-20pct);
        border-radius: var(--lumo-border-radius-m);
    }
    
    /**
     * Label styles
     * 
     * Can be replaced with packages/vaadin-lumo-styles/mixins/required-field.js import
     * after other required-field functionality is added 
     */

    [part='label'] {
        align-self: flex-start;
        color: var(--vaadin-input-field-label-color, var(--lumo-secondary-text-color));
        font-weight: var(--vaadin-input-field-label-font-weight, 500);
        font-size: var(--vaadin-input-field-label-font-size, var(--lumo-font-size-s));
        margin-left: calc(var(--lumo-border-radius-m) / 4);
        transition: color 0.2s;
        line-height: 1;
        padding-right: 1em;
        padding-bottom: 0.5em;
        /* As a workaround for diacritics being cut off, add a top padding and a
        negative margin to compensate */
        padding-top: 0.25em;
        margin-top: -0.25em;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        position: relative;
        max-width: 100%;
        box-sizing: border-box;
    }

    :host([focused]:not([readonly])) [part='label'] {
        color: var(--vaadin-input-field-focused-label-color, var(--lumo-primary-text-color));
    }

    :host(:hover:not([readonly]):not([focused])) [part='label'] {
        color: var(--vaadin-input-field-hovered-label-color, var(--lumo-body-text-color));
    }

    /* Touch device adjustment */
    @media (pointer: coarse) {
        :host(:hover:not([readonly]):not([focused])) [part='label'] {
            color: var(--vaadin-input-field-label-color, var(--lumo-secondary-text-color));
        }
    }

    :host([has-label]) {
        padding-top: var(--lumo-space-m);
    }

    /* RTL specific styles */

    :host([dir='rtl']) [part='label'] {
        margin-left: 0;
        margin-right: calc(var(--lumo-border-radius-m) / 4);
    }

    :host([dir='rtl']) [part='label'] {
        padding-left: 1em;
        padding-right: 0;
    }
`;
const Quill = window.Quill;
const Inline = Quill.import("blots/inline");
class CustomColor extends Inline {
  constructor(domNode, value) {
    super(domNode, value);
    domNode.style.color = domNode.color;
    const span = this.replaceWith(new Inline(Inline.create()));
    span.children.forEach((child) => {
      if (child.attributes) child.attributes.copy(span);
      if (child.unwrap) child.unwrap();
    });
    this.remove();
    return span;
  }
}
CustomColor.blotName = "customColor";
CustomColor.tagName = "FONT";
Quill.register(CustomColor, true);
const SOURCE = {
  API: "api",
  USER: "user",
  SILENT: "silent"
};
const STATE = {
  DEFAULT: 0,
  CLICKED: 1
};
const HANDLERS = [
  "bold",
  "italic",
  "underline",
  "strike",
  "header",
  /* 1, 2, 3 */
  "script",
  /* sub, super */
  "list",
  /* ordered, bullet */
  "align",
  /* default, center, justify */
  "blockquote",
  "code-block"
];
registerStyles$1("jmix-rich-text-editor", [jmixRichTextEditorStyles, helper], { moduleId: "jmix-rich-text-editor-styles" });
class RichTextEditor extends ElementMixin(FocusMixin(LabelMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "jmix-rich-text-editor";
  }
  static get template() {
    return html`
            <div class="jmix-rich-text-editor-wrapper">
                <div part="label">
                    <slot name="label"></slot>
                    <span part="required-indicator" aria-hidden="true"></span>
                </div>

                <div part="editor">
                    <slot name="editor"></slot>
                </div>

                <div part="helper-text">
                    <slot name="helper"></slot>
                </div>

                <div part="error-message">
                    <slot name="error-message"></slot>
                </div>
            </div>
        `;
  }
  /** @private */
  _layout() {
    const container = document.createElement("div");
    container.className = "jmix-rich-text-editor-container";
    container.innerHTML = `
                <div class="jmix-rich-text-editor-toolbar">
                    <span class="toolbar-group toolbar-group-emphasis">
                        <!-- Bold -->
                        <button class="toolbar-button toolbar-button-bold ql-bold"
                                i18n="bold">
                        </button>
    
                        <!-- Italic -->
                        <button class="toolbar-button toolbar-button-italic ql-italic"
                                i18n="italic">
                        </button>
    
                        <!-- Underline -->
                        <button class="toolbar-button toolbar-button-underline ql-underline"
                                i18n="underline">
                        </button>
    
                        <!-- Strike -->
                        <button class="toolbar-button toolbar-button-strike ql-strike"
                                i18n="strike">
                        </button>
                    </span>
                    
                    <span class="toolbar-group toolbar-group-heading">
                        <!-- Header 1 -->
                        <button class="toolbar-button toolbar-button-h1 ql-header" value="1" 
                                i18n="h1">
                        </button>
                        
                        <!-- Header 2 -->
                        <button class="toolbar-button toolbar-button-h2 ql-header" value="2"
                                i18n="h2">
                        </button>
                        
                        <!-- Header 3 -->
                        <button class="toolbar-button toolbar-button-h3 ql-header" value="3"
                                i18n="h3">
                        </button>
                    </span>
                    
                    <span class="toolbar-group toolbar-group-glyph-transformation">
                        <!-- Subscript -->
                        <button class="toolbar-button toolbar-button-subscript ql-script" value="sub"
                                i18n="subscript">
                        </button>
                        
                        <!-- Superscript -->
                        <button class="toolbar-button toolbar-button-superscript ql-script" value="super"
                                i18n="superscript">
                        </button>
                    </span>
                    
                    <span class="toolbar-group toolbar-group-list">
                        <!-- Ordered list -->
                        <button class="toolbar-button toolbar-button-list-ordered ql-list" value="ordered"
                                i18n="listOrdered">
                        </button>
                        
                        <!-- Unordered list -->
                        <button class="toolbar-button toolbar-button-list-bullet ql-list" value="bullet"
                                i18n="listBullet">
                        </button>
                    </span>
                    
                    <span class="toolbar-group toolbar-group-alignment">
                        <!-- Align start (left for ltr and right for rtl) -->
                        <button class="toolbar-button toolbar-button-align-start ql-align" value="" 
                                i18n="alignStart">
                        </button>
                        
                        <!-- Align center -->
                        <button class="toolbar-button toolbar-button-align-center ql-align" value="center"
                                i18n="alignCenter">
                        </button>
                        
                        <!-- Align end (right for ltr and left for rtl) -->
                        <button class="toolbar-button toolbar-button-align-end ql-align" value="right"
                                i18n="alignEnd">
                        </button>
                        
                        <!-- Align justify -->
                        <button class="toolbar-button toolbar-button-align-justify ql-align" value="justify"
                                i18n="alignJustify">
                        </button>
                    </span>
                    
                    <span class="toolbar-group toolbar-group-rich-text">
                        <!-- Image -->
                        <button class="toolbar-button toolbar-button-image"
                                i18n="image">
                        </button>
                        
                        <!-- Link -->
                        <button class="toolbar-button toolbar-button-link ql-link"
                                i18n="link">
                        </button>
                    </span>
                    
                    <span class="toolbar-group toolbar-group-block">
                        <!-- Blockquote -->
                        <button class="toolbar-button toolbar-button-blockquote ql-blockquote"
                                i18n="blockquote">
                        </button>
                        
                        <!-- Code block -->
                        <button class="toolbar-button toolbar-button-code-block ql-code-block"
                                i18n="codeBlock">
                        </button>
                    </span>
                    
                    <span class="toolbar-group toolbar-group-format">
                        <!-- Clean -->
                        <button class="toolbar-button toolbar-button-clean ql-clean"
                                i18n="clean">
                        </button>
                    </span>
                    
                    <input type="file"
                        class="jmix-rich-text-editor-file-input"
                        accept="image/png, image/gif, image/jpeg, image/bmp, image/x-icon"/>
                </div>
                
                <div class="jmix-rich-text-editor-content"></div>
        `;
    return container;
  }
  static get properties() {
    return {
      /**
       * Value is a list of the operations which describe change to the document.
       * Each of those operations describe the change at the current index.
       * They can be an `insert`, `delete` or `retain`. The format is as follows:
       *
       * ```js
       *  [
       *    { insert: 'Hello World' },
       *    { insert: '!', attributes: { bold: true }}
       *  ]
       * ```
       *
       * See also https://github.com/quilljs/delta for detailed documentation.
       * @type {string}
       */
      value: {
        type: String,
        notify: true,
        value: "",
        sync: true
      },
      /**
       * HTML representation of the rich text editor content.
       */
      htmlValue: {
        type: String,
        notify: true,
        readOnly: true
      },
      /**
       * When true, the user can not modify, nor copy the editor content.
       * @type {boolean}
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * When true, the user can not modify the editor content, but can copy it.
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * String used for the helper text.
       * @attr {string} helper-text
       */
      helperText: {
        type: String,
        observer: "_helperTextChanged"
      },
      /**
       * An object used to localize this component. The properties are used
       * e.g. as the tooltips for the editor toolbar buttons.
       *
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value: () => {
          return {
            bold: "bold",
            italic: "italic",
            underline: "underline",
            strike: "strike",
            h1: "h1",
            h2: "h2",
            h3: "h3",
            subscript: "subscript",
            superscript: "superscript",
            listOrdered: "list ordered",
            listBullet: "list bullet",
            alignStart: "align start",
            alignCenter: "align center",
            alignEnd: "align end",
            alignJustify: "align justify",
            image: "image",
            link: "link",
            blockquote: "blockquote",
            codeBlock: "code block",
            clean: "clean"
          };
        }
      },
      /** @private */
      _editor: {
        type: Object,
        sync: true
      },
      /**
       * Stores old value
       * @private
       */
      __oldValue: String,
      /** @private */
      __lastCommittedChange: {
        type: String,
        value: ""
      }
    };
  }
  static get observers() {
    return [
      "_valueChanged(value, _editor)",
      "_disabledChanged(disabled, readonly, _editor)"
    ];
  }
  /** @protected */
  async connectedCallback() {
    super.connectedCallback();
    if (!this.$ && this.updateComplete) {
      await this.updateComplete;
    }
    this.__flushPendingHtmlValue();
  }
  /** @private */
  __flushPendingHtmlValue() {
    if (this.__pendingHtmlValue) {
      this.setHtmlValueInternal(this.__pendingHtmlValue);
    }
  }
  constructor() {
    super();
    this._helperController = new HelperController(this);
    this._helperController.addEventListener("slot-content-changed", (event) => {
      const { hasContent, node } = event.detail;
      this.toggleAttribute("has-helper", hasContent);
    });
  }
  /** @protected */
  ready() {
    super.ready();
    const layout = this._layout();
    layout.setAttribute("slot", "editor");
    this.appendChild(layout);
    const editor = this.querySelector(".jmix-rich-text-editor-content");
    const toolbar = this.querySelector(".jmix-rich-text-editor-toolbar");
    const toolbarConfig = this._prepareToolbar(toolbar);
    this._editor = new Quill(editor, {
      modules: {
        toolbar: toolbarConfig
      }
    });
    const qlEditor = editor.querySelector(".ql-editor");
    qlEditor.setAttribute("role", "textbox");
    qlEditor.setAttribute("aria-multiline", "true");
    this._editor.on("text-change", () => {
      const timeout = 200;
      this.__debounceSetValue = Debouncer$1.debounce(this.__debounceSetValue, timeOut.after(timeout), () => {
        this.value = JSON.stringify(this._editor.getContents().ops);
      });
    });
    qlEditor.addEventListener("focusout", () => {
      if (this._toolbarState !== STATE.DEFAULT) {
        this._cleanToolbarState();
      } else {
        this.__emitChangeEvent();
      }
    });
    qlEditor.addEventListener("focus", () => {
      if (this._toolbarState !== STATE.CLICKED) {
        this._cleanToolbarState();
      }
    });
    this.applyLocalization();
  }
  /** @private */
  _prepareToolbar(toolbar) {
    const imageBtn = toolbar.querySelector(".toolbar-button-image");
    imageBtn.onclick = () => {
      this._onImageClick();
    };
    imageBtn.ontouchend = (event) => {
      this._onImageTouchEnd(event);
    };
    const fileInput = toolbar.querySelector(".jmix-rich-text-editor-file-input");
    fileInput.onchange = (event) => {
      this._uploadImage(event);
    };
    const clean = Quill.imports["modules/toolbar"].DEFAULTS.handlers.clean;
    const self2 = this;
    const toolbarConfig = {
      container: toolbar,
      handlers: {
        clean() {
          self2._markToolbarClicked();
          clean.call(this);
        }
      }
    };
    HANDLERS.forEach((handler) => {
      toolbarConfig.handlers[handler] = (value) => {
        self2._markToolbarClicked();
        self2._editor.format(handler, value, SOURCE.USER);
      };
    });
    return toolbarConfig;
  }
  /**
   * Sets content represented by HTML snippet into the editor.
   * The snippet is interpreted by [Quill's Clipboard matchers](https://quilljs.com/docs/modules/clipboard/#matchers),
   * which may not produce the exactly input HTML.
   *
   * **NOTE:** Improper handling of HTML can lead to cross site scripting (XSS) and failure to sanitize
   * properly is both notoriously error-prone and a leading cause of web vulnerabilities.
   * This method is aptly named to ensure the developer has taken the necessary precautions.
   * @param {string} htmlValue
   */
  setHtmlValueInternal(htmlValue2) {
    if (!this._editor) {
      this.__pendingHtmlValue = htmlValue2;
      this.value = "";
      return;
    }
    const whitespaceCharacters = {
      "	": "__RICH_TEXT_EDITOR_TAB",
      "  ": "__RICH_TEXT_EDITOR_DOUBLE_SPACE"
    };
    Object.entries(whitespaceCharacters).forEach(([character, replacement]) => {
      htmlValue2 = htmlValue2.replaceAll(/>[^<]*</gu, (match2) => match2.replaceAll(character, replacement));
    });
    const deltaFromHtml = this._editor.clipboard.convert(htmlValue2);
    Object.entries(whitespaceCharacters).forEach(([character, replacement]) => {
      deltaFromHtml.ops.forEach((op) => {
        if (typeof op.insert === "string") {
          op.insert = op.insert.replaceAll(replacement, character);
        }
      });
    });
    this._editor.setContents(deltaFromHtml, SOURCE.API);
  }
  /** @private */
  _valueChanged(value, editor) {
    if (value && this.__pendingHtmlValue) {
      this.__pendingHtmlValue = void 0;
    }
    if (editor === void 0) {
      return;
    }
    if (value == null || value === '[{"insert":"\\n"}]') {
      this.value = "";
      return;
    }
    if (value === "") {
      this._clear();
      return;
    }
    let parsedValue;
    try {
      parsedValue = JSON.parse(value);
      if (Array.isArray(parsedValue)) {
        this.__oldValue = value;
      } else {
        throw new Error(`expected JSON string with array of objects, got: ${value}`);
      }
    } catch (err) {
      this.value = this.__oldValue;
      console.error("Invalid value set to rich-text-editor:", err);
      return;
    }
    const delta = new Quill.imports.delta(parsedValue);
    if (JSON.stringify(editor.getContents()) !== JSON.stringify(delta)) {
      editor.setContents(delta, SOURCE.SILENT);
    }
    this.__updateHtmlValue();
    if (this._toolbarState === STATE.CLICKED) {
      this._cleanToolbarState();
      this.__emitChangeEvent();
    } else if (!this._editor.hasFocus()) {
      this.__lastCommittedChange = this.value;
    }
  }
  /** @private */
  _disabledChanged(disabled, readonly, editor) {
    if (disabled === void 0 || readonly === void 0 || editor === void 0) {
      return;
    }
    if (disabled || readonly) {
      editor.enable(false);
      if (disabled) {
        this._toggleToolbarDisabled(true);
      }
    } else {
      editor.enable();
      if (this.__oldDisabled) {
        this._toggleToolbarDisabled(false);
      }
    }
    this.__oldDisabled = disabled;
  }
  /**
   * @param {string} helperText
   * @private
   */
  _helperTextChanged(helperText) {
    this._helperController.setHelperText(helperText);
  }
  applyLocalization() {
    const buttons = this._toolbarButtons;
    buttons.forEach((btn) => {
      const i18nKey = btn.getAttribute("i18n");
      const value = this.i18n[i18nKey];
      if (value) {
        btn.setAttribute("title", value);
      } else {
        btn.removeAttribute("title");
      }
    });
  }
  /** @private */
  _toggleToolbarDisabled(disable) {
    const buttons = this._toolbarButtons;
    if (disable) {
      buttons.forEach((btn) => btn.setAttribute("disabled", "true"));
    } else {
      buttons.forEach((btn) => btn.removeAttribute("disabled"));
    }
  }
  /** @private */
  get _toolbarButtons() {
    return this.querySelectorAll(".jmix-rich-text-editor-toolbar button");
  }
  /** @private */
  __emitChangeEvent() {
    let lastCommittedChange = this.__lastCommittedChange;
    if (this.__debounceSetValue && this.__debounceSetValue.isActive()) {
      lastCommittedChange = this.value;
      this.__debounceSetValue.flush();
    }
    if (lastCommittedChange !== this.value) {
      this.dispatchEvent(new CustomEvent("change", { bubbles: true, cancelable: false }));
      this.__lastCommittedChange = this.value;
    }
  }
  /** @private */
  _clear() {
    this._editor.deleteText(0, this._editor.getLength(), SOURCE.SILENT);
    this.__updateHtmlValue();
  }
  /** @private */
  __updateHtmlValue() {
    const editor = this._editor.container.querySelector(".ql-editor");
    let content = editor.innerHTML;
    content = content.replace(/\s*ql-(?!align)[\w-]*\s*/gu, "");
    content = content.replace(/<\/?span[^>]*>/gu, "");
    [this.__dir === "rtl" ? "left" : "right", "center", "justify"].forEach((align) => {
      content = content.replace(
        new RegExp(` class=[\\\\]?"\\s?ql-align-${align}[\\\\]?"`, "gu"),
        ` style="text-align: ${align}"`
      );
    });
    content = content.replace(/ class=""/gu, "");
    this._setHtmlValue(content);
  }
  /** @private */
  _onImageTouchEnd(event) {
    event.preventDefault();
    this._onImageClick();
  }
  /** @private */
  _onImageClick() {
    const fileInput = this.querySelector(".jmix-rich-text-editor-file-input");
    fileInput.value = "";
    fileInput.click();
  }
  /** @private */
  _uploadImage(e2) {
    const fileInput = e2.target;
    if (fileInput.files != null && fileInput.files[0] != null) {
      const reader = new FileReader();
      reader.onload = (e3) => {
        const image = e3.target.result;
        const range = this._editor.getSelection(true);
        this._editor.updateContents(
          new Quill.imports.delta().retain(range.index).delete(range.length).insert({ image }),
          SOURCE.USER
        );
        this._markToolbarClicked();
        this._editor.setSelection(range.index + 1, SOURCE.SILENT);
        fileInput.value = "";
      };
      reader.readAsDataURL(fileInput.files[0]);
    }
  }
  /** @private */
  _markToolbarClicked() {
    this._toolbarState = STATE.CLICKED;
  }
  /** @private */
  _cleanToolbarState() {
    this._toolbarState = STATE.DEFAULT;
  }
}
defineCustomElement(RichTextEditor);
class JmixTimer extends ElementMixin(PolymerElement) {
  static get is() {
    return "jmix-timer";
  }
  static get template() {
    return html`
            <style>
                :host {
                    display: none;
                }
            </style>
        `;
  }
  static get properties() {
    return {
      repeating: {
        type: Boolean,
        value: false
      },
      delay: {
        type: Number,
        value: 0
      },
      autostart: {
        type: Boolean,
        value: false
      }
    };
  }
  start() {
    if (!this.running) {
      this.runTimer();
      this.running = true;
    }
  }
  runTimer() {
    this.intervalId = setTimeout(this.onTimerTick.bind(this), this.delay);
  }
  onTimerTick() {
    this.dispatchEvent(new CustomEvent("jmix-timer-tick"));
    if (this.repeating) {
      this.runTimer();
    } else {
      this.intervalId = null;
      this.running = false;
    }
  }
  stop() {
    this.stopInternal(true);
  }
  stopInternal(userOriginated) {
    if (this.running) {
      clearInterval(this.intervalId);
      this.intervalId = null;
      this.running = false;
      if (userOriginated) {
        this.dispatchEvent(new CustomEvent("jmix-timer-stop"));
      }
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stopInternal(false);
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.autostart) {
      this.start();
    }
  }
}
defineCustomElement(JmixTimer);
const jmixTwinColumnStyles = css`
    .jmix-twin-column-container {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
    }

    .jmix-twin-column-input-container {
        height: 100%;
        overflow-y: auto;
        overflow-x: auto;
        display: grid;
        grid-template-columns: 1fr 0fr 1fr;
        grid-template-rows: 0fr 1fr;
    }

    :host([has-width]) .jmix-twin-column-input-container {
        width: 100%;
    }

    ::slotted([slot="items-label"]) {
        grid-row: 1;
        grid-column: 1;
    }

    ::slotted([slot="selected-items-label"]) {
        grid-row: 1;
        grid-column: 3;
    }

    ::slotted([slot="items"]) {
        grid-row: 2;
        grid-column: 1;
        overflow-y: auto;
    }

    ::slotted([slot="actions"]) {
        grid-row: 2;
        grid-column: 2;
    }

    ::slotted([slot="selected-items"]) {
        grid-row: 2;
        grid-column: 3;
        overflow-y: auto;
    }

    :host(:not([has-label])) [part='label'] {
        display: none;
    }

    :host(:not([has-width])) ::slotted([slot="items"]),
    :host(:not([has-width])) ::slotted([slot="selected-items"]) {
        min-width: var(--jmix-twin-column-column-min-width, 15em);
        width: var(--jmix-twin-column-column-width, 15em);
        max-width: var(--jmix-twin-column-column-max-width, 15em);
    }

    :host(:not([has-height])) ::slotted([slot="items"]),
    :host(:not([has-height])) ::slotted([slot="selected-items"]) {
        min-height: var(--jmix-twin-column-column-min-height, 20em);
        height: var(--jmix-twin-column-column-height, 20em);
        max-height: var(--jmix-twin-column-column-max-height, 20em);
    }

    :host(:not([has-width])) ::slotted([slot="items-label"]),
    :host(:not([has-width])) ::slotted([slot="selected-items-label"]) {
        min-width: var(--jmix-twin-column-column-min-width, 15em);
        width: var(--jmix-twin-column-column-width, 15em);
        max-width: var(--jmix-twin-column-column-max-width, 15em);
    }

    :host(:not([has-height])) ::slotted([slot="actions"]) {
        min-height: var(--jmix-twin-column-column-min-height, 20em);
        height: var(--jmix-twin-column-column-height, 20em);
        max-height: var(--jmix-twin-column-column-max-height, 20em);
    }
`;
registerStyles$1("jmix-twin-column", [inputFieldShared$1, jmixTwinColumnStyles], { moduleId: "jmix-twin-column-styles" });
class JmixTwinColumn extends InputFieldMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "jmix-twin-column";
  }
  static get template() {
    return html`
        <vaadin-vertical-layout class="jmix-twin-column-container">
            <div part="label" on-click="focus">
              <slot name="label"></slot>
              <span part="required-indicator" aria-hidden="true"></span>
            </div>

            <div class="jmix-twin-column-input-container">
                <slot name="items-label"></slot>
                <slot name="selected-items-label"></slot>
                <slot name="items"></slot>
                <slot name="actions"></slot>
                <slot name="selected-items"></slot>
            </div>

            <div part="helper-text">
              <slot name="helper"></slot>
            </div>

            <div part="error-message">
              <slot name="error-message"></slot>
            </div>
        </vaadin-vertical-layout>

        <slot name="tooltip"></slot>
        `;
  }
  /** @protected */
  ready() {
    super.ready();
    let components = [
      this.getElementsByClassName("jmix-twin-column-actions-panel")[0],
      this.getElementsByClassName("jmix-twin-column-items-column")[0],
      this.getElementsByClassName("jmix-twin-column-selected-items-column")[0]
    ];
    (function(twinColumn) {
      for (let component of components) {
        component.addEventListener("focusin", () => {
          twinColumn._setFocused(true);
        });
        component.addEventListener("focusout", () => {
          twinColumn._setFocused(false);
        });
      }
    })(this);
  }
}
defineCustomElement(JmixTwinColumn);
const uploadField$1 = css`
  :host(:hover:not([readonly]):not([focused])) [part='input-field']::after {
    opacity: 0;
  }
  
  ::slotted(:not([slot$='fix'])) {
    padding: 0;
    --_lumo-text-field-overflow-mask-image: 0;
    -webkit-mask-image: 0;
    mask-image: 0;
  }
`;
registerStyles$1("jmix-upload-field", [inputFieldShared$1, uploadField$1], {
  moduleId: "lumo-jmix-upload-field-styles"
});
const uploadField = css`
  :host::before {
    display: inline-flex;
  }
  
  /*
   * Use "auto" width instead of default 12em, because upload field
   * with visible file name is not fit in.
   */
  [class$='container'] {
    width: var(--jmix-upload-field-default-width, var(--vaadin-field-default-width, auto));
  }
`;
registerStyles$1("jmix-upload-field", [inputFieldShared, uploadField], {
  moduleId: "jmix-upload-field-styles"
});
class JmixUploadField extends SlotStylesMixin(DelegateFocusMixin(InputConstraintsMixin(FieldMixin(ThemableMixin(
  ElementMixin(PolymerElement)
))))) {
  static get is() {
    return "jmix-upload-field";
  }
  static get template() {
    return html`
            <style>
                vaadin-input-container {
                    background-color: transparent;
                    padding: 0;
                    cursor: auto;
                }

                vaadin-input-container:after {
                    border: 0;
                }
            </style>

            <div class="upload-field-container">
                <div part="label">
                    <slot name="label"></slot>
                    <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
                </div>

                <vaadin-input-container
                        part="input-field"
                        readonly="[[readonly]]"
                        disabled="[[disabled]]"
                        invalid="[[invalid]]"
                        theme$="[[_theme]]">
                    <slot name="input"></slot>
                </vaadin-input-container>

                <div part="helper-text">
                    <slot name="helper"></slot>
                </div>

                <div part="error-message">
                    <slot name="error-message"></slot>
                </div>
            </div>
            
            <slot name="tooltip"></slot>
        `;
  }
  static get properties() {
    return {};
  }
  /** @protected */
  get slotStyles() {
    return [];
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this.addController(this._tooltipController);
  }
}
defineCustomElement(JmixUploadField);
const uploadButton = css`
  :host(:not([nodrop])) {
    border: 0;
    overflow: initial;
    padding: 0;
    transition: background-color 0.6s;
  }
  [part='drop-label'] {
    display: none;
  }

  ::slotted(vaadin-button) {
    margin: 0;
  }
  
  ::slotted(vaadin-button[theme~="full-width"]) {
    width: 100%;
  }
`;
registerStyles$1("jmix-upload-button", uploadButton, {
  moduleId: "lumo-jmix-upload-button-styles"
});
class JmixUploadButton extends Upload {
  static get is() {
    return "jmix-upload-button";
  }
  static get properties() {
    return {
      file: Object,
      jmixI18n: {
        type: Object,
        value: function() {
          return {
            uploadDialog: {
              title: "Uploading",
              cancel: "Cancel"
            }
          };
        },
        notify: true
      }
    };
  }
  ready() {
    super.ready();
    this.$.dropLabelContainer.hidden = true;
    this.addEventListener("upload-progress", this._onUploadProgressEvent.bind(this));
    this.addEventListener("upload-success", this._onUploadSuccessEvent.bind(this));
    this.addEventListener("upload-error", this._onUploadFailedEvent.bind(this));
    this.addEventListener("file-abort", this._closeUploadDialogOnEvent.bind(this));
    this.addEventListener("file-reject", this._closeUploadDialogOnEvent.bind(this));
    this.addEventListener("upload-start", this._openUploadDialogOnEvent.bind(this));
    this._initUploadDialog();
  }
  static get observers() {
    return [
      "_onJmixI18nChanged(jmixI18n)"
    ];
  }
  /**
   * @private
   * @override
   */
  _renderFileList() {
    if (this._fileList) {
      this._fileList.hidden = true;
    }
  }
  _onUploadSuccessEvent(event) {
    this.files = [];
    this._closeUploadDialogOnEvent(event);
  }
  _onUploadFailedEvent(event) {
    this.files = [];
    this._closeUploadDialogOnEvent(event);
    this.dispatchEvent(new CustomEvent("jmix-upload-internal-error", { detail: { file: this.file, xhr: this.file.xhr } }));
  }
  _openUploadDialogOnEvent(event) {
    this._setUploadDialogOpened(true);
  }
  _closeUploadDialogOnEvent(event) {
    this._setUploadDialogOpened(false);
  }
  _initUploadDialog() {
    const uploadDialog = document.createElement("vaadin-dialog");
    uploadDialog.id = "jmixUploadDialog";
    uploadDialog.headerTitle = this.jmixI18n.uploadDialog.title;
    uploadDialog.noCloseOnOutsideClick = true;
    uploadDialog.noCloseOnEsc = true;
    uploadDialog.className = "jmix-upload-dialog";
    uploadDialog.renderer = this._uploadDialogRenderer();
    this.appendChild(uploadDialog);
  }
  _uploadDialogRenderer() {
    const uploadContext = this;
    return function(root2, dialog) {
      if (root2.children && root2.children.length > 0) {
        const fileWrapper = root2.children[0].children.fileWrapper;
        uploadContext._updateUploadFileElement(uploadContext.file, fileWrapper, uploadContext.jmixI18n);
        const uploadFileElements = root2.getElementsByTagName("vaadin-upload-file");
        if (uploadFileElements.length === 0) {
          return;
        }
        const uploadFile2 = uploadFileElements[0];
        const uploadFileButtons = uploadFile2.shadowRoot.querySelectorAll("button");
        if (uploadFileButtons.length > 0) {
          for (const btn of uploadFileButtons) {
            btn.hidden = true;
          }
        }
      } else {
        const dialogContent = document.createElement("div");
        dialogContent.className = "jmix-upload-dialog-content";
        const fileWrapper = document.createElement("div");
        fileWrapper.id = "fileWrapper";
        uploadContext._updateUploadFileElement(uploadContext.file, fileWrapper, uploadContext.jmixI18n);
        const cancelBtn = uploadContext._createUploadDialogCancelButton();
        dialogContent.appendChild(fileWrapper);
        dialogContent.appendChild(cancelBtn);
        root2.appendChild(dialogContent);
      }
    };
  }
  _updateUploadFileElement(file, content, i18n) {
    if (!file) {
      return;
    }
    return render(html$1`
            <vaadin-upload-file
                    .file="${file}"
                    .complete="${file.complete}"
                    .errorMessage="${file.error}"
                    .fileName="${file.name}"
                    .held="${file.held}"
                    .indeterminate="${file.indeterminate}"
                    .progress="${file.progress}"
                    .status="${file.status}"
                    .uploading="${file.uploading}"
                    .i18n="${i18n}"
            ></vaadin-upload-file>
        `, content);
  }
  _createUploadDialogCancelButton() {
    const cancelBtn = document.createElement("vaadin-button");
    cancelBtn.className = "jmix-upload-dialog-cancel-button";
    cancelBtn.innerText = this.jmixI18n.uploadDialog.cancel;
    cancelBtn.addEventListener("click", this._onUploadDialogCancelButtonClick.bind(this));
    return cancelBtn;
  }
  _onUploadDialogCancelButtonClick(event) {
    this.dispatchEvent(new CustomEvent("file-abort", { detail: { file: this.file, xhr: this.file.xhr } }));
  }
  _onJmixI18nChanged(jmixI18n) {
    const dialog = this._getUploadDialog();
    if (dialog) {
      dialog.headerTitle = jmixI18n.uploadDialog.title;
    }
  }
  _onUploadProgressEvent(e2) {
    this.file = e2.detail.file;
    const dialog = this._getUploadDialog();
    if (dialog) {
      dialog.requestContentUpdate();
    }
  }
  _setUploadDialogOpened(opened) {
    const dialog = this._getUploadDialog();
    if (dialog) {
      dialog.opened = opened;
    }
  }
  _getUploadDialog() {
    const dialogs = this.getElementsByTagName("vaadin-dialog");
    if (dialogs.length <= 0) {
      return;
    }
    const dialog = Array.from(dialogs).filter((dialog2) => {
      return dialog2.id === "jmixUploadDialog";
    });
    return dialog.length > 0 ? dialog[0] : null;
  }
}
defineCustomElement(JmixUploadButton);
const valuePicker$1 = css`
  [part="action-part"] ::slotted(*) {
    gap: var(--lumo-space-xs);
  }
  
  :host([has-actions]) [part="input-field"] {
    padding-right: var(--lumo-space-xs);
  }
`;
registerStyles$1("jmix-value-picker", [inputFieldShared$1, valuePicker$1], {
  moduleId: "lumo-value-picker-styles"
});
const valuePicker = css`
  :host::before {
    display: inline-flex;
  }
`;
registerStyles$1("jmix-value-picker", [inputFieldShared, valuePicker], {
  moduleId: "jmix-value-picker-styles"
});
class JmixValuePicker extends InputFieldMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "jmix-value-picker";
  }
  static get template() {
    return html`
            <style>
                [part="action-part"] ::slotted(*) {
                    display: flex;
                }

                :host([readonly]) [part="action-part"] {
                    display: none;
                }
            </style>

            <div class="value-picker-container">
                <div part="label">
                    <slot name="label"></slot>
                    <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
                </div>

                <vaadin-input-container
                        part="input-field"
                        readonly="[[readonly]]"
                        disabled="[[disabled]]"
                        invalid="[[invalid]]"
                        theme$="[[_theme]]"
                >
                    <slot name="prefix" slot="prefix"></slot>
                    <slot name="input"></slot>
                    <slot name="suffix" slot="suffix"></slot>
                    <div id="pickerAction" part="action-part" slot="suffix">
                        <slot name="actions"></slot>
                    </div>
                </vaadin-input-container>

                <div part="helper-text">
                    <slot name="helper"></slot>
                </div>

                <div part="error-message">
                    <slot name="error-message"></slot>
                </div>
            </div>

            <slot name="tooltip"></slot>
        `;
  }
  static get properties() {
    return {
      allowCustomValue: {
        type: Boolean,
        value: false
      }
    };
  }
  constructor() {
    super();
    this._setType("text");
  }
  /** @protected */
  get clearElement() {
    return null;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this.addController(this._tooltipController);
  }
  _onInput(event) {
    if (!this.allowCustomValue) {
      this.inputElement.value = this.value || "";
    }
    super._onInput(event);
  }
  checkValidity() {
    return !this.invalid && super.checkValidity();
  }
}
defineCustomElement(JmixValuePicker);
const pickerButton = css`
  :host {
    /* Sizing */
    --lumo-button-size: var(--lumo-size-s);
    min-width: var(--lumo-button-size);
    height: var(--lumo-button-size);
    box-sizing: border-box;
    
    /* Style */
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    font-weight: 500;
    color: var(--_lumo-button-color, var(--lumo-primary-text-color));
    background-color: var(--_lumo-button-background-color, var(--lumo-contrast-5pct));
    border-radius: var(--lumo-border-radius-m);
    cursor: var(--lumo-clickable-cursor);
    -webkit-tap-highlight-color: transparent;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  
  /* Set only for the internal parts so we don’t affect the host vertical alignment */
  [part='icon'] {
    line-height: var(--lumo-line-height-xs);
  }
  
  /* For interaction states */
  :host::before,
  :host::after {
    content: '';
    /* We rely on the host always being relative */
    position: absolute;
    z-index: 1;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: currentColor;
    border-radius: inherit;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
  }
  
  /* Hover */
  
  @media (any-hover: hover) {
    :host(:hover)::before {
      opacity: 0.02;
    }
  }
  
  /* Active */
  
  :host::after {
    transition: opacity 1.4s, transform 0.1s;
    filter: blur(8px);
  }
  
  :host([active])::before {
    opacity: 0.05;
    transition-duration: 0s;
  }
  
  :host([active])::after {
    opacity: 0.1;
    transition-duration: 0s, 0s;
    transform: scale(0);
  }
  
  /* Keyboard focus */
  
  :host([focus-ring]) {
    box-shadow: 0 0 0 2px var(--lumo-primary-color-50pct);
  }
  
  /* Disabled state. Keep selectors after other color variants. */
  
  :host([disabled]) {
    pointer-events: none;
    color: var(--lumo-disabled-text-color);
  }
  
  /* Icons */
  
  [part] ::slotted(vaadin-icon),
  [part] ::slotted(iron-icon) {
    display: inline-block;
    width: var(--lumo-icon-size-m);
    height: var(--lumo-icon-size-m);
  }
  
  /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
  [part] ::slotted(vaadin-icon[icon^='vaadin:']),
  [part] ::slotted(iron-icon[icon^='vaadin:']) {
    padding: 0.25em;
    box-sizing: border-box !important;
  }
`;
registerStyles$1("jmix-value-picker-button", pickerButton, {
  moduleId: "lumo-value-picker-button-styles"
});
registerStyles$1("jmix-value-picker-button", [], {
  moduleId: "jmix-value-picker-button-styles"
});
class JmixValuePickerButton extends ActiveMixin(TabindexMixin(FocusMixin(ElementMixin(ThemableMixin(PolymerElement))))) {
  static get is() {
    return "jmix-value-picker-button";
  }
  static get template() {
    return html`
            <style>
                :host {
                    display: inline-block;
                    position: relative;
                    outline: none;
                    white-space: nowrap;
                    -webkit-user-select: none;
                    -moz-user-select: none;
                    user-select: none;
                }

                :host([hidden]) {
                    display: none !important;
                }
                
                /* Aligns the button with form fields when placed on the same line.
                Note, to make it work, the form fields should have the same "::before" pseudo-element. */
                .value-picker-button-container::before {
                    content: '\\2003';
                    display: inline-block;
                    width: 0;
                }
                
                .value-picker-button-container {
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    text-align: center;
                    width: 100%;
                    height: 100%;
                    min-height: inherit;
                    text-shadow: inherit;
                    background: transparent;
                    padding: 0;
                    border: none;
                    box-shadow: none;
                }

                [part='icon'] {
                    flex: none;
                }
            </style>

            <div class="value-picker-button-container">
                <span part="icon">
                    <slot name="icon"></slot>
                </span>
            </div>
        `;
  }
  static get properties() {
    return {
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       *
       * @override
       * @protected
       */
      tabindex: {
        value: 0
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", "button");
    }
  }
  /**
   * By default, `Space` is the only possible activation key for a focusable HTML element.
   * Nonetheless, the button is an exception as it can be also activated by pressing `Enter`.
   * See the "Keyboard Support" section in https://www.w3.org/TR/wai-aria-practices/examples/button/button.html.
   *
   * @protected
   * @override
   */
  get _activeKeys() {
    return ["Enter", " "];
  }
  /**
   * Since the button component is designed on the base of the `[role=button]` attribute,
   * and doesn't have a native <button> inside, in order to be fully accessible from the keyboard,
   * it should manually fire the `click` event once an activation key is pressed,
   * as it follows from the WAI-ARIA specifications:
   * https://www.w3.org/TR/wai-aria-practices-1.1/#button
   *
   * According to the UI Events specifications,
   * the `click` event should be fired exactly on `keydown`:
   * https://www.w3.org/TR/uievents/#event-type-keydown
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    if (this._activeKeys.includes(event.key)) {
      event.preventDefault();
      this.click();
    }
  }
}
defineCustomElement(JmixValuePickerButton);
const loadOnDemand = (key) => {
  return Promise.resolve(0);
};
window.Vaadin = window.Vaadin || {};
window.Vaadin.Flow = window.Vaadin.Flow || {};
window.Vaadin.Flow.loadOnDemand = loadOnDemand;
window.Vaadin.Flow.resetFocus = () => {
  let ae = document.activeElement;
  while (ae && ae.shadowRoot) ae = ae.shadowRoot.activeElement;
  return !ae || ae.blur() || ae.focus() || true;
};
